using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using DocGen.CompoundFile.DocIO;
using DocGen.Compression;
using DocGen.Compression.Zip;
using DocGen.DocIO.DLS.Entities;
using DocGen.DocIO.ReaderWriter.Biff_Records;
using DocGen.DocIO.ReaderWriter.DataStreamParser.Escher;
using DocGen.DocIO.ReaderWriter.Security;
using DocGen.Drawing;
using DocGen.Layouting;
using DocGen.Office;
using DocGen.OfficeChart;
using DocGen.OfficeChart.Implementation;
using DocGen.OfficeChart.Implementation.Charts;
using DocGen.OfficeChart.Implementation.XmlSerialization;
using DocGen.OfficeChart.Implementation.XmlSerialization.Charts;

namespace DocGen.DocIO.DLS.Convertors;

internal class DocxParser : DocumentParser
{
	private struct BookmarkInfo
	{
		internal string bookmarkId;

		internal string bookmarName;
	}

	private enum GraphicDataContentType
	{
		None,
		Shape,
		Picture,
		Chart,
		Group
	}

	private const char NONBREAK_HYPHEN = '\u001e';

	// Pull the proper schema to prevent shit from breaking
	private string m_nameSpace = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

	private string m_strictNameSpace = "http://purl.oclc.org/ooxml/wordprocessingml/main";

	private string m_strictANameSpace = "http://purl.oclc.org/ooxml/drawingml/main";

	private Regex m_isFloatValue = new Regex("^.*\\d+(\\.*\\d+)*$");

	private Regex m_hasAlphabet = new Regex("^[^ A-Za-z_@/#&+-]*$");

	private ZipArchive m_docArchive;

	private XmlReader m_reader;

	private WordDocument m_doc;

	private string m_majorFontName;

	private string m_minorFontName;

	private string m_majorLatinFontName = string.Empty;

	private string m_majorEaFontName = string.Empty;

	private string m_majorCsFontName = string.Empty;

	private string m_minorLatinFontName = string.Empty;

	private string m_minorEaFontName = string.Empty;

	private string m_minorCsFontName = string.Empty;

	private float m_gutter;

	private string m_currentFile = string.Empty;

	private Dictionary<string, string> m_linkStyleNames;

	private Dictionary<string, string> m_baseStyleNames;

	private Dictionary<string, DictionaryEntry> m_docRelations;

	private Dictionary<string, DictionaryEntry> m_fontTableRelations;

	private Dictionary<string, DictionaryEntry> m_settingsRelations;

	private Dictionary<string, bool> m_isExternalHyperlink;

	private List<BookmarkInfo> m_bookmarkNames;

	private Dictionary<string, Dictionary<string, DictionaryEntry>> m_hfRelations;

	private Dictionary<string, WPicture> m_pictureBullet;

	private Dictionary<string, string> m_abstractListStyles;

	private Dictionary<string, string> m_overrideListStyles;

	private WCharacterFormat m_currentRunFormat;

	private List<DictionaryEntry> m_footnote;

	private List<DictionaryEntry> m_endnote;

	private Stack<WField> m_fieldStack;

	private Stack<RevisionType> m_trackchangeStack = new Stack<RevisionType>();

	private Stack<Revision> m_trackchangeRevisionDetails = new Stack<Revision>();

	private RevisionType m_trackChangeType = RevisionType.None;

	private Revision moveRevision;

	private Revision contentRevision;

	private Revision emptyContentRevision;

	private string m_revAuthorName = string.Empty;

	private DateTime m_revDateTime;

	private string m_name = string.Empty;

	private BiDirectionalOverride m_biDirectionalOverride;

	private List<Entity> m_altChunkCollection;

	private List<Entity> m_postParaItemsCollection;

	private WCommentMark m_postCommMark;

	private Dictionary<string, WComment> m_comments;

	private List<WCommentExtended> m_commentsEx;

	private Stack<WComment> m_commStack;

	private short m_gridCount;

	private short m_formatChangeGridCount;

	private short m_gridSpan;

	private Dictionary<string, int> m_imageIds;

	private Dictionary<string, byte[]> m_svgDataDict;

	private string m_appVersion = string.Empty;

	private string m_documentPath;

	private List<FontFamilyNameRecord> m_fontFamilyRecords = new List<FontFamilyNameRecord>();

	private byte m_flags;

	private string m_firstInvalidNumId;

	private byte m_bFlags;

	private byte m_bFlags4;

	private List<BlockContentControl> m_blockControls;

	private List<InlineContentControl> m_inlineControls;

	private List<WTableCell> m_cellControls;

	private Dictionary<string, DictionaryEntry> m_chartRelations;

	private AutoShapeHelper m_autoShapeHelper;

	private long shapeID = 1L;

	private Dictionary<string, DictionaryEntry> ChartRelations
	{
		get
		{
			if (m_chartRelations == null)
			{
				m_chartRelations = new Dictionary<string, DictionaryEntry>();
			}
			return m_chartRelations;
		}
	}

	private bool IsInFootnote
	{
		get
		{
			return (m_bFlags & 1) != 0;
		}
		set
		{
			m_bFlags = (byte)((m_bFlags & 0xFEu) | (value ? 1u : 0u));
		}
	}

	private bool IsInEndnote
	{
		get
		{
			return (m_bFlags & 2) >> 1 != 0;
		}
		set
		{
			m_bFlags = (byte)((m_bFlags & 0xFDu) | ((value ? 1u : 0u) << 1));
		}
	}

	private bool IsInComments
	{
		get
		{
			return (m_bFlags & 4) >> 2 != 0;
		}
		set
		{
			m_bFlags = (byte)((m_bFlags & 0xFBu) | ((value ? 1u : 0u) << 2));
		}
	}

	private bool IsWord2003ML
	{
		get
		{
			return (m_bFlags & 0x10) >> 4 != 0;
		}
		set
		{
			m_bFlags = (byte)((m_bFlags & 0xEFu) | ((value ? 1u : 0u) << 4));
		}
	}

	private bool IsStrict
	{
		get
		{
			return (m_bFlags4 & 1) != 0;
		}
		set
		{
			m_bFlags4 = (byte)((m_bFlags4 & 0xFEu) | (value ? 1u : 0u));
		}
	}

	private Dictionary<string, int> ImageIds
	{
		get
		{
			if (m_imageIds == null)
			{
				m_imageIds = new Dictionary<string, int>();
			}
			return m_imageIds;
		}
	}

	private Dictionary<string, byte[]> SvgDataDict
	{
		get
		{
			if (m_svgDataDict == null)
			{
				m_svgDataDict = new Dictionary<string, byte[]>();
			}
			return m_svgDataDict;
		}
	}

	private List<BlockContentControl> BlockContentControls
	{
		get
		{
			if (m_blockControls == null)
			{
				m_blockControls = new List<BlockContentControl>();
			}
			return m_blockControls;
		}
	}

	private List<InlineContentControl> InlineContentControls
	{
		get
		{
			if (m_inlineControls == null)
			{
				m_inlineControls = new List<InlineContentControl>();
			}
			return m_inlineControls;
		}
	}

	private List<WTableCell> CellContentControls
	{
		get
		{
			if (m_cellControls == null)
			{
				m_cellControls = new List<WTableCell>();
			}
			return m_cellControls;
		}
	}

	private Dictionary<string, WComment> Comments => m_comments;

	private List<Entity> AltChunkCollection
	{
		get
		{
			if (m_altChunkCollection == null)
			{
				m_altChunkCollection = new List<Entity>();
			}
			return m_altChunkCollection;
		}
	}

	private List<Entity> PostParaItemsCollection
	{
		get
		{
			if (m_postParaItemsCollection == null)
			{
				m_postParaItemsCollection = new List<Entity>();
			}
			return m_postParaItemsCollection;
		}
	}

	private Stack<WComment> CommentsStack
	{
		get
		{
			if (m_commStack == null)
			{
				m_commStack = new Stack<WComment>();
			}
			return m_commStack;
		}
	}

	private WComment CurrentComment
	{
		get
		{
			if (m_commStack != null && m_commStack.Count > 0)
			{
				return m_commStack.Peek();
			}
			return null;
		}
	}

	private Stack<WField> FieldStack
	{
		get
		{
			if (m_fieldStack == null)
			{
				m_fieldStack = new Stack<WField>();
			}
			return m_fieldStack;
		}
	}

	private WField CurrentField
	{
		get
		{
			if (m_fieldStack != null && m_fieldStack.Count > 0)
			{
				return m_fieldStack.Peek();
			}
			return null;
		}
	}

	private List<DictionaryEntry> Footnote
	{
		get
		{
			if (m_footnote == null || m_footnote.Count == 0)
			{
				m_footnote = new List<DictionaryEntry>();
			}
			return m_footnote;
		}
	}

	private List<DictionaryEntry> Endnote
	{
		get
		{
			if (m_endnote == null)
			{
				m_endnote = new List<DictionaryEntry>();
			}
			return m_endnote;
		}
	}

	private Dictionary<string, string> OverrideListStyleNames
	{
		get
		{
			if (m_overrideListStyles == null)
			{
				m_overrideListStyles = new Dictionary<string, string>();
			}
			return m_overrideListStyles;
		}
	}

	private Dictionary<string, string> AbstractListStyleNames
	{
		get
		{
			if (m_abstractListStyles == null)
			{
				m_abstractListStyles = new Dictionary<string, string>();
			}
			return m_abstractListStyles;
		}
	}

	private Dictionary<string, WPicture> PictureBullet
	{
		get
		{
			if (m_pictureBullet == null)
			{
				m_pictureBullet = new Dictionary<string, WPicture>();
			}
			return m_pictureBullet;
		}
	}

	private Dictionary<string, DictionaryEntry> DocumentRelations
	{
		get
		{
			if (m_docRelations == null)
			{
				m_docRelations = new Dictionary<string, DictionaryEntry>();
			}
			return m_docRelations;
		}
	}

	private Dictionary<string, DictionaryEntry> FontTableRelations
	{
		get
		{
			if (m_fontTableRelations == null)
			{
				m_fontTableRelations = new Dictionary<string, DictionaryEntry>();
			}
			return m_fontTableRelations;
		}
	}

	private Dictionary<string, DictionaryEntry> SettingsRelations
	{
		get
		{
			if (m_settingsRelations == null)
			{
				m_settingsRelations = new Dictionary<string, DictionaryEntry>();
			}
			return m_settingsRelations;
		}
	}

	private Dictionary<string, bool> IsExternalHyperlink
	{
		get
		{
			if (m_isExternalHyperlink == null)
			{
				m_isExternalHyperlink = new Dictionary<string, bool>();
			}
			return m_isExternalHyperlink;
		}
	}

	private List<BookmarkInfo> BookmarkNames
	{
		get
		{
			if (m_bookmarkNames == null)
			{
				m_bookmarkNames = new List<BookmarkInfo>();
			}
			return m_bookmarkNames;
		}
	}

	private Dictionary<string, Dictionary<string, DictionaryEntry>> HFRelations
	{
		get
		{
			if (m_hfRelations == null)
			{
				m_hfRelations = new Dictionary<string, Dictionary<string, DictionaryEntry>>();
			}
			return m_hfRelations;
		}
	}

	private Dictionary<string, string> BaseStyleNames
	{
		get
		{
			if (m_baseStyleNames == null)
			{
				m_baseStyleNames = new Dictionary<string, string>();
			}
			return m_baseStyleNames;
		}
	}

	private Dictionary<string, string> StyleNameId => m_doc.StyleNameIds;

	private Dictionary<string, string> LinkStyleNames
	{
		get
		{
			if (m_linkStyleNames == null)
			{
				m_linkStyleNames = new Dictionary<string, string>();
			}
			return m_linkStyleNames;
		}
	}

	private string AppVersion
	{
		get
		{
			if (StartsWithExt(m_appVersion, "12"))
			{
				return "Word2007";
			}
			if (StartsWithExt(m_appVersion, "14"))
			{
				return "Word2010";
			}
			if (StartsWithExt(m_appVersion, "15"))
			{
				return "Word2013";
			}
			if (StartsWithExt(m_appVersion, "16"))
			{
				return "WordLatest";
			}
			return "Docx";
		}
		set
		{
			m_appVersion = value;
		}
	}

	private AutoShapeHelper AutoShapeHelper
	{
		get
		{
			if (m_autoShapeHelper == null)
			{
				m_autoShapeHelper = new AutoShapeHelper();
			}
			return m_autoShapeHelper;
		}
	}

	private bool IsSDTHasSectionBreak
	{
		get
		{
			return (m_flags & 0x40) >> 6 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xBFu) | ((value ? 1u : 0u) << 6));
		}
	}

	private bool IsRowChangeFormat
	{
		get
		{
			return (m_flags & 1) != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xFEu) | (value ? 1u : 0u));
		}
	}

	private bool IsCellChangeFormat
	{
		get
		{
			return (m_flags & 2) >> 1 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xFDu) | ((value ? 1u : 0u) << 1));
		}
	}

	private bool IsTableChangeFormat
	{
		get
		{
			return (m_flags & 4) >> 2 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xFBu) | ((value ? 1u : 0u) << 2));
		}
	}

	private bool IsHyperLinkField
	{
		get
		{
			return (m_flags & 8) >> 3 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xF7u) | ((value ? 1u : 0u) << 3));
		}
	}

	private bool IsFirstInvalidNumID
	{
		get
		{
			return (m_flags & 0x20) >> 5 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xDFu) | ((value ? 1u : 0u) << 5));
		}
	}

	private bool IsNeedToApplyParaFormat
	{
		get
		{
			return (m_flags & 0x10) >> 4 != 0;
		}
		set
		{
			m_flags = (byte)((m_flags & 0xEFu) | ((value ? 1u : 0u) << 4));
		}
	}

	private bool PreserveSpace
	{
		get
		{
			return (m_bFlags & 8) >> 3 != 0;
		}
		set
		{
			m_bFlags = (byte)((m_bFlags & 0xF7u) | ((value ? 1u : 0u) << 3));
		}
	}

	internal WordDocument ReadWord2003Xml(Stream stream, WordDocument document)
	{
		m_doc = document;
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "wordDocument")
		{
			throw new NotSupportedException("The Specified file is not a Word 2003 XML file");
		}
		if (!xmlReader.IsEmptyElement)
		{
			string attribute = xmlReader.GetAttribute("xml:space");
			if (!string.IsNullOrEmpty(attribute))
			{
				PreserveSpace = attribute == "preserve";
			}
			string localName = xmlReader.LocalName;
			xmlReader.Read();
			if (!(localName == xmlReader.LocalName) || xmlReader.NodeType != XmlNodeType.EndElement)
			{
				bool flag = false;
				SkipWhitespaces(xmlReader);
				while (xmlReader.LocalName != "wordDocument")
				{
					flag = false;
					if (xmlReader.NodeType == XmlNodeType.Element)
					{
						switch (xmlReader.LocalName)
						{
						case "DocumentProperties":
							ParseWord2003DocumentProperties(xmlReader);
							break;
						case "CustomDocumentProperties":
							ParseWord2003CustomDocumentproperties(xmlReader);
							break;
						case "fonts":
							ParseFontTable(xmlReader);
							break;
						case "lists":
							ParseNumberings(xmlReader);
							break;
						case "styles":
							ParseStyles(xmlReader);
							break;
						case "shapeDefaults":
							xmlReader.Skip();
							flag = true;
							break;
						case "docPr":
							ParseWord2003DocPr(xmlReader);
							break;
						case "body":
							m_doc.AddSection();
							if (m_doc.Sections.Count == 1)
							{
								m_doc.LastSection.PageSetup.InitializeDocxPageSetup();
							}
							ParseBody(xmlReader, null, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
							break;
						default:
							flag = true;
							xmlReader.Skip();
							break;
						}
						if (!flag)
						{
							xmlReader.Read();
						}
					}
					else
					{
						xmlReader.Read();
					}
					SkipWhitespaces(xmlReader);
				}
				Close();
				return document;
			}
			return document;
		}
		return document;
	}

	private void ReadAndSkipWhiteSpaces(XmlReader reader)
	{
		reader.Read();
		SkipWhitespaces(reader);
	}

	internal void OpenFlatOPC(Stream docStream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(docStream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "package" || xmlReader.NamespaceURI != "http://schemas.microsoft.com/office/2006/xmlPackage")
		{
			throw new NotSupportedException("The Specified file is not a Word XML document file.");
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != "package")
		{
			if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.LocalName == "part")
			{
				string attribute = xmlReader.GetAttribute("name", "http://schemas.microsoft.com/office/2006/xmlPackage");
				xmlReader.GetAttribute("contentType", "http://schemas.microsoft.com/office/2006/xmlPackage");
				if (!StartsWithExt(attribute, "/"))
				{
					continue;
				}
				ReadAndSkipWhiteSpaces(xmlReader);
				if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.LocalName == "xmlData")
				{
					ReadAndSkipWhiteSpaces(xmlReader);
					if (xmlReader.Name == "mso-contentType")
					{
						ReadAndSkipWhiteSpaces(xmlReader);
					}
					string name = xmlReader.Name;
					localName = xmlReader.LocalName;
					XmlNodeType nodeType = xmlReader.NodeType;
					Stream data = ReadSingleNodeIntoStream(xmlReader);
					if (!xmlReader.IsEmptyElement)
					{
						if (!(localName == xmlReader.LocalName) || xmlReader.NodeType != XmlNodeType.EndElement)
						{
							if (nodeType == XmlNodeType.Element)
							{
								m_docArchive.AddItem(attribute.Remove(0, 1), data, bControlStream: false, DocGen.Compression.FileAttributes.Normal);
							}
						}
						else if (name == "ax:ocx")
						{
							m_docArchive.AddItem(attribute.Remove(0, 1), data, bControlStream: false, DocGen.Compression.FileAttributes.Normal);
						}
					}
					else if (name == "ax:ocx")
					{
						m_docArchive.AddItem(attribute.Remove(0, 1), data, bControlStream: false, DocGen.Compression.FileAttributes.Normal);
					}
				}
				else if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.LocalName == "binaryData")
				{
					if (!xmlReader.IsEmptyElement)
					{
						localName = xmlReader.LocalName;
						xmlReader.Read();
						if (!(localName == xmlReader.LocalName) || xmlReader.NodeType != XmlNodeType.EndElement)
						{
							string text = Read2003ImageBase64String(xmlReader, localName);
							if (!string.IsNullOrEmpty(text))
							{
								MemoryStream memoryStream = new MemoryStream();
								BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
								byte[] buffer = Convert.FromBase64String(text);
								binaryWriter.Write(buffer);
								binaryWriter.Flush();
								m_docArchive.AddItem(attribute.Remove(0, 1), memoryStream, bControlStream: false, DocGen.Compression.FileAttributes.Normal);
							}
						}
						else
						{
							xmlReader.Skip();
						}
					}
					else
					{
						xmlReader.Skip();
					}
				}
				else
				{
					xmlReader.Skip();
				}
			}
			else
			{
				ReadAndSkipWhiteSpaces(xmlReader);
			}
		}
	}

	internal WordDocument Read(Stream docStream, WordDocument document)
	{
		m_docArchive = new ZipArchive();
		if (document.CheckForEncryption(docStream))
		{
			Stream stream = DecryptDocumentStream(docStream, document);
			m_docArchive.Open(stream, closeStream: false);
		}
		else
		{
			m_docArchive.Open(docStream, closeStream: false);
		}
		document.Password = null;
		m_doc = document;
		Read(document, isFlatOPC: false);
		Close();
		return document;
	}

	internal WordDocument ReadWordML(Stream docStream, WordDocument document)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(docStream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		m_doc = document;
		if (xmlReader.LocalName == "wordDocument")
		{
			IsWord2003ML = true;
			m_nameSpace = "http://schemas.microsoft.com/office/word/2003/wordml";
			document.Settings.CompatibilityMode = CompatibilityMode.Word2003;
			document = ReadWord2003Xml(docStream, document);
			IsWord2003ML = false;
			m_nameSpace = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
			return document;
		}
		m_docArchive = new ZipArchive();
		OpenFlatOPC(docStream);
		Read(document, isFlatOPC: true);
		Close();
		return document;
	}

	private Stream DecryptDocumentStream(Stream stream, WordDocument doc)
	{
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		Stream result = new MemoryStream();
		bool flag = false;
		using (ICompoundFile compoundFile = doc.CreateCompoundFile(stream))
		{
			ICompoundStorage rootStorage = compoundFile.RootStorage;
			SecurityHelper.EncrytionType encryptionType = new SecurityHelper().GetEncryptionType(rootStorage);
			if (encryptionType != SecurityHelper.EncrytionType.None)
			{
				if (doc.Password == null)
				{
					throw new ArgumentException("Document is encrypted, password is needed to open the document");
				}
				switch (encryptionType)
				{
				case SecurityHelper.EncrytionType.Standard:
				{
					flag = true;
					StandardDecryptor standardDecryptor = new StandardDecryptor();
					standardDecryptor.Initialize(rootStorage);
					if (!standardDecryptor.CheckPassword(doc.Password))
					{
						throw new Exception("Specified password \"" + doc.Password + "\" is incorrect!");
					}
					result = standardDecryptor.Decrypt();
					break;
				}
				case SecurityHelper.EncrytionType.Agile:
				{
					flag = true;
					AgileDecryptor agileDecryptor = new AgileDecryptor();
					agileDecryptor.Initialize(rootStorage);
					if (!agileDecryptor.CheckPassword(doc.Password))
					{
						throw new Exception("Specified password \"" + doc.Password + "\" is incorrect!");
					}
					result = agileDecryptor.Decrypt();
					break;
				}
				}
			}
		}
		if (!flag)
		{
			throw new ApplicationException("Wrong Word version");
		}
		return result;
	}

	private void Read(WordDocument document, bool isFlatOPC)
	{
		document.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2007);
		document.DocxPackage = new Package();
		document.DocxPackage.Load(m_docArchive);
		m_docArchive.Dispose();
		m_docArchive = null;
		if (document.DocxPackage != null && document.DocxPackage.XmlPartContainers.ContainsKey("word/") && (isFlatOPC || document.DocxPackage.XmlParts.ContainsKey("[Content_Types].xml")))
		{
			if (isFlatOPC)
			{
				m_documentPath = "document.xml";
			}
			else
			{
				UpdatePath(document.DocxPackage);
			}
			ParseDocumentProperties(document.DocxPackage);
			if (!isFlatOPC)
			{
				UpdateFormatType(document);
			}
			ParseDocument(document.DocxPackage);
			if (IsStrict)
			{
				document.ActualFormatType = FormatType.StrictDocx;
			}
			return;
		}
		throw new NotSupportedException("The specified file is not a valid DOCX, DOTX, DOCM, DOTM, or WordML(XML) format file");
	}

	private void UpdatePath(Package wordPackage)
	{
		m_documentPath = "document.xml";
		string pathByContentType = GetPathByContentType("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", wordPackage);
		if (!string.IsNullOrEmpty(pathByContentType))
		{
			m_documentPath = pathByContentType;
		}
		pathByContentType = GetPathByContentType("application/vnd.ms-word.document.macroEnabled.main+xml", wordPackage);
		if (!string.IsNullOrEmpty(pathByContentType))
		{
			m_documentPath = pathByContentType;
		}
		pathByContentType = GetPathByContentType("application/vnd.ms-word.template.macroEnabledTemplate.main+xml", wordPackage);
		if (!string.IsNullOrEmpty(pathByContentType))
		{
			m_documentPath = pathByContentType;
		}
		pathByContentType = GetPathByContentType("application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml", wordPackage);
		if (!string.IsNullOrEmpty(pathByContentType))
		{
			m_documentPath = pathByContentType;
		}
	}

	private string GetPathByContentType(string contentType, Package wordPackage)
	{
		wordPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
		XmlReader xmlReader = XmlReader.Create(m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "Types")
		{
			throw new XmlException("Expected xml tag \"Types\"");
		}
		xmlReader.Read();
		while (xmlReader.LocalName != "Types")
		{
			if (xmlReader.LocalName == "Override" && xmlReader.HasAttributes)
			{
				string attribute = xmlReader.GetAttribute("ContentType");
				if (contentType == attribute)
				{
					string attribute2 = xmlReader.GetAttribute("PartName");
					if (!string.IsNullOrEmpty(attribute2))
					{
						return attribute2.Split('/')[^1];
					}
				}
			}
			xmlReader.Read();
		}
		wordPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
		return null;
	}

	private string GetExtensionContentType(string extension)
	{
		m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
		XmlReader xmlReader = XmlReader.Create(m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "Types")
		{
			throw new XmlException("Expected xml tag \"Types\"");
		}
		xmlReader.Read();
		while (xmlReader.LocalName != "Types")
		{
			if (xmlReader.LocalName == "Default" && xmlReader.HasAttributes)
			{
				string attribute = xmlReader.GetAttribute("Extension");
				if (extension == attribute)
				{
					return xmlReader.GetAttribute("ContentType");
				}
			}
			xmlReader.Read();
		}
		return null;
	}

	private FormatType GetFormatType(string type)
	{
		return AppVersion switch
		{
			"Word2007" => type switch
			{
				"DOCM" => FormatType.Word2007Docm, 
				"DOTM" => FormatType.Word2007Dotm, 
				"DOTX" => FormatType.Word2007Dotx, 
				_ => FormatType.Word2007, 
			}, 
			"Word2010" => type switch
			{
				"DOCM" => FormatType.Word2010Docm, 
				"DOTM" => FormatType.Word2010Dotm, 
				"DOTX" => FormatType.Word2010Dotx, 
				_ => FormatType.Word2010, 
			}, 
			"Word2013" => type switch
			{
				"DOCM" => FormatType.Word2013Docm, 
				"DOTM" => FormatType.Word2013Dotm, 
				"DOTX" => FormatType.Word2013Dotx, 
				_ => FormatType.Word2013, 
			}, 
			_ => type switch
			{
				"DOCM" => FormatType.Docm, 
				"DOTM" => FormatType.Dotm, 
				"DOTX" => FormatType.Dotx, 
				_ => FormatType.Docx, 
			}, 
		};
	}

	private void UpdateFormatType(WordDocument document)
	{
		document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
		document.ActualFormatType = GetFormatType("DOCX");
		XmlReader xmlReader = XmlReader.Create(document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "Types")
		{
			throw new XmlException("Expected xml tag \"Types\"");
		}
		xmlReader.Read();
		while (xmlReader.LocalName != "Types")
		{
			if (xmlReader.LocalName == "Override" && xmlReader.HasAttributes)
			{
				string attribute = xmlReader.GetAttribute("PartName");
				if ("/word/" + m_documentPath == attribute)
				{
					if (xmlReader.GetAttribute("ContentType") == "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml")
					{
						document.ActualFormatType = GetFormatType("DOTX");
						break;
					}
					if (xmlReader.GetAttribute("ContentType") == "application/vnd.ms-word.template.macroEnabledTemplate.main+xml")
					{
						document.ActualFormatType = GetFormatType("DOTM");
						break;
					}
					if (xmlReader.GetAttribute("ContentType") == "application/vnd.ms-word.document.macroEnabled.main+xml")
					{
						document.ActualFormatType = GetFormatType("DOCM");
						break;
					}
				}
			}
			xmlReader.Read();
		}
		document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
	}

	private void ParseDocument(Package wordPackage)
	{
		PartContainer partContainer = wordPackage.FindPartContainer("word/");
		if (partContainer.Relations.ContainsKey("word/_rels/fontTable.xml.rels"))
		{
			Relations relations = partContainer.Relations["word/_rels/fontTable.xml.rels"];
			ParseFontTableRelations(relations.DataStream);
		}
		if (partContainer.Relations.ContainsKey("word/_rels/" + m_documentPath + ".rels"))
		{
			Relations relations2 = partContainer.Relations["word/_rels/" + m_documentPath + ".rels"];
			ParseDocumentRelations(relations2.DataStream);
		}
		partContainer = wordPackage.FindPartContainer("word/theme/");
		string key = "theme1.xml";
		if (!partContainer.XmlParts.ContainsKey(key))
		{
			foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
			{
				if (xmlPart.Key.Contains("theme"))
				{
					key = xmlPart.Key;
					break;
				}
			}
		}
		if (partContainer.XmlParts.ContainsKey(key))
		{
			ParseThemes(partContainer.XmlParts[key].DataStream);
			m_doc.DocHasThemes = true;
		}
		partContainer = wordPackage.FindPartContainer("word/");
		string key2 = "numbering.xml";
		if (!partContainer.XmlParts.ContainsKey(key2))
		{
			foreach (KeyValuePair<string, Part> xmlPart2 in partContainer.XmlParts)
			{
				if (xmlPart2.Key.Contains("numbering"))
				{
					key2 = xmlPart2.Key;
					break;
				}
			}
		}
		if (partContainer.XmlParts.ContainsKey(key2))
		{
			Part part = partContainer.XmlParts[key2];
			if (part != null && part.DataStream != null && part.DataStream.Length > 0)
			{
				m_reader = UtilityMethods.CreateReader(part.DataStream);
				ParseNumberings(m_reader);
				m_reader.Dispose();
			}
		}
		string key3 = "styles.xml";
		if (!partContainer.XmlParts.ContainsKey(key3))
		{
			foreach (KeyValuePair<string, Part> xmlPart3 in partContainer.XmlParts)
			{
				if (xmlPart3.Key.Contains("styles"))
				{
					key3 = xmlPart3.Key;
					break;
				}
			}
		}
		if (partContainer.XmlParts.ContainsKey(key3))
		{
			m_doc.HasStyleSheets = true;
			m_reader = UtilityMethods.CreateReader(partContainer.XmlParts[key3].DataStream);
			ParseStyles(m_reader);
			m_reader.Dispose();
		}
		if (partContainer.XmlParts.ContainsKey("footnotes.xml"))
		{
			ParseFootnotePart(isFootnote: true);
		}
		if (partContainer.XmlParts.ContainsKey("endnotes.xml"))
		{
			ParseFootnotePart(isFootnote: false);
		}
		if (partContainer.Relations.ContainsKey("word/_rels/settings.xml.rels"))
		{
			ParseSettingsRelations(partContainer.Relations["word/_rels/settings.xml.rels"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("settings.xml"))
		{
			ParseSettings(partContainer.XmlParts["settings.xml"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("comments.xml"))
		{
			ParseComments();
		}
		foreach (string key4 in partContainer.XmlParts.Keys)
		{
			if (key4 == m_documentPath)
			{
				ParseDocument(partContainer.XmlParts[m_documentPath].DataStream);
				break;
			}
		}
		m_doc.Settings.IsOptimizedForBrowser = false;
		if (partContainer.XmlParts.ContainsKey("commentsExtended.xml"))
		{
			Part part2 = FindPart("word/", "commentsExtended.xml");
			if (part2 != null && part2.DataStream != null && part2.DataStream.Length > 0)
			{
				m_reader = UtilityMethods.CreateReader(part2.DataStream);
				ParseCommentsExtended(m_reader);
				m_reader.Dispose();
				m_doc.Comments.SetParentParaIDAndIsResolved();
			}
		}
		if (partContainer.XmlParts.ContainsKey("webSettings.xml"))
		{
			ParseWebSettings(partContainer.XmlParts["webSettings.xml"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("fontTable.xml"))
		{
			ParseFontTable(partContainer.XmlParts["fontTable.xml"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("vbaProject.bin"))
		{
			ParseVbaProject(partContainer.XmlParts["vbaProject.bin"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("vbaProjectSignature.bin"))
		{
			ParseVbaProjectSignature(partContainer.XmlParts["vbaProjectSignature.bin"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("vbaProjectSignatureAgile.bin"))
		{
			ParseVbaProjectSignatureAgile(partContainer.XmlParts["vbaProjectSignatureAgile.bin"].DataStream);
		}
		if (partContainer.XmlParts.ContainsKey("vbaData.xml"))
		{
			ParseVbaData(partContainer.XmlParts["vbaData.xml"].DataStream);
		}
		partContainer = m_doc.DocxPackage.FindPartContainer("customUI/");
		if (partContainer.XmlParts.ContainsKey("customUI.xml"))
		{
			m_doc.CustomUIPartContainer = partContainer;
		}
		partContainer = m_doc.DocxPackage.FindPartContainer("userCustomization/");
		if (partContainer.XmlParts.ContainsKey("customUI.xml"))
		{
			m_doc.UserCustomizationPartContainer = partContainer;
		}
		partContainer = m_doc.DocxPackage.FindPartContainer("customXml/");
		if (partContainer.Name == "customXml/")
		{
			SortCustomXmlbyRid(partContainer);
			m_doc.CustomXMLContainer = partContainer;
			BindCustomXmlData(partContainer);
		}
		if (m_doc.m_AltChunkOwner != null)
		{
			partContainer = m_doc.m_AltChunkOwner.DocxPackage.FindPartContainer("customXml/").Clone();
			BindCustomXmlData(partContainer);
		}
	}

	private void SortCustomXmlbyRid(PartContainer partContainer)
	{
		Dictionary<string, Part> dictionary = new Dictionary<string, Part>();
		Dictionary<string, Part> xmlParts = partContainer.XmlParts;
		bool flag = false;
		int num = 0;
		int num2 = 0;
		foreach (string key3 in DocumentRelations.Keys)
		{
			if (DocumentRelations[key3].Value.ToString().ToLower().Contains("customxml/item"))
			{
				string text = key3.ToLower();
				if (!text.StartsWith("rid"))
				{
					break;
				}
				int result = 0;
				int.TryParse(text.Replace("rid", ""), out result);
				if (!flag)
				{
					flag = result < num;
				}
				if (result > num2)
				{
					num2 = result;
				}
				num = result;
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		while (dictionary.Count < xmlParts.Count && num3 <= num2)
		{
			string key = "rId" + num3;
			if (DocumentRelations.ContainsKey(key) && DocumentRelations[key].Value.ToString().ToLower().Contains("customxml/item"))
			{
				string? text2 = DocumentRelations[key].Value.ToString();
				string text3 = text2.Substring(text2.LastIndexOf('/') + 1);
				if (!xmlParts.ContainsKey(text3))
				{
					break;
				}
				dictionary.Add(text3, xmlParts[text3]);
				string key2 = text3.Replace("item", "itemProps");
				if (!xmlParts.ContainsKey(key2))
				{
					break;
				}
				dictionary.Add(key2, xmlParts[key2]);
			}
			num3++;
		}
		if (dictionary.Count != xmlParts.Count)
		{
			return;
		}
		partContainer.XmlParts.Clear();
		foreach (string key4 in dictionary.Keys)
		{
			partContainer.XmlParts[key4] = dictionary[key4];
		}
	}

	private void BindCustomXmlData(PartContainer partContainer)
	{
		if (BlockContentControls.Count > 0 || InlineContentControls.Count > 0 || CellContentControls.Count > 0)
		{
			MapContentControl(partContainer);
		}
		ParseMetaDataProperties(partContainer);
	}

	private void ParseMetaDataProperties(PartContainer partContainer)
	{
		System.Xml.Linq.XDocument xDocument = null;
		System.Xml.Linq.XDocument xDocument2 = null;
		if (partContainer.XmlParts.Count <= 0)
		{
			return;
		}
		foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
		{
			string key = xmlPart.Key;
			if (!(key == "") && partContainer.XmlParts[key].DataStream.Length != 0L)
			{
				Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[key].DataStream);
				System.Xml.Linq.XDocument xDocument3 = new System.Xml.Linq.XDocument();
				using (XmlReader reader = XmlReader.Create(input))
				{
					xDocument3 = System.Xml.Linq.XDocument.Load(reader, LoadOptions.None);
				}
				XElement root = xDocument3.Root;
				if (root.Name.LocalName == "properties" && root.HasElements && root.FirstNode is XElement && ((XElement)root.FirstNode).Name.LocalName == "documentManagement")
				{
					m_doc.m_metaXmlItem = key;
					xDocument2 = xDocument3;
				}
				if (root.Name.LocalName == "contentTypeSchema")
				{
					xDocument = xDocument3;
				}
			}
		}
		if (xDocument != null && xDocument2 != null)
		{
			MetaProperty metaProperty = new MetaProperty();
			m_doc.m_contentTypeProperties = metaProperty.ParseMetaProperty(xDocument.Root, xDocument2);
		}
	}

	private void ResetControls(PartContainer partContainer, Dictionary<string, List<InlineContentControl>> resultInlineControls, Dictionary<string, List<BlockContentControl>> resultBlockControls, Dictionary<string, List<WTableCell>> resultCellControls)
	{
		string text = string.Empty;
		foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
		{
			if (xmlPart.Key.Contains("Props"))
			{
				text = xmlPart.Key;
			}
		}
		if (partContainer.XmlParts.Count == 0 || text != string.Empty)
		{
			if (BlockContentControls.Count > 0)
			{
				resultBlockControls.Add(text, BlockContentControls);
				ResetBlockControlWithMappedItem(partContainer, resultBlockControls);
			}
			if (InlineContentControls.Count > 0)
			{
				resultInlineControls.Add(text, InlineContentControls);
				ResetInlineControlWithMappedItem(partContainer, resultInlineControls);
			}
			if (CellContentControls.Count > 0)
			{
				resultCellControls.Add(text, CellContentControls);
				ResetCellControlWithMappedItem(partContainer, resultCellControls);
			}
		}
	}

	internal bool IsXmlPartsContainsProps(PartContainer partContainer)
	{
		foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
		{
			if (xmlPart.Key.Contains("Props"))
			{
				return true;
			}
		}
		return false;
	}

	internal void MapContentControl(PartContainer partContainer)
	{
		Dictionary<string, List<InlineContentControl>> dictionary = new Dictionary<string, List<InlineContentControl>>();
		Dictionary<string, List<BlockContentControl>> dictionary2 = new Dictionary<string, List<BlockContentControl>>();
		Dictionary<string, List<WTableCell>> dictionary3 = new Dictionary<string, List<WTableCell>>();
		if (partContainer.XmlParts.Count == 0 || (partContainer.XmlParts.Count == 2 && IsXmlPartsContainsProps(partContainer)))
		{
			ResetControls(partContainer, dictionary, dictionary2, dictionary3);
			return;
		}
		foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
		{
			string key = xmlPart.Key;
			if (!key.Contains("Props") || partContainer.XmlParts[xmlPart.Key].DataStream.Length <= 0)
			{
				continue;
			}
			List<InlineContentControl> list = new List<InlineContentControl>();
			List<BlockContentControl> list2 = new List<BlockContentControl>();
			List<WTableCell> list3 = new List<WTableCell>();
			System.Xml.Linq.XAttribute xMLAttribute = partContainer.XmlParts[xmlPart.Key].GetXMLAttribute("itemID");
			if (xMLAttribute != null)
			{
				foreach (InlineContentControl inlineContentControl in InlineContentControls)
				{
					if (xMLAttribute.Value.Equals(inlineContentControl.ContentControlProperties.XmlMapping.StoreItemID))
					{
						list.Add(inlineContentControl);
					}
				}
				foreach (BlockContentControl blockContentControl in BlockContentControls)
				{
					if (xMLAttribute.Value.Equals(blockContentControl.ContentControlProperties.XmlMapping.StoreItemID))
					{
						list2.Add(blockContentControl);
					}
				}
				foreach (WTableCell cellContentControl in CellContentControls)
				{
					if (xMLAttribute.Value.Equals(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.StoreItemID))
					{
						list3.Add(cellContentControl);
					}
				}
			}
			if (list.Count > 0)
			{
				dictionary.Add(key, list);
			}
			if (list2.Count > 0)
			{
				dictionary2.Add(key, list2);
			}
			if (list3.Count > 0)
			{
				dictionary3.Add(key, list3);
			}
		}
		List<BlockContentControl> idMisMatchedContentControl = GetIdMisMatchedContentControl(dictionary2, BlockContentControls);
		if (idMisMatchedContentControl.Count > 0)
		{
			dictionary2.Add("", idMisMatchedContentControl);
		}
		if (dictionary2.Count > 0)
		{
			ResetBlockControlWithMappedItem(partContainer, dictionary2);
		}
		idMisMatchedContentControl.Clear();
		List<InlineContentControl> idMisMatchedContentControl2 = GetIdMisMatchedContentControl(dictionary);
		if (idMisMatchedContentControl2.Count > 0)
		{
			dictionary.Add("", idMisMatchedContentControl2);
		}
		if (dictionary.Count > 0)
		{
			ResetInlineControlWithMappedItem(partContainer, dictionary);
		}
		idMisMatchedContentControl2.Clear();
		List<WTableCell> idMisMatchedContentControl3 = GetIdMisMatchedContentControl(dictionary3);
		if (idMisMatchedContentControl3.Count > 0)
		{
			dictionary3.Add("", idMisMatchedContentControl3);
		}
		if (dictionary3.Count > 0)
		{
			ResetCellControlWithMappedItem(partContainer, dictionary3);
		}
		idMisMatchedContentControl3.Clear();
	}

	private List<BlockContentControl> GetIdMisMatchedContentControl(Dictionary<string, List<BlockContentControl>> resultBlockControls, List<BlockContentControl> ContentControls)
	{
		List<BlockContentControl> list = new List<BlockContentControl>();
		foreach (BlockContentControl ContentControl in ContentControls)
		{
			if (string.IsNullOrEmpty(ContentControl.ContentControlProperties.XmlMapping.XPath) || !(ContentControl.ContentControlProperties.XmlMapping.StoreItemID != string.Empty))
			{
				continue;
			}
			bool flag = false;
			foreach (KeyValuePair<string, List<BlockContentControl>> resultBlockControl in resultBlockControls)
			{
				foreach (BlockContentControl item in resultBlockControl.Value)
				{
					if (item == ContentControl)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				list.Add(ContentControl);
			}
		}
		return list;
	}

	private List<WTableCell> GetIdMisMatchedContentControl(Dictionary<string, List<WTableCell>> resultCellControls)
	{
		List<WTableCell> list = new List<WTableCell>();
		foreach (WTableCell cellContentControl in CellContentControls)
		{
			if (string.IsNullOrEmpty(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.XPath) || !(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.StoreItemID != string.Empty))
			{
				continue;
			}
			bool flag = false;
			foreach (KeyValuePair<string, List<WTableCell>> resultCellControl in resultCellControls)
			{
				foreach (WTableCell item in resultCellControl.Value)
				{
					if (item == cellContentControl)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				list.Add(cellContentControl);
			}
		}
		return list;
	}

	private List<InlineContentControl> GetIdMisMatchedContentControl(Dictionary<string, List<InlineContentControl>> resultInlineControls)
	{
		List<InlineContentControl> list = new List<InlineContentControl>();
		foreach (InlineContentControl inlineContentControl in InlineContentControls)
		{
			if (string.IsNullOrEmpty(inlineContentControl.ContentControlProperties.XmlMapping.XPath) || !(inlineContentControl.ContentControlProperties.XmlMapping.StoreItemID != string.Empty))
			{
				continue;
			}
			bool flag = false;
			foreach (KeyValuePair<string, List<InlineContentControl>> resultInlineControl in resultInlineControls)
			{
				foreach (InlineContentControl item in resultInlineControl.Value)
				{
					if (item == inlineContentControl)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				list.Add(inlineContentControl);
			}
		}
		return list;
	}

	private void ResetCellControlWithMappedItem(PartContainer partContainer, Dictionary<string, List<WTableCell>> resultCellControls)
	{
		foreach (KeyValuePair<string, List<WTableCell>> resultCellControl in resultCellControls)
		{
			if (partContainer.XmlParts.Count == 0)
			{
				ResetCellControls(resultCellControl, null);
				continue;
			}
			foreach (string key in partContainer.XmlParts.Keys)
			{
				if (resultCellControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0 || resultCellControl.Key == "")
				{
					ResetCellControls(resultCellControl, GetXmlElement(key, partContainer));
				}
			}
		}
	}

	private void ResetCellControls(KeyValuePair<string, List<WTableCell>> control, XmlElement rootElement)
	{
		foreach (WTableCell item in control.Value)
		{
			if (string.IsNullOrEmpty(item.ContentControl.ContentControlProperties.XmlMapping.XPath))
			{
				continue;
			}
			bool isDocProperty = false;
			List<string> listPath = GetListPath(item.ContentControl.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
			if (isDocProperty)
			{
				SetCoreProperty(item, listPath);
				continue;
			}
			if (rootElement == null)
			{
				continue;
			}
			XmlDocument ownerDocument = rootElement.OwnerDocument;
			XmlNamespaceManager xmlNamespaceManager = item.ContentControl.ContentControlProperties.XmlMapping.GetXmlNamespaceManager(ownerDocument, item.ContentControl.ContentControlProperties.XmlMapping.PrefixMapping);
			XmlNode xmlNode = null;
			try
			{
				xmlNode = ownerDocument.SelectSingleNode(item.ContentControl.ContentControlProperties.XmlMapping.XPath, xmlNamespaceManager);
			}
			catch (XPathException)
			{
			}
			if (xmlNode == null)
			{
				continue;
			}
			string innerText = xmlNode.InnerText;
			string text = string.Empty;
			foreach (Entity childEntity in item.ChildEntities)
			{
				if (!(childEntity is WParagraph))
				{
					continue;
				}
				foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
				{
					if (childEntity2 is WTextRange)
					{
						text += (childEntity2 as WTextRange).Text;
					}
				}
			}
			string text2;
			if (!text.Equals(innerText) && item.ContentControl.ContentControlProperties.Type != ContentControlType.Picture)
			{
				text2 = (item.ContentControl.ContentControlProperties.Multiline ? ReplaceAsSoftBreaks(innerText) : ReplaceBreakChars(innerText));
				text2 = ConvertTextToDateFormat(item.ContentControl.ContentControlProperties, text2);
				bool num;
				if (listPath.Count != 1)
				{
					if (!item.ContentControl.ContentControlProperties.XmlMapping.IsSupportWordML)
					{
						goto IL_0247;
					}
					num = item.ContentControl.ContentControlProperties.Type == ContentControlType.RichText;
				}
				else
				{
					num = item.ContentControl.ContentControlProperties.XmlMapping.IsWordML;
				}
				if (num)
				{
					ConvertWordMLToText(item, text2);
					continue;
				}
				goto IL_0247;
			}
			if (item.ContentControl.ContentControlProperties.Type == ContentControlType.Picture)
			{
				SetMappedPicture(item, innerText);
			}
			continue;
			IL_0247:
			SetMappedCell(item, text2);
		}
	}

	private void ResetBlockControlWithMappedItem(PartContainer partContainer, Dictionary<string, List<BlockContentControl>> resultBlockControls)
	{
		foreach (KeyValuePair<string, List<BlockContentControl>> resultBlockControl in resultBlockControls)
		{
			if (partContainer.XmlParts.Count == 0)
			{
				ResetBlockControls(resultBlockControl, null);
				continue;
			}
			foreach (string key in partContainer.XmlParts.Keys)
			{
				if (resultBlockControl.Key == "" || resultBlockControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0)
				{
					ResetBlockControls(resultBlockControl, GetXmlElement(key, partContainer));
				}
			}
		}
	}

	private void ResetBlockControls(KeyValuePair<string, List<BlockContentControl>> blockControl, XmlElement rootElement)
	{
		foreach (BlockContentControl item in blockControl.Value)
		{
			if (string.IsNullOrEmpty(item.ContentControlProperties.XmlMapping.XPath))
			{
				continue;
			}
			bool isRootElement = false;
			bool isDocProperty = false;
			bool isMappedElementHasNoValue = false;
			string orUpdateMappedValue = item.ContentControlProperties.XmlMapping.GetOrUpdateMappedValue(m_doc, item, rootElement, null, ref isRootElement, ref isDocProperty, ref isMappedElementHasNoValue);
			if (!(isDocProperty ? (!string.IsNullOrEmpty(orUpdateMappedValue)) : (!isMappedElementHasNoValue)))
			{
				continue;
			}
			string text = string.Empty;
			foreach (Entity childEntity in item.TextBody.ChildEntities)
			{
				if (!(childEntity is WParagraph))
				{
					continue;
				}
				foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
				{
					if (childEntity2 is WTextRange)
					{
						text += (childEntity2 as WTextRange).Text;
					}
				}
			}
			bool num;
			if (isRootElement)
			{
				num = !text.Equals(orUpdateMappedValue);
			}
			else
			{
				if (!text.Equals(orUpdateMappedValue))
				{
					goto IL_016c;
				}
				if (!(text == string.Empty))
				{
					goto IL_01fe;
				}
				num = orUpdateMappedValue == string.Empty;
			}
			if (num)
			{
				goto IL_016c;
			}
			goto IL_01fe;
			IL_01fe:
			if (item.ContentControlProperties.Type == ContentControlType.Picture)
			{
				SetMappedPicture(item, orUpdateMappedValue);
			}
			continue;
			IL_016c:
			string text2;
			if (item.ContentControlProperties.Type != ContentControlType.Picture)
			{
				text2 = (item.ContentControlProperties.Multiline ? ReplaceAsSoftBreaks(orUpdateMappedValue) : ReplaceBreakChars(orUpdateMappedValue));
				text2 = ConvertTextToDateFormat(item.ContentControlProperties, text2);
				bool num2;
				if (!isRootElement)
				{
					if (!item.ContentControlProperties.XmlMapping.IsSupportWordML)
					{
						goto IL_01f3;
					}
					num2 = item.ContentControlProperties.Type == ContentControlType.RichText;
				}
				else
				{
					num2 = item.ContentControlProperties.XmlMapping.IsWordML;
				}
				if (num2)
				{
					ConvertWordMLToText(item, text2);
					continue;
				}
				goto IL_01f3;
			}
			goto IL_01fe;
			IL_01f3:
			SetMappedParagraph(item, text2);
		}
	}

	private void SetCoreProperty(object control, List<string> xPathList)
	{
		foreach (string xPath in xPathList)
		{
			if (xPath.Contains("coreProperties"))
			{
				continue;
			}
			int startIndex = 0;
			int endIndex = 0;
			string text = GetPathIndex(xPath, ref startIndex, ref endIndex);
			if ((startIndex == -1 || endIndex == -1) && (startIndex != -1 || endIndex != -1))
			{
				continue;
			}
			if (startIndex != -1 && endIndex != -1)
			{
				text = text.Substring(0, startIndex);
			}
			string text2 = string.Empty;
			switch (text)
			{
			case "title":
				text2 = m_doc.BuiltinDocumentProperties.Title;
				break;
			case "creator":
				text2 = m_doc.BuiltinDocumentProperties.Author;
				break;
			case "category":
				text2 = m_doc.BuiltinDocumentProperties.Category;
				break;
			case "created":
				text2 = Convert.ToString(m_doc.BuiltinDocumentProperties.CreateDate, CultureInfo.InvariantCulture);
				break;
			case "description":
				text2 = m_doc.BuiltinDocumentProperties.Comments;
				break;
			case "keywords":
				text2 = m_doc.BuiltinDocumentProperties.Keywords;
				break;
			case "lastModifiedBy":
				text2 = m_doc.BuiltinDocumentProperties.LastAuthor;
				break;
			case "lastPrinted":
				text2 = Convert.ToString(m_doc.BuiltinDocumentProperties.LastPrinted, CultureInfo.InvariantCulture);
				break;
			case "modified":
				text2 = Convert.ToString(m_doc.BuiltinDocumentProperties.LastSaveDate, CultureInfo.InvariantCulture);
				break;
			case "subject":
				text2 = m_doc.BuiltinDocumentProperties.Subject;
				break;
			case "revision":
				text2 = m_doc.BuiltinDocumentProperties.RevisionNumber;
				break;
			case "contentStatus":
				text2 = m_doc.BuiltinDocumentProperties.ContentStatus;
				break;
			}
			if (!string.IsNullOrEmpty(text2))
			{
				if (control is BlockContentControl)
				{
					SetMappedParagraph(control as BlockContentControl, text2);
				}
				else if (control is InlineContentControl)
				{
					SetMappedItem(control as InlineContentControl, text2);
				}
				else if (control is WTableCell)
				{
					SetMappedCell(control as WTableCell, text2);
				}
			}
		}
	}

	private void ResetInlineControlWithMappedItem(PartContainer partContainer, Dictionary<string, List<InlineContentControl>> resultInlineControls)
	{
		foreach (KeyValuePair<string, List<InlineContentControl>> resultInlineControl in resultInlineControls)
		{
			if (partContainer.XmlParts.Count == 0)
			{
				ResetInlineControls(resultInlineControl, null, isCustomXmlItem: false);
				continue;
			}
			foreach (string key in partContainer.XmlParts.Keys)
			{
				if (resultInlineControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0 || resultInlineControl.Key == "")
				{
					ResetInlineControls(resultInlineControl, GetXmlElement(key, partContainer), isCustomXmlItem: true);
				}
			}
		}
	}

	private void ResetInlineControls(KeyValuePair<string, List<InlineContentControl>> inlineControl, XmlElement rootElement, bool isCustomXmlItem)
	{
		foreach (InlineContentControl item in inlineControl.Value)
		{
			if (string.IsNullOrEmpty(item.ContentControlProperties.XmlMapping.XPath))
			{
				continue;
			}
			bool isRootElement = false;
			bool isDocProperty = false;
			bool isMappedElementHasNoValue = false;
			string orUpdateMappedValue = item.ContentControlProperties.XmlMapping.GetOrUpdateMappedValue(m_doc, item, rootElement, null, isCustomXmlItem, ref isRootElement, ref isDocProperty, ref isMappedElementHasNoValue);
			if (!(isDocProperty ? (!string.IsNullOrEmpty(orUpdateMappedValue)) : (!isMappedElementHasNoValue)))
			{
				continue;
			}
			string text = string.Empty;
			foreach (ParagraphItem paragraphItem in item.ParagraphItems)
			{
				if (paragraphItem is WTextRange)
				{
					text += (paragraphItem as WTextRange).Text;
				}
			}
			string text2;
			if (!text.Equals(orUpdateMappedValue) && item.ContentControlProperties.Type != ContentControlType.Picture)
			{
				text2 = (item.ContentControlProperties.Multiline ? ReplaceAsSoftBreaks(orUpdateMappedValue) : ReplaceBreakChars(orUpdateMappedValue));
				text2 = ConvertTextToDateFormat(item.ContentControlProperties, text2);
				bool num;
				if (!isRootElement)
				{
					if (!item.ContentControlProperties.XmlMapping.IsSupportWordML)
					{
						goto IL_016d;
					}
					num = item.ContentControlProperties.Type == ContentControlType.RichText;
				}
				else
				{
					num = item.ContentControlProperties.XmlMapping.IsWordML;
				}
				if (num)
				{
					ConvertWordMLToText(item, text2);
					continue;
				}
				goto IL_016d;
			}
			if (item.ContentControlProperties.Type == ContentControlType.Picture)
			{
				SetMappedPicture(item, orUpdateMappedValue);
			}
			continue;
			IL_016d:
			SetMappedItem(item, text2);
		}
	}

	private XmlElement GetXmlElement(string xmlPartsPath, PartContainer partContainer)
	{
		if (partContainer.XmlParts[xmlPartsPath].DataStream.Length <= 0)
		{
			return null;
		}
		Stream stream = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPartsPath].DataStream);
		stream.Position = 0L;
		XmlDocument xmlDocument = new XmlDocument();
		xmlDocument.PreserveWhitespace = true;
		xmlDocument.Load(stream);
		return xmlDocument.DocumentElement;
	}

	private XElement GetLinqXmlElement(string xmlPartsPath, PartContainer partContainer)
	{
		if (partContainer.XmlParts[xmlPartsPath].DataStream.Length <= 0)
		{
			return null;
		}
		Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPartsPath].DataStream);
		new System.Xml.Linq.XDocument();
		using XmlReader reader = XmlReader.Create(input);
		return System.Xml.Linq.XDocument.Load(reader).Root;
	}

	private List<string> GetParamListPath(string path, ref bool isDocProperty)
	{
		if (path.Contains("//"))
		{
			path = path.Replace("//", "");
		}
		string[] array = path.Split('[', ']');
		List<string> list = new List<string>();
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			string text = array2[i];
			if (text.Contains("@"))
			{
				text = text.Replace("@", "");
			}
			if (text != "")
			{
				list.Add(text);
			}
			if (text.ToLower().Contains("coreproperties") || text.ToLower().Contains("coverpageproperties"))
			{
				isDocProperty = true;
			}
		}
		return list;
	}

	private List<string> GetListPath(string path, ref bool isDocProperty)
	{
		string[] array = path.Split(new char[1] { '/' });
		List<string> list = new List<string>();
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (text != "")
			{
				list.Add(text);
			}
			if (text.ToLower().Contains("coreproperties") || text.ToLower().Contains("coverpageproperties"))
			{
				isDocProperty = true;
			}
		}
		return list;
	}

	private List<string> GetListPath(string path)
	{
		bool isDocProperty = false;
		return GetListPath(path, ref isDocProperty);
	}

	private string GetPathIndex(string path, ref int startIndex, ref int endIndex)
	{
		if (path.Contains(":"))
		{
			path = path.Substring(path.IndexOf(":") + 1);
		}
		startIndex = path.IndexOf("[");
		endIndex = path.IndexOf("]");
		return path;
	}

	private System.Xml.Linq.XNode GetCurrentNode(IEnumerable<System.Xml.Linq.XNode> childNodes, System.Xml.Linq.XNode currentNode, ref int toIterate, int nodeIndex, string path, string parentInfo, string attributeName, string attributeValue)
	{
		foreach (System.Xml.Linq.XNode childNode in childNodes)
		{
			string text = ((childNode is XElement) ? ((XElement)childNode).Name.LocalName.ToString() : string.Empty);
			if (text.Contains(":"))
			{
				text = text.Substring(text.IndexOf(":") + 1);
			}
			if (text.Equals(path) && parentInfo != null && CheckValidNode(parentInfo, childNode))
			{
				toIterate++;
				if (attributeName.Contains(":"))
				{
					attributeName = attributeName.Substring(attributeName.IndexOf(":") + 1);
				}
				if (nodeIndex == toIterate || (!string.IsNullOrEmpty(attributeName) && !string.IsNullOrEmpty(attributeValue) && ((XElement)childNode).Attribute(((XElement)childNode).Name.Namespace + attributeName) != null && ((XElement)childNode).Attribute(((XElement)childNode).Name.Namespace + attributeName).Value == attributeValue))
				{
					currentNode = childNode;
					break;
				}
			}
		}
		return currentNode;
	}

	private bool CheckValidNode(string parentOfTempPath, System.Xml.Linq.XNode node)
	{
		if (parentOfTempPath.Contains("[@"))
		{
			int num = parentOfTempPath.IndexOf('[');
			string text = parentOfTempPath.Substring(0, num);
			if (text.Contains(":"))
			{
				text = text.Substring(text.IndexOf(":") + 1);
			}
			if (node.Parent.Name.LocalName != text)
			{
				return false;
			}
			string secondPart = parentOfTempPath.Substring(num);
			Dictionary<string, string> attributesOfXPath = GetAttributesOfXPath(secondPart);
			return CheckNodeHasValidAttributes(attributesOfXPath, node);
		}
		return true;
	}

	private bool CheckNodeHasValidAttributes(Dictionary<string, string> expectedAttributes, System.Xml.Linq.XNode currentNode)
	{
		System.Xml.Linq.XAttribute firstAttribute = currentNode.Parent.FirstAttribute;
		foreach (KeyValuePair<string, string> expectedAttribute in expectedAttributes)
		{
			System.Xml.Linq.XAttribute xAttribute = firstAttribute;
			while (xAttribute != null)
			{
				int num = xAttribute.ToString().IndexOf('=');
				string text = xAttribute.ToString().Substring(0, num);
				string text2 = xAttribute.ToString().Substring(num + 1);
				if (expectedAttribute.Key == text)
				{
					if (!(expectedAttribute.Value == text2.Trim('"')))
					{
						return false;
					}
					xAttribute = xAttribute.NextAttribute;
				}
				else
				{
					xAttribute = xAttribute.NextAttribute;
				}
			}
		}
		return true;
	}

	private string GetResultText(string path, List<string> xPathList, WTableCell contentControl)
	{
		string text = string.Empty;
		if (xPathList[xPathList.Count - 1].Contains(path))
		{
			foreach (Entity childEntity in contentControl.ChildEntities)
			{
				if (!(childEntity is WParagraph))
				{
					continue;
				}
				foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
				{
					if (childEntity2 is WTextRange)
					{
						text += (childEntity2 as WTextRange).Text;
					}
				}
			}
		}
		return text;
	}

	private string GetTextFromContentControl(string path, List<string> xPathList, BlockContentControl contentControl)
	{
		string text = string.Empty;
		if (xPathList[xPathList.Count - 1].Contains(path))
		{
			foreach (Entity childEntity in contentControl.TextBody.ChildEntities)
			{
				if (!(childEntity is WParagraph))
				{
					continue;
				}
				foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
				{
					if (childEntity2 is WTextRange)
					{
						text += (childEntity2 as WTextRange).Text;
					}
				}
			}
		}
		return text;
	}

	private Dictionary<string, string> GetAttributesOfXPath(string secondPart)
	{
		string[] array = secondPart.Split(new char[1] { '[' }, StringSplitOptions.RemoveEmptyEntries);
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		foreach (string obj in array)
		{
			int num = obj.IndexOf('@');
			string text = obj.Remove(0, num + 1);
			num = text.LastIndexOf(']');
			string[] array2 = text.Remove(num).Split('=');
			array2[1] = array2[1].Trim();
			array2[1] = array2[1].TrimStart('\'');
			array2[1] = array2[1].TrimEnd('\'');
			dictionary.Add(array2[0].Trim(), array2[1]);
		}
		return dictionary;
	}

	private string ConvertTextToDateFormat(ContentControlProperties control, string text)
	{
		if (control.Type == ContentControlType.Date && !string.IsNullOrEmpty(control.DateDisplayFormat) && control.DateStorageFormat != ContentControlDateStorageFormat.DateStorageText && IsProperDateTimeFormat(ref text))
		{
			string text2 = control.DateDisplayFormat;
			if (text2.Contains("am/pm"))
			{
				text2 = text2.Replace("am/pm", "tt");
			}
			DateTime result = default(DateTime);
			if (DateTime.TryParse(text, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result))
			{
				if (result.Year < 1900)
				{
					result = new DateTime(1900, 1, 1, 12, 0, 0);
				}
				else if (result.Year > 2411)
				{
					result = new DateTime(2411, 12, 31, 23, 59, 0);
				}
				text = result.AddSeconds(-result.Second).ToString(text2);
			}
		}
		return text;
	}

	private bool IsProperDateTimeFormat(ref string str)
	{
		bool result = false;
		if (new Regex("^(?:[01]\\d|2[0123]):$|^(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array = str.Split(':');
			if (int.Parse(array[0]) > 23)
			{
				str = "00:" + array[1] + ":00";
			}
			else
			{
				str = array[0] + ":00:00";
			}
			result = true;
		}
		else if (new Regex("^(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^(?:[01]\\d|2[0123]):(?:[012345]\\d):$|^(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array2 = str.Split(':');
			if (int.Parse(array2[0]) > 23)
			{
				str = "00:" + array2[1] + ":00";
			}
			else
			{
				str = array2[0] + ":" + array2[1] + ":00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$").IsMatch(str))
		{
			string[] array3 = str.Split('T');
			str = array3[0];
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123])$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):$").IsMatch(str))
		{
			string[] array4 = str.Split('T', ':');
			str = array4[0] + "T" + array4[1] + ":00:00";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array5 = str.Split('T');
			if (int.Parse(array5[1]) > 23)
			{
				str = array5[0] + "T00:00:00";
			}
			else
			{
				str = array5[0] + "T" + array5[1] + ":00:00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array6 = str.Split('T', ':');
			str = array6[0] + "T" + array6[1] + ":" + array6[2] + ":00";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d):((?:[012345]\\d[Zz])||(?:[012345]\\d[+-](?:[012345]\\d):(?:[012345]\\d)))$").IsMatch(str))
		{
			if (str.ToLower().Contains("z"))
			{
				string[] array7 = str.Split('T', ':', 'Z', 'z');
				str = array7[0] + "T" + array7[1] + ":" + array7[2] + ":" + array7[3];
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array8 = str.Split('T', ':');
			if (int.Parse(array8[1]) > 23)
			{
				str = array8[0] + "T00:" + array8[2] + ":00";
			}
			else
			{
				str = array8[0] + "T" + array8[1] + ":" + array8[2] + ":00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str) || new Regex("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}Z$").IsMatch(str))
		{
			string[] array9 = str.Split('T', ':');
			str = array9[0] + "T" + array9[1] + ":" + array9[2] + ":00";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])$|^\\d{4}-(0[1-9]|1[012])T$|^\\d{4}-(0[1-9]|1[012])-$").IsMatch(str))
		{
			string[] array10 = str.Split('T', '-');
			str = array10[0] + "-" + array10[1] + "-01";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123])$|^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):$").IsMatch(str))
		{
			string[] array11 = str.Split('T', ':');
			str = array11[0] + "-01T" + array11[1] + ":00:00";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array12 = str.Split('T', ':');
			if (int.Parse(array12[1]) > 23)
			{
				str = array12[0] + "-01T00:00:00";
			}
			else
			{
				str = array12[0] + "-01T" + array12[1] + ":00:00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array13 = str.Split('T', ':');
			str = array13[0] + "-01T" + array13[1] + ":" + array13[2] + ":00";
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array14 = str.Split('T', ':');
			if (int.Parse(array14[1]) > 23)
			{
				str = array14[0] + "-01T00:" + array14[2] + ":00";
			}
			else
			{
				str = array14[0] + "-01T" + array14[1] + ":" + array14[2] + ":00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array15 = str.Split('T', ':');
			str = array15[0] + "-01T" + array15[1] + ":" + array15[2] + ":00";
			result = true;
		}
		else if (new Regex("^\\d{4}$|^\\d{4}-$|^\\d{4}T$").IsMatch(str))
		{
			string[] array16 = str.Split('T', '-');
			str = array16[0] + "-01-01";
			result = true;
		}
		else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123])$|^\\d{4}T(?:[01]\\d|2[0123]):$").IsMatch(str))
		{
			string[] array17 = str.Split('T', ':');
			str = array17[0] + "-01-01T" + array17[1] + ":00:00";
			result = true;
		}
		else if (new Regex("^\\d{4}T(?:[012345]\\d)$|^\\d{4}T(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array18 = str.Split('T', ':');
			if (int.Parse(array18[1]) > 23)
			{
				str = array18[0] + "-01-01T00:00:00";
			}
			else
			{
				str = array18[0] + "-01-01T" + array18[1] + ":00:00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
		{
			string[] array19 = str.Split('T', ':');
			str = array19[0] + "-01-01T" + array19[1] + ":" + array19[2] + ":00";
			result = true;
		}
		else if (new Regex("^\\d{4}T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array20 = str.Split('T', ':');
			if (int.Parse(array20[1]) > 23)
			{
				str = array20[0] + "-01-01T00:" + array20[2] + ":00";
			}
			else
			{
				str = array20[0] + "-01-01T" + array20[1] + ":" + array20[2] + ":00";
			}
			result = true;
		}
		else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array21 = str.Split('T', ':');
			str = array21[0] + "-01-01T" + array21[1] + ":" + array21[2] + ":00";
			result = true;
		}
		else if (new Regex("^(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
		{
			string[] array22 = str.Split(':');
			str = array22[0] + ":" + array22[1] + ":00";
			result = true;
		}
		return result;
	}

	private void SetSpacesForEmptyContentControl(ParagraphItem paraitem)
	{
		(paraitem as WTextRange).Text = "     ";
	}

	private bool HasEmptyTextInParagraph(WParagraph para)
	{
		foreach (ParagraphItem item in para.Items)
		{
			if (!(item is WTextRange) || !((item as WTextRange).Text == ""))
			{
				return false;
			}
		}
		return true;
	}

	private bool HasEmptyBodyItems(BodyItemCollection itemCollection)
	{
		foreach (Entity item in itemCollection)
		{
			if (!(item is WParagraph) || !HasEmptyTextInParagraph(item as WParagraph))
			{
				return false;
			}
		}
		return true;
	}

	private WTextRange GetDefaultSpaceFromWordML(WTextBody textBody)
	{
		WParagraph wParagraph = textBody.Items.LastItem as WParagraph;
		WTextRange wTextRange = ((wParagraph.ChildEntities.Count == 0) ? (wParagraph.AppendText("") as WTextRange) : ((wParagraph.LastItem is WTextRange) ? (wParagraph.LastItem as WTextRange) : (wParagraph.AppendText("") as WTextRange)));
		SetSpacesForEmptyContentControl(wTextRange);
		return wTextRange;
	}

	private void ConvertWordMLToText(InlineContentControl contentControl, string text)
	{
		if (contentControl == null || text == null)
		{
			return;
		}
		MemoryStream stream = null;
		if (IsWordML(text, ref stream))
		{
			contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
			WordDocument wordDocument = new WordDocument(stream, FormatType.WordML);
			WTextBody wTextBody = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
			if (wordDocument.Sections.Count == 1 && (wordDocument.Sections[0].ChildEntities[0] as WTextBody).Count == 1 && (wordDocument.Sections[0].ChildEntities[0] as WTextBody).ChildEntities[0] is WParagraph)
			{
				if (contentControl.ParagraphItems.Count > 0)
				{
					contentControl.ParagraphItems.Clear();
				}
				contentControl.Document.IsOpening = false;
				foreach (ParagraphItem item in (wTextBody.ChildEntities[0] as WParagraph).Items)
				{
					IEntity entity = item.Clone();
					contentControl.ParagraphItems.Add(entity);
					if (HasEmptyTextInParagraph(wTextBody.ChildEntities[0] as WParagraph))
					{
						WTextRange wTextRange = ((contentControl.ParagraphItems.LastItem is WTextRange) ? (contentControl.ParagraphItems.LastItem as WTextRange) : new WTextRange(contentControl.Document));
						SetSpacesForEmptyContentControl(wTextRange);
						wTextRange.ApplyCharacterFormat(contentControl.ContentControlProperties.CharacterFormat);
						if (contentControl.Owner is WParagraph && contentControl.OwnerParagraph.ParaStyle != null)
						{
							wTextRange.CharacterFormat.ApplyBase(contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
						}
						break;
					}
					if (item is WTextRange)
					{
						(entity as WTextRange).ApplyCharacterFormat((item as WTextRange).CharacterFormat);
						if (contentControl.Owner is WParagraph && contentControl.OwnerParagraph.ParaStyle != null)
						{
							(entity as WTextRange).CharacterFormat.ApplyBase(contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
						}
					}
				}
				contentControl.Document.IsOpening = true;
			}
			else if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].Body.Items.Count > 1 && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
			{
				WParagraph ownerParagraph = contentControl.OwnerParagraph;
				int index = contentControl.Index;
				WParagraph wParagraph = ownerParagraph.Clone() as WParagraph;
				for (int num = ownerParagraph.ChildEntities.Count - 1; num >= index; num--)
				{
					ownerParagraph.ChildEntities[num].RemoveSelf();
				}
				for (int i = 0; i <= index; i++)
				{
					wParagraph.ChildEntities[0].RemoveSelf();
				}
				BlockContentControl blockContentControl = new BlockContentControl(contentControl.Document);
				WTextBody ownerTextBody = ownerParagraph.OwnerTextBody;
				int indexInOwnerCollection = ownerParagraph.GetIndexInOwnerCollection();
				ownerTextBody.ChildEntities.Insert(indexInOwnerCollection + 1, blockContentControl);
				ownerTextBody.ChildEntities.Insert(indexInOwnerCollection + 2, wParagraph);
				MapWordMLToBlockContentControl(blockContentControl, wTextBody);
				WParagraph lastParagraphOfSDTContent = blockContentControl.GetLastParagraphOfSDTContent();
				lastParagraphOfSDTContent.ParagraphFormat.ClearFormatting();
				lastParagraphOfSDTContent.ParagraphFormat.CopyFormat(ownerParagraph.ParagraphFormat);
				lastParagraphOfSDTContent = blockContentControl.GetFirstParagraphOfSDTContent();
				ownerParagraph.ParagraphFormat.ClearFormatting();
				ownerParagraph.ParagraphFormat.CopyFormat(lastParagraphOfSDTContent.ParagraphFormat);
			}
			else
			{
				SetMappedItem(contentControl, text);
			}
			wordDocument.Close();
		}
		else
		{
			SetMappedItem(contentControl, text);
		}
		stream.Dispose();
	}

	private void MapWordMLToBlockContentControl(BlockContentControl contentControl, WTextBody textBody)
	{
		contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
		if (contentControl.ChildEntities.Count > 0)
		{
			contentControl.ChildEntities.Clear();
		}
		foreach (Entity item in textBody.Items)
		{
			contentControl.ChildEntities.Add(item.Clone());
			if (item is WParagraph)
			{
				(contentControl.ChildEntities.LastItem as WParagraph).ParagraphFormat.CopyFormat((item as WParagraph).ParagraphFormat);
			}
		}
	}

	private void ConvertWordMLToText(BlockContentControl contentControl, string text)
	{
		if (contentControl == null || text == null)
		{
			return;
		}
		MemoryStream stream = null;
		if (IsWordML(text, ref stream))
		{
			contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
			WTextBody wTextBody = null;
			WordDocument wordDocument = new WordDocument(stream, FormatType.WordML);
			if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].ChildEntities[0] is WTextBody)
			{
				wTextBody = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
				contentControl.Document.IsOpening = false;
				if (HasEmptyBodyItems(wTextBody.Items))
				{
					if (wTextBody.Paragraphs.Count <= 1 && contentControl.ChildEntities.Count > 0)
					{
						WParagraph wParagraph = ClearContentControlExceptLastPara(contentControl);
						WTextRange defaultSpaceFromWordML = GetDefaultSpaceFromWordML(wTextBody);
						wParagraph.ChildEntities.Add(defaultSpaceFromWordML.Clone());
						contentControl.ChildEntities.Add(wParagraph.Clone());
					}
					else if (wTextBody.Paragraphs.Count == 2 && contentControl.ChildEntities.Count >= 0)
					{
						contentControl.ChildEntities.Clear();
						WParagraph wParagraph2 = wTextBody.Paragraphs[0];
						WTextRange defaultSpaceFromWordML2 = GetDefaultSpaceFromWordML(wTextBody);
						wParagraph2.ChildEntities.Add(defaultSpaceFromWordML2.Clone());
						contentControl.ChildEntities.Add(wParagraph2.Clone());
					}
					else if (wTextBody.Paragraphs.Count <= 1 && contentControl.ChildEntities.Count == 0)
					{
						contentControl.ChildEntities.Clear();
						contentControl.TextBody.AddParagraph();
						WTextRange defaultSpaceFromWordML3 = GetDefaultSpaceFromWordML(wTextBody);
						(contentControl.ChildEntities[0] as WParagraph).ChildEntities.Add(defaultSpaceFromWordML3.Clone());
					}
					else
					{
						if (contentControl.ChildEntities.Count > 0)
						{
							contentControl.ChildEntities.Clear();
						}
						for (int num = wTextBody.Paragraphs.Count - 2; num >= 0; num--)
						{
							contentControl.ChildEntities.Insert(0, wTextBody.Paragraphs[num].Clone());
						}
					}
				}
				else
				{
					MapWordMLToBlockContentControl(contentControl, wTextBody);
				}
				contentControl.Document.IsOpening = true;
			}
			else
			{
				SetMappedParagraph(contentControl, text);
			}
			wordDocument.Close();
		}
		else
		{
			SetMappedParagraph(contentControl, text);
		}
		stream.Dispose();
	}

	private void ConvertWordMLToText(WTableCell contentControl, string text)
	{
		if (contentControl == null || text == null)
		{
			return;
		}
		MemoryStream stream = null;
		if (IsWordML(text, ref stream))
		{
			contentControl.ContentControl.ContentControlProperties.XmlMapping.IsWordML = true;
			WordDocument wordDocument = new WordDocument(stream, FormatType.WordML);
			if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].ChildEntities[0] is WTextBody)
			{
				if (contentControl.ChildEntities.Count > 0)
				{
					contentControl.ChildEntities.Clear();
				}
				WTextBody obj = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
				contentControl.Document.IsOpening = false;
				foreach (Entity item in obj.Items)
				{
					contentControl.ChildEntities.Add(item.Clone());
					if (item is WParagraph)
					{
						(contentControl.ChildEntities.LastItem as WParagraph).ParagraphFormat.ApplyBase((item as WParagraph).ParagraphFormat);
					}
				}
				contentControl.Document.IsOpening = true;
			}
			else
			{
				SetMappedCell(contentControl, text);
			}
			wordDocument.Close();
		}
		else
		{
			SetMappedCell(contentControl, text);
		}
		stream.Dispose();
	}

	private bool IsWordML(string text, ref MemoryStream stream)
	{
		try
		{
			byte[] bytes = Encoding.UTF8.GetBytes(text);
			stream = new MemoryStream(bytes);
			XmlReader xmlReader = UtilityMethods.CreateReader(stream);
			xmlReader.MoveToElement();
			if (xmlReader.LocalName == "wordDocument" || xmlReader.LocalName == "package")
			{
				return true;
			}
		}
		catch (Exception)
		{
		}
		return false;
	}

	private void SetMappedCell(WTableCell tableCell, string text)
	{
		if (tableCell == null || text == null)
		{
			return;
		}
		if (text == string.Empty)
		{
			if (string.IsNullOrEmpty(tableCell.ContentControl.ContentControlProperties.PlaceHolderDocPartId) && tableCell.ContentControl.ContentControlProperties.HasPlaceHolderText && tableCell.ContentControl.ContentControlProperties.Type == ContentControlType.Text)
			{
				return;
			}
			text = GetTextForEmptyMappedContent(tableCell.ContentControl);
		}
		else
		{
			tableCell.ContentControl.ContentControlProperties.HasPlaceHolderText = false;
		}
		if (IsMapPlaceHolderFromGlossary(tableCell.ContentControl, text))
		{
			MapContentFromGlossaryDocument(tableCell.ContentControl);
		}
		else if (tableCell.LastParagraph == null)
		{
			WParagraph wParagraph = new WParagraph(m_doc);
			wParagraph.AppendText(text);
			tableCell.ChildEntities.Add(wParagraph);
			wParagraph.SetOwner(tableCell);
		}
		else if (tableCell.LastParagraph.Text != text)
		{
			tableCell.LastParagraph.Text = text;
		}
		tableCell.ContentControl.ContentControlProperties.XmlMapping.IsMapped = true;
	}

	private void SetMappedPicture(BlockContentControl contentControl, string text)
	{
		bool flag = false;
		foreach (Entity childEntity in contentControl.TextBody.ChildEntities)
		{
			if (!(childEntity is WParagraph))
			{
				continue;
			}
			foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
			{
				if (childEntity2 is WPicture)
				{
					flag = true;
					MappedBase64Image(childEntity2 as WPicture, text, contentControl);
				}
			}
		}
		if (!flag)
		{
			MappedBase64Image(null, text, contentControl);
		}
	}

	private void SetMappedPicture(InlineContentControl contentControl, string text)
	{
		bool flag = false;
		foreach (ParagraphItem paragraphItem in contentControl.ParagraphItems)
		{
			if (paragraphItem is WPicture)
			{
				flag = true;
				MappedBase64Image(paragraphItem as WPicture, text, contentControl);
			}
		}
		if (!flag)
		{
			MappedBase64Image(null, text, contentControl);
		}
	}

	private void SetMappedPicture(WTableCell contentControl, string text)
	{
		bool flag = false;
		foreach (Entity childEntity in contentControl.ChildEntities)
		{
			if (!(childEntity is WParagraph))
			{
				continue;
			}
			foreach (Entity childEntity2 in (childEntity as WParagraph).ChildEntities)
			{
				if (childEntity2 is WPicture)
				{
					flag = true;
					MappedBase64Image(childEntity2 as WPicture, text, contentControl);
				}
			}
		}
		if (!flag)
		{
			MappedBase64Image(null, text, contentControl);
		}
	}

	private WPicture SetDefaultPic(WPicture picture)
	{
		DocGen.DocIO.DLS.Entities.Image image = null;
		Stream manifestResourceStream = WPicture.GetManifestResourceStream("ImageNotFound.jpg");
		MemoryStream memoryStream = new MemoryStream();
		manifestResourceStream.CopyTo(memoryStream);
		image = DocGen.DocIO.DLS.Entities.Image.FromStream(memoryStream);
		picture.LoadImage(image);
		picture.IsDefaultPicOfContentControl = false;
		return picture;
	}

	private WPicture AppendPictureToContentControl(WPicture picture, Entity contentControl)
	{
		if (contentControl is BlockContentControl)
		{
			WParagraph entity = new WParagraph(contentControl.Document);
			BlockContentControl obj = contentControl as BlockContentControl;
			obj.ChildEntities.Add(entity);
			(obj.ChildEntities[0] as WParagraph).AppendPicture(picture.ImageBytes);
			picture = (obj.ChildEntities[0] as WParagraph).ChildEntities[0] as WPicture;
		}
		picture.Height = 100f;
		picture.Width = 100f;
		return picture;
	}

	internal bool IsDefaultPicture(byte[] sourceImageBytes)
	{
		Stream manifestResourceStream = WPicture.GetManifestResourceStream("ImageNotFound.jpg");
		byte[] array;
		using (BinaryReader binaryReader = new BinaryReader(manifestResourceStream))
		{
			array = binaryReader.ReadBytes((int)manifestResourceStream.Length);
		}
		if (sourceImageBytes.Length != array.Length)
		{
			return false;
		}
		for (int i = 0; i < sourceImageBytes.Length; i++)
		{
			if (sourceImageBytes[i] != array[i])
			{
				return false;
			}
		}
		return true;
	}

	private void MappedBase64Image(WPicture picture, string text, Entity contentControl)
	{
		float num = 0f;
		float num2 = 0f;
		try
		{
			if (picture != null)
			{
				SizeF sizeF = default(SizeF);
				sizeF = picture.Size;
				num = picture.Height;
				num2 = picture.Width;
				if (text == string.Empty && (contentControl.EntityType == EntityType.BlockContentControl || contentControl.EntityType == EntityType.InlineContentControl) && !IsDefaultPicture(picture.ImageBytes))
				{
					picture = SetDefaultPic(picture);
					picture.Height = 100f;
					picture.Width = 100f;
					return;
				}
				if (text == string.Empty && (contentControl.EntityType == EntityType.BlockContentControl || contentControl.EntityType == EntityType.InlineContentControl))
				{
					picture = SetDefaultPic(picture);
					picture.IsDefaultPicOfContentControl = true;
					picture.Height = num;
					picture.Width = num2;
					return;
				}
				byte[] imageBytes = Convert.FromBase64String(text);
				picture.LoadImage(imageBytes);
				if (!(picture.Size == sizeF) && picture.LockAspectRatio)
				{
					if (picture.Size.Height > sizeF.Height || (picture.Size.Height == sizeF.Height && picture.Size.Width < sizeF.Width))
					{
						picture.Height = num;
						float num3 = num / picture.Size.Height * 100f;
						picture.Width = picture.Size.Width / (100f / num3);
					}
					else
					{
						picture.Width = num2;
						float num4 = num2 / picture.Size.Width * 100f;
						picture.Height = picture.Size.Height / (100f / num4);
					}
				}
			}
			else if (text == string.Empty && (contentControl.EntityType == EntityType.BlockContentControl || contentControl.EntityType == EntityType.InlineContentControl))
			{
				picture = new WPicture(contentControl.Document);
				picture = SetDefaultPic(picture);
				picture = AppendPictureToContentControl(picture, contentControl);
			}
		}
		catch (Exception ex)
		{
			if (!(ex.Message.Trim() == "The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters."))
			{
				picture = SetDefaultPic(picture);
				picture.Height = num;
				picture.Width = num2;
			}
		}
	}

	private void SetMappedParagraph(BlockContentControl contentControl, string text)
	{
		if (contentControl == null || text == null || contentControl.TextBody == null)
		{
			return;
		}
		if (text == string.Empty)
		{
			if (SkipToMapDatabindingValue(contentControl))
			{
				return;
			}
			text = GetTextForEmptyMappedContent(contentControl);
		}
		else
		{
			contentControl.ContentControlProperties.HasPlaceHolderText = false;
		}
		if (IsMapPlaceHolderFromGlossary(contentControl, text))
		{
			MapContentFromGlossaryDocument(contentControl);
		}
		else if (contentControl.TextBody.LastParagraph == null)
		{
			WParagraph wParagraph = new WParagraph(m_doc);
			wParagraph.AppendText(text);
			contentControl.TextBody.ChildEntities.Add(wParagraph);
			wParagraph.SetOwner(contentControl.TextBody);
		}
		else if (contentControl.TextBody.LastParagraph.Items.Count == 1 && contentControl.TextBody.LastParagraph.Items[0] is WTextRange)
		{
			(contentControl.TextBody.LastParagraph.Items[0] as WTextRange).Text = text;
		}
		else if (contentControl.TextBody.LastParagraph.Text != text)
		{
			contentControl.TextBody.LastParagraph.Text = text;
		}
		if (contentControl.TextBody.LastParagraph != null && contentControl.TextBody.LastParagraph.Items.Count > 0 && contentControl.TextBody.LastParagraph.Items[0] is WTextRange)
		{
			WCharacterFormat characterFormat = (contentControl.TextBody.LastParagraph.Items[0] as WTextRange).CharacterFormat;
			UpdateFormatting(contentControl.ContentControlProperties.CharacterFormat, characterFormat);
		}
		contentControl.ContentControlProperties.XmlMapping.IsMapped = true;
	}

	private bool HasGlossaryDocument()
	{
		PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("word/");
		if (!partContainer.XmlPartContainers.ContainsKey("glossary/"))
		{
			return false;
		}
		return partContainer.XmlPartContainers["glossary/"]?.XmlParts.ContainsKey("document.xml") ?? false;
	}

	private bool IsMapPlaceHolderFromGlossary(Entity contentControl, string text)
	{
		if (contentControl != null && string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(GetPlaceHolderName(contentControl)) && HasGlossaryDocument())
		{
			return true;
		}
		return false;
	}

	private bool SkipToMapDatabindingValue(Entity contentControl)
	{
		string placeHolderName = GetPlaceHolderName(contentControl);
		if (contentControl is BlockContentControl)
		{
			BlockContentControl blockContentControl = contentControl as BlockContentControl;
			bool flag = blockContentControl.ContentControlProperties.Type != ContentControlType.Text || HasEmptyBodyItems(blockContentControl.TextBody.Items);
			if (!string.IsNullOrEmpty(placeHolderName) && HasGlossaryDocument() && !flag)
			{
				return true;
			}
			if (string.IsNullOrEmpty(blockContentControl.ContentControlProperties.PlaceHolderDocPartId) && blockContentControl.ContentControlProperties.HasPlaceHolderText && blockContentControl.ContentControlProperties.Type == ContentControlType.Text)
			{
				return true;
			}
		}
		return false;
	}

	private string GetPlaceHolderName(Entity contentControl)
	{
		if (!(contentControl is BlockContentControl))
		{
			if (!(contentControl is InlineContentControl))
			{
				if (!(contentControl is CellContentControl))
				{
					return string.Empty;
				}
				return (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId;
			}
			return (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId;
		}
		return (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId;
	}

	private void MapContentFromGlossaryDocument(Entity contentControl)
	{
		PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("word/");
		if (partContainer.XmlPartContainers.ContainsKey("glossary/"))
		{
			partContainer = partContainer.XmlPartContainers["glossary/"];
		}
		XmlReader xmlReader = UtilityMethods.CreateReader(partContainer.XmlParts["document.xml"].DataStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "glossaryDocument")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool isDocPartFound = false;
		while (xmlReader.LocalName != "glossaryDocument")
		{
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				if (xmlReader.LocalName == "docPart")
				{
					ParseGLossaryDocPart(xmlReader, contentControl, ref isDocPartFound);
				}
				xmlReader.Read();
				if (isDocPartFound)
				{
					break;
				}
			}
			else
			{
				xmlReader.Read();
			}
		}
	}

	private WParagraph ClearContentControlExceptLastPara(Entity contentControl)
	{
		WParagraph lastParagraphOfSDTContent = (contentControl as BlockContentControl).GetLastParagraphOfSDTContent();
		lastParagraphOfSDTContent.ChildEntities.Clear();
		(contentControl as BlockContentControl).TextBody.ChildEntities.Clear();
		return lastParagraphOfSDTContent;
	}

	private void MapParagraphsFromDocPart(WTextBody body, Entity contentControl, WParagraph lastParagraph, bool isCreateNewParaForLast)
	{
		for (int i = 0; i < body.Paragraphs.Count; i++)
		{
			WParagraph wParagraph = body.Paragraphs[i];
			if (i == body.Paragraphs.Count - 1)
			{
				if (isCreateNewParaForLast)
				{
					(contentControl as BlockContentControl).TextBody.AddParagraph();
				}
				else
				{
					(contentControl as BlockContentControl).TextBody.ChildEntities.Add(lastParagraph.Clone());
				}
				lastParagraph = (contentControl as BlockContentControl).GetLastParagraphOfSDTContent();
				for (int num = wParagraph.Items.Count - 1; num >= 0; num--)
				{
					lastParagraph.Items.Insert(0, wParagraph.Items[num]);
				}
			}
			else
			{
				(contentControl as BlockContentControl).TextBody.ChildEntities.Add(wParagraph.Clone());
			}
		}
	}

	private void ParseGLossaryDocPart(XmlReader reader, Entity contentControl, ref bool isDocPartFound)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (reader.LocalName != "docPart")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "docPartBody"))
				{
					if (localName2 == "docPartPr" && !reader.IsEmptyElement)
					{
						string localName3 = reader.LocalName;
						reader.Read();
						if (!(localName3 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							bool flag2 = false;
							while (reader.LocalName != "docPartPr")
							{
								if (reader.NodeType == XmlNodeType.Element)
								{
									string localName4 = reader.LocalName;
									if (!(localName4 == "name"))
									{
										if (localName4 == "category")
										{
											flag2 = true;
										}
									}
									else if (!flag2)
									{
										string text = ((contentControl is BlockContentControl) ? (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId : ((contentControl is InlineContentControl) ? (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId : ((contentControl is CellContentControl) ? (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId : string.Empty)));
										string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
										isDocPartFound = !string.IsNullOrEmpty(attribute) && attribute == text;
									}
									reader.Read();
								}
								else
								{
									reader.Read();
								}
							}
						}
					}
				}
				else if (isDocPartFound)
				{
					if (contentControl is BlockContentControl)
					{
						WParagraph lastParagraph = null;
						WTextBody wTextBody = new WTextBody(m_doc.LastSection);
						ParseBody(reader, wTextBody, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						if (wTextBody.Paragraphs.Count >= 0 && (contentControl as BlockContentControl).TextBody.Paragraphs.Count > 0)
						{
							lastParagraph = ClearContentControlExceptLastPara(contentControl);
							MapParagraphsFromDocPart(wTextBody, contentControl, lastParagraph, isCreateNewParaForLast: false);
						}
						else if (wTextBody.Paragraphs.Count > 0 && (contentControl as BlockContentControl).TextBody.Paragraphs.Count == 0)
						{
							MapParagraphsFromDocPart(wTextBody, contentControl, lastParagraph, isCreateNewParaForLast: true);
						}
					}
					else if (contentControl is InlineContentControl)
					{
						(contentControl as InlineContentControl).ParagraphItems.Clear();
						WTextBody wTextBody2 = new WTextBody(m_doc.LastSection);
						ParseBody(reader, wTextBody2, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						foreach (WParagraph paragraph in wTextBody2.Paragraphs)
						{
							for (int num = paragraph.Items.Count - 1; num >= 0; num--)
							{
								(contentControl as InlineContentControl).ParagraphItems.Insert(0, paragraph.Items[num]);
							}
						}
					}
					else if (contentControl is CellContentControl)
					{
						WTableCell ownerCell = (contentControl as CellContentControl).OwnerCell;
						IWParagraph iWParagraph = ownerCell.LastParagraph as WParagraph;
						WTextBody wTextBody3 = new WTextBody(m_doc.LastSection);
						ParseBody(reader, wTextBody3, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						iWParagraph = ((iWParagraph == null) ? ownerCell.AddParagraph() : iWParagraph);
						iWParagraph.ChildEntities.Clear();
						foreach (WParagraph paragraph2 in wTextBody3.Paragraphs)
						{
							for (int num2 = paragraph2.Items.Count - 1; num2 >= 0; num2--)
							{
								iWParagraph.Items.Insert(0, paragraph2.Items[num2]);
							}
						}
					}
					flag = true;
				}
				reader.Read();
				if (isDocPartFound && flag)
				{
					break;
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private string GetTextForEmptyMappedContent(Entity contentControl)
	{
		if (contentControl != null && string.IsNullOrEmpty((contentControl is BlockContentControl) ? (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId : ((contentControl is InlineContentControl) ? (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId : ((contentControl is CellContentControl) ? (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId : string.Empty))))
		{
			return "     ";
		}
		return string.Empty;
	}

	private void UpdateFormatting(WCharacterFormat source, WCharacterFormat dest)
	{
		foreach (KeyValuePair<int, object> item in source.PropertiesHash)
		{
			if (!dest.PropertiesHash.ContainsKey(item.Key))
			{
				dest.PropertiesHash.Add(item.Key, item.Value);
			}
		}
	}

	private void SetMappedItem(InlineContentControl contentControl, string text)
	{
		WTextRange wTextRange = null;
		bool flag = false;
		if (contentControl == null || text == null)
		{
			return;
		}
		if (text == string.Empty)
		{
			if (string.IsNullOrEmpty(contentControl.ContentControlProperties.PlaceHolderDocPartId) && contentControl.ContentControlProperties.HasPlaceHolderText && contentControl.ContentControlProperties.Type == ContentControlType.Text)
			{
				return;
			}
			text = GetTextForEmptyMappedContent(contentControl);
		}
		else
		{
			contentControl.ContentControlProperties.HasPlaceHolderText = false;
		}
		if (IsMapPlaceHolderFromGlossary(contentControl, text))
		{
			MapContentFromGlossaryDocument(contentControl);
			for (int num = contentControl.ParagraphItems.Count - 1; num >= 0; num--)
			{
				if (contentControl.ParagraphItems[num] is WTextRange && !(contentControl.ParagraphItems[num] is WField))
				{
					wTextRange = contentControl.ParagraphItems[num] as WTextRange;
					break;
				}
			}
			flag = true;
		}
		else
		{
			if (contentControl.ParagraphItems.Count > 0)
			{
				contentControl.ParagraphItems.Clear();
			}
			wTextRange = new WTextRange(m_doc);
			contentControl.ParagraphItems.Add(wTextRange);
			wTextRange.Text = text;
			wTextRange.ApplyCharacterFormat(contentControl.ContentControlProperties.CharacterFormat);
		}
		if (wTextRange != null && contentControl.Owner is WParagraph && contentControl.OwnerParagraph.ParaStyle != null)
		{
			wTextRange.CharacterFormat.ApplyBase(contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
		}
		InlineContentControl inlineContentControl = contentControl;
		BlockContentControl blockContentControl = null;
		while (inlineContentControl.Owner is InlineContentControl && (inlineContentControl.Owner as InlineContentControl).ContentControlProperties.HasPlaceHolderText)
		{
			inlineContentControl = inlineContentControl.Owner as InlineContentControl;
		}
		if (wTextRange != null && inlineContentControl.Owner is WParagraph && (inlineContentControl.Owner as WParagraph).Owner is WTextBody && ((inlineContentControl.Owner as WParagraph).Owner as WTextBody).Owner is BlockContentControl)
		{
			blockContentControl = ((inlineContentControl.Owner as WParagraph).Owner as WTextBody).Owner as BlockContentControl;
			if (blockContentControl.ContentControlProperties.HasPlaceHolderText)
			{
				wTextRange.ApplyCharacterFormat(blockContentControl.ContentControlProperties.CharacterFormat);
			}
			else
			{
				wTextRange.ApplyCharacterFormat(inlineContentControl.ContentControlProperties.CharacterFormat);
			}
		}
		if (wTextRange != null && blockContentControl == null && !flag)
		{
			wTextRange.ApplyCharacterFormat(inlineContentControl.ContentControlProperties.CharacterFormat);
		}
		if (wTextRange != null && inlineContentControl.OwnerParagraph.ParaStyle != null)
		{
			wTextRange.CharacterFormat.ApplyBase(inlineContentControl.OwnerParagraph.ParaStyle.CharacterFormat);
		}
		contentControl.MappedItem = ((wTextRange != null) ? (wTextRange.Clone() as ParagraphItem) : null);
		contentControl.ContentControlProperties.XmlMapping.IsMapped = true;
	}

	private string ReplaceBreakChars(string text)
	{
		text = text.Replace(ControlChar.CrLf, string.Empty);
		text = text.Replace(ControlChar.ParagraphBreak, string.Empty);
		text = text.Replace(ControlChar.LineFeed, string.Empty);
		return text;
	}

	private string ReplaceAsSoftBreaks(string text)
	{
		text = text.Replace(ControlChar.CrLf, ControlChar.LineBreak);
		text = text.Replace(ControlChar.ParagraphBreak, ControlChar.LineBreak);
		text = text.Replace(ControlChar.LineFeed, ControlChar.LineBreak);
		return text;
	}

	private void ClearParsedImage(string imageName, string containerName)
	{
		PartContainer partContainer = m_doc.DocxPackage.FindPartContainer(containerName);
		if (partContainer.XmlParts.ContainsKey(imageName))
		{
			Part part = partContainer.XmlParts[imageName];
			partContainer.XmlParts.Remove(imageName);
			part.DataStream.Close();
			part = null;
		}
	}

	private void ParseThemes(Stream stream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader.NamespaceURI == m_strictANameSpace)
		{
			IsStrict = true;
		}
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "theme")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(xmlReader);
		while (!(xmlReader.LocalName == "theme") || xmlReader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "themeElements":
					ParseThemeElements(xmlReader);
					break;
				case "objectDefaults":
					m_doc.Themes.DocxProps.Add("objectDefaults", ReadSingleNodeIntoStream(xmlReader));
					break;
				case "extLst":
					m_doc.Themes.DocxProps.Add("extLst", ReadSingleNodeIntoStream(xmlReader));
					break;
				case "extraClrSchemeLst":
					m_doc.Themes.DocxProps.Add("extraClrSchemeLst", ReadSingleNodeIntoStream(xmlReader));
					break;
				default:
					flag = true;
					break;
				}
				if (flag)
				{
					xmlReader.Read();
				}
			}
			else
			{
				xmlReader.Read();
			}
			SkipWhitespaces(xmlReader);
		}
	}

	private void ParseThemeElements(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (localName != "themeElements")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		bool flag = true;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == "themeElements") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "clrScheme":
					if (reader.HasAttributes)
					{
						m_doc.Themes.ColorSchemeName = reader.GetAttribute("name");
					}
					ParseSchemeColor(reader);
					break;
				case "fmtScheme":
					if (reader.HasAttributes)
					{
						m_doc.Themes.FmtScheme.FmtName = reader.GetAttribute("name");
					}
					ParseFormatScheme(reader);
					break;
				case "fontScheme":
					if (reader.HasAttributes)
					{
						m_doc.Themes.FontScheme.FontSchemeName = reader.GetAttribute("name");
					}
					ParseFontScheme(reader);
					break;
				default:
					flag = true;
					break;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseFormatScheme(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (localName != "fmtScheme")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == "fmtScheme") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "fillStyleLst":
					ParseFillStyleList(reader, reader.LocalName);
					break;
				case "lnStyleLst":
					ParseLineStyleScheme(reader);
					break;
				case "effectStyleLst":
					ParseEffectStyleScheme(reader);
					break;
				case "bgFillStyleLst":
					ParseFillStyleList(reader, reader.LocalName);
					break;
				default:
					flag = true;
					break;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseEffectStyleScheme(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (localName != "effectStyleLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		bool flag = false;
		while (!(reader.LocalName == "effectStyleLst") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "effectStyle")
				{
					EffectFormat effectFormat = ParseEffectList(reader);
					if (effectFormat != null)
					{
						m_doc.Themes.FmtScheme.EffectStyles.Add(effectFormat);
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private EffectFormat ParseEffectList(XmlReader reader)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				EffectFormat effectFormat = new EffectFormat(new Shape(m_doc));
				if (localName != "effectStyle")
				{
					throw new XmlException("Unexpected xml tag " + reader.LocalName);
				}
				SkipWhitespaces(reader);
				bool flag = true;
				string text = null;
				while (!(reader.LocalName == "effectStyle") || reader.NodeType != XmlNodeType.EndElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "effectLst":
							ParseEffectListItems(reader, effectFormat);
							flag = false;
							break;
						case "scene3d":
							effectFormat.IsSceneProperties = true;
							ParseSceneProperties(reader, effectFormat);
							break;
						case "sp3d":
							effectFormat.IsShapeProperties = true;
							if (reader.HasAttributes)
							{
								text = reader.GetAttribute("contourW");
								if (!string.IsNullOrEmpty(text))
								{
									effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(text, "contourW");
								}
								text = reader.GetAttribute("extrusionH");
								if (!string.IsNullOrEmpty(text))
								{
									effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(text, "extrusionH");
								}
								text = reader.GetAttribute("z");
								if (!string.IsNullOrEmpty(text))
								{
									effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(text, "z");
								}
								text = reader.GetAttribute("prstMaterial");
								if (!string.IsNullOrEmpty(text) && text.Length > 2)
								{
									if (text == "dkEdge")
									{
										text = "darkEdge";
									}
									effectFormat.ThreeDFormat.PresetMaterialType = (Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(text[0]) + text.Substring(1)) ? ((PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), text, ignoreCase: true)) : PresetMaterialType.None);
								}
							}
							ParseShapeProperties(reader, effectFormat);
							break;
						default:
							flag = false;
							break;
						}
						if (!flag)
						{
							reader.Read();
						}
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return effectFormat;
			}
			return null;
		}
		return null;
	}

	private float GetPropertyValue(string value, string attributeName)
	{
		float result = 0f;
		value = value.TrimStart(new char[1] { ControlChar.SpaceChar });
		if (value.EndsWith("cm"))
		{
			float.TryParse(value.Remove(value.IndexOf("cm"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)((double)result * 28.35);
		}
		if (value.EndsWith("mm"))
		{
			float.TryParse(value.Remove(value.IndexOf("mm"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)((double)result * 2.835);
		}
		if (value.EndsWith("pt"))
		{
			float.TryParse(value.Remove(value.IndexOf("pt"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return result;
		}
		if (value.EndsWith("pi"))
		{
			float.TryParse(value.Remove(value.IndexOf("pi"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return result * 12f;
		}
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		if (attributeName != null)
		{
			switch (attributeName.Length)
			{
			case 4:
			{
				char c = attributeName[3];
				if ((uint)c <= 89u)
				{
					if (c != 'X')
					{
						if (c != 'Y' || !(attributeName == "offY"))
						{
							break;
						}
					}
					else if (!(attributeName == "offX"))
					{
						break;
					}
				}
				else if (c != 'm')
				{
					if (c != 't')
					{
						if (c != 'w' || !(attributeName == "glow"))
						{
							break;
						}
					}
					else if (!(attributeName == "dist"))
					{
						break;
					}
				}
				else if (!(attributeName == "norm"))
				{
					break;
				}
				goto IL_03c9;
			}
			case 2:
			{
				char c = attributeName[0];
				if ((uint)c <= 108u)
				{
					if (c != 'c')
					{
						if (c != 'l' || !(attributeName == "ln"))
						{
							break;
						}
					}
					else if (!(attributeName == "cx") && !(attributeName == "cy"))
					{
						break;
					}
				}
				else
				{
					if (c == 's')
					{
						if (!(attributeName == "sx") && !(attributeName == "sy"))
						{
							break;
						}
						goto IL_03d1;
					}
					if (c != 'u' || !(attributeName == "up"))
					{
						break;
					}
				}
				goto IL_03c9;
			}
			case 1:
				switch (attributeName[0])
				{
				case 'b':
				case 'l':
				case 'r':
				case 't':
				case 'w':
				case 'x':
				case 'y':
				case 'z':
					break;
				default:
					goto end_IL_011b;
				}
				goto IL_03c9;
			case 8:
			{
				char c = attributeName[0];
				if (c != 'c')
				{
					if (c != 's' || !(attributeName == "softEdge"))
					{
						break;
					}
				}
				else if (!(attributeName == "contourW"))
				{
					break;
				}
				goto IL_03c9;
			}
			case 3:
			{
				char c = attributeName[0];
				if (c != 'f')
				{
					if (c != 'r' || !(attributeName == "rad"))
					{
						break;
					}
				}
				else if (!(attributeName == "fov"))
				{
					break;
				}
				goto IL_03c9;
			}
			case 7:
			{
				char c = attributeName[0];
				if (c != 'b')
				{
					if (c != 's' || !(attributeName == "srcRect"))
					{
						break;
					}
					goto IL_03d1;
				}
				if (!(attributeName == "blurRad"))
				{
					break;
				}
				goto IL_03c9;
			}
			case 10:
				if (!(attributeName == "extrusionH"))
				{
					break;
				}
				goto IL_03c9;
			case 5:
				if (!(attributeName == "bevel"))
				{
					break;
				}
				goto IL_03c9;
			case 6:
				{
					if (!(attributeName == "anchor"))
					{
						break;
					}
					goto IL_03c9;
				}
				IL_03c9:
				return result / 12700f;
				IL_03d1:
				return result / 1000f;
				end_IL_011b:
				break;
			}
		}
		return result;
	}

	private EffectFormat ParseShapeProperties(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "sp3d")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				SkipWhitespaces(reader);
				bool flag = true;
				string text = null;
				while (!(reader.LocalName == "sp3d") || reader.NodeType != XmlNodeType.EndElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "bevelB":
						case "bevelT":
							if (reader.LocalName == "bevelT")
							{
								effectFormat.ThreeDFormat.HasBevelTop = true;
							}
							else
							{
								effectFormat.ThreeDFormat.HasBevelBottom = true;
							}
							if (reader.HasAttributes)
							{
								text = reader.GetAttribute("w");
								if (!string.IsNullOrEmpty(text))
								{
									if (reader.LocalName == "bevelT")
									{
										effectFormat.ThreeDFormat.BevelTopWidth = GetPropertyValue(text, "bevel");
									}
									else
									{
										effectFormat.ThreeDFormat.BevelBottomWidth = GetPropertyValue(text, "bevel");
									}
								}
								text = reader.GetAttribute("h");
								if (!string.IsNullOrEmpty(text))
								{
									if (reader.LocalName == "bevelT")
									{
										effectFormat.ThreeDFormat.BevelTopHeight = GetPropertyValue(text, "bevel");
									}
									else
									{
										effectFormat.ThreeDFormat.BevelBottomHeight = GetPropertyValue(text, "bevel");
									}
								}
								text = reader.GetAttribute("prst");
								if (!string.IsNullOrEmpty(text) && text.Length > 2)
								{
									if (reader.LocalName == "bevelT")
									{
										effectFormat.ThreeDFormat.BevelTPresetType = (Enum.IsDefined(typeof(BevelPresetType), char.ToUpper(text[0]) + text.Substring(1)) ? ((BevelPresetType)Enum.Parse(typeof(BevelPresetType), text, ignoreCase: true)) : BevelPresetType.None);
									}
									else
									{
										effectFormat.ThreeDFormat.BevelBPresetType = (Enum.IsDefined(typeof(BevelPresetType), char.ToUpper(text[0]) + text.Substring(1)) ? ((BevelPresetType)Enum.Parse(typeof(BevelPresetType), text, ignoreCase: true)) : BevelPresetType.None);
									}
								}
							}
							flag = false;
							break;
						case "extList":
							flag = false;
							break;
						case "contourClr":
						case "extrusionClr":
						{
							if (reader.LocalName == "contourClr")
							{
								effectFormat.ThreeDFormat.HasContourColor = true;
							}
							else
							{
								effectFormat.ThreeDFormat.HasExtrusionColor = true;
							}
							uint opacity = uint.MaxValue;
							float num = 0f;
							if (reader.LocalName == "extrusionClr")
							{
								effectFormat.ThreeDFormat.ExtrusionColor = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
								if (opacity != uint.MaxValue)
								{
									num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
									effectFormat.ThreeDFormat.ExtrusionOpacity = 1f - num;
								}
							}
							else
							{
								effectFormat.ThreeDFormat.ContourColor = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
								if (opacity != uint.MaxValue)
								{
									num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
									effectFormat.ThreeDFormat.ContourOpacity = 1f - num;
								}
							}
							break;
						}
						default:
							flag = false;
							break;
						}
						if (!flag)
						{
							reader.Read();
						}
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return effectFormat;
			}
			return null;
		}
		return null;
	}

	private EffectFormat ParseSceneProperties(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "scene3d")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				SkipWhitespaces(reader);
				bool flag = true;
				while (!(reader.LocalName == "scene3d") || reader.NodeType != XmlNodeType.EndElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "backdrop":
							effectFormat.ThreeDFormat.HasBackdropEffect = true;
							ParseBackdrop(reader, effectFormat);
							break;
						case "camera":
							effectFormat.ThreeDFormat.HasCameraEffect = true;
							ParseCameraSettings(reader, effectFormat);
							flag = false;
							break;
						case "extLst":
							effectFormat.ThreeDFormat.DocxProps.Add("scene3d" + reader.LocalName, ReadSingleNodeIntoStream(reader));
							flag = false;
							break;
						case "lightRig":
							effectFormat.ThreeDFormat.HasLightRigEffect = true;
							ParseLightRigSettings(reader, effectFormat);
							break;
						}
						if (!flag)
						{
							reader.Read();
						}
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return effectFormat;
			}
			return null;
		}
		return null;
	}

	private void ParseCameraSettings(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "camera")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		string text = null;
		if (reader.HasAttributes)
		{
			text = reader.GetAttribute("fov");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.FieldOfView = GetPropertyValue(text, "fov");
			}
			text = reader.GetAttribute("zoom");
			if (!string.IsNullOrEmpty(text))
			{
				float result = 0f;
				bool flag = text.EndsWith("%");
				if (float.TryParse(flag ? text.Replace("%", "") : text, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
				{
					effectFormat.ThreeDFormat.Zoom = (flag ? (result * 1000f) : result);
				}
			}
			text = reader.GetAttribute("prst");
			if (!string.IsNullOrEmpty(text) && text.Length > 2)
			{
				effectFormat.ThreeDFormat.CameraPresetType = (Enum.IsDefined(typeof(CameraPresetType), char.ToUpper(text[0]) + text.Substring(1)) ? ((CameraPresetType)Enum.Parse(typeof(CameraPresetType), text, ignoreCase: true)) : CameraPresetType.None);
			}
		}
		SkipWhitespaces(reader);
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			XmlNodeType nodeType = reader.NodeType;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseScene3DRotation(reader, localName, effectFormat, nodeType);
			}
		}
	}

	private void ParseLightRigSettings(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "lightRig")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		string text = null;
		if (reader.HasAttributes)
		{
			text = reader.GetAttribute("rig");
			if (!string.IsNullOrEmpty(text) && text.Length > 2)
			{
				effectFormat.ThreeDFormat.LightRigType = (Enum.IsDefined(typeof(LightRigType), char.ToUpper(text[0]) + text.Substring(1)) ? ((LightRigType)Enum.Parse(typeof(LightRigType), text, ignoreCase: true)) : LightRigType.None);
			}
			text = reader.GetAttribute("dir");
			if (!string.IsNullOrEmpty(text) && Enum.IsDefined(typeof(LightRigDirection), text.ToUpper()))
			{
				effectFormat.ThreeDFormat.LightRigDirection = (LightRigDirection)Enum.Parse(typeof(LightRigDirection), text, ignoreCase: true);
			}
		}
		SkipWhitespaces(reader);
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			XmlNodeType nodeType = reader.NodeType;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseScene3DRotation(reader, localName, effectFormat, nodeType);
			}
		}
	}

	private string GetLightRigDirection(string value)
	{
		return value switch
		{
			"t" => "T", 
			"b" => "Bottom", 
			"bl" => "BottomLeft", 
			"br" => "BottomRight", 
			"tl" => "TopLeft", 
			"tr" => "TopRight", 
			"l" => "Left", 
			"r" => "Right", 
			_ => null, 
		};
	}

	private void ParseScene3DRotation(XmlReader reader, string parentName, EffectFormat effectFormat, XmlNodeType nodeType)
	{
		string text = ((nodeType == XmlNodeType.Element) ? parentName : reader.LocalName);
		XmlNodeType xmlNodeType = ((nodeType == XmlNodeType.Element) ? nodeType : reader.NodeType);
		while (xmlNodeType != XmlNodeType.Element)
		{
			reader.Read();
			xmlNodeType = reader.NodeType;
			text = reader.LocalName;
		}
		if (text != parentName)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		string text2 = null;
		while (!(reader.LocalName == parentName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "rot" && reader.HasAttributes)
				{
					text2 = reader.GetAttribute("lat");
					if (!string.IsNullOrEmpty(text2))
					{
						uint.TryParse(text2, NumberStyles.Number, CultureInfo.InvariantCulture, out var result);
						if (parentName == "camera")
						{
							effectFormat.ThreeDFormat.CameraRotationX = (float)Math.Round((double)result / 60000.0, 5);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotationX = (float)Math.Round((double)result / 60000.0, 5);
						}
					}
					text2 = reader.GetAttribute("lon");
					if (!string.IsNullOrEmpty(text2))
					{
						uint.TryParse(text2, NumberStyles.Number, CultureInfo.InvariantCulture, out var result2);
						if (parentName == "camera")
						{
							effectFormat.ThreeDFormat.CameraRotationY = (float)Math.Round((double)result2 / 60000.0, 5);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotationY = (float)Math.Round((double)result2 / 60000.0, 5);
						}
					}
					text2 = reader.GetAttribute("rev");
					if (!string.IsNullOrEmpty(text2))
					{
						uint.TryParse(text2, NumberStyles.Number, CultureInfo.InvariantCulture, out var result3);
						if (parentName == "camera")
						{
							effectFormat.ThreeDFormat.CameraRotationZ = (float)Math.Round((double)result3 / 60000.0, 5);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotationZ = (float)Math.Round((double)result3 / 60000.0, 5);
						}
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseBackdrop(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "backdrop")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		string text = null;
		bool flag = true;
		while (!(reader.LocalName == "backdrop") || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "anchor":
					text = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropAnchorX = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropAnchorY = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("z");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropAnchorZ = GetPropertyValue(text, reader.LocalName);
					}
					break;
				case "norm":
					text = reader.GetAttribute("dx");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropNormalX = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("dy");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropNormalY = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("dz");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropNormalZ = GetPropertyValue(text, reader.LocalName);
					}
					break;
				case "extLst":
					effectFormat.ThreeDFormat.DocxProps.Add("sp3d" + reader.LocalName, ReadSingleNodeIntoStream(reader));
					flag = false;
					break;
				case "up":
					text = reader.GetAttribute("dx");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropUpX = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("dy");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropUpY = GetPropertyValue(text, reader.LocalName);
					}
					text = reader.GetAttribute("dz");
					if (!string.IsNullOrEmpty(text))
					{
						effectFormat.ThreeDFormat.BackdropUpZ = GetPropertyValue(text, reader.LocalName);
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseEffectListItems(XmlReader reader, EffectFormat effectFormat)
	{
		if (reader.LocalName != "effectLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		uint opacity = uint.MaxValue;
		bool flag = true;
		while (!(reader.LocalName == "effectLst") || reader.NodeType != XmlNodeType.EndElement)
		{
			effectFormat.IsEffectListItem = true;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "outerShdw":
				case "innerShdw":
					effectFormat.ShadowFormat.m_type = reader.LocalName;
					effectFormat.IsShadowEffect = true;
					ParseShadowEffect(reader, reader.LocalName, effectFormat);
					break;
				case "reflection":
					if (reader.HasAttributes)
					{
						effectFormat.IsReflection = true;
						ParseReflectionEffect(reader, effectFormat);
					}
					flag = false;
					break;
				case "glow":
					effectFormat.IsGlowEffect = true;
					if (reader.HasAttributes)
					{
						string attribute2 = reader.GetAttribute("rad");
						if (!string.IsNullOrEmpty(attribute2))
						{
							effectFormat.GlowFormat.IsInlineRadius = true;
							effectFormat.GlowFormat.Radius = GetPropertyValue(attribute2, reader.LocalName);
						}
					}
					if (reader.IsEmptyElement)
					{
						break;
					}
					localName = reader.LocalName;
					reader.Read();
					if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
					{
						effectFormat.GlowFormat.Color = ParseColor(reader, localName, ref opacity, localName, isAlreadyChecked: true);
						effectFormat.GlowFormat.IsInlineColor = true;
						if (opacity != uint.MaxValue)
						{
							float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
							effectFormat.GlowFormat.Transparency = 1f - num;
							effectFormat.GlowFormat.IsInlineTransparency = true;
						}
					}
					break;
				case "softEdge":
					effectFormat.IsSoftEdge = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("rad");
						effectFormat.SoftEdgeRadius = GetPropertyValue(attribute, reader.LocalName);
						if (effectFormat.SoftEdgeRadius == 0f)
						{
							effectFormat.NoSoftEdges = true;
						}
					}
					flag = false;
					break;
				default:
					flag = false;
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseFillStyleList(XmlReader reader, string localName)
	{
		if (reader.LocalName != "fillStyleLst" && reader.LocalName != "bgFillStyleLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		reader.Read();
		SkipWhitespaces(reader);
		bool flag = false;
		while (!(reader.LocalName == localName) || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				FillFormat fillFormat = new FillFormat((ShapeBase)new Shape(m_doc));
				switch (reader.LocalName)
				{
				case "solidFill":
				{
					fillFormat.Fill = true;
					fillFormat.FillType = FillType.FillSolid;
					List<DictionaryEntry> colorEntries2 = new List<DictionaryEntry>();
					uint opacity = uint.MaxValue;
					Color color = Color.Empty;
					colorEntries2 = ParseThemeFillColor(reader, "solidFill", colorEntries2, ref opacity, ref color);
					fillFormat.Color = color;
					if (colorEntries2 != null && colorEntries2.Count > 0)
					{
						fillFormat.FillSchemeColorTransforms = colorEntries2;
					}
					if (opacity != uint.MaxValue)
					{
						fillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					if (localName.Equals("fillStyleLst"))
					{
						m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
					}
					else
					{
						m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
					}
					flag = true;
					break;
				}
				case "gradFill":
					fillFormat.Fill = true;
					fillFormat.FillType = FillType.FillGradient;
					ParseFormatSchemeGradientFill(reader, fillFormat.GradientFill);
					if (localName.Equals("fillStyleLst"))
					{
						m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
					}
					else
					{
						m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
					}
					flag = true;
					break;
				case "noFill":
					fillFormat.Fill = false;
					flag = true;
					fillFormat.FillType = FillType.None;
					if (localName.Equals("fillStyleLst"))
					{
						m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
					}
					else
					{
						m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
					}
					break;
				case "blipFill":
					fillFormat.Fill = true;
					fillFormat.FillType = FillType.FillPicture;
					ParseBlipFill(reader, fillFormat);
					if (localName.Equals("fillStyleLst"))
					{
						m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
					}
					else
					{
						m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
					}
					break;
				case "pattFill":
				{
					fillFormat.FillType = FillType.FillPatterned;
					string attribute = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute))
					{
						fillFormat.Pattern = GetPatternType(attribute);
					}
					List<DictionaryEntry> colorEntries = new List<DictionaryEntry>();
					uint opacity = uint.MaxValue;
					Color color = Color.Empty;
					Color foreColor = Color.Empty;
					uint fgOpacity = uint.MaxValue;
					colorEntries = ParseThemePatternFill(reader, "pattFill", colorEntries, ref color, ref foreColor, ref opacity, ref fgOpacity);
					if (colorEntries != null && colorEntries.Count > 0)
					{
						fillFormat.FillSchemeColorTransforms = colorEntries;
					}
					fillFormat.Color = color;
					fillFormat.ForeColor = foreColor;
					if (opacity != uint.MaxValue)
					{
						fillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					if (fgOpacity != uint.MaxValue)
					{
						fillFormat.SecondaryOpacity = (float)Math.Round(1f - (float)fgOpacity / 65536f, 2) * 100f;
					}
					if (localName.Equals("fillStyleLst"))
					{
						m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
					}
					else
					{
						m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
					}
					break;
				}
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private List<DictionaryEntry> ParseThemeFillColor(XmlReader reader, string localName, List<DictionaryEntry> colorEntries, ref uint opacity, ref Color color)
	{
		if (!reader.IsEmptyElement)
		{
			string localName2 = reader.LocalName;
			reader.Read();
			if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				while (reader.NodeType != XmlNodeType.Element)
				{
					reader.Read();
				}
				if (localName2 != localName)
				{
					throw new XmlException("Unexpected xml tag " + reader.LocalName);
				}
				color = Color.Empty;
				SkipWhitespaces(reader);
				while (!(reader.LocalName == localName) || reader.NodeType != XmlNodeType.EndElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "schemeClr":
						{
							string attribute3 = reader.GetAttribute("val");
							if (m_doc != null && m_doc.Themes != null && m_doc.Themes.SchemeColor != null && attribute3 != null && m_doc.Themes.SchemeColor.ContainsKey(attribute3))
							{
								color = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
								break;
							}
							color = Color.Empty;
							colorEntries = ParseThemeColorTransform(reader, localName);
							break;
						}
						case "srgbClr":
						{
							string attribute4 = reader.GetAttribute("val");
							color = GetHexColor(attribute4);
							ParseColorTransform(reader, "srgbClr", ref color, ref opacity);
							break;
						}
						case "scrgbClr":
						{
							string attribute5 = reader.GetAttribute("r");
							double percentage = GetPercentage(attribute5);
							percentage = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage / 100.0));
							attribute5 = reader.GetAttribute("g");
							double percentage2 = GetPercentage(attribute5);
							percentage2 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage2 / 100.0));
							attribute5 = reader.GetAttribute("b");
							double percentage3 = GetPercentage(attribute5);
							percentage3 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage3 / 100.0));
							color = Color.FromArgb(255, (byte)percentage, (byte)percentage2, (byte)percentage3);
							ParseColorTransform(reader, "scrgbClr", ref color, ref opacity);
							break;
						}
						case "prstClr":
						{
							string attribute2 = reader.GetAttribute("val");
							if (attribute2 != null)
							{
								color = Color.FromName(attribute2);
							}
							ParseColorTransform(reader, "prstClr", ref color, ref opacity);
							break;
						}
						case "hslClr":
						{
							double result = 0.0;
							double num = 0.0;
							double num2 = 0.0;
							string attribute = reader.GetAttribute("hue");
							double.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							result /= 60000.0;
							result /= 360.0;
							attribute = reader.GetAttribute("lum");
							num = GetPercentage(attribute) / 100.0;
							attribute = reader.GetAttribute("sat");
							num2 = GetPercentage(attribute) / 100.0;
							color = WordColor.ConvertHSLToColor(result, num2, num);
							ParseColorTransform(reader, "hslClr", ref color, ref opacity);
							break;
						}
						case "sysClr":
							color = GetSystemColor(reader);
							ParseColorTransform(reader, "sysClr", ref color, ref opacity);
							break;
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return colorEntries;
			}
			return null;
		}
		return null;
	}

	private List<DictionaryEntry> ParseThemeColorTransform(XmlReader reader, string parentElement)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				bool flag = false;
				while (reader.NodeType != XmlNodeType.Element)
				{
					reader.Read();
					flag = true;
				}
				if (localName != "schemeClr")
				{
					throw new XmlException("Unexpected xml tag " + reader.LocalName);
				}
				if (!flag)
				{
					return ParseThemeColorTransformValues(reader, parentElement);
				}
				if (!reader.IsEmptyElement)
				{
					localName = reader.LocalName;
					reader.Read();
					if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
					{
						return ParseThemeColorTransformValues(reader, parentElement);
					}
				}
			}
			return null;
		}
		return null;
	}

	private List<DictionaryEntry> ParseThemeColorTransformValues(XmlReader reader, string parentElement)
	{
		List<DictionaryEntry> list = new List<DictionaryEntry>();
		SkipWhitespaces(reader);
		while (!(reader.LocalName == "schemeClr") || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "alpha":
				case "green":
				case "shade":
				case "alphaMod":
				case "alphaOff":
				case "greenMod":
				case "greenOff":
				case "tint":
				case "blue":
				case "blueMod":
				case "blueOff":
				case "red":
				case "hue":
				case "sat":
				case "lum":
				case "redOff":
				case "redMod":
				case "satMod":
				case "satOff":
				case "hueMod":
				case "hueOff":
				case "lumMod":
				case "lumOff":
				{
					string key = ((parentElement == "fgClr" || parentElement == "bgClr") ? parentElement : "") + reader.LocalName;
					if (IsStrict)
					{
						int result = 0;
						int.TryParse(reader.GetAttribute("val").Replace("%", ""), NumberStyles.Number, CultureInfo.CurrentCulture, out result);
						result *= 1000;
						list.Add(new DictionaryEntry(key, result));
					}
					else
					{
						list.Add(new DictionaryEntry(key, reader.GetAttribute("val")));
					}
					break;
				}
				case "gamma":
				case "invGamma":
				case "gray":
				case "comp":
				case "inv":
					list.Add(new DictionaryEntry(reader.LocalName, string.Empty));
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		return list;
	}

	private void ParseFormatSchemeGradientFill(XmlReader reader, GradientFill gradientFill)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			string attribute = reader.GetAttribute("flip");
			string attribute2 = reader.GetAttribute("rotWithShape");
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				while (reader.NodeType != XmlNodeType.Element)
				{
					reader.Read();
				}
				if (localName != "gradFill")
				{
					throw new XmlException("Unexpected xml tag " + reader.LocalName);
				}
				if (!string.IsNullOrEmpty(attribute))
				{
					gradientFill.Flip = GetFlipOrientation(attribute);
				}
				if (!string.IsNullOrEmpty(attribute2))
				{
					gradientFill.RotateWithShape = GetBoolValue(attribute2);
				}
				SkipWhitespaces(reader);
				string text = null;
				while (!(reader.LocalName == "gradFill") || reader.NodeType != XmlNodeType.EndElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "gsLst":
							ParseFormatSchemeGradientStop(reader, gradientFill);
							break;
						case "lin":
							ParseLinearGradient(reader, gradientFill);
							break;
						case "path":
							gradientFill.PathGradient = new PathGradient();
							text = reader.GetAttribute("path");
							gradientFill.PathGradient.PathShade = GetGradientShadeType(text);
							if (!reader.IsEmptyElement)
							{
								localName = reader.LocalName;
								reader.Read();
								if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
								{
									ParsePathGradient(reader, gradientFill.PathGradient, localName);
								}
							}
							break;
						case "tileRect":
							ParseTileRectangle(reader, gradientFill);
							break;
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
			}
			else
			{
				gradientFill.IsEmptyElement = true;
			}
		}
		else
		{
			gradientFill.IsEmptyElement = true;
		}
	}

	private List<DictionaryEntry> ParseThemePatternFill(XmlReader reader, string parentElement, List<DictionaryEntry> colorEntries, ref Color color, ref Color foreColor, ref uint opacity, ref uint fgOpacity)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			string localName2 = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				bool flag = true;
				reader.Read();
				SkipWhitespaces(reader);
				while (!(reader.LocalName == localName2) || reader.NodeType != XmlNodeType.EndElement)
				{
					flag = false;
					opacity = uint.MaxValue;
					if (reader.NodeType == XmlNodeType.Element)
					{
						string localName3 = reader.LocalName;
						if (localName3 == "fgClr" || localName3 == "bgClr")
						{
							Color color2 = Color.Empty;
							uint opacity2 = uint.MaxValue;
							colorEntries = ParseThemeFillColor(reader, reader.LocalName, colorEntries, ref opacity2, ref color2);
							if (reader.LocalName == "fgClr")
							{
								foreColor = color2;
								fgOpacity = opacity2;
							}
							else
							{
								color = color2;
								opacity = opacity2;
							}
						}
						else
						{
							flag = true;
						}
						if (flag)
						{
							reader.Read();
						}
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return colorEntries;
			}
			return null;
		}
		return null;
	}

	private void ParseFormatSchemeGradientStop(XmlReader reader, GradientFill gradientFill)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "gsLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		int num = 0;
		SkipWhitespaces(reader);
		for (; !(reader.LocalName == "gsLst") || reader.NodeType != XmlNodeType.EndElement; SkipWhitespaces(reader))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "gs")
				{
					string attribute = reader.GetAttribute("pos");
					GradientStop gradientStop = new GradientStop();
					if (!string.IsNullOrEmpty(attribute))
					{
						double result;
						if (IsStrict && attribute.EndsWith("%"))
						{
							double.TryParse(attribute.Remove(attribute.IndexOf("%")), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							gradientStop.Position = (byte)Math.Round(result);
						}
						else if (double.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							gradientStop.Position = (byte)Math.Round(result / 1000.0);
						}
						else
						{
							if (gradientFill.GradientStops.Count != 0)
							{
								goto IL_01ba;
							}
							gradientStop.Position = (byte)result;
						}
					}
					uint opacity = uint.MaxValue;
					List<DictionaryEntry> colorEntries = new List<DictionaryEntry>();
					Color color = Color.Empty;
					colorEntries = ParseThemeFillColor(reader, "gs", colorEntries, ref opacity, ref color);
					gradientStop.Color = color;
					if (colorEntries != null && colorEntries.Count > 0)
					{
						gradientStop.FillSchemeColorTransforms = colorEntries;
					}
					if (opacity != uint.MaxValue)
					{
						gradientStop.Opacity = (byte)Math.Round((double)opacity / 65536.0 * 100.0);
					}
					num++;
					gradientFill.GradientStops.Add(gradientStop);
				}
				goto IL_01ba;
			}
			reader.Read();
			continue;
			IL_01ba:
			reader.Read();
		}
	}

	private void ParseLineStyleScheme(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (localName != "lnStyleLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		Shape shape = new Shape(m_doc);
		while (!(reader.LocalName == "lnStyleLst") || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				LineFormat lineFormat = new LineFormat(shape);
				if (reader.LocalName == "ln")
				{
					string text = null;
					string text2 = null;
					string text3 = null;
					string text4 = null;
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						text = reader.GetAttribute("w");
						text2 = reader.GetAttribute("cmpd");
						text3 = reader.GetAttribute("algn");
						text4 = reader.GetAttribute("cap");
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							if (!string.IsNullOrEmpty(text))
							{
								lineFormat.Weight = GetPropertyValue(text, "ln");
							}
							if (!string.IsNullOrEmpty(text2))
							{
								lineFormat.Style = GetShapeOutLineStyle(text2);
							}
							if (text3 == "in")
							{
								lineFormat.InsetPen = true;
							}
							if (!string.IsNullOrEmpty(text4))
							{
								lineFormat.LineCap = GetLineCapStyle(text4);
							}
							ParseLineStyle(reader, lineFormat, localName);
							m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
						}
						else
						{
							lineFormat.Line = false;
							m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
						}
					}
					else
					{
						lineFormat.Line = false;
						m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseLineStyle(XmlReader reader, LineFormat lineFormat, string localName)
	{
		if (localName != "ln")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		bool flag = false;
		while (!(reader.LocalName == "ln") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "bevel":
					lineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Bevel;
					break;
				case "miter":
					lineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Miter;
					if (IsStrict)
					{
						int result = 0;
						int.TryParse(reader.GetAttribute("lim").Replace("%", ""), NumberStyles.Number, CultureInfo.CurrentCulture, out result);
						lineFormat.MiterJoinLimit = (result * 1000).ToString();
					}
					else
					{
						lineFormat.MiterJoinLimit = reader.GetAttribute("lim");
					}
					break;
				case "round":
					lineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Round;
					break;
				case "headEnd":
					ParseHeadEnd(reader, lineFormat);
					break;
				case "tailEnd":
					ParseTailEnd(reader, lineFormat);
					break;
				case "extLst":
					lineFormat.DocxProps.Add(reader.LocalName, ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				case "prstDash":
				{
					string attribute2 = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute2))
					{
						lineFormat.DashStyle = GetDashStyle(attribute2);
					}
					break;
				}
				case "solidFill":
				{
					lineFormat.Line = true;
					lineFormat.LineFormatType = LineFormatType.Solid;
					List<DictionaryEntry> colorEntries2 = new List<DictionaryEntry>();
					Color color = Color.Empty;
					uint num = uint.MaxValue;
					colorEntries2 = ParseThemeFillColor(reader, reader.LocalName, colorEntries2, ref num, ref color);
					if (colorEntries2 != null && colorEntries2.Count > 0)
					{
						lineFormat.LineSchemeColorTransforms = colorEntries2;
					}
					lineFormat.Color = color;
					if (num != uint.MaxValue)
					{
						lineFormat.Transparency = (float)Math.Round(1f - (float)num / 65536f, 2) * 100f;
					}
					break;
				}
				case "noFill":
					lineFormat.Line = false;
					lineFormat.LineFormatType = LineFormatType.None;
					break;
				case "gradFill":
					lineFormat.Line = true;
					lineFormat.LineFormatType = LineFormatType.Gradient;
					ParseFormatSchemeGradientFill(reader, lineFormat.GradientFill);
					break;
				case "pattFill":
				{
					lineFormat.Line = true;
					lineFormat.LineFormatType = LineFormatType.Patterned;
					string attribute = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute))
					{
						lineFormat.Pattern = GetPatternType(attribute);
					}
					uint num = uint.MaxValue;
					List<DictionaryEntry> colorEntries = new List<DictionaryEntry>();
					num = uint.MaxValue;
					uint fgOpacity = uint.MaxValue;
					Color color = Color.Empty;
					Color foreColor = Color.Empty;
					colorEntries = ParseThemePatternFill(reader, "pattFill", colorEntries, ref color, ref foreColor, ref num, ref fgOpacity);
					lineFormat.Color = color;
					lineFormat.ForeColor = foreColor;
					if (num != uint.MaxValue)
					{
						lineFormat.Transparency = (float)Math.Round(1f - (float)num / 65536f, 2) * 100f;
					}
					break;
				}
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				case "custDash":
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseFontScheme(XmlReader reader)
	{
		if (reader.LocalName != "fontScheme")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		bool flag = false;
		bool flag2 = false;
		while (!(reader.LocalName == "fontScheme") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (localName == "majorFont" || localName == "minorFont")
				{
					if (reader.IsEmptyElement)
					{
						flag = true;
					}
					else
					{
						flag2 = reader.LocalName.Equals("majorFont");
						ParseFontSchemeInternal(reader, flag2, reader.LocalName);
						flag2 = false;
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseFontSchemeInternal(XmlReader reader, bool IsMajorFont, string parentElement)
	{
		if (reader.LocalName != "majorFont" && reader.LocalName != "minorFont")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		reader.Read();
		SkipWhitespaces(reader);
		FontSchemeStruct item = default(FontSchemeStruct);
		string value = null;
		string panose = null;
		string text = null;
		string value2 = null;
		string key = null;
		bool flag = false;
		while (!(reader.LocalName == parentElement) || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				item.Name = reader.LocalName;
				switch (reader.LocalName)
				{
				case "latin":
				case "ea":
				case "cs":
					if (!reader.HasAttributes)
					{
						break;
					}
					while (reader.MoveToNextAttribute())
					{
						switch (reader.Name)
						{
						case "typeface":
							if (string.IsNullOrEmpty(reader.Name))
							{
								break;
							}
							text = reader.Value;
							if (item.Name == "latin")
							{
								if (IsMajorFont)
								{
									m_majorFontName = text;
								}
								else
								{
									m_minorFontName = text;
								}
							}
							break;
						case "charset":
							if (!string.IsNullOrEmpty(reader.Name))
							{
								value = reader.Value;
							}
							break;
						case "panose":
							if (!string.IsNullOrEmpty(reader.Name))
							{
								panose = reader.Value;
							}
							break;
						case "pitchFamily":
							if (!string.IsNullOrEmpty(reader.Name))
							{
								value2 = reader.Value;
							}
							break;
						}
					}
					item.Typeface = text;
					item.Charset = Convert.ToByte(value);
					item.Panose = panose;
					item.PitchFamily = Convert.ToByte(value2);
					if (IsMajorFont)
					{
						m_doc.Themes.FontScheme.MajorFontScheme.FontSchemeList.Add(item);
					}
					else
					{
						m_doc.Themes.FontScheme.MinorFontScheme.FontSchemeList.Add(item);
					}
					switch (item.Name)
					{
					case "latin":
						if (IsMajorFont)
						{
							m_majorLatinFontName = item.Typeface;
						}
						else
						{
							m_minorLatinFontName = item.Typeface;
						}
						break;
					case "ea":
						if (IsMajorFont)
						{
							m_majorEaFontName = item.Typeface;
						}
						else
						{
							m_minorEaFontName = item.Typeface;
						}
						break;
					case "cs":
						if (IsMajorFont)
						{
							m_majorCsFontName = item.Typeface;
						}
						else
						{
							m_minorCsFontName = item.Typeface;
						}
						break;
					}
					break;
				case "font":
					if (!reader.HasAttributes)
					{
						break;
					}
					while (reader.MoveToNextAttribute())
					{
						string name = reader.Name;
						if (!(name == "script"))
						{
							if (name == "typeface")
							{
								text = reader.Value;
							}
						}
						else
						{
							key = reader.Value;
						}
					}
					if (IsMajorFont)
					{
						if (!m_doc.Themes.FontScheme.MajorFontScheme.FontTypeface.ContainsKey(key))
						{
							m_doc.Themes.FontScheme.MajorFontScheme.FontTypeface.Add(key, text);
						}
					}
					else if (!m_doc.Themes.FontScheme.MinorFontScheme.FontTypeface.ContainsKey(key))
					{
						m_doc.Themes.FontScheme.MinorFontScheme.FontTypeface.Add(key, text);
					}
					break;
				default:
					flag = true;
					break;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseSchemeColor(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (localName != "clrScheme")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		uint opacity = uint.MaxValue;
		Color empty = Color.Empty;
		bool flag = false;
		while (!(reader.LocalName == "clrScheme") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "dk1":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("dk1"))
					{
						m_doc.Themes.SchemeColor.Add("dk1", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "lt1":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("lt1"))
					{
						m_doc.Themes.SchemeColor.Add("lt1", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "dk2":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("dk2"))
					{
						m_doc.Themes.SchemeColor.Add("dk2", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "lt2":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("lt2"))
					{
						m_doc.Themes.SchemeColor.Add("lt2", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent1":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent1"))
					{
						m_doc.Themes.SchemeColor.Add("accent1", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent2":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent2"))
					{
						m_doc.Themes.SchemeColor.Add("accent2", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent3":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent3"))
					{
						m_doc.Themes.SchemeColor.Add("accent3", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent4":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent4"))
					{
						m_doc.Themes.SchemeColor.Add("accent4", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent5":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent5"))
					{
						m_doc.Themes.SchemeColor.Add("accent5", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "accent6":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("accent6"))
					{
						m_doc.Themes.SchemeColor.Add("accent6", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "hlink":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("hlink"))
					{
						m_doc.Themes.SchemeColor.Add("hlink", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "folHlink":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("folHlink"))
					{
						m_doc.Themes.SchemeColor.Add("folHlink", empty);
					}
					opacity = uint.MaxValue;
					break;
				case "phClr":
					empty = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (!m_doc.Themes.SchemeColor.ContainsKey("phClr"))
					{
						m_doc.Themes.SchemeColor.Add("phClr", empty);
					}
					opacity = uint.MaxValue;
					break;
				default:
					flag = true;
					break;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private string GetBaseFontName(Stream stream, bool isMajor)
	{
		string localName = (isMajor ? "majorFont" : "minorFont");
		stream.Position = 0L;
		XmlReader xmlReader = XmlReader.Create(stream);
		xmlReader.ReadToFollowing(localName, "http://schemas.openxmlformats.org/drawingml/2006/main");
		if (xmlReader.EOF)
		{
			return null;
		}
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == "latin")
			{
				string attribute = xmlReader.GetAttribute("typeface");
				if (!string.IsNullOrEmpty(attribute))
				{
					stream.Position = 0L;
					return attribute;
				}
			}
		}
		return null;
	}

	private void ParseDocumentProperties(Package wordPackage)
	{
		PartContainer partContainer = wordPackage.FindPartContainer("docProps/");
		foreach (string key in partContainer.XmlParts.Keys)
		{
			Stream dataStream = partContainer.XmlParts[key].DataStream;
			switch (key)
			{
			case "app.xml":
				m_reader = UtilityMethods.CreateReader(dataStream);
				ParseAppProperties(m_reader);
				m_reader.Dispose();
				break;
			case "core.xml":
				m_reader = UtilityMethods.CreateReader(dataStream);
				ParseCoreProperties(m_reader);
				m_reader.Dispose();
				break;
			case "custom.xml":
				m_reader = UtilityMethods.CreateReader(dataStream);
				ParseCustomProperties(m_reader);
				m_reader.Dispose();
				break;
			}
		}
	}

	private void ParseVbaProject(Stream stream)
	{
		m_doc.VbaProject = stream;
	}

	private void ParseVbaProjectSignature(Stream stream)
	{
		m_doc.VbaProjectSignature = stream;
	}

	private void ParseVbaProjectSignatureAgile(Stream stream)
	{
		m_doc.VbaProjectSignatureAgile = stream;
	}

	private void ParseVbaData(Stream stream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader is null");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "vbaSuppData")
		{
			throw new XmlException("Expected xml tag \"vbaSuppData\"");
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != "vbaSuppData")
		{
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				string localName2 = xmlReader.LocalName;
				if (!(localName2 == "mcds"))
				{
					if (localName2 == "docEvents")
					{
						xmlReader.Read();
						ParseDocEvents(xmlReader);
					}
				}
				else
				{
					xmlReader.Read();
					ParseMacroData(xmlReader);
				}
			}
			xmlReader.Read();
			SkipWhitespaces(xmlReader);
		}
	}

	private void ParseMacroData(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "mcd")
		{
			throw new XmlException("Expected xml tag \"mcd\"");
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "mcds")
		{
			if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "mcd")
			{
				MacroData macroData = new MacroData();
				macroData.Name = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2006/wordml");
				macroData.Encrypt = reader.GetAttribute("bEncrypt", "http://schemas.microsoft.com/office/word/2006/wordml");
				macroData.Cmg = reader.GetAttribute("cmg", "http://schemas.microsoft.com/office/word/2006/wordml");
				m_doc.VbaData.Add(macroData);
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private void ParseDocEvents(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "docEvents")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				m_doc.DocEvents.Add(reader.LocalName);
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private void ParseFontTable(Stream stream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader is null");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "fonts")
		{
			throw new XmlException("Expected xml tag \"fonts\"");
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != "fonts")
		{
			if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.LocalName == "font")
			{
				string attribute = xmlReader.GetAttribute("name", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
				ParseFontDetails(xmlReader, attribute);
			}
			xmlReader.Read();
			SkipWhitespaces(xmlReader);
		}
		UpdateFontTable();
	}

	private void ParseFontTable(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "fonts")
		{
			throw new XmlException("Expected xml tag \"fonts\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "fonts")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "defaultFonts"))
				{
					if (localName2 == "font")
					{
						string attribute = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
						Parse2003FontDetails(reader, attribute);
					}
				}
				else
				{
					m_doc.DefCharFormat = new WCharacterFormat(m_doc);
					int i = 0;
					for (int attributeCount = reader.AttributeCount; i < attributeCount; i++)
					{
						reader.MoveToAttribute(i);
						switch (reader.LocalName)
						{
						case "hint":
						{
							string attribute3 = reader.GetAttribute(i);
							if (!(attribute3 == "cs"))
							{
								if (attribute3 == "fareast")
								{
									m_doc.DefCharFormat.IdctHint = FontHintType.EastAsia;
								}
								else
								{
									m_doc.DefCharFormat.IdctHint = FontHintType.Default;
								}
							}
							else
							{
								m_doc.DefCharFormat.IdctHint = FontHintType.CS;
							}
							break;
						}
						case "ascii":
						{
							string attribute2 = reader.GetAttribute(i);
							m_doc.DefCharFormat.FontNameAscii = attribute2;
							m_doc.DefCharFormat.FontName = attribute2;
							break;
						}
						case "h-ansi":
							m_doc.DefCharFormat.FontNameNonFarEast = reader.GetAttribute(i);
							break;
						case "fareast":
							m_doc.DefCharFormat.FontNameFarEast = reader.GetAttribute(i);
							break;
						case "cs":
							m_doc.DefCharFormat.FontNameBidi = reader.GetAttribute(i);
							break;
						}
					}
				}
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
		UpdateFontTable();
	}

	private void UpdateFontTable()
	{
		m_doc.FFNStringTable = new FontFamilyNameStringTable();
		m_doc.FFNStringTable.RecordsCount = m_fontFamilyRecords.Count;
		int num = 0;
		foreach (FontFamilyNameRecord fontFamilyRecord in m_fontFamilyRecords)
		{
			m_doc.FFNStringTable.FontFamilyNameRecords[num] = fontFamilyRecord;
			num++;
		}
	}

	private void Parse2003FontDetails(XmlReader reader, string fontName)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "font")
		{
			throw new XmlException("Expected xml tag \"font\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		FontFamilyNameRecord fontFamilyNameRecord = new FontFamilyNameRecord();
		SkipWhitespaces(reader);
		while (reader.LocalName != "font")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "altName":
				{
					string attribute4 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (m_doc.FontSubstitutionTable.ContainsKey(fontName))
					{
						m_doc.FontSubstitutionTable[fontName] = attribute4;
					}
					else if (!string.IsNullOrEmpty(attribute4))
					{
						m_doc.FontSubstitutionTable.Add(fontName, attribute4);
					}
					fontFamilyNameRecord.AlternativeFontName = attribute4;
					break;
				}
				case "charset":
				{
					string attribute3 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					try
					{
						fontFamilyNameRecord.CharacterSetId = Convert.ToByte(attribute3);
					}
					catch
					{
						fontFamilyNameRecord.CharacterSetId = 1;
					}
					break;
				}
				case "family":
				{
					string attribute2 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute2))
					{
						switch (attribute2.ToLower())
						{
						case "auto":
							fontFamilyNameRecord.FontFamilyID = 0;
							break;
						case "roman":
							fontFamilyNameRecord.FontFamilyID = 1;
							break;
						case "swiss":
							fontFamilyNameRecord.FontFamilyID = 2;
							break;
						case "modern":
							fontFamilyNameRecord.FontFamilyID = 3;
							break;
						case "script":
							fontFamilyNameRecord.FontFamilyID = 4;
							break;
						case "decorative":
							fontFamilyNameRecord.FontFamilyID = 5;
							break;
						}
					}
					break;
				}
				case "pitch":
				{
					string attribute5 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute5))
					{
						switch (attribute5.ToLower())
						{
						case "default":
							fontFamilyNameRecord.PitchRequest = 0;
							break;
						case "fixed":
							fontFamilyNameRecord.PitchRequest = 1;
							break;
						case "variable":
							fontFamilyNameRecord.PitchRequest = 2;
							break;
						}
					}
					break;
				}
				case "sig":
				{
					string attribute = reader.GetAttribute("usb-0", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigUsb0 = GetBytes(attribute);
					}
					attribute = reader.GetAttribute("usb-1", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigUsb1 = GetBytes(attribute);
					}
					attribute = reader.GetAttribute("usb-2", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigUsb2 = GetBytes(attribute);
					}
					attribute = reader.GetAttribute("usb-3", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigUsb3 = GetBytes(attribute);
					}
					attribute = reader.GetAttribute("csb-0", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigCsb0 = GetBytes(attribute);
					}
					attribute = reader.GetAttribute("csb-1", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						fontFamilyNameRecord.SigCsb1 = GetBytes(attribute);
					}
					break;
				}
				}
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
		fontFamilyNameRecord.FontName = fontName;
		m_fontFamilyRecords.Add(fontFamilyNameRecord);
	}

	private void ParseFontDetails(XmlReader reader, string fontName)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "font")
		{
			throw new XmlException("Expected xml tag \"font\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		FontFamilyNameRecord fontFamilyNameRecord = new FontFamilyNameRecord();
		SkipWhitespaces(reader);
		while (reader.LocalName != "font")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "altName":
				{
					string attribute8 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute8))
					{
						if (m_doc.FontSubstitutionTable.ContainsKey(fontName))
						{
							m_doc.FontSubstitutionTable[fontName] = attribute8;
						}
						else if (!string.IsNullOrEmpty(attribute8))
						{
							m_doc.FontSubstitutionTable.Add(fontName, attribute8);
						}
						fontFamilyNameRecord.AlternativeFontName = attribute8;
					}
					break;
				}
				case "charset":
				{
					string attribute6 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					int result = -1;
					if (int.TryParse(attribute6, NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
					{
						fontFamilyNameRecord.CharacterSetId = Convert.ToByte(result);
					}
					else if (int.TryParse(attribute6, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out result))
					{
						fontFamilyNameRecord.CharacterSetId = Convert.ToByte(result);
					}
					else
					{
						fontFamilyNameRecord.CharacterSetId = 1;
					}
					break;
				}
				case "family":
				{
					string attribute7 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute7))
					{
						switch (attribute7.ToLower())
						{
						case "auto":
							fontFamilyNameRecord.FontFamilyID = 0;
							break;
						case "roman":
							fontFamilyNameRecord.FontFamilyID = 1;
							break;
						case "swiss":
							fontFamilyNameRecord.FontFamilyID = 2;
							break;
						case "modern":
							fontFamilyNameRecord.FontFamilyID = 3;
							break;
						case "script":
							fontFamilyNameRecord.FontFamilyID = 4;
							break;
						case "decorative":
							fontFamilyNameRecord.FontFamilyID = 5;
							break;
						}
					}
					break;
				}
				case "pitch":
				{
					string attribute4 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute4))
					{
						switch (attribute4.ToLower())
						{
						case "default":
							fontFamilyNameRecord.PitchRequest = 0;
							break;
						case "fixed":
							fontFamilyNameRecord.PitchRequest = 1;
							break;
						case "variable":
							fontFamilyNameRecord.PitchRequest = 2;
							break;
						}
					}
					break;
				}
				case "sig":
				{
					string attribute5 = reader.GetAttribute("usb0", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigUsb0 = GetBytes(attribute5);
					}
					attribute5 = reader.GetAttribute("usb1", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigUsb1 = GetBytes(attribute5);
					}
					attribute5 = reader.GetAttribute("usb2", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigUsb2 = GetBytes(attribute5);
					}
					attribute5 = reader.GetAttribute("usb3", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigUsb3 = GetBytes(attribute5);
					}
					attribute5 = reader.GetAttribute("csb0", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigCsb0 = GetBytes(attribute5);
					}
					attribute5 = reader.GetAttribute("csb1", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						fontFamilyNameRecord.SigCsb1 = GetBytes(attribute5);
					}
					break;
				}
				case "embedRegular":
				case "embedBold":
				case "embedItalic":
				case "embedBoldItalic":
				{
					string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (string.IsNullOrEmpty(attribute))
					{
						break;
					}
					string fileName = FontTableRelations[attribute].Value.ToString();
					string partName = GetPartName(ref fileName);
					MemoryStream obj = m_doc.DocxPackage.FindPart(partName + fileName).DataStream as MemoryStream;
					obj.Position = 0L;
					MemoryStream memoryStream = new MemoryStream();
					obj.WriteTo(memoryStream);
					string attribute2 = reader.GetAttribute("fontKey", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!fontFamilyNameRecord.EmbedFonts.ContainsKey(reader.LocalName) && !string.IsNullOrEmpty(attribute2))
					{
						DictionaryEntry value = new DictionaryEntry(attribute2, memoryStream);
						Dictionary<string, DictionaryEntry> dictionary = new Dictionary<string, DictionaryEntry>();
						dictionary.Add(FontTableRelations[attribute].Value.ToString(), value);
						fontFamilyNameRecord.EmbedFonts.Add(reader.LocalName, dictionary);
						break;
					}
					string attribute3 = reader.GetAttribute("subsetted", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!fontFamilyNameRecord.EmbedFonts.ContainsKey(reader.LocalName) && !string.IsNullOrEmpty(attribute3))
					{
						fontFamilyNameRecord.IsSubsetted = true;
						DictionaryEntry value2 = new DictionaryEntry(attribute3, memoryStream);
						Dictionary<string, DictionaryEntry> dictionary2 = new Dictionary<string, DictionaryEntry>();
						dictionary2.Add(FontTableRelations[attribute].Value.ToString(), value2);
						fontFamilyNameRecord.EmbedFonts.Add(reader.LocalName, dictionary2);
					}
					else if (!fontFamilyNameRecord.EmbedFonts.ContainsKey(reader.LocalName) && (attribute2 == null || attribute3 == null))
					{
						DictionaryEntry value3 = new DictionaryEntry(string.Empty, memoryStream);
						Dictionary<string, DictionaryEntry> dictionary3 = new Dictionary<string, DictionaryEntry>();
						dictionary3.Add(FontTableRelations[attribute].Value.ToString(), value3);
						fontFamilyNameRecord.EmbedFonts.Add(reader.LocalName, dictionary3);
					}
					break;
				}
				}
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
		fontFamilyNameRecord.FontName = fontName;
		m_fontFamilyRecords.Add(fontFamilyNameRecord);
	}

	private byte[] GetBytes(string signature)
	{
		byte[] array = new byte[4];
		if (signature.Length == 8)
		{
			char[] array2 = signature.ToCharArray();
			Array.Reverse(array2);
			signature = new string(array2);
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				array[i] = Convert.ToByte(signature.Substring(num, 2), 16);
				num += 2;
			}
		}
		return array;
	}

	private void ParseDocument(Stream stream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "document")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		string attribute = xmlReader.GetAttribute("conformance", "http://purl.oclc.org/ooxml/wordprocessingml/main");
		string attribute2 = xmlReader.GetAttribute("xml:space");
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (attribute == "strict")
		{
			IsStrict = true;
		}
		if (!string.IsNullOrEmpty(attribute2))
		{
			PreserveSpace = attribute2 == "preserve";
		}
		bool flag = false;
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != "document")
		{
			flag = false;
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				string localName2 = xmlReader.LocalName;
				if (!(localName2 == "background"))
				{
					if (localName2 == "body")
					{
						m_doc.AddSection();
						if (m_doc.Sections.Count == 1)
						{
							m_doc.LastSection.PageSetup.InitializeDocxPageSetup();
						}
						ParseBody(xmlReader, null, isRunElementTextBody: false, isFromDocument: true, isMappedPictureContentControl: false);
						flag = true;
					}
				}
				else
				{
					ParseDocumentBackground(xmlReader);
					flag = true;
				}
				if (!flag)
				{
					xmlReader.Read();
				}
			}
			else
			{
				xmlReader.Read();
			}
			SkipWhitespaces(xmlReader);
		}
	}

	private bool IsNeedToMergeTables(WTable table)
	{
		if (!(table.PreviousSibling is WTable))
		{
			return false;
		}
		WTable wTable = table.PreviousSibling as WTable;
		if (!table.TableFormat.WrapTextAround && !wTable.TableFormat.WrapTextAround && !table.IsFrame && !wTable.IsFrame && (wTable.TableGrid.Count == table.TableGrid.Count || IsRowHeaderEnabled(wTable)))
		{
			return table.StyleName == wTable.StyleName;
		}
		return false;
	}

	private bool IsRowHeaderEnabled(WTable prevTable)
	{
		for (int i = 0; i < prevTable.ChildEntities.Count; i++)
		{
			if ((prevTable.ChildEntities[i] as WTableRow).IsHeader)
			{
				return true;
			}
		}
		return false;
	}

	private void ParseBody(XmlReader reader, IEntity entity, bool isRunElementTextBody, bool isFromDocument, bool isMappedPictureContentControl)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		string localName = reader.LocalName;
		MemoryStream drawingStream = null;
		if (!reader.IsEmptyElement)
		{
			string localName2 = reader.LocalName;
			reader.Read();
			if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				return;
			}
			bool flag = false;
			SkipWhitespaces(reader);
			while (true)
			{
				if (isFromDocument)
				{
					if (reader.LocalName == "document" || reader.LocalName == "background")
					{
						break;
					}
				}
				else if (!(reader.LocalName != localName))
				{
					break;
				}
				flag = false;
				if (reader.NodeType == XmlNodeType.Element)
				{
					switch (reader.LocalName)
					{
					case "pPr":
					{
						IWParagraph iWParagraph3 = m_doc.LastSection.AddParagraph();
						ParseParagraphFormat(reader, iWParagraph3.ParagraphFormat);
						IsNeedToApplyParaFormat = true;
						break;
					}
					case "p":
					{
						if (isRunElementTextBody)
						{
							IWParagraph lastParagraph = m_doc.LastParagraph;
							(lastParagraph as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
							AddPostParaItems(lastParagraph);
							ParseParagraphItems(reader, lastParagraph.Items, null, null, isMappedPictureContentControl);
							m_doc.UpdateLastItemRevision(lastParagraph, lastParagraph.Items);
							if (!string.IsNullOrEmpty(lastParagraph.StyleName))
							{
								(lastParagraph as WParagraph).ApplyStyle(lastParagraph.StyleName, isDomChanges: false);
							}
							isRunElementTextBody = false;
							break;
						}
						if (IsNeedToApplyParaFormat)
						{
							IWParagraph iWParagraph = null;
							if (m_doc.LastParagraph == null)
							{
								WSection obj = m_doc.LastSection.PreviousSibling as WSection;
								int index = obj.Paragraphs.Count - 1;
								iWParagraph = obj.Paragraphs[index];
							}
							else
							{
								iWParagraph = m_doc.LastParagraph;
							}
							ParseParagraphItems(reader, iWParagraph.Items, null, null, isMappedPictureContentControl);
							m_doc.UpdateLastItemRevision(iWParagraph, iWParagraph.Items);
							IsNeedToApplyParaFormat = false;
							break;
						}
						IWParagraph iWParagraph2 = AddParagraph(entity);
						(iWParagraph2 as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
						AddPostParaItems(iWParagraph2);
						ParseParagraphItems(reader, iWParagraph2.Items, null, null, isMappedPictureContentControl);
						m_doc.UpdateLastItemRevision(iWParagraph2, iWParagraph2.Items);
						if (iWParagraph2.NextSibling != null && !(iWParagraph2.NextSibling is AlternateChunk))
						{
							UpdateNestedParaItems(iWParagraph2 as WParagraph);
						}
						if (!string.IsNullOrEmpty(iWParagraph2.StyleName))
						{
							(iWParagraph2 as WParagraph).ApplyStyle(iWParagraph2.StyleName, isDomChanges: false);
						}
						break;
					}
					case "tbl":
					{
						if (IsNeedToApplyParaFormat && m_doc.LastSection.ChildEntities.Count == 0)
						{
							m_doc.LastSection.RemoveSelf();
						}
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 11);
						IWTable iWTable = AddTable(entity);
						iWTable.TableFormat.IsAutoResized = true;
						short gridCount = m_gridCount;
						ParseTable(reader, iWTable as WTable, isAlreadyCheck: false, reader.LocalName);
						m_gridCount = gridCount;
						if (iWTable.Rows.Count == 0)
						{
							(iWTable.Owner as WTextBody).ChildEntities.RemoveAt((iWTable as WTable).Index);
						}
						if (IsNeedToMergeTables(iWTable as WTable))
						{
							(iWTable.PreviousSibling as WTable).MergeTables(iWTable as WTable);
						}
						break;
					}
					case "sectPr":
						if (IsPostParaItemsContainRenderableItem())
						{
							IWParagraph paragraph = AddParagraph(entity);
							AddPostParaItems(paragraph);
						}
						else if (m_doc.LastParagraph != null)
						{
							AddPostParaItems(m_doc.LastParagraph);
						}
						ParseSectionProperties(reader, m_doc.LastSection);
						break;
					case "bookmarkStart":
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 5);
						ParseBookmarkStart(reader, null);
						break;
					case "bookmarkEnd":
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 4);
						ParseBookmarkEnd(reader, entity);
						break;
					case "permStart":
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 21);
						ParseEditableRangeStart(reader, null);
						break;
					case "permEnd":
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 22);
						ParseEditableRangeEnd(reader, entity);
						break;
					case "comment":
						m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 6);
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 10);
						ParseComment(reader);
						break;
					case "commentRangeStart":
						ParseCommentRangeStart(reader, null);
						break;
					case "commentRangeEnd":
						ParseCommentRangeEnd(reader, null, null);
						break;
					case "moveFromRangeEnd":
					case "moveToRangeEnd":
						ParseMoveRangeEnd(reader, entity);
						moveRevision = null;
						break;
					case "AlternateContent":
						ParseRunValues(reader, null, null, isMappedPictureContentControl: false, isFromBody: true);
						break;
					case "drawing":
					{
						ParagraphItem item = ParseDrawing(reader, null, ref drawingStream, isMappedPictureContentControl);
						PostParaItemsCollection.Add(item);
						m_currentRunFormat = null;
						flag = true;
						break;
					}
					case "sdt":
						ParseBlockContentControl(reader, entity);
						break;
					case "altChunk":
					{
						m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 2);
						AlternateChunk alternateChunk = AddAlternateChunk(entity);
						AddBookmark(alternateChunk);
						ParseAlternateChunk(reader, alternateChunk);
						break;
					}
					case "br":
					{
						WParagraph wParagraph = new WParagraph(m_doc);
						ParseBreak(reader, wParagraph.Items, null);
						if (wParagraph.ChildEntities.Count > 0)
						{
							PostParaItemsCollection.Add(wParagraph.LastItem);
						}
						break;
					}
					case "footerReference":
					case "headerReference":
						ParseHeaderFooter(reader);
						break;
					default:
						if (!IsWord2003ML)
						{
							break;
						}
						switch (reader.LocalName)
						{
						case "annotation":
							switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
							{
							case "Word.Bookmark.Start":
								ParseBookmarkStart(reader, null);
								break;
							case "Word.Bookmark.End":
								ParseBookmarkEnd(reader, entity);
								break;
							case "Word.Comment.Start":
								ParseCommentRangeStart(reader, null);
								break;
							case "Word.Comment.End":
								ParseCommentRangeEnd(reader, null, null);
								break;
							}
							break;
						case "hdr":
						case "ftr":
						{
							bool isHeader = reader.LocalName == "hdr";
							string attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
							ParseHeaderFooter(m_doc.LastSection.HeadersFooters, reader, attribute, isHeader);
							break;
						}
						}
						break;
					}
					if (!flag)
					{
						reader.Read();
					}
				}
				else
				{
					reader.Read();
				}
			}
			if (IsNeedToApplyParaFormat)
			{
				if (m_doc.LastParagraph != null)
				{
					m_doc.LastParagraph.RemoveSelf();
				}
				else
				{
					WSection obj2 = m_doc.LastSection.PreviousSibling as WSection;
					int index2 = obj2.Paragraphs.Count - 1;
					obj2.Paragraphs[index2].RemoveSelf();
					m_doc.LastSection.RemoveSelf();
				}
				IsNeedToApplyParaFormat = false;
			}
		}
		else
		{
			reader.Read();
		}
	}

	private void ParseBlockContentControl(XmlReader reader, IEntity entity)
	{
		if (IsPostParaItemsContainRenderableItem())
		{
			IWParagraph paragraph = AddParagraph(entity);
			AddPostParaItems(paragraph);
		}
		if (IsNeedToApplyParaFormat)
		{
			if (m_doc.LastParagraph != null)
			{
				m_doc.LastParagraph.RemoveSelf();
			}
			else
			{
				WSection obj = m_doc.LastSection.PreviousSibling as WSection;
				int index = obj.Paragraphs.Count - 1;
				obj.Paragraphs[index].RemoveSelf();
				m_doc.LastSection.RemoveSelf();
			}
			IsNeedToApplyParaFormat = false;
		}
		IBlockContentControl blockContentControl = AddStructureDocumentTagBlock(entity);
		ParseStructureDocumentTagBlock(reader, blockContentControl as BlockContentControl);
		if (blockContentControl.Owner != null && blockContentControl.Owner.Owner != null && blockContentControl.Owner.Owner is WSection && IsSDTHasSectionBreak)
		{
			SDTContentWithSectionBreakParagraph(blockContentControl as BlockContentControl);
			IsSDTHasSectionBreak = false;
		}
	}

	private void PostProcessBlockContentControl(BlockContentControl sdTagBlock)
	{
		if (sdTagBlock.ContentControlProperties.XmlMapping != null && sdTagBlock.ContentControlProperties.XmlMapping.IsMapped && sdTagBlock.ContentControlProperties.Type == ContentControlType.Picture)
		{
			MapPictureContentControl(sdTagBlock);
		}
		else if (sdTagBlock.ContentControlProperties.XmlMapping != null)
		{
			BlockContentControls.Add(sdTagBlock);
		}
		if (IsPostParaItemsContainRenderableItem())
		{
			IWParagraph paragraph = AddParagraph(sdTagBlock);
			AddPostParaItems(paragraph);
		}
	}

	private bool IsPostParaItemsContainRenderableItem()
	{
		foreach (Entity item in PostParaItemsCollection)
		{
			if (item.EntityType != EntityType.BookmarkStart && item.EntityType != EntityType.BookmarkEnd && item.EntityType != EntityType.EditableRangeStart && item.EntityType != EntityType.EditableRangeEnd)
			{
				return true;
			}
		}
		return false;
	}

	private void UpdateNestedParaItems(WParagraph paragraph)
	{
		WParagraph wParagraph = null;
		if (paragraph.NextSibling is WParagraph)
		{
			wParagraph = paragraph.NextSibling as WParagraph;
			for (int i = 0; i < paragraph.ChildEntities.Count; i++)
			{
				Entity entity = paragraph.ChildEntities[i].Clone();
				if (entity is BookmarkStart || entity is BookmarkEnd)
				{
					paragraph.ChildEntities.Remove(entity);
				}
				wParagraph.ChildEntities.Insert(i, entity);
			}
			paragraph.ChildEntities.Clear();
			wParagraph.OwnerTextBody.ChildEntities.Add(paragraph);
		}
		else if (paragraph.NextSibling is WTable)
		{
			WTable obj = paragraph.NextSibling as WTable;
			wParagraph = obj.Rows[0].Cells[0].GetTextBodyFirstPara(isAddNewParagraph: true);
			obj.OwnerTextBody.ChildEntities.Add(paragraph);
		}
		if (wParagraph != null)
		{
			paragraph.ParagraphFormat.NestedParaFormatting(wParagraph.ParagraphFormat);
			if (wParagraph.ListFormat.CurrentListLevel == null && paragraph.ListFormat.CurrentListLevel != null)
			{
				wParagraph.ListFormat.ImportListFormat(paragraph.ListFormat);
			}
		}
	}

	internal void SDTContentWithSectionBreakParagraph(BlockContentControl sdttagblock)
	{
		WTextBody textBody = sdttagblock.TextBody;
		_ = textBody.ChildEntities.Count;
		for (int i = 0; i < textBody.ChildEntities.Count; i++)
		{
			if (textBody.ChildEntities[i] is WParagraph && (textBody.ChildEntities[i] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
			{
				WParagraph obj = textBody.ChildEntities[i] as WParagraph;
				XmlReader xmlReader = UtilityMethods.CreateReader(obj.ParagraphFormat.XmlProps["sectPr"]);
				xmlReader.MoveToElement();
				ParseSectionProperties(xmlReader, m_doc.LastSection);
				m_doc.AddSection();
				obj.ParagraphFormat.XmlProps.Remove("sectPr");
				BlockContentControl blockContentControl = sdttagblock.Clone();
				blockContentControl.TextBody.ChildEntities.Clear();
				m_doc.LastSection.Body.ChildEntities.Add(blockContentControl);
				int num = i + 1;
				while (num < textBody.ChildEntities.Count)
				{
					if (textBody.ChildEntities[num] is WParagraph && (textBody.ChildEntities[num] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
					{
						blockContentControl.TextBody.AddParagraph();
						int num2 = 0;
						while (num2 < (textBody.ChildEntities[num] as WParagraph).ChildEntities.Count)
						{
							blockContentControl.TextBody.LastParagraph.ChildEntities.Add((textBody.ChildEntities[num] as WParagraph).ChildEntities[num2]);
						}
						break;
					}
					blockContentControl.TextBody.ChildEntities.Add(textBody.ChildEntities[num]);
				}
			}
			else
			{
				if (!(textBody.ChildEntities[i] is BlockContentControl))
				{
					continue;
				}
				BlockContentControl blockContentControl2 = textBody.ChildEntities[i] as BlockContentControl;
				WTextBody textBody2 = blockContentControl2.TextBody;
				for (int j = 0; j < textBody2.ChildEntities.Count; j++)
				{
					if (!(textBody2.ChildEntities[j] is WParagraph) || !(textBody2.ChildEntities[j] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
					{
						continue;
					}
					WParagraph obj2 = textBody2.ChildEntities[j] as WParagraph;
					XmlReader xmlReader2 = UtilityMethods.CreateReader(obj2.ParagraphFormat.XmlProps["sectPr"]);
					xmlReader2.MoveToElement();
					ParseSectionProperties(xmlReader2, m_doc.LastSection);
					m_doc.AddSection();
					obj2.ParagraphFormat.XmlProps.Remove("sectPr");
					BlockContentControl blockContentControl3 = sdttagblock.Clone();
					blockContentControl3.TextBody.ChildEntities.Clear();
					m_doc.LastSection.Body.ChildEntities.Add(blockContentControl3);
					BlockContentControl blockContentControl4 = blockContentControl2.Clone();
					blockContentControl4.TextBody.ChildEntities.Clear();
					blockContentControl3.TextBody.ChildEntities.Add(blockContentControl4);
					bool flag = false;
					int num3 = j + 1;
					while (num3 < textBody2.ChildEntities.Count)
					{
						if (textBody2.ChildEntities[num3] is WParagraph && (textBody2.ChildEntities[num3] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
						{
							blockContentControl4.TextBody.AddParagraph();
							int num4 = 0;
							while (num4 < (textBody2.ChildEntities[num3] as WParagraph).ChildEntities.Count)
							{
								blockContentControl4.TextBody.LastParagraph.ChildEntities.Add((textBody2.ChildEntities[num3] as WParagraph).ChildEntities[num4]);
							}
							flag = true;
							break;
						}
						blockContentControl4.TextBody.ChildEntities.Add(textBody2.ChildEntities[num3]);
					}
					if (flag)
					{
						continue;
					}
					int num5 = i + 1;
					while (num5 < textBody.ChildEntities.Count)
					{
						if (textBody.ChildEntities[num5] is WParagraph && (textBody.ChildEntities[num5] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
						{
							blockContentControl3.TextBody.AddParagraph();
							int num6 = 0;
							while (num6 < (textBody.ChildEntities[num5] as WParagraph).ChildEntities.Count)
							{
								blockContentControl3.TextBody.LastParagraph.ChildEntities.Add((textBody.ChildEntities[num5] as WParagraph).ChildEntities[num6]);
							}
							flag = true;
							break;
						}
						blockContentControl3.TextBody.ChildEntities.Add(textBody.ChildEntities[num5]);
					}
					if (flag)
					{
						break;
					}
				}
			}
		}
	}

	private IWParagraph AddParagraph(IEntity entity)
	{
		IWParagraph iWParagraph = null;
		if (entity is HeaderFooter)
		{
			return (entity as HeaderFooter).AddParagraph();
		}
		if (entity is WFootnote)
		{
			return (entity as WFootnote).TextBody.AddParagraph();
		}
		if (entity is WComment)
		{
			return (entity as WComment).TextBody.AddParagraph();
		}
		if (entity is BlockContentControl)
		{
			return (entity as BlockContentControl).TextBody.AddParagraph();
		}
		if (entity is WTextBody)
		{
			return (entity as WTextBody).AddParagraph();
		}
		return m_doc.LastSection.AddParagraph();
	}

	private void AddPostParaItems(IWParagraph paragraph)
	{
		if (PostParaItemsCollection.Count > 0)
		{
			foreach (Entity item in PostParaItemsCollection)
			{
				paragraph.Items.Add(item);
			}
			PostParaItemsCollection.Clear();
		}
		if (m_postCommMark != null)
		{
			paragraph.Items.Add(m_postCommMark);
			m_postCommMark = null;
		}
	}

	private void AddBookmark(AlternateChunk altchunk)
	{
		if (PostParaItemsCollection.Count <= 0)
		{
			return;
		}
		foreach (Entity item in PostParaItemsCollection)
		{
			if (item.EntityType == EntityType.BookmarkStart || item.EntityType == EntityType.BookmarkEnd)
			{
				altchunk.AltChunkBookmarks.Add(item);
			}
		}
		PostParaItemsCollection.Clear();
	}

	private void ParseParagraphItems(XmlReader reader, ParagraphItemCollection paraItems, string endnode, IOfficeMathRunElement mathRunElement, bool isMappedPictureContentControl)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		if (endnode == null)
		{
			endnode = reader.LocalName;
			reader.Read();
		}
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		MemoryStream drawingStream = null;
		SkipWhitespaces(reader);
		string text = string.Empty;
		bool flag2 = false;
		while (reader.LocalName != endnode || ((reader.LocalName == "p" || reader.LocalName == "ins" || reader.LocalName == "del") && reader.NodeType == XmlNodeType.Element))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "pPr":
				{
					WParagraph wParagraph = paraItems.OwnerBase as WParagraph;
					if (paraItems.Owner is InlineContentControl)
					{
						wParagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
					}
					else if (paraItems.Owner is XmlParagraphItem)
					{
						wParagraph = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
					}
					else if (paraItems.Owner is XmlParagraphItem)
					{
						wParagraph = paraItems.Owner.Owner as WParagraph;
					}
					if (wParagraph != null && !(paraItems.OwnerBase is InlineContentControl))
					{
						ParseParagraphFormat(reader, wParagraph.ParagraphFormat);
						if ((wParagraph.StyleName == null || wParagraph.StyleName == string.Empty) && m_doc.Styles.FindByName("Normal") != null)
						{
							wParagraph.ApplyStyle("Normal", isDomChanges: false);
						}
					}
					break;
				}
				case "bdo":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!(attribute == "rtl"))
					{
						if (attribute == "ltr")
						{
							m_biDirectionalOverride = BiDirectionalOverride.LTR;
						}
					}
					else
					{
						m_biDirectionalOverride = BiDirectionalOverride.RTL;
					}
					break;
				}
				case "p":
					ParseNestedParagraph(reader, paraItems, flag2);
					flag2 = true;
					break;
				case "tbl":
					ParseTableInsideParagraph(reader, paraItems);
					break;
				case "r":
					ParseRun(reader, paraItems, null, isAlreadyChecked: false, reader.NodeType, isMappedPictureContentControl);
					m_currentRunFormat = null;
					break;
				case "br":
				case "cr":
					if (flag2)
					{
						WParagraph wParagraph2 = paraItems.OwnerBase as WParagraph;
						if (paraItems.Owner is InlineContentControl)
						{
							wParagraph2 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
						}
						else if (paraItems.Owner is XmlParagraphItem)
						{
							wParagraph2 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
						}
						paraItems = (wParagraph2.OwnerTextBody.AddParagraph() as WParagraph).Items;
					}
					ParseBreak(reader, paraItems, mathRunElement);
					break;
				case "bookmarkStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 5);
					ParseBookmarkStart(reader, paraItems);
					break;
				case "bookmarkEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 4);
					ParseBookmarkEnd(reader, paraItems);
					break;
				case "permStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 21);
					ParseEditableRangeStart(reader, paraItems);
					break;
				case "permEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 22);
					ParseEditableRangeEnd(reader, paraItems);
					break;
				case "commentRangeStart":
					ParseCommentRangeStart(reader, paraItems);
					break;
				case "commentRangeEnd":
					ParseCommentRangeEnd(reader, paraItems, null);
					break;
				case "del":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 12);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateInsDelRevision(reader, paraItems, RevisionType.Deletions, mathRunElement, isParsingRun: false);
					break;
				case "moveFromRangeStart":
					UpdateRevAuthorInformation(reader, null);
					text = reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace);
					CreateMoveRangeRevision(paraItems.Owner as WParagraph, RevisionType.MoveFrom);
					break;
				case "moveFrom":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 26);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateRevAuthorInformation(reader, null);
					if (moveRevision != null)
					{
						m_trackChangeType = RevisionType.MoveFrom;
					}
					else
					{
						m_trackChangeType = RevisionType.Deletions;
					}
					m_trackchangeStack.Push(m_trackChangeType);
					ParseParagraphItems(reader, paraItems, null, mathRunElement, isMappedPictureContentControl);
					m_trackChangeType = RevisionType.None;
					m_trackchangeStack.Pop();
					if (m_trackchangeStack.Count > 0)
					{
						m_trackChangeType = m_trackchangeStack.Peek();
					}
					break;
				case "moveToRangeStart":
					UpdateRevAuthorInformation(reader, null);
					text = reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace);
					CreateMoveRangeRevision(paraItems.Owner as WParagraph, RevisionType.MoveTo);
					break;
				case "moveTo":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 27);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateRevAuthorInformation(reader, null);
					if (moveRevision != null)
					{
						m_trackChangeType = RevisionType.MoveTo;
					}
					else
					{
						m_trackChangeType = RevisionType.Insertions;
					}
					m_trackchangeStack.Push(m_trackChangeType);
					ParseParagraphItems(reader, paraItems, null, mathRunElement, isMappedPictureContentControl);
					m_trackChangeType = RevisionType.None;
					m_trackchangeStack.Pop();
					if (m_trackchangeStack.Count > 0)
					{
						m_trackChangeType = m_trackchangeStack.Peek();
					}
					break;
				case "moveFromRangeEnd":
				case "moveToRangeEnd":
					if (reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace) == text)
					{
						moveRevision = null;
					}
					break;
				case "ins":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 24);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateInsDelRevision(reader, paraItems, RevisionType.Insertions, mathRunElement, isParsingRun: false);
					break;
				case "customXmlInsRangeStart":
					UpdateRevAuthorInformation(reader, null);
					ContentControlRevision(paraItems, RevisionType.Insertions);
					break;
				case "customXmlDelRangeStart":
					UpdateRevAuthorInformation(reader, null);
					ContentControlRevision(paraItems, RevisionType.Deletions);
					break;
				case "hyperlink":
					if (!IsWord2003ML)
					{
						ParseHyperlink(reader, paraItems);
					}
					break;
				case "fldSimple":
					flag = ParseFieldSimple(reader, paraItems);
					break;
				case "drawing":
				{
					ParagraphItem paragraphItem = ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
					paraItems.Add(paragraphItem);
					if (paragraphItem is WPicture)
					{
						(paragraphItem as WPicture).CheckTextWrappingStyle();
					}
					m_currentRunFormat = null;
					flag = true;
					break;
				}
				case "sdt":
				{
					IInlineContentControl inlineContentControl = new InlineContentControl(m_doc);
					AddItem(inlineContentControl as ParagraphItem, paraItems);
					if (paraItems.OwnerBase is WParagraph)
					{
						(paraItems.OwnerBase as WParagraph).HasSDTInlineItem = true;
					}
					ParseStructureDocumentTagInline(reader, inlineContentControl as InlineContentControl);
					break;
				}
				case "altChunk":
				{
					AlternateChunk alternateChunk = AddAlternateChunk(null);
					AddBookmark(alternateChunk);
					ParseAlternateChunk(reader, alternateChunk);
					alternateChunk.IsParagraphItem = true;
					break;
				}
				case "oMathPara":
				case "oMath":
					ParseMathMlElement(reader, paraItems);
					flag = true;
					break;
				case "pict":
				{
					MemoryStream shapeStream = ReadSingleNodeIntoStream(reader);
					ParagraphItem paragraphItem = ParseShape(reader, paraItems, drawingStream, shapeStream, null);
					if (paragraphItem is Shape && (paragraphItem as Shape).TextBody.Count > 0)
					{
						AddToParagraph(paragraphItem, paraItems);
						CheckTrackChange(paragraphItem);
					}
					if (reader.LocalName == "p" && reader.NodeType == XmlNodeType.EndElement)
					{
						flag = true;
					}
					break;
				}
				default:
				{
					string namespaceURI = reader.NamespaceURI;
					if (!string.IsNullOrEmpty(namespaceURI) && namespaceURI == (IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/math" : "http://schemas.openxmlformats.org/officeDocument/2006/math"))
					{
						m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 19);
					}
					if (!IsWord2003ML)
					{
						break;
					}
					if (reader.LocalName == "annotation")
					{
						switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
						{
						case "Word.Bookmark.Start":
							ParseBookmarkStart(reader, paraItems);
							break;
						case "Word.Bookmark.End":
							ParseBookmarkEnd(reader, paraItems);
							break;
						case "Word.Comment.Start":
							ParseCommentRangeStart(reader, paraItems);
							break;
						case "Word.Comment.End":
							ParseCommentRangeEnd(reader, paraItems, null);
							break;
						case "Word.Insertion":
							m_trackChangeType = RevisionType.Insertions;
							ParseParagraphItems(reader, paraItems, null, mathRunElement, isMappedPictureContentControl);
							m_trackChangeType = RevisionType.None;
							break;
						case "Word.Deletion":
							m_trackChangeType = RevisionType.Deletions;
							ParseParagraphItems(reader, paraItems, null, mathRunElement, isMappedPictureContentControl);
							m_trackChangeType = RevisionType.None;
							break;
						}
					}
					else if (reader.LocalName == "hlink")
					{
						ParseHyperlink(reader, paraItems);
					}
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else if (reader.LocalName == "bdo" && reader.NodeType == XmlNodeType.EndElement)
			{
				m_biDirectionalOverride = BiDirectionalOverride.None;
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseNestedParagraph(XmlReader reader, ParagraphItemCollection paraItems, bool isFirstNestedParaOccured)
	{
		WParagraph wParagraph = paraItems.OwnerBase as WParagraph;
		if (paraItems.Owner is InlineContentControl)
		{
			wParagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
			(paraItems.Owner as InlineContentControl).IsFirstNestedParaParsed = true;
		}
		else if (paraItems.Owner is XmlParagraphItem)
		{
			wParagraph = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
		}
		else if (paraItems.Owner is XmlParagraphItem)
		{
			wParagraph = paraItems.Owner.Owner as WParagraph;
		}
		if (wParagraph == null || wParagraph.OwnerTextBody == null)
		{
			return;
		}
		if (paraItems.Owner is InlineContentControl && wParagraph.Owner is WTableCell && !isFirstNestedParaOccured)
		{
			ParseParagraphItems(reader, (paraItems.Owner as InlineContentControl).ParagraphItems, null, null, isMappedPictureContentControl: false);
			m_doc.UpdateLastItemRevision(wParagraph, wParagraph.Items);
			return;
		}
		IWParagraph iWParagraph = null;
		iWParagraph = ((!(wParagraph.ChildEntities.Count == 1 && wParagraph.ChildEntities[0] is Break && isFirstNestedParaOccured)) ? wParagraph.OwnerTextBody.AddParagraph() : wParagraph);
		ParseParagraphItems(reader, iWParagraph.Items, null, null, isMappedPictureContentControl: false);
		m_doc.UpdateLastItemRevision(iWParagraph, iWParagraph.Items);
		if (iWParagraph.NextSibling != null)
		{
			WParagraph wParagraph2 = iWParagraph.NextSibling as WParagraph;
			for (int i = 0; i < iWParagraph.ChildEntities.Count; i++)
			{
				wParagraph2.ChildEntities.Insert(i, iWParagraph.ChildEntities[i].Clone());
			}
			iWParagraph.ChildEntities.Clear();
			wParagraph2.OwnerTextBody.ChildEntities.Add(iWParagraph);
			wParagraph.ParagraphFormat.NestedParaFormatting(iWParagraph.ParagraphFormat);
			if (iWParagraph.ListFormat.CurrentListLevel == null && wParagraph.ListFormat.CurrentListLevel != null)
			{
				iWParagraph.ListFormat.ImportListFormat(wParagraph.ListFormat);
			}
			iWParagraph.ParagraphFormat.NestedParaFormatting(wParagraph2.ParagraphFormat);
			if (wParagraph2.ListFormat.CurrentListLevel == null && iWParagraph.ListFormat.CurrentListLevel != null)
			{
				wParagraph2.ListFormat.ImportListFormat(iWParagraph.ListFormat);
			}
		}
	}

	private void ParseTableInsideParagraph(XmlReader reader, ParagraphItemCollection paraItems)
	{
		WParagraph wParagraph = paraItems.OwnerBase as WParagraph;
		if (paraItems.Owner is InlineContentControl)
		{
			wParagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
		}
		if (wParagraph == null || wParagraph.OwnerTextBody == null)
		{
			return;
		}
		WTable wTable = ParseNestedTable(reader, wParagraph.OwnerTextBody, reader.LocalName, isAlreadyCheck: false);
		if (wTable == null || wTable.Rows.Count <= 0)
		{
			return;
		}
		WParagraph textBodyFirstPara = wTable.Rows[0].Cells[0].GetTextBodyFirstPara(isAddNewParagraph: true);
		if (textBodyFirstPara != null)
		{
			if (paraItems.Owner is InlineContentControl)
			{
				MoveParaItemsToNestedTable(wParagraph.Items, textBodyFirstPara, isNestedInInlineContentControl: true);
			}
			else
			{
				MoveParaItemsToNestedTable(paraItems, textBodyFirstPara, isNestedInInlineContentControl: false);
			}
		}
	}

	private void MoveParaItemsToNestedTable(ParagraphItemCollection paraItems, WParagraph cellPara, bool isNestedInInlineContentControl)
	{
		int num = paraItems.Count - 1;
		paraItems.MoveParaItems(cellPara.Items, isRemoveLastInlineCC: false);
		if (isNestedInInlineContentControl)
		{
			InlineContentControl inlineContentControl = cellPara.ChildEntities[num] as InlineContentControl;
			while (num + 1 < cellPara.ChildEntities.Count)
			{
				Entity entity = cellPara.ChildEntities[num + 1].Clone();
				cellPara.ChildEntities.Remove(cellPara.ChildEntities[num + 1]);
				inlineContentControl.ParagraphItems.Add(entity);
			}
		}
	}

	private void ApplyDirectionalOverride(WCharacterFormat charFormat)
	{
		if (m_biDirectionalOverride != 0)
		{
			charFormat.BiDirectionalOverride = m_biDirectionalOverride;
		}
	}

	private void ContentControlRevision(ParagraphItemCollection paraItems, RevisionType revisionType)
	{
		if (paraItems.Count == 0)
		{
			if (emptyContentRevision == null)
			{
				emptyContentRevision = m_doc.CreateNewChildRevision(revisionType, m_revAuthorName, m_revDateTime, m_name);
				contentRevision = null;
			}
			return;
		}
		if (m_doc.HasRenderableItemBefore(paraItems.LastItem as ParagraphItem) && contentRevision == null)
		{
			Entity entity = paraItems.Owner.PreviousSibling as Entity;
			if (entity is WParagraph && (paraItems.Owner.PreviousSibling as WParagraph).BreakCharacterFormat.Revisions.Count > 0)
			{
				foreach (Revision revision in (paraItems.Owner.PreviousSibling as WParagraph).BreakCharacterFormat.Revisions)
				{
					if (revision.RevisionType == revisionType && revision.Author == m_revAuthorName)
					{
						contentRevision = revision;
						break;
					}
				}
				return;
			}
			if (entity is WTable && (entity as WTable).LastRow.RowFormat.Revisions.Count > 0)
			{
				foreach (Revision revision2 in (entity as WTable).LastRow.RowFormat.Revisions)
				{
					if (revision2.RevisionType == revisionType && revision2.Author == m_revAuthorName)
					{
						contentRevision = revision2;
						break;
					}
				}
				return;
			}
			contentRevision = m_doc.CreateNewChildRevision(revisionType, m_revAuthorName, m_revDateTime, m_name);
			return;
		}
		Entity entity2 = paraItems.LastItem;
		do
		{
			entity2 = ((!(entity2 is InlineContentControl)) ? entity2 : (((entity2 as InlineContentControl).ParagraphItems.Count > 0) ? (entity2 as InlineContentControl).ParagraphItems.LastItem : entity2));
			while (entity2 is BookmarkStart || entity2 is BookmarkEnd || entity2 is EditableRangeStart || entity2 is EditableRangeEnd)
			{
				entity2 = entity2.PreviousSibling as Entity;
			}
		}
		while (entity2 is InlineContentControl && (entity2 as InlineContentControl).ParagraphItems.Count > 0);
		if (entity2 == null || entity2.RevisionsInternal.Count <= 0)
		{
			return;
		}
		foreach (Revision item in entity2.RevisionsInternal)
		{
			if (item.RevisionType == revisionType && item.Author == m_revAuthorName)
			{
				contentRevision = item;
				break;
			}
		}
	}

	private void ParseComment(XmlReader reader)
	{
		if (m_comments == null)
		{
			m_comments = new Dictionary<string, WComment>();
		}
		WComment wComment = new WComment(m_doc);
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		wComment.Format.TagBkmk = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string attribute2 = reader.GetAttribute("author", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute2))
		{
			wComment.Format.User = attribute2;
		}
		string attribute3 = reader.GetAttribute("initials", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute3))
		{
			wComment.Format.UserInitials = attribute3;
		}
		string attribute4 = reader.GetAttribute("date", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute4))
		{
			DateTime result = default(DateTime);
			CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
			if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
			{
				cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
			}
			DateTime.TryParse(attribute4, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
			wComment.Format.DateTime = result;
		}
		if (m_comments != null && attribute != null && !m_comments.ContainsKey(attribute))
		{
			m_comments.Add(attribute, wComment);
		}
		if (!reader.IsEmptyElement)
		{
			ParseBody(reader, wComment, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
		}
	}

	private WComment Parse2003Comment(XmlReader reader)
	{
		if (m_comments == null)
		{
			m_comments = new Dictionary<string, WComment>();
		}
		WComment wComment = new WComment(m_doc);
		string attribute = reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
		wComment.Format.TagBkmk = reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
		string attribute2 = reader.GetAttribute("author", "http://schemas.microsoft.com/aml/2001/core");
		if (!string.IsNullOrEmpty(attribute2))
		{
			wComment.Format.User = attribute2;
		}
		string attribute3 = reader.GetAttribute("createdate", "http://schemas.microsoft.com/aml/2001/core");
		if (!string.IsNullOrEmpty(attribute3))
		{
			DateTime result = default(DateTime);
			CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
			if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
			{
				cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
			}
			DateTime.TryParse(attribute3, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
			wComment.Format.DateTime = result;
		}
		string attribute4 = reader.GetAttribute("initials", "http://schemas.microsoft.com/office/word/2003/wordml");
		if (!string.IsNullOrEmpty(attribute4))
		{
			wComment.Format.UserInitials = attribute4;
		}
		if (m_comments != null && attribute != null)
		{
			m_comments.Add(attribute, wComment);
		}
		ParseBody(reader, wComment, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
		return wComment;
	}

	private void ParseComments()
	{
		Part part = FindPart("word/", "comments.xml");
		if (part != null && part.DataStream != null && part.DataStream.Length != 0L)
		{
			part.DataStream.Position = 0L;
			XmlReader reader = UtilityMethods.CreateReader(part.DataStream);
			m_currentFile = "comments.xml";
			ParseBody(reader, null, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
			m_currentFile = string.Empty;
		}
	}

	private void ParseCommentRangeStart(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string attribute = reader.GetAttribute("id", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		WCommentMark wCommentMark = new WCommentMark(m_doc, attribute);
		if (paraItems != null && paraItems.OwnerBase != null)
		{
			paraItems.Add(wCommentMark);
		}
		else
		{
			m_postCommMark = wCommentMark;
		}
		bool flag = m_comments == null;
		if (!IsWord2003ML && Comments != null && attribute != null && Comments.ContainsKey(attribute))
		{
			CommentsStack.Push(Comments[attribute]);
		}
		if (paraItems == null && flag)
		{
			m_postCommMark = wCommentMark;
		}
		if (Comments != null && attribute != null && Comments.ContainsKey(attribute))
		{
			wCommentMark.Comment = Comments[attribute];
			Comments[attribute].CommentRangeStart = wCommentMark;
		}
	}

	private void ParseCommentRangeEnd(XmlReader reader, ParagraphItemCollection paraItems, IEntity ent)
	{
		string attribute = reader.GetAttribute("id", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		WCommentMark wCommentMark = new WCommentMark(m_doc, attribute, CommentMarkType.CommentEnd);
		if (paraItems != null && paraItems.OwnerBase != null)
		{
			paraItems.Add(wCommentMark);
		}
		else if (ent == null)
		{
			m_postCommMark = wCommentMark;
		}
		else
		{
			WTable ownerTable = GetOwnerTable(ent);
			bool flag = false;
			flag = ((ownerTable != null && ownerTable.LastRow != null) ? true : false);
			WParagraph wParagraph = GetOwnerParagraph(ent, flag);
			if (flag)
			{
				wParagraph = GetEndParagraph(ownerTable.LastRow);
			}
			if (wParagraph != null)
			{
				wParagraph.Items.Add(wCommentMark);
				if (ent is WTableRow)
				{
					wCommentMark.IsAfterCellMark = true;
				}
			}
			else
			{
				m_postCommMark = wCommentMark;
			}
		}
		if (m_commStack != null && m_commStack.Count > 0)
		{
			UpdateCommentsStack(attribute);
		}
		if (Comments != null && attribute != null && Comments.ContainsKey(attribute))
		{
			wCommentMark.Comment = Comments[attribute];
			Comments[attribute].CommentRangeEnd = wCommentMark;
		}
	}

	private void UpdateCommentsStack(string id)
	{
		WComment wComment = null;
		if (Comments != null && id != null && Comments.ContainsKey(id))
		{
			wComment = Comments[id];
		}
		List<WComment> list = new List<WComment>();
		if (wComment != null && wComment != m_commStack.Peek())
		{
			while (m_commStack.Count > 0)
			{
				list.Add(m_commStack.Peek());
				m_commStack.Pop();
				if (m_commStack.Count > 0 && m_commStack.Peek() == wComment)
				{
					m_commStack.Pop();
					break;
				}
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				m_commStack.Push(list[num]);
			}
		}
		else if (wComment != null)
		{
			m_commStack.Pop();
		}
	}

	private void UpdateCommentItems(ParagraphItem item)
	{
		if (CurrentComment != null)
		{
			CurrentComment.CommentedItems.InnerList.Add(item);
		}
	}

	private void ParseCommentsExtended(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (reader.NodeType != XmlNodeType.Element && (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement))
		{
			reader.Read();
		}
		SkipWhitespaces(reader);
		while (reader.LocalName == "commentEx")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				ParseCommentExtended(reader);
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseCommentExtended(XmlReader reader)
	{
		if (m_commentsEx == null)
		{
			m_commentsEx = new List<WCommentExtended>();
		}
		WCommentExtended wCommentExtended = new WCommentExtended();
		string attribute = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2012/wordml");
		wCommentExtended.ParaId = attribute;
		string attribute2 = reader.GetAttribute("paraIdParent", "http://schemas.microsoft.com/office/word/2012/wordml");
		wCommentExtended.ParentParaId = attribute2;
		string? attribute3 = reader.GetAttribute("done", "http://schemas.microsoft.com/office/word/2012/wordml");
		bool isResolved = true;
		if (attribute3 == "0")
		{
			isResolved = false;
		}
		wCommentExtended.IsResolved = isResolved;
		m_commentsEx.Add(wCommentExtended);
		m_doc.CommentsEx.Add(wCommentExtended);
	}

	private void ParseTable(XmlReader reader, WTable table, bool isAlreadyCheck, string m_localName)
	{
		if (m_localName != "tbl")
		{
			throw new XmlException("table element");
		}
		if (isAlreadyCheck)
		{
			ParseTableValue(reader, table);
		}
		else if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseTableValue(reader, table);
			}
		}
	}

	private void ParseTableValue(XmlReader reader, WTable table)
	{
		if (table == null)
		{
			throw new ArgumentException("table");
		}
		bool flag = false;
		SkipWhitespaces(reader);
		Dictionary<string, short> dictionary = new Dictionary<string, short>();
		bool flag2 = false;
		bool isTableCellWidthDefined = true;
		int num = 0;
		table.IsAllCellsHavePointWidth = true;
		table.HasOnlyParagraphs = true;
		table.HasOnlyHorizontalText = true;
		while (reader.LocalName != "tbl")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "tblPr":
				{
					bool isEmptyElement = true;
					ParseTableProperties(reader, table, ref isEmptyElement);
					if (!isEmptyElement)
					{
						flag = true;
						UpdateTableBorders(table.DocxTableFormat);
					}
					break;
				}
				case "pPr":
				{
					IWParagraph iWParagraph = null;
					iWParagraph = ((!IsNeedToApplyParaFormat) ? m_doc.LastSection.AddParagraph() : m_doc.LastParagraph);
					ParseParagraphFormat(reader, iWParagraph.ParagraphFormat);
					IsNeedToApplyParaFormat = true;
					break;
				}
				case "tblGrid":
					if (!reader.IsEmptyElement)
					{
						string localName = reader.LocalName;
						reader.Read();
						if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && (table.TableGrid.Count <= 0 || !table.TableFormat.IsAutoResized))
						{
							ParseTableGrid(reader, table, isTableGridChange: false, localName);
						}
					}
					else
					{
						table.IsTableGridCorrupted = true;
					}
					break;
				case "tr":
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 16);
					WTableRow wTableRow = table.AddRow(isCopyFormat: false, autoPopulateCells: false);
					ApplyTableProperties(wTableRow, table);
					ParseTableRow(reader, wTableRow, ref isTableCellWidthDefined, dictionary);
					m_doc.UpdateTableFormatRevision(wTableRow);
					if (wTableRow.Cells.Count > table.TableGrid.Count)
					{
						flag2 = true;
					}
					if (wTableRow.Index == 0)
					{
						num = wTableRow.Cells.Count;
					}
					else if (table.IsAllRowsHaveSameCellCount && num != wTableRow.Cells.Count)
					{
						table.IsAllRowsHaveSameCellCount = false;
					}
					break;
				}
				case "sdt":
				{
					RowContentControl sdtRow = new RowContentControl(table.Document);
					ParseStructureDocumentTagRow(reader, sdtRow, table, ref isTableCellWidthDefined, dictionary);
					break;
				}
				case "bookmarkStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 5);
					ParseBookmarkStart(reader, null);
					break;
				case "bookmarkEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 4);
					ParseBookmarkEnd(reader, table);
					break;
				case "permStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 21);
					ParseEditableRangeStart(reader, null);
					break;
				case "permEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 22);
					ParseEditableRangeEnd(reader, table);
					break;
				case "moveFromRangeEnd":
				case "moveToRangeEnd":
					ParseMoveRangeEnd(reader, table);
					moveRevision = null;
					break;
				case "commentRangeEnd":
					ParseCommentRangeEnd(reader, table.LastCell.LastParagraph.Items, null);
					break;
				default:
					if (IsWord2003ML && reader.LocalName == "annotation")
					{
						string attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
						if (attribute == "Word.Bookmark.Start")
						{
							ParseBookmarkStart(reader, null);
						}
						else if (attribute == "Word.Bookmark.End")
						{
							ParseBookmarkEnd(reader, table);
						}
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
		if (table.Rows.Count > 0 && table.Rows[0].Cells.Count > 0 && table.IsAllRowsHaveSameCellCount && table.Rows[0].Cells.Count == table.TableGrid.Count)
		{
			CheckGridSpan(table);
		}
		if (!table.IsInCell)
		{
			table.IsUpdateCellWidthByPartitioning = true;
		}
		if (table.Rows.Count > 0 && table.Rows[0].Cells.Count > 0 && (flag2 || (isTableCellWidthDefined && !table.TableFormat.IsAutoResized)))
		{
			table.UpdateTableGrid(flag2, IsNeedtoConsiderGridafter(table));
		}
		table.UpdateGridSpan();
		if (table.TableGrid.Count > 1)
		{
			UpdateTableCellWidth(table, dictionary);
		}
		if (dictionary.Count != 0)
		{
			dictionary.Clear();
			dictionary = null;
		}
		table.RemoveUnwantedHorizontalMergeCells(table);
	}

	private void CheckGridSpan(WTable table)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < table.Rows[0].Cells.Count; i++)
		{
			short gridSpan = table.Rows[0].Cells[i].GridSpan;
			if (gridSpan <= 1)
			{
				continue;
			}
			bool flag = true;
			for (int j = 1; j < table.Rows.Count; j++)
			{
				if (gridSpan != table.Rows[j].Cells[i].GridSpan)
				{
					flag = false;
					break;
				}
				if (table.Rows[j].RowFormat.BeforeWidth != 0f)
				{
					return;
				}
			}
			if (flag)
			{
				list.Add(i);
			}
		}
		if (list.Count <= 0)
		{
			return;
		}
		foreach (int item in list)
		{
			foreach (WTableRow row in table.Rows)
			{
				row.Cells[item].GridSpan = 1;
			}
		}
		foreach (WTableRow row2 in table.Rows)
		{
			m_gridCount = 0;
			foreach (WTableCell cell in row2.Cells)
			{
				UpdateCellWidth(cell, cell.GridSpan);
				m_gridCount++;
			}
		}
	}

	private bool IsNeedtoConsiderGridafter(WTable table)
	{
		bool result = true;
		if (table.Rows.Count > 0)
		{
			int count = table.Rows[0].Cells.Count;
			foreach (WTableRow row in table.Rows)
			{
				if (count == row.Cells.Count)
				{
					result = m_gridCount > row.Cells.Count;
					continue;
				}
				result = true;
				break;
			}
		}
		return result;
	}

	private void UpdateTableCellWidth(WTable table, Dictionary<string, short> cellGridSpan)
	{
		WTableColumnCollection tableGrid = table.TableGrid;
		foreach (WTableRow row in table.Rows)
		{
			if (!IsRowsFirstCellWidthZero(row.Cells[0]))
			{
				continue;
			}
			int index = row.Index;
			if (!IsCellsWidthTypesNoneOrAuto(row))
			{
				continue;
			}
			short num = 0;
			if (!row.RowFormat.IsFormattingChange && row.RowFormat.GridBefore > 0)
			{
				num = row.RowFormat.GridBefore;
			}
			foreach (WTableCell cell in row.Cells)
			{
				int index2 = cell.Index;
				string key = index + "," + index2;
				short num2 = 1;
				if (cellGridSpan.ContainsKey(key))
				{
					num2 = cellGridSpan[key];
				}
				if (num + num2 - 1 < tableGrid.Count)
				{
					cell.CellFormat.CellWidth = ((num == 0) ? tableGrid[num + num2 - 1].EndOffset : (tableGrid[num + num2 - 1].EndOffset - tableGrid[num - 1].EndOffset)) / 20f;
					if (num2 > 1)
					{
						num += (short)(num2 - 1);
					}
					cellGridSpan.Remove(key);
					num++;
				}
			}
		}
	}

	private void ParseTableRow(XmlReader reader, WTableRow tableRow, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan)
	{
		if (reader.LocalName != "tr")
		{
			throw new XmlException("table row element");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (tableRow == null)
		{
			throw new ArgumentException("table row");
		}
		bool flag = false;
		m_gridCount = 0;
		m_formatChangeGridCount = 0;
		SkipWhitespaces(reader);
		while (reader.LocalName != "tr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "trPr":
					ParseTableRowProperties(reader, tableRow);
					break;
				case "tblPrEx":
				{
					tableRow.HasTblPrEx = true;
					bool isEmptyElement = true;
					ParseTableProperties(reader, tableRow, ref isEmptyElement);
					if (isEmptyElement)
					{
						tableRow.HasTblPrEx = false;
					}
					else
					{
						flag = true;
					}
					break;
				}
				case "pPr":
				{
					IWParagraph iWParagraph = null;
					iWParagraph = ((!IsNeedToApplyParaFormat) ? m_doc.LastSection.AddParagraph() : m_doc.LastParagraph);
					ParseParagraphFormat(reader, iWParagraph.ParagraphFormat);
					IsNeedToApplyParaFormat = true;
					break;
				}
				case "sdt":
				{
					CellContentControl sdtCell = new CellContentControl(tableRow.Document);
					ParseStructureDocumentTagCell(reader, sdtCell, tableRow, ref isTableCellWidthDefined, cellGridSpan);
					break;
				}
				case "altChunk":
				{
					AlternateChunk alternateChunk = new AlternateChunk(m_doc);
					AddBookmark(alternateChunk);
					ParseAlternateChunk(reader, alternateChunk);
					AltChunkCollection.Add(alternateChunk);
					break;
				}
				case "tc":
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 10);
					WTableCell wTableCell = tableRow.AddCell(isCopyFormat: false);
					if (m_altChunkCollection != null && m_altChunkCollection.Count != 0)
					{
						AddAltChunk(wTableCell);
					}
					ParseTableCell(reader, wTableCell, cellGridSpan);
					if (tableRow.OwnerTable != null && tableRow.OwnerTable.IsAllCellsHavePointWidth && wTableCell.PreferredWidth.WidthType != FtsWidth.Point)
					{
						tableRow.OwnerTable.IsAllCellsHavePointWidth = false;
					}
					if (tableRow.OwnerTable != null && wTableCell.OwnerRow.OwnerTable.HasOnlyParagraphs && ((wTableCell.Tables != null && wTableCell.Tables.Count > 0) || wTableCell.ContentControl != null))
					{
						wTableCell.OwnerRow.OwnerTable.HasOnlyParagraphs = false;
					}
					if (tableRow.OwnerTable != null && wTableCell.OwnerRow.OwnerTable.HasOnlyHorizontalText && (wTableCell.CellFormat.TextDirection == TextDirection.Vertical || wTableCell.CellFormat.TextDirection == TextDirection.VerticalBottomToTop || wTableCell.CellFormat.TextDirection == TextDirection.VerticalTopToBottom || wTableCell.CellFormat.TextDirection == TextDirection.VerticalFarEast))
					{
						wTableCell.OwnerRow.OwnerTable.HasOnlyHorizontalText = false;
					}
					if (isTableCellWidthDefined && ((wTableCell.PreferredWidth.WidthType != FtsWidth.Point && wTableCell.PreferredWidth.WidthType != FtsWidth.Percentage) || (wTableCell.GridSpan > 1 && (wTableCell.OwnerRow.OwnerTable.TableFormat.IsAutoResized || wTableCell.OwnerRow.OwnerTable.PreferredTableWidth.WidthType != 0))))
					{
						isTableCellWidthDefined = false;
					}
					wTableCell.SetHasPreferredWidth();
					break;
				}
				case "bookmarkStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 5);
					ParseBookmarkStart(reader, null);
					break;
				case "bookmarkEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 4);
					ParseBookmarkEnd(reader, tableRow);
					break;
				case "permStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 21);
					ParseEditableRangeStart(reader, null);
					break;
				case "permEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 22);
					ParseEditableRangeEnd(reader, tableRow);
					break;
				case "moveFromRangeEnd":
				case "moveToRangeEnd":
					ParseMoveRangeEnd(reader, tableRow);
					moveRevision = null;
					break;
				case "commentRangeStart":
					ParseCommentRangeStart(reader, null);
					break;
				case "commentRangeEnd":
					ParseCommentRangeEnd(reader, null, tableRow);
					break;
				default:
					if (IsWord2003ML && reader.LocalName == "annotation")
					{
						string attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
						if (attribute == "Word.Bookmark.Start")
						{
							ParseBookmarkStart(reader, null);
						}
						else if (attribute == "Word.Bookmark.End")
						{
							ParseBookmarkEnd(reader, tableRow);
						}
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		if (reader.LocalName == "tr" && m_altChunkCollection != null && m_altChunkCollection.Count != 0)
		{
			WTableCell tableCell = tableRow.AddCell(isCopyFormat: false);
			AddAltChunk(tableCell);
		}
	}

	private void AddAltChunk(WTableCell tableCell)
	{
		foreach (AlternateChunk item2 in AltChunkCollection)
		{
			AlternateChunk item = tableCell.AddAltChunk(item2);
			if (m_doc.LastSection != null)
			{
				m_doc.LastSection.Body.AlternateChunkCollection.Add(item);
			}
		}
		AltChunkCollection.Clear();
	}

	private void ParseStructureDocumentTagCell(XmlReader reader, CellContentControl sdtCell, WTableRow tableRow, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 3);
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sdtPr":
					ParseSDTProperties(reader, sdtCell.ContentControlProperties);
					break;
				case "sdtContent":
					ParseSDTCellContent(reader, sdtCell, tableRow, ref isTableCellWidthDefined, cellGridSpan);
					break;
				case "sdtEndPr":
					ParseSDTEndCharacterFormat(reader, sdtCell.BreakCharacterFormat);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTCellContent(XmlReader reader, CellContentControl sdtCell, WTableRow tableRow, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		string localName = reader.LocalName;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName3 = reader.LocalName;
				if (!(localName3 == "tc"))
				{
					if (localName3 == "sdt")
					{
						CellContentControl sdtCell2 = new CellContentControl(m_doc);
						ParseStructureDocumentTagCell(reader, sdtCell2, tableRow, ref isTableCellWidthDefined, cellGridSpan);
					}
				}
				else
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 10);
					WTableCell wTableCell = tableRow.AddCell(isCopyFormat: false);
					if (m_altChunkCollection != null && m_altChunkCollection.Count != 0)
					{
						AddAltChunk(wTableCell);
					}
					ParseTableCell(reader, wTableCell, cellGridSpan);
					wTableCell.ContentControl = sdtCell;
					if (isTableCellWidthDefined && ((wTableCell.PreferredWidth.WidthType != FtsWidth.Point && wTableCell.PreferredWidth.WidthType != FtsWidth.Percentage) || wTableCell.GridSpan > 1))
					{
						isTableCellWidthDefined = false;
					}
					if (sdtCell.ContentControlProperties.XmlMapping != null)
					{
						CellContentControls.Add(wTableCell);
					}
					wTableCell.SetHasPreferredWidth();
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseStructureDocumentTagRow(XmlReader reader, RowContentControl sdtRow, WTable table, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 4);
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		bool isSDTcontentFirst = true;
		while (reader.LocalName != localName2)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sdtPr":
					ParseSDTProperties(reader, sdtRow.ContentControlProperties);
					break;
				case "sdtContent":
				{
					MemoryStream stream = ReadSingleNodeIntoStream(reader);
					ParseSDTRowContent(stream, sdtRow, table, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan);
					flag = true;
					if (sdtRow.ContentControlProperties.XmlMapping == null || !sdtRow.ContentControlProperties.XmlMapping.IsMapped || sdtRow.ContentControlProperties.Type != ContentControlType.RepeatingSection)
					{
						break;
					}
					PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("customXml/");
					if (!(partContainer.Name == "customXml/"))
					{
						break;
					}
					int itemsCount = 0;
					string tempPath = string.Empty;
					string parentOfTempPath = string.Empty;
					foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
					{
						string key = xmlPart.Key;
						if (!key.Contains("Props") || partContainer.XmlParts[xmlPart.Key].DataStream.Length <= 0)
						{
							continue;
						}
						Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPart.Key].DataStream);
						System.Xml.Linq.XDocument xDocument = new System.Xml.Linq.XDocument();
						using (XmlReader reader2 = XmlReader.Create(input))
						{
							xDocument = System.Xml.Linq.XDocument.Load(reader2, LoadOptions.None);
						}
						XElement root = xDocument.Root;
						if (root == null)
						{
							continue;
						}
						foreach (System.Xml.Linq.XAttribute item in root.Attributes())
						{
							if (item.Name.ToString().Contains("itemID") && item.Value.Equals(sdtRow.ContentControlProperties.XmlMapping.StoreItemID))
							{
								GetXMLNodesForRepeatSection(ref tempPath, ref parentOfTempPath, ref itemsCount, partContainer, sdtRow, key);
								if (itemsCount > 0)
								{
									break;
								}
							}
						}
						if (itemsCount > 0)
						{
							break;
						}
					}
					if (itemsCount == 0)
					{
						foreach (KeyValuePair<string, Part> xmlPart2 in partContainer.XmlParts)
						{
							GetXMLNodesForRepeatSection(ref tempPath, ref parentOfTempPath, ref itemsCount, partContainer, sdtRow, xmlPart2.Key);
						}
					}
					UpdateXPathForRepeatSection(itemsCount, table, stream, 2, tempPath, parentOfTempPath, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan, sdtRow);
					break;
				}
				case "sdtEndPr":
					ParseSDTEndCharacterFormat(reader, sdtRow.BreakCharacterFormat);
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void UpdateXPathForRepeatSection(int itemsCount, WTable table, MemoryStream stream, int sdtRowIndex, string tempPath, string parentOfTempPath, ref bool isSDTcontentFirst, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan, RowContentControl sdtRow)
	{
		while (itemsCount > 1)
		{
			List<BlockContentControl> list = new List<BlockContentControl>();
			List<InlineContentControl> list2 = new List<InlineContentControl>();
			List<WTableCell> list3 = new List<WTableCell>();
			foreach (BlockContentControl blockContentControl in BlockContentControls)
			{
				list.Add(blockContentControl);
			}
			foreach (WTableCell cellContentControl in CellContentControls)
			{
				list3.Add(cellContentControl);
			}
			foreach (InlineContentControl inlineContentControl in InlineContentControls)
			{
				list2.Add(inlineContentControl);
			}
			BlockContentControls.Clear();
			InlineContentControls.Clear();
			CellContentControls.Clear();
			stream.Position = 0L;
			RowContentControl rowContentControl = new RowContentControl(table.Document);
			rowContentControl.ContentControlProperties = sdtRow.ContentControlProperties.Clone();
			ParseSDTRowContent(stream, rowContentControl, table, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan);
			itemsCount--;
			foreach (BlockContentControl blockContentControl2 in BlockContentControls)
			{
				if (blockContentControl2.ContentControlProperties.XmlMapping != null)
				{
					blockContentControl2.ContentControlProperties.XmlMapping.XPath = GetNewpath(blockContentControl2.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
				}
			}
			foreach (WTableCell cellContentControl2 in CellContentControls)
			{
				if (cellContentControl2.ContentControl != null && cellContentControl2.ContentControl.ContentControlProperties.XmlMapping != null)
				{
					cellContentControl2.ContentControl.ContentControlProperties.XmlMapping.XPath = GetNewpath(cellContentControl2.ContentControl.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
				}
			}
			foreach (InlineContentControl inlineContentControl2 in InlineContentControls)
			{
				if (inlineContentControl2.ContentControlProperties.XmlMapping != null)
				{
					inlineContentControl2.ContentControlProperties.XmlMapping.XPath = GetNewpath(inlineContentControl2.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
				}
			}
			sdtRowIndex++;
			foreach (BlockContentControl item in list)
			{
				BlockContentControls.Add(item);
			}
			foreach (WTableCell item2 in list3)
			{
				CellContentControls.Add(item2);
			}
			foreach (InlineContentControl item3 in list2)
			{
				InlineContentControls.Add(item3);
			}
		}
	}

	private string GetNewpath(string newPath, string tempPath, string parentOfTempPath, int sdtRowIndex)
	{
		List<string> listPath = GetListPath(newPath);
		for (int i = 0; i < listPath.Count; i++)
		{
			string text = listPath[i];
			if ((i == 0 && text.Contains(tempPath)) || (text.Contains(tempPath) && parentOfTempPath == listPath[i - 1]))
			{
				if (text.Contains(":"))
				{
					text = text.Substring(text.IndexOf(":") + 1);
				}
				string oldValue = text.Substring(tempPath.Length);
				oldValue = text.Replace(oldValue, "[" + sdtRowIndex + "]");
				if (parentOfTempPath != string.Empty)
				{
					string text2 = newPath.Substring(0, newPath.IndexOf(parentOfTempPath));
					string text3 = newPath.Substring(newPath.IndexOf(parentOfTempPath));
					newPath = text2 + text3.Replace(text, oldValue);
				}
				else
				{
					newPath = newPath.Replace(text, oldValue);
				}
				return newPath;
			}
		}
		return newPath;
	}

	private void GetXMLNodesForRepeatSection(ref string tempPath, ref string parentOfTempPath, ref int itemsCount, PartContainer partContainer, RowContentControl sdtRow, string key)
	{
		IEnumerable<System.Xml.Linq.XNode> enumerable = GetLinqXmlElement(key, partContainer).Nodes();
		bool isDocProperty = false;
		List<string> listPath = GetListPath(sdtRow.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
		System.Xml.Linq.XNode xNode = null;
		int num = 0;
		int num2 = 0;
		int result = 0;
		string attributeName = string.Empty;
		string attributeValue = string.Empty;
		for (int i = 0; i < listPath.Count; i++)
		{
			string path = listPath[num];
			if (num > 0)
			{
				parentOfTempPath = ((i > 0) ? listPath[i - 1] : string.Empty);
				int startIndex = 0;
				int endIndex = 0;
				tempPath = GetPathIndex(path, ref startIndex, ref endIndex);
				if ((startIndex != -1 && endIndex != -1) || (startIndex == -1 && endIndex == -1))
				{
					if (startIndex == -1 || endIndex == -1)
					{
						result = 1;
						if (itemsCount != 0)
						{
							itemsCount = 0;
						}
						{
							foreach (System.Xml.Linq.XNode item in enumerable)
							{
								if (((item is XElement) ? ((XElement)item).Name.LocalName.ToString() : string.Empty) == tempPath)
								{
									itemsCount++;
								}
							}
							break;
						}
					}
					int num3 = endIndex - (startIndex + 1);
					startIndex++;
					if (startIndex + num3 <= endIndex && !int.TryParse(tempPath.Substring(startIndex, num3), NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
					{
						string text = tempPath.Substring(startIndex, num3);
						if (text.Contains("="))
						{
							attributeName = (text.Contains("@") ? text.Substring(text.IndexOf("@") + 1, text.IndexOf("=") - 1) : text.Substring(0, text.IndexOf("=")));
							attributeValue = text.Substring(text.IndexOf("=") + 1);
							attributeValue = attributeValue.Trim('\'');
						}
					}
					tempPath = tempPath.Substring(0, startIndex - 1);
					num2 = 0;
					xNode = GetCurrentNode(enumerable, xNode, ref num2, result, tempPath, parentOfTempPath, attributeName, attributeValue);
					if (xNode != null)
					{
						enumerable = ((XElement)xNode).Elements();
					}
				}
			}
			num++;
		}
	}

	private void ParseSDTRowContent(MemoryStream stream, RowContentControl sdtRow, WTable table, ref bool isSDTcontentFirst, ref bool isTableCellWidthDefined, Dictionary<string, short> cellGridSpan)
	{
		stream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		string localName = xmlReader.LocalName;
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName2 = xmlReader.LocalName;
		xmlReader.Read();
		if (localName2 == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != localName)
		{
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				string localName3 = xmlReader.LocalName;
				if (!(localName3 == "tr"))
				{
					if (localName3 == "sdt")
					{
						RowContentControl sdtRow2 = new RowContentControl(m_doc);
						ParseStructureDocumentTagRow(xmlReader, sdtRow2, table, ref isTableCellWidthDefined, cellGridSpan);
					}
				}
				else
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 16);
					WTableRow wTableRow = table.AddRow(isCopyFormat: false, autoPopulateCells: false);
					ApplyTableProperties(wTableRow, table);
					ParseTableRow(xmlReader, wTableRow, ref isTableCellWidthDefined, cellGridSpan);
					m_doc.UpdateTableFormatRevision(wTableRow);
					if (isSDTcontentFirst)
					{
						wTableRow.ContentControl = sdtRow;
						isSDTcontentFirst = false;
					}
				}
				xmlReader.Read();
			}
			else
			{
				xmlReader.Read();
			}
			SkipWhitespaces(xmlReader);
		}
	}

	private void ParseTableCell(XmlReader reader, WTableCell tableCell, Dictionary<string, short> cellGridSpan)
	{
		if (reader.LocalName != "tc")
		{
			throw new XmlException("table cell element");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (tableCell == null)
		{
			throw new ArgumentException("table cell");
		}
		bool flag = false;
		SkipWhitespaces(reader);
		UpdateCellWidth(tableCell, 1);
		while (reader.LocalName != "tc")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "tcPr":
					if (reader.IsEmptyElement)
					{
						break;
					}
					localName = reader.LocalName;
					reader.Read();
					if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
					{
						tableCell.CellFormat.Borders.IsDefault = false;
						m_gridSpan = 1;
						ParseCellProperties(reader, tableCell, cellGridSpan, localName);
						UpdateCellWidth(tableCell, m_gridSpan);
						if (m_gridSpan > 1)
						{
							m_gridCount += (short)(m_gridSpan - 1);
							m_gridSpan = 1;
						}
					}
					break;
				case "pPr":
				{
					IWParagraph iWParagraph = null;
					iWParagraph = ((!IsNeedToApplyParaFormat) ? m_doc.LastSection.AddParagraph() : m_doc.LastParagraph);
					ParseParagraphFormat(reader, iWParagraph.ParagraphFormat);
					IsNeedToApplyParaFormat = true;
					break;
				}
				case "p":
				{
					IWParagraph iWParagraph2 = null;
					if (IsNeedToApplyParaFormat)
					{
						if (m_doc.LastParagraph != null)
						{
							iWParagraph2 = tableCell.AddPrevParagraph();
						}
						IsNeedToApplyParaFormat = false;
					}
					else
					{
						iWParagraph2 = tableCell.AddParagraph();
					}
					AddPostParaItems(iWParagraph2);
					ParseParagraphItems(reader, iWParagraph2.Items, null, null, isMappedPictureContentControl: false);
					m_doc.UpdateLastItemRevision(iWParagraph2, iWParagraph2.Items);
					if (!string.IsNullOrEmpty(iWParagraph2.StyleName))
					{
						(iWParagraph2 as WParagraph).ApplyStyle(iWParagraph2.StyleName, isDomChanges: false);
					}
					break;
				}
				case "tbl":
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 11);
					WTable wTable = tableCell.AddTable() as WTable;
					wTable.TableFormat.IsAutoResized = true;
					short gridCount = m_gridCount;
					ParseTable(reader, wTable, isAlreadyCheck: false, reader.LocalName);
					m_gridCount = gridCount;
					if (wTable.Rows.Count == 0)
					{
						(wTable.Owner as WTextBody).ChildEntities.RemoveAt(wTable.Index);
					}
					break;
				}
				case "bookmarkStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 5);
					ParseBookmarkStart(reader, null);
					break;
				case "bookmarkEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 4);
					ParseBookmarkEnd(reader, tableCell);
					break;
				case "permStart":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 21);
					ParseEditableRangeStart(reader, null);
					break;
				case "permEnd":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 22);
					ParseEditableRangeEnd(reader, tableCell);
					break;
				case "moveFromRangeEnd":
				case "moveToRangeEnd":
					ParseMoveRangeEnd(reader, tableCell);
					moveRevision = null;
					break;
				case "altChunk":
				{
					AlternateChunk alternateChunk = AddAlternateChunk(tableCell);
					AddBookmark(alternateChunk);
					ParseAlternateChunk(reader, alternateChunk);
					break;
				}
				case "sdt":
				{
					IBlockContentControl blockContentControl = AddStructureDocumentTagBlock(tableCell);
					ParseStructureDocumentTagBlock(reader, blockContentControl as BlockContentControl);
					break;
				}
				case "commentRangeStart":
					ParseCommentRangeStart(reader, null);
					break;
				case "commentRangeEnd":
					ParseCommentRangeEnd(reader, null, tableCell);
					break;
				default:
					if (IsWord2003ML && reader.LocalName == "annotation")
					{
						string attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
						if (attribute == "Word.Bookmark.Start")
						{
							ParseBookmarkStart(reader, null);
						}
						else if (attribute == "Word.Bookmark.End")
						{
							ParseBookmarkEnd(reader, tableCell);
						}
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		m_gridCount++;
	}

	private void ParseCellProperties(XmlReader reader, WTableCell tableCell, Dictionary<string, short> cellGridSpan, string localName)
	{
		if (localName != "tcPr")
		{
			throw new XmlException("table cell properties element");
		}
		bool flag = false;
		SkipWhitespaces(reader);
		CellFormat cellFormat = tableCell.CellFormat;
		while (reader.LocalName != "tcPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "noWrap":
					cellFormat.TextWrap = !GetBooleanValue(reader);
					break;
				case "tcFitText":
					cellFormat.FitText = GetBooleanValue(reader);
					break;
				case "hideMark":
					cellFormat.HideMark = GetBooleanValue(reader);
					break;
				case "tcW":
					ParseCellWidth(reader, tableCell);
					break;
				case "textDirection":
					ParseCellDirection(reader, cellFormat);
					break;
				case "textFlow":
					if (IsWord2003ML)
					{
						Parse2003CellDirection(reader, cellFormat);
					}
					break;
				case "vAlign":
					cellFormat.VerticalAlignment = ParseCellVerticalAlignment(reader);
					break;
				case "vmerge":
				case "vMerge":
					ParseCellVerticalMerge(reader, cellFormat);
					break;
				case "hmerge":
				case "hMerge":
					ParseCellHorizontalMerge(reader, cellFormat);
					tableCell.OwnerRow.OwnerTable.HasHorizontalMergeCells = true;
					break;
				case "tcMar":
					cellFormat.SamePaddingsAsTable = false;
					ParseTableMargins(reader, tableCell);
					break;
				case "tcBorders":
					ParseBorders(reader, tableCell, null);
					break;
				case "shd":
					ParseCellShading(reader, tableCell);
					break;
				case "gridSpan":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (string.IsNullOrEmpty(attribute2))
					{
						break;
					}
					float result2 = 0f;
					float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
					if (!(result2 > 0f))
					{
						break;
					}
					if (!IsCellChangeFormat)
					{
						m_gridSpan = (short)result2;
						if (result2 > 1f && IsRowsFirstCellWidthZero(tableCell) && IsCellsWidthTypesNoneOrAuto(tableCell.OwnerRow))
						{
							string key = tableCell.OwnerRow.Index + "," + tableCell.Index;
							cellGridSpan.Add(key, (short)result2);
						}
					}
					else
					{
						tableCell.GridSpan = (short)result2;
					}
					break;
				}
				case "tcPrChange":
					IsCellChangeFormat = true;
					if (reader.AttributeCount > 0)
					{
						string attribute = reader.GetAttribute("author", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute))
						{
							tableCell.CellFormat.FormatChangeAuthorName = attribute;
						}
						attribute = reader.GetAttribute("date", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute))
						{
							DateTime result = default(DateTime);
							CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
							if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
							{
								cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
							}
							DateTime.TryParse(attribute, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
							tableCell.CellFormat.FormatChangeDateTime = result;
						}
					}
					ParseChangeCellFormat(reader, tableCell, cellGridSpan);
					IsCellChangeFormat = false;
					m_doc.UpdateCellFormatRevision(tableCell);
					break;
				default:
					if (!IsWord2003ML)
					{
						cellFormat.XmlProps.Add(ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "cnfStyle":
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private bool IsRowsFirstCellWidthZero(WTableCell cell)
	{
		WTableCell wTableCell = cell.OwnerRow.Cells[0];
		if (wTableCell.PreferredWidth.WidthType < FtsWidth.Percentage && wTableCell.PreferredWidth.Width == 0f)
		{
			return true;
		}
		return false;
	}

	private bool IsCellsWidthTypesNoneOrAuto(WTableRow row)
	{
		foreach (WTableCell cell in row.Cells)
		{
			if (cell.PreferredWidth.WidthType >= FtsWidth.Percentage || cell.PreferredWidth.Width != 0f)
			{
				return false;
			}
		}
		return true;
	}

	private void ParseChangeCellFormat(XmlReader reader, WTableCell tableCell, Dictionary<string, short> cellGridSpan)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				return;
			}
			tableCell.CellFormat.IsFormattingChange = true;
			tableCell.CellFormat.IsChangedFormat = true;
			SkipWhitespaces(reader);
			if (reader.LocalName == "tcPrChange" && reader.NodeType == XmlNodeType.EndElement)
			{
				return;
			}
			bool flag = false;
			while (reader.LocalName != "tcPrChange")
			{
				flag = false;
				if (reader.NodeType == XmlNodeType.Element)
				{
					if (reader.LocalName == "tcPr")
					{
						if (!reader.IsEmptyElement)
						{
							localName = reader.LocalName;
							reader.Read();
							if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
							{
								ParseCellProperties(reader, tableCell, cellGridSpan, localName);
							}
						}
					}
					else
					{
						reader.Read();
						flag = true;
					}
					if (!flag)
					{
						reader.Read();
					}
				}
				else
				{
					reader.Read();
				}
				SkipWhitespaces(reader);
			}
			short num = 1;
			if (tableCell.CellFormat.OldPropertiesHash.ContainsKey(17))
			{
				num = (short)tableCell.CellFormat.OldPropertiesHash[17];
			}
			UpdateFormatChangeCellWidth(tableCell, num);
			if (num > 1)
			{
				m_formatChangeGridCount += (short)(num - 1);
			}
		}
		tableCell.CellFormat.IsFormattingChange = false;
		m_formatChangeGridCount++;
	}

	private void ParseCellShading(XmlReader reader, WTableCell cell)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (IsWord2003ML)
		{
			cell.CellFormat.TextureStyle = Parse2003Texture(attribute);
		}
		else
		{
			cell.CellFormat.TextureStyle = ParseTexture(attribute);
		}
		string attribute2 = reader.GetAttribute("fill", IsStrict ? m_strictNameSpace : m_nameSpace);
		Color backColor = Color.Empty;
		if (attribute2 != "auto")
		{
			backColor = GetColorValue(attribute2);
		}
		cell.CellFormat.BackColor = backColor;
		string attribute3 = reader.GetAttribute("color", IsStrict ? m_strictNameSpace : m_nameSpace);
		Color foreColor = ((!(attribute3 == "auto")) ? GetColorValue(attribute3) : Color.Empty);
		cell.CellFormat.ForeColor = foreColor;
	}

	private void ParseCellVerticalMerge(XmlReader reader, CellFormat cellFormat)
	{
		if (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace) == "restart")
		{
			cellFormat.VerticalMerge = CellMerge.Start;
		}
		else
		{
			cellFormat.VerticalMerge = CellMerge.Continue;
		}
	}

	private void ParseCellHorizontalMerge(XmlReader reader, CellFormat cellFormat)
	{
		if (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace) == "restart")
		{
			cellFormat.HorizontalMerge = CellMerge.Start;
		}
		else
		{
			cellFormat.HorizontalMerge = CellMerge.Continue;
		}
	}

	private VerticalAlignment ParseCellVerticalAlignment(XmlReader reader)
	{
		VerticalAlignment result = VerticalAlignment.Top;
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "top":
				result = VerticalAlignment.Top;
				break;
			case "bottom":
				result = VerticalAlignment.Bottom;
				break;
			case "center":
				result = VerticalAlignment.Middle;
				break;
			}
		}
		return result;
	}

	private void Parse2003CellDirection(XmlReader reader, CellFormat cellFormat)
	{
		switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml"))
		{
		case "tb-rl":
			cellFormat.TextDirection = TextDirection.VerticalTopToBottom;
			break;
		case "bt-lr":
			cellFormat.TextDirection = TextDirection.VerticalBottomToTop;
			break;
		case "lr-tb-v":
			cellFormat.TextDirection = TextDirection.HorizontalFarEast;
			break;
		case "tb-rl-v":
			cellFormat.TextDirection = TextDirection.VerticalFarEast;
			break;
		case "tb-lr-v":
			cellFormat.TextDirection = TextDirection.Vertical;
			break;
		default:
			cellFormat.TextDirection = TextDirection.Horizontal;
			break;
		}
	}

	private void ParseCellDirection(XmlReader reader, CellFormat cellFormat)
	{
		switch (reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
		{
		case "tbRl":
			cellFormat.TextDirection = TextDirection.VerticalTopToBottom;
			break;
		case "btLr":
			cellFormat.TextDirection = TextDirection.VerticalBottomToTop;
			break;
		case "lrTbV":
			cellFormat.TextDirection = TextDirection.HorizontalFarEast;
			break;
		case "tbRlV":
			cellFormat.TextDirection = TextDirection.VerticalFarEast;
			break;
		case "tbLrV":
			cellFormat.TextDirection = TextDirection.Vertical;
			break;
		default:
			cellFormat.TextDirection = TextDirection.Horizontal;
			break;
		}
	}

	private void ParseCellWidth(XmlReader reader, WTableCell cell)
	{
		string attribute = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == null)
		{
			return;
		}
		CellFormat cellFormat = cell.CellFormat;
		if (attribute == "auto")
		{
			cellFormat.PreferredWidth.WidthType = FtsWidth.Auto;
			if (!IsCellChangeFormat)
			{
				UpdateCellWidth(cell);
			}
			return;
		}
		string attribute2 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == "pct")
		{
			cellFormat.PreferredWidth.WidthType = FtsWidth.Percentage;
			if (attribute2.EndsWith("%"))
			{
				cellFormat.PreferredWidth.Width = (float)GetPercentage(attribute2);
			}
			else
			{
				cellFormat.PreferredWidth.Width = (float)ParseIntegerValue(attribute2) / 50f;
			}
		}
		else if (attribute == "dxa")
		{
			cellFormat.PreferredWidth.WidthType = FtsWidth.Point;
			if (IsStrict)
			{
				cellFormat.PreferredWidth.Width = ParseFloatValue(attribute2);
			}
			else
			{
				cellFormat.PreferredWidth.Width = (float)ParseIntegerValue(attribute2) / 20f;
			}
		}
	}

	private void UpdateCellWidth(WTableCell cell)
	{
		if (cell.OwnerRow == null || cell.OwnerRow.OwnerTable == null)
		{
			return;
		}
		WTableColumnCollection tableGrid = cell.OwnerRow.OwnerTable.TableGrid;
		float num = 0f;
		if (tableGrid == null || tableGrid.Count == 0)
		{
			float width = cell.OwnerRow.OwnerTable.Width;
			if (width != 0f)
			{
				num = width / (float)cell.OwnerRow.Cells.Count;
			}
		}
		else if (m_gridCount < tableGrid.Count)
		{
			num = ((m_gridCount == 0) ? tableGrid[m_gridCount].EndOffset : (tableGrid[m_gridCount].EndOffset - tableGrid[m_gridCount - 1].EndOffset));
		}
		cell.CellFormat.CellWidth = num / 20f;
	}

	private void UpdateCellWidth(WTableCell cell, short gridSpan)
	{
		cell.GridColumnStartIndex = m_gridCount;
		cell.GridSpan = gridSpan;
		if (cell.OwnerRow != null && cell.OwnerRow.OwnerTable != null && cell.OwnerRow.OwnerTable.TableGrid != null && cell.OwnerRow.OwnerTable.TableGrid.Count != 0)
		{
			WTableColumnCollection tableGrid = cell.OwnerRow.OwnerTable.TableGrid;
			float num = 0f;
			if (m_gridCount + gridSpan - 1 < tableGrid.Count)
			{
				num = ((m_gridCount == 0) ? tableGrid[m_gridCount + gridSpan - 1].EndOffset : (tableGrid[m_gridCount + gridSpan - 1].EndOffset - tableGrid[m_gridCount - 1].EndOffset));
			}
			cell.CellFormat.CellWidth = num / 20f;
		}
	}

	private void UpdateFormatChangeCellWidth(WTableCell cell, short gridSpan)
	{
		if (cell.OwnerRow != null && cell.OwnerRow.OwnerTable != null && cell.OwnerRow.OwnerTable.TrackTableGrid != null && cell.OwnerRow.OwnerTable.TrackTableGrid.Count != 0)
		{
			WTableColumnCollection trackTableGrid = cell.OwnerRow.OwnerTable.TrackTableGrid;
			float num = 0f;
			if (m_formatChangeGridCount + gridSpan - 1 < trackTableGrid.Count)
			{
				num = ((m_formatChangeGridCount == 0) ? trackTableGrid[m_formatChangeGridCount + gridSpan - 1].EndOffset : (trackTableGrid[m_formatChangeGridCount + gridSpan - 1].EndOffset - trackTableGrid[m_formatChangeGridCount - 1].EndOffset));
			}
			cell.CellFormat.CellWidth = num / 20f;
		}
	}

	private void ParseTableRowProperties(XmlReader reader, WTableRow tableRow)
	{
		if (reader.LocalName != "trPr")
		{
			throw new XmlException("table row element");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		RowFormat rowFormat = GetRowFormat(tableRow);
		while (reader.LocalName != "trPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "trHeight":
					ParseRowHeight(reader, tableRow);
					break;
				case "tblCellSpacing":
				{
					float num = 0f;
					string attribute3 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute3))
					{
						num = GetFloatValue(attribute3, reader.LocalName);
					}
					string attribute4 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (num != float.MaxValue && (string.IsNullOrEmpty(attribute4) || !(attribute4 == "nil")))
					{
						rowFormat.CellSpacing = num;
					}
					break;
				}
				case "tblHeader":
					tableRow.IsHeader = GetBooleanValue(reader);
					break;
				case "trPrChange":
					IsRowChangeFormat = true;
					UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Formatting);
					ParseChangeRowFormat(reader, tableRow);
					IsRowChangeFormat = false;
					m_doc.UpdateRowFormatRevision(tableRow.RowFormat);
					break;
				case "del":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 12);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Deletions);
					tableRow.IsDeleteRevision = true;
					m_doc.TableRowRevision(RevisionType.Deletions, tableRow, null);
					break;
				case "ins":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 24);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Insertions);
					tableRow.IsInsertRevision = true;
					m_doc.TableRowRevision(RevisionType.Insertions, tableRow, null);
					break;
				case "cantSplit":
					rowFormat.IsBreakAcrossPages = !GetBooleanValue(reader);
					break;
				case "jc":
					rowFormat.HorizontalAlignment = ParseTableJustification(reader);
					break;
				case "gridBefore":
				{
					string attribute5 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					float result2 = 0f;
					if (!string.IsNullOrEmpty(attribute5) && !float.TryParse(attribute5, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
					{
						result2 = 0f;
					}
					if (result2 > 0f && !rowFormat.IsFormattingChange)
					{
						rowFormat.BeforeWidth = rowFormat.UpdateRowBeforeAfterWidth((short)result2, isAfterWidth: false);
						m_gridCount = (short)result2;
					}
					break;
				}
				case "gridAfter":
				{
					string attribute5 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					short result = 0;
					if (!string.IsNullOrEmpty(attribute5))
					{
						short.TryParse(attribute5, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					}
					if (result > 0 && !rowFormat.IsFormattingChange)
					{
						rowFormat.AfterWidth = rowFormat.UpdateRowBeforeAfterWidth(result, isAfterWidth: true);
					}
					break;
				}
				case "wBefore":
				{
					string attribute6 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					string attribute2 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!(attribute2 == "pct"))
					{
						if (attribute2 == "dxa")
						{
							rowFormat.GridBeforeWidth.WidthType = FtsWidth.Point;
							rowFormat.GridBeforeWidth.Width = (float)ParseIntegerValue(attribute6) / 20f;
						}
					}
					else
					{
						rowFormat.GridBeforeWidth.WidthType = FtsWidth.Percentage;
						rowFormat.GridBeforeWidth.Width = (float)ParseIntegerValue(attribute6) / 50f;
					}
					break;
				}
				case "wAfter":
				{
					string attribute = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					string attribute2 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!(attribute2 == "pct"))
					{
						if (attribute2 == "dxa")
						{
							rowFormat.GridAfterWidth.WidthType = FtsWidth.Point;
							rowFormat.GridAfterWidth.Width = (float)ParseIntegerValue(attribute) / 20f;
						}
					}
					else
					{
						rowFormat.GridAfterWidth.WidthType = FtsWidth.Percentage;
						rowFormat.GridAfterWidth.Width = (float)ParseIntegerValue(attribute) / 50f;
					}
					break;
				}
				case "hidden":
					rowFormat.Hidden = true;
					break;
				default:
					if (!IsWord2003ML)
					{
						rowFormat.XmlProps.Add(ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "cnfStyle":
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseChangeRowFormat(XmlReader reader, WTableRow tableRow)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		tableRow.RowFormat.IsChangedFormat = true;
		tableRow.RowFormat.IsFormattingChange = true;
		SkipWhitespaces(reader);
		if (reader.LocalName == "trPrChange" && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (reader.LocalName != "trPrChange")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "trPr")
				{
					ParseTableRowProperties(reader, tableRow);
				}
				else
				{
					reader.Read();
					flag = true;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private string GetStringVal(XmlReader reader, string attrName, string attrNS)
	{
		if (reader.AttributeCount == 0)
		{
			return null;
		}
		if (attrNS == null)
		{
			return reader.GetAttribute(attrName);
		}
		return reader.GetAttribute(attrName, attrNS);
	}

	private void ParseRowHeight(XmlReader reader, WTableRow tableRow)
	{
		string name = (IsWord2003ML ? "h-rule" : "hRule");
		if (!tableRow.RowFormat.IsFormattingChange)
		{
			string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				tableRow.RowFormat.Height = GetFloatValue(attribute, "rowHeight");
			}
			string attribute2 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute2) && attribute2 == "exact")
			{
				tableRow.HeightType = TableRowHeightType.Exactly;
			}
		}
	}

	private void ApplyTableProperties(WTableRow tblRow, WTable table)
	{
		tblRow.RowFormat.ImportContainer(table.DocxTableFormat.Format);
		tblRow.RowFormat.IsAutoResized = table.DocxTableFormat.Format.IsAutoResized;
		if (table.DocxTableFormat.StyleName == null || table.DocxTableFormat.StyleName.Length == 0)
		{
			Borders borders = table.DocxTableFormat.Format.Borders;
			Borders borders2 = tblRow.RowFormat.Borders;
			if (borders.Bottom.BorderType == BorderStyle.None)
			{
				borders2.Bottom.HasNoneStyle = true;
			}
			if (borders.Left.BorderType == BorderStyle.None)
			{
				borders2.Left.HasNoneStyle = true;
			}
			if (borders.Right.BorderType == BorderStyle.None)
			{
				borders2.Right.HasNoneStyle = true;
			}
			if (borders.Top.BorderType == BorderStyle.None)
			{
				borders2.Top.HasNoneStyle = true;
			}
			if (borders.Horizontal.BorderType == BorderStyle.None)
			{
				borders2.Horizontal.HasNoneStyle = true;
			}
			if (borders.Vertical.BorderType == BorderStyle.None)
			{
				borders2.Vertical.HasNoneStyle = true;
			}
		}
	}

	private void UpdateTableBorders(XmlTableFormat xmlFormat)
	{
		if (string.IsNullOrEmpty(xmlFormat.StyleName) && xmlFormat.Format.Borders.IsDefault)
		{
			xmlFormat.Format.Borders.BorderType = BorderStyle.None;
		}
	}

	private void ParseTableProperties(XmlReader reader, IEntity entity, ref bool isEmptyElement)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			Stream stream = ReadSingleNodeIntoStream(reader);
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				isEmptyElement = false;
				bool flag = HasNode(stream, "tblStyle");
				XmlReader xmlReader = UtilityMethods.CreateReader(stream);
				if (flag)
				{
					while (xmlReader.Read())
					{
						if (xmlReader.LocalName == "tblStyle")
						{
							string attribute = xmlReader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
							if (string.IsNullOrEmpty(attribute) || !StyleNameId.ContainsKey(attribute) || m_doc.Styles.FindByName(StyleNameId[attribute], StyleType.TableStyle) == null)
							{
								flag = false;
							}
							break;
						}
					}
					stream.Position = 0L;
					xmlReader = UtilityMethods.CreateReader(stream);
				}
				string localName2 = xmlReader.LocalName;
				if (localName2 == "tblPrEx")
				{
					flag = false;
				}
				RowFormat rowFormat = GetRowFormat(entity);
				bool flag2 = false;
				xmlReader.Read();
				SkipWhitespaces(xmlReader);
				WTable wTable = entity as WTable;
				if (entity is WTableRow)
				{
					wTable = (entity as WTableRow).OwnerTable;
				}
				while (xmlReader.LocalName != localName2)
				{
					flag2 = false;
					if (xmlReader.NodeType == XmlNodeType.Element)
					{
						switch (xmlReader.LocalName)
						{
						case "tblStyle":
							if (flag)
							{
								ParseTableStyle(xmlReader, wTable);
							}
							flag = false;
							break;
						case "tblW":
						{
							string attribute5 = xmlReader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
							if (attribute5 == null)
							{
								return;
							}
							if (flag)
							{
								break;
							}
							if (!(entity is WTableRow))
							{
								if (attribute5 == "auto")
								{
									wTable.PreferredTableWidth.WidthType = FtsWidth.Auto;
									break;
								}
								string attribute6 = xmlReader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
								if (attribute5 == "pct")
								{
									wTable.PreferredTableWidth.WidthType = FtsWidth.Percentage;
									if (attribute6.EndsWith("%"))
									{
										wTable.PreferredTableWidth.Width = (float)GetPercentage(attribute6);
									}
									else
									{
										wTable.PreferredTableWidth.Width = (float)ParseIntegerValue(attribute6) / 50f;
									}
								}
								else if (attribute5 == "dxa")
								{
									wTable.PreferredTableWidth.WidthType = FtsWidth.Point;
									wTable.PreferredTableWidth.Width = (IsStrict ? ParseFloatValue(attribute6) : ((float)ParseIntegerValue(attribute6) / 20f));
								}
								break;
							}
							if (attribute5 == "auto")
							{
								(entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Auto;
								break;
							}
							string attribute7 = xmlReader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
							if (attribute5 == "pct")
							{
								(entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Percentage;
								if (attribute7.EndsWith("%"))
								{
									(entity as WTableRow).RowFormat.PreferredWidth.Width = (float)GetPercentage(attribute7);
								}
								else
								{
									(entity as WTableRow).RowFormat.PreferredWidth.Width = (float)ParseIntegerValue(attribute7) / 50f;
								}
							}
							else if (attribute5 == "dxa")
							{
								(entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Point;
								(entity as WTableRow).RowFormat.PreferredWidth.Width = (IsStrict ? ParseFloatValue(attribute7) : ((float)ParseIntegerValue(attribute7) / 20f));
							}
							break;
						}
						case "tblBorders":
							if (flag)
							{
								xmlReader.Skip();
							}
							else
							{
								ParseBorders(xmlReader, entity, null);
							}
							break;
						case "tblCellSpacing":
							if (!flag)
							{
								float num = 0f;
								string attribute3 = xmlReader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
								if (!string.IsNullOrEmpty(attribute3))
								{
									num = GetFloatValue(attribute3, xmlReader.LocalName);
								}
								string attribute4 = xmlReader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
								if (num != float.MaxValue && (string.IsNullOrEmpty(attribute4) || !(attribute4 == "nil")))
								{
									rowFormat.CellSpacing = num;
								}
							}
							break;
						case "jc":
							if (!flag)
							{
								rowFormat.HorizontalAlignment = ParseTableJustification(xmlReader);
							}
							break;
						case "bidiVisual":
							rowFormat.Bidi = GetBooleanValue(xmlReader);
							break;
						case "tblCellMar":
							if (flag)
							{
								xmlReader.Skip();
							}
							else
							{
								ParseTableMargins(xmlReader, entity);
							}
							break;
						case "tblInd":
						{
							if (flag)
							{
								break;
							}
							string attribute8 = xmlReader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
							if (!string.IsNullOrEmpty(attribute8))
							{
								float floatValue = GetFloatValue(attribute8, "tblInd");
								if (floatValue < -1080f || floatValue > 1080f || float.IsNaN(floatValue))
								{
									rowFormat.LeftIndent = 0f;
								}
								else
								{
									rowFormat.LeftIndent = floatValue;
								}
							}
							if (localName2 == "tblPrEx" && entity is WTableRow && (entity as WTableRow).GetRowIndex() == 0)
							{
								rowFormat.OwnerRow.OwnerTable.TableFormat.LeftIndent = rowFormat.LeftIndent;
							}
							break;
						}
						case "tblLayout":
							if (!flag)
							{
								ParseTableLayout(xmlReader, rowFormat);
							}
							break;
						case "tblPrChange":
							if (flag)
							{
								xmlReader.Skip();
								flag2 = true;
								break;
							}
							IsTableChangeFormat = true;
							UpdateRevAuthorInformation(wTable.DocxTableFormat.Format, xmlReader, RevisionType.Formatting);
							ParseChangeTableProperties(xmlReader, wTable);
							IsTableChangeFormat = false;
							wTable.DocxTableFormat.Format.IsFormattingChange = false;
							m_doc.UpdateTableRevision(wTable);
							break;
						case "tblPrExChange":
						{
							if (flag)
							{
								xmlReader.Skip();
								flag2 = true;
								break;
							}
							IsRowChangeFormat = true;
							UpdateRevAuthorInformation(rowFormat, xmlReader, RevisionType.Formatting);
							ParseChangeTableProperties(xmlReader, entity);
							IsRowChangeFormat = false;
							rowFormat.IsFormattingChange = false;
							Revision revision = m_doc.CreateNewRevision(RevisionType.Formatting, rowFormat.FormatChangeAuthorName, rowFormat.FormatChangeDateTime, null);
							rowFormat.Revisions.Add(revision);
							revision.Range.Items.Add(rowFormat);
							break;
						}
						case "tblpPr":
							if (!flag)
							{
								ParseTablePositioning(xmlReader, wTable);
							}
							break;
						case "tblOverlap":
							if (wTable.TableFormat.WrapTextAround)
							{
								string attribute2 = xmlReader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
								if (!string.IsNullOrEmpty(attribute2) && attribute2.ToLower() == "never")
								{
									wTable.TableFormat.Positioning.AllowOverlap = false;
								}
							}
							break;
						case "shd":
							if (!flag)
							{
								ParseTableShading(xmlReader, rowFormat);
							}
							break;
						case "tblLook":
							ParseTableLook(xmlReader, wTable);
							break;
						case "tblCaption":
							ParseTableTitle(xmlReader, wTable);
							break;
						case "tblDescription":
							ParseTableDescription(xmlReader, wTable);
							break;
						default:
							if (!IsWord2003ML && xmlReader.LocalName != string.Empty && !(entity is WTableRow))
							{
								if (!IsTableChangeFormat)
								{
									wTable.DocxTableFormat.NodeArray.Add(ReadSingleNodeIntoStream(xmlReader));
								}
								flag2 = true;
							}
							break;
						}
						if (!flag2)
						{
							xmlReader.Read();
						}
					}
					else
					{
						xmlReader.Read();
					}
				}
			}
			else
			{
				isEmptyElement = true;
			}
		}
		else
		{
			isEmptyElement = true;
		}
	}

	private void ParseChangeTableProperties(XmlReader reader, IEntity entity)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (entity is WTableRow)
		{
			(entity as WTableRow).RowFormat.IsFormattingChange = true;
		}
		else
		{
			(entity as WTable).DocxTableFormat.Format.IsFormattingChange = true;
		}
		SkipWhitespaces(reader);
		if (reader.LocalName == localName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (reader.LocalName != localName)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (localName2 == "tblPr" || localName2 == "tblPrEx")
				{
					bool isEmptyElement = true;
					ParseTableProperties(reader, entity, ref isEmptyElement);
					if (isEmptyElement)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private int ParseIntegerValue(string value)
	{
		int result = 0;
		double result2 = 0.0;
		if (double.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out result2))
		{
			if (value.Contains("."))
			{
				int num = value.IndexOf('.');
				if (num > 0)
				{
					value = value.Substring(0, num);
				}
				else if (num == 0)
				{
					value = "0";
				}
			}
			int.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		return result;
	}

	private float ParseFloatValue(string value)
	{
		float result = 0f;
		double result2 = 0.0;
		if (double.TryParse(value.Remove(value.IndexOf("pt")), NumberStyles.Any, CultureInfo.InvariantCulture, out result2))
		{
			result2 *= 20.0;
			value = value.Remove(value.IndexOf("pt"));
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		return result;
	}

	private void ParseTableTitle(XmlReader reader, WTable table)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			table.Title = attribute;
		}
	}

	private void ParseTableDescription(XmlReader reader, WTable table)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			table.Description = attribute;
		}
	}

	private void ParseTableLook(XmlReader reader, WTable table)
	{
		string tableLookValue = GetTableLookValue(reader, "firstRow");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForHeaderRow = GetBoolValue(tableLookValue);
		}
		tableLookValue = GetTableLookValue(reader, "lastRow");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForLastRow = GetBoolValue(tableLookValue);
		}
		tableLookValue = GetTableLookValue(reader, "firstColumn");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForFirstColumn = GetBoolValue(tableLookValue);
		}
		tableLookValue = GetTableLookValue(reader, "lastColumn");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForLastColumn = GetBoolValue(tableLookValue);
		}
		tableLookValue = GetTableLookValue(reader, "noHBand");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForBandedRows = !GetBoolValue(tableLookValue);
		}
		tableLookValue = GetTableLookValue(reader, "noVBand");
		if (!string.IsNullOrEmpty(tableLookValue))
		{
			table.ApplyStyleForBandedColumns = !GetBoolValue(tableLookValue);
		}
	}

	private bool GetBoolValue(string value)
	{
		if (!string.IsNullOrEmpty(value))
		{
			switch (value)
			{
			case "f":
			case "0":
			case "off":
			case "false":
				break;
			default:
				return true;
			}
		}
		return false;
	}

	private bool GetBoolValue(XmlReader reader, string nameSpace)
	{
		string attribute = reader.GetAttribute("val", nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "0":
			case "off":
			case "false":
				return false;
			}
		}
		return true;
	}

	private string GetTableLookValue(XmlReader reader, string name)
	{
		string text = reader.GetAttribute(name, IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (text == null)
		{
			string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
			if (!string.IsNullOrEmpty(attribute))
			{
				string text2 = Convert.ToString(Convert.ToInt32(attribute, 16), 2).PadLeft(11, '0');
				switch (name)
				{
				case "firstRow":
					text = text2.Substring(5, 1);
					break;
				case "lastRow":
					text = text2.Substring(4, 1);
					break;
				case "firstColumn":
					text = text2.Substring(3, 1);
					break;
				case "lastColumn":
					text = text2.Substring(2, 1);
					break;
				case "noHBand":
					text = text2.Substring(1, 1);
					break;
				case "noVBand":
					text = text2.Substring(0, 1);
					break;
				}
			}
		}
		return text;
	}

	private void ParseTableMargins(XmlReader reader, Paddings paddings)
	{
		string empty = string.Empty;
		if (reader.LocalName != "tblCellMar" && reader.LocalName != "tcMar")
		{
			throw new XmlException("Table margins");
		}
		string localName = reader.LocalName;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "top":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Top = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "left":
				case "start":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Left = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "bottom":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Bottom = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "right":
				case "end":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Right = GetFloatValue(empty, reader.LocalName);
					}
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTableMargins(XmlReader reader, IEntity entity)
	{
		string empty = string.Empty;
		Paddings paddings = GetPaddings(entity);
		if (reader.LocalName != "tblCellMar" && reader.LocalName != "tcMar")
		{
			throw new XmlException("Table margins");
		}
		string localName = reader.LocalName;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "top":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Top = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "left":
				case "start":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Left = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "bottom":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Bottom = GetFloatValue(empty, reader.LocalName);
					}
					break;
				case "right":
				case "end":
					empty = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(empty))
					{
						paddings.Right = GetFloatValue(empty, reader.LocalName);
					}
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private Paddings GetPaddings(IEntity entity)
	{
		Paddings paddings = new Paddings();
		if (entity is WTable)
		{
			if (IsTableChangeFormat)
			{
				(entity as WTable).DocxTableFormat.Format.SetPropertyValue(3, paddings);
				paddings = (Paddings)(entity as WTable).DocxTableFormat.Format.OldPropertiesHash[3];
			}
			else
			{
				paddings = (entity as WTable).DocxTableFormat.Format.Paddings;
			}
		}
		else if (entity is WTableRow)
		{
			if (IsRowChangeFormat)
			{
				(entity as WTableRow).RowFormat.SetPropertyValue(3, paddings);
				paddings = (Paddings)(entity as WTableRow).RowFormat.OldPropertiesHash[3];
			}
			else
			{
				paddings = (entity as WTableRow).RowFormat.Paddings;
			}
		}
		else if (entity is WTableCell)
		{
			if (IsCellChangeFormat)
			{
				(entity as WTableCell).CellFormat.SetPropertyValue(3, paddings);
				paddings = (Paddings)(entity as WTableCell).CellFormat.OldPropertiesHash[3];
			}
			else
			{
				paddings = (entity as WTableCell).CellFormat.Paddings;
			}
		}
		return paddings;
	}

	private RowAlignment ParseTableJustification(XmlReader reader)
	{
		RowAlignment result = RowAlignment.Left;
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "left":
				result = RowAlignment.Left;
				break;
			case "center":
				result = RowAlignment.Center;
				break;
			case "right":
				result = RowAlignment.Right;
				break;
			}
		}
		return result;
	}

	private void ParseTablePositioning(XmlReader reader, WTable table)
	{
		RowFormat.TablePositioning positioning = table.DocxTableFormat.Format.Positioning;
		string attribute = reader.GetAttribute("leftFromText", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.DistanceFromLeft = GetFloatValue(attribute, "leftFromText");
		}
		attribute = reader.GetAttribute("rightFromText", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.DistanceFromRight = GetFloatValue(attribute, "rightFromText");
		}
		attribute = reader.GetAttribute("topFromText", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.DistanceFromTop = GetFloatValue(attribute, "topFromText");
		}
		attribute = reader.GetAttribute("bottomFromText", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.DistanceFromBottom = GetFloatValue(attribute, "bottomFromText");
		}
		attribute = reader.GetAttribute("vertAnchor", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			ParseTableVerticalRelation(positioning, attribute);
		}
		attribute = reader.GetAttribute("horzAnchor", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			ParseTableHorizontalRelation(positioning, attribute);
		}
		attribute = reader.GetAttribute("tblpXSpec", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			ParseTableHorizontalPosition(positioning, attribute);
		}
		attribute = reader.GetAttribute("tblpYSpec", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			ParseTableVerticalPosition(positioning, attribute);
		}
		attribute = reader.GetAttribute("tblpX", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.HorizPosition = GetFloatValue(attribute, "tblpX");
		}
		attribute = reader.GetAttribute("tblpY", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			positioning.VertPosition = GetFloatValue(attribute, "tblpY");
		}
	}

	private void ParseTableVerticalRelation(RowFormat.TablePositioning positioning, string position)
	{
		if (!(position == "page"))
		{
			if (position == "text")
			{
				positioning.VertRelationTo = VerticalRelation.Paragraph;
			}
			else
			{
				positioning.VertRelationTo = VerticalRelation.Margin;
			}
		}
		else
		{
			positioning.VertRelationTo = VerticalRelation.Page;
		}
	}

	private void ParseTableHorizontalRelation(RowFormat.TablePositioning positioning, string position)
	{
		if (!(position == "page"))
		{
			if (position == "margin")
			{
				positioning.HorizRelationTo = HorizontalRelation.Margin;
			}
			else
			{
				positioning.HorizRelationTo = HorizontalRelation.Column;
			}
		}
		else
		{
			positioning.HorizRelationTo = HorizontalRelation.Page;
		}
	}

	private void ParseTableHorizontalPosition(RowFormat.TablePositioning positioning, string position)
	{
		switch (position)
		{
		case "inside":
			positioning.HorizPositionAbs = HorizontalPosition.Inside;
			break;
		case "outside":
			positioning.HorizPositionAbs = HorizontalPosition.Outside;
			break;
		case "center":
			positioning.HorizPositionAbs = HorizontalPosition.Center;
			break;
		case "right":
			positioning.HorizPositionAbs = HorizontalPosition.Right;
			break;
		default:
			positioning.HorizPositionAbs = HorizontalPosition.Left;
			break;
		}
	}

	private void ParseTableVerticalPosition(RowFormat.TablePositioning positioning, string position)
	{
		switch (position)
		{
		case "inside":
			positioning.VertPositionAbs = VerticalPosition.Inside;
			break;
		case "outside":
			positioning.VertPositionAbs = VerticalPosition.Outside;
			break;
		case "center":
			positioning.VertPositionAbs = VerticalPosition.Center;
			break;
		case "bottom":
			positioning.VertPositionAbs = VerticalPosition.Bottom;
			break;
		case "top":
			positioning.VertPositionAbs = VerticalPosition.Top;
			break;
		default:
			positioning.VertPositionAbs = VerticalPosition.None;
			break;
		}
	}

	private void ParseTableShading(XmlReader reader, RowFormat format)
	{
		string attribute = reader.GetAttribute("fill", IsStrict ? m_strictNameSpace : m_nameSpace);
		string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			format.TextureStyle = ParseTexture(attribute2);
		}
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				format.BackColor = Color.Empty;
			}
			else
			{
				format.BackColor = GetColorValue(attribute);
			}
		}
	}

	private void ParseTableLayout(XmlReader reader, RowFormat format)
	{
		string text = (IsWord2003ML ? "Fixed" : "fixed");
		if (reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace) == text)
		{
			format.IsAutoResized = false;
		}
	}

	private void ParseTableStyle(XmlReader reader, WTable table)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (IsTableChangeFormat)
		{
			table.TrackTblFormat.StyleName = attribute;
			return;
		}
		if (!string.IsNullOrEmpty(attribute) && StyleNameId.ContainsKey(attribute) && m_doc.Styles.FindByName(StyleNameId[attribute], StyleType.TableStyle) != null)
		{
			table.ApplyStyle(StyleNameId[attribute], isClearCellShading: false);
		}
		table.DocxTableFormat.StyleName = attribute;
	}

	private RowFormat GetRowFormat(IEntity entity)
	{
		RowFormat result = null;
		WTable wTable = null;
		if (entity is WTable)
		{
			wTable = entity as WTable;
			result = wTable.DocxTableFormat.Format;
			if (wTable.DocxTableFormat.StyleName == null)
			{
				wTable.DocxTableFormat.StyleName = string.Empty;
			}
		}
		else if (entity is WTableRow)
		{
			result = (entity as WTableRow).RowFormat;
		}
		return result;
	}

	private void ParseTableGrid(XmlReader reader, WTable table, bool isTableGridChange, string localName)
	{
		if (!(localName == "tblGrid") && !(localName == "tblGridChange"))
		{
			throw new XmlException("table grid");
		}
		string text = localName;
		WTableColumnCollection wTableColumnCollection = (isTableGridChange ? table.TrackTableGrid : table.TableGrid);
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "gridCol"))
				{
					if (localName2 == "tblGridChange" && !reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && table.TrackTableGrid.Count <= 0)
						{
							ParseTableGrid(reader, table, isTableGridChange: true, localName);
						}
					}
				}
				else
				{
					string text2 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (string.IsNullOrEmpty(text2))
					{
						table.IsTableGridCorrupted = true;
					}
					else
					{
						int num = text2.IndexOf('.');
						if (num != -1)
						{
							text2 = text2.Substring(0, num);
						}
						float num2 = 0f;
						if (wTableColumnCollection.Count > 0)
						{
							num2 = wTableColumnCollection[wTableColumnCollection.Count - 1].EndOffset;
						}
						float result = 0f;
						float.TryParse(text2, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						wTableColumnCollection.AddColumns(result + num2);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private IWTable AddTable(IEntity entity)
	{
		IWTable iWTable = null;
		if (entity is HeaderFooter)
		{
			return (entity as HeaderFooter).AddTable();
		}
		if (entity is WFootnote)
		{
			return (entity as WFootnote).TextBody.AddTable();
		}
		if (entity is WComment)
		{
			return (entity as WComment).TextBody.AddTable();
		}
		if (entity is BlockContentControl)
		{
			return (entity as BlockContentControl).TextBody.AddTable();
		}
		if (entity is WTextBody)
		{
			return (entity as WTextBody).AddTable();
		}
		return m_doc.LastSection.AddTable();
	}

	private bool ParseHyperlink(XmlReader reader, ParagraphItemCollection paraItems)
	{
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 23);
		string text = null;
		string text2 = null;
		if (IsWord2003ML)
		{
			text2 = reader.GetAttribute("bookmark", "http://schemas.microsoft.com/office/word/2003/wordml");
		}
		else
		{
			text = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
			text2 = reader.GetAttribute("anchor", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
			if (text == null && text2 == null)
			{
				return false;
			}
		}
		WField wField = new WField(m_doc);
		wField.FieldType = FieldType.FieldHyperlink;
		Hyperlink hyperlink = new Hyperlink(wField);
		WTextRange item = new WTextRange(m_doc);
		if (IsWord2003ML)
		{
			hyperlink.Type = HyperlinkType.Bookmark;
			if (text2 != null)
			{
				hyperlink.BookmarkName = text2;
			}
			string attribute = reader.GetAttribute("dest", "http://schemas.microsoft.com/office/word/2003/wordml");
			if (!string.IsNullOrEmpty(attribute))
			{
				wField.m_fieldValue = attribute;
			}
			AddToParagraph(wField, paraItems);
			AddToParagraph(item, paraItems);
		}
		else
		{
			string attribute2 = reader.GetAttribute("tooltip", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
			if (!string.IsNullOrEmpty(attribute2))
			{
				wField.ScreenTip = attribute2;
			}
			if (text == null)
			{
				hyperlink.Type = HyperlinkType.Bookmark;
				hyperlink.BookmarkName = text2;
				AddToParagraph(wField, paraItems);
				AddToParagraph(item, paraItems);
			}
			else
			{
				DictionaryEntry relation = GetRelation(text);
				if (relation.Key == null || relation.Key.ToString() != "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink")
				{
					return false;
				}
				AddToParagraph(wField, paraItems);
				AddToParagraph(item, paraItems);
				string text3 = (string)relation.Value;
				if (StartsWithExt(text3, "#"))
				{
					hyperlink.Type = HyperlinkType.Bookmark;
					hyperlink.BookmarkName = text3.Replace("#", string.Empty);
				}
				else
				{
					wField.m_fieldValue = "\"" + text3.Replace("\\", "\\\\") + "\"";
				}
				if (m_isExternalHyperlink != null && m_docRelations.ContainsKey(text))
				{
					if (IsExternalHyperlink.ContainsKey(text) && IsExternalHyperlink[text])
					{
						if (text2 != null)
						{
							wField.IsLocal = true;
							wField.LocalReference = text2;
						}
					}
					else
					{
						wField.IsLocal = true;
					}
				}
			}
		}
		FieldStack.Push(wField);
		WFieldMark wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
		AddToParagraph(wFieldMark, paraItems);
		wField.FieldSeparator = wFieldMark;
		hyperlink.SetHyperlinkFieldCode();
		string text4 = (IsWord2003ML ? "hlink" : "hyperlink");
		if (reader.LocalName.ToLower() == text4)
		{
			ParseHyperlinkText(reader, paraItems);
			if (paraItems.Count > wFieldMark.Index + 1 && paraItems[wFieldMark.Index + 1] != null && paraItems[wFieldMark.Index + 1].ParaItemCharFormat.Hidden)
			{
				for (int i = wField.Index; i <= wFieldMark.Index; i++)
				{
					paraItems[i].ParaItemCharFormat.Hidden = true;
				}
			}
			WFieldMark wFieldMark2 = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
			if (paraItems.Count > wFieldMark.Index + 1 && paraItems[wFieldMark.Index + 1] != null && paraItems[paraItems.Count - 1].ParaItemCharFormat.Hidden)
			{
				wFieldMark2.CharacterFormat.Hidden = true;
			}
			AddToParagraph(wFieldMark2, paraItems);
			wField.FieldEnd = wFieldMark2;
			FieldStack.Pop();
			return false;
		}
		return true;
	}

	private DictionaryEntry GetRelation(string id)
	{
		DictionaryEntry result = default(DictionaryEntry);
		if (m_currentFile.Contains("header") || m_currentFile.Contains("footer") || StartsWithExt(m_currentFile, "comments") || StartsWithExt(m_currentFile, "footnotes") || StartsWithExt(m_currentFile, "endnotes"))
		{
			string name = string.Empty;
			if (m_currentFile.Contains("header") || m_currentFile.Contains("footer"))
			{
				name = m_currentFile;
			}
			else if (StartsWithExt(m_currentFile, "comments"))
			{
				name = "comments.xml.rels";
			}
			else if (StartsWithExt(m_currentFile, "footnotes"))
			{
				name = "footnotes.xml.rels";
			}
			else if (StartsWithExt(m_currentFile, "endnotes"))
			{
				name = "endnotes.xml.rels";
			}
			Dictionary<string, DictionaryEntry> fileRelations = GetFileRelations(name);
			if (fileRelations != null && fileRelations.ContainsKey(id))
			{
				return fileRelations[id];
			}
		}
		else if (m_docRelations.ContainsKey(id))
		{
			return m_docRelations[id];
		}
		return result;
	}

	private void ParseHyperlinkText(XmlReader reader, ParagraphItemCollection paraItems)
	{
		reader.MoveToElement();
		string text = (IsWord2003ML ? "hlink" : "hyperlink");
		if (reader.LocalName != text)
		{
			throw new XmlException(text);
		}
		if (!reader.IsEmptyElement)
		{
			IsHyperLinkField = true;
			ParseParagraphItems(reader, paraItems, null, null, isMappedPictureContentControl: false);
			IsHyperLinkField = false;
		}
	}

	private bool ParseFieldSimple(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string text = reader.GetAttribute("instr", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (string.IsNullOrEmpty(text))
		{
			text = ModifyText(reader.ReadInnerXml());
		}
		WField wField = new WField(m_doc);
		wField = wField.CreateFieldByType(text, FieldType.FieldUnknown);
		wField.UpdateFieldCode(text);
		WTextRange wTextRange = new WTextRange(m_doc);
		wTextRange.Text = text;
		if (m_currentRunFormat != null)
		{
			wField.ApplyCharacterFormat(m_currentRunFormat);
			ApplyDirectionalOverride(wField.CharacterFormat);
			wTextRange.ApplyCharacterFormat(wField.CharacterFormat);
		}
		bool flag = wField.FieldType == FieldType.FieldTOC && !m_doc.TOC.ContainsKey(wField);
		if (flag)
		{
			m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 15);
			TableOfContent tableOfContent = new TableOfContent(m_doc, wField.FormattingString);
			m_doc.TOC.Add(wField, tableOfContent);
			AddItem(tableOfContent, paraItems);
			paraItems.Add(wTextRange);
		}
		else
		{
			AddItem(wField, paraItems);
			paraItems.Add(wTextRange);
		}
		WFieldMark wFieldMark = null;
		bool flag2 = false;
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			flag2 = true;
			if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
				AddItem(wFieldMark, paraItems);
				wField.FieldSeparator = wFieldMark;
				wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
				AddItem(wFieldMark, paraItems);
				wField.FieldEnd = wFieldMark;
				return false;
			}
			wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
			AddItem(wFieldMark, paraItems);
			if (flag && m_doc.TOC.ContainsKey(wField))
			{
				m_doc.TOC[wField].TOCField.FieldSeparator = wFieldMark;
			}
			else
			{
				wField.FieldSeparator = wFieldMark;
			}
			wField.FieldSeparator = wFieldMark;
			if (flag2)
			{
				ParseParagraphItems(reader, paraItems, localName, null, isMappedPictureContentControl: false);
			}
			else
			{
				ParseParagraphItems(reader, paraItems, null, null, isMappedPictureContentControl: false);
			}
			wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
			AddItem(wFieldMark, paraItems);
			if (flag && m_doc.TOC.ContainsKey(wField))
			{
				m_doc.TOC[wField].TOCField.FieldEnd = wFieldMark;
			}
			else
			{
				wField.FieldEnd = wFieldMark;
			}
			return true;
		}
		wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
		AddItem(wFieldMark, paraItems);
		wField.FieldSeparator = wFieldMark;
		wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
		AddItem(wFieldMark, paraItems);
		wField.FieldEnd = wFieldMark;
		return false;
	}

	private string GetBookmarkName(string bookmarkId)
	{
		for (int i = 0; i < BookmarkNames.Count; i++)
		{
			if (BookmarkNames[i].bookmarkId != null && BookmarkNames[i].bookmarkId.Equals(bookmarkId))
			{
				return BookmarkNames[i].bookmarName;
			}
		}
		return null;
	}

	private bool RemoveBookmarkName(string bookmarkId)
	{
		for (int i = 0; i < BookmarkNames.Count; i++)
		{
			if (BookmarkNames[i].bookmarkId != null && BookmarkNames[i].bookmarkId.Equals(bookmarkId))
			{
				BookmarkNames.RemoveAt(i);
				return true;
			}
		}
		return false;
	}

	private void ParseBookmarkEnd(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string attribute = reader.GetAttribute("id", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string bookmarkName = GetBookmarkName(attribute);
		if (bookmarkName == null)
		{
			return;
		}
		BookmarkEnd bookmarkEnd = new BookmarkEnd(m_doc, bookmarkName);
		string attribute2 = reader.GetAttribute("displacedByCustomXml", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute2))
		{
			bookmarkEnd.DisplacedByCustomXml = attribute2;
		}
		WParagraph wParagraph = ((paraItems.Owner is InlineContentControl) ? (paraItems.Owner as InlineContentControl).OwnerParagraph : (paraItems.Owner as WParagraph));
		if (wParagraph.Index == 0 && (paraItems.Count == 0 || HasNoRenderableItemBefore(paraItems, bookmarkName)) && wParagraph.IsInCell && wParagraph.GetOwnerTableCell(wParagraph.OwnerTextBody).Index == 0)
		{
			if (wParagraph.GetOwnerTableCell(wParagraph.OwnerTextBody).OwnerRow.PreviousSibling is WTableRow wTableRow && wTableRow.Cells[wTableRow.Cells.Count - 1].ChildEntities.LastItem is WParagraph)
			{
				(wTableRow.Cells[wTableRow.Cells.Count - 1].ChildEntities.LastItem as WParagraph).ChildEntities.Add(bookmarkEnd);
				if (paraItems.Count == 0)
				{
					bookmarkEnd.IsAfterRowMark = true;
				}
				else
				{
					bookmarkEnd.IsToAddInNextPara = true;
				}
			}
			else
			{
				paraItems.Add(bookmarkEnd);
			}
		}
		else
		{
			paraItems.Add(bookmarkEnd);
		}
		if (moveRevision != null)
		{
			moveRevision.Range.Items.Add(bookmarkEnd);
		}
		RemoveBookmarkName(attribute);
	}

	private bool HasNoRenderableItemBefore(ParagraphItemCollection paraItems, string bookmarkName)
	{
		foreach (ParagraphItem paraItem in paraItems)
		{
			if ((!(paraItem is BookmarkStart) && !(paraItem is BookmarkEnd)) || (paraItem is BookmarkStart && (paraItem as BookmarkStart).Name == bookmarkName))
			{
				return false;
			}
		}
		return true;
	}

	private void ParseBookmarkEnd(XmlReader reader, IEntity ent)
	{
		string attribute = reader.GetAttribute("id", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string bookmarkName = GetBookmarkName(attribute);
		string attribute2 = reader.GetAttribute("displacedByCustomXml", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		BookmarkEnd bkmkEnd = null;
		WTable ownerTable = GetOwnerTable(ent);
		bool flag = false;
		flag = ((ownerTable != null && ownerTable.LastRow != null) ? true : false);
		if (bookmarkName == null)
		{
			return;
		}
		WParagraph wParagraph = GetOwnerParagraph(ent, flag);
		if (flag)
		{
			wParagraph = GetEndParagraph(ownerTable.LastRow);
		}
		if (IsUpdateBkmkEnd(bkmkEnd, bookmarkName, ent, attribute2, flag))
		{
			return;
		}
		Bookmark bookmark = m_doc.Bookmarks.FindByName(bookmarkName);
		if (wParagraph != null && bookmark != null)
		{
			bkmkEnd = wParagraph.AppendBookmarkEnd(bookmarkName);
			if (!string.IsNullOrEmpty(attribute2))
			{
				bkmkEnd.DisplacedByCustomXml = attribute2;
			}
			RemoveBookmarkName(attribute);
			if ((ent == null || ent is WTableCell || ent is BlockContentControl) && !flag)
			{
				bkmkEnd.IsAfterParagraphMark = true;
			}
			else if (ent is WTableRow)
			{
				bkmkEnd.IsAfterCellMark = true;
			}
			else if (ent is WTable)
			{
				bkmkEnd.IsAfterRowMark = true;
			}
			else if (flag)
			{
				bkmkEnd.IsAfterTableMark = true;
			}
		}
		else
		{
			bkmkEnd = new BookmarkEnd(m_doc, bookmarkName);
			if (!string.IsNullOrEmpty(attribute2))
			{
				bkmkEnd.DisplacedByCustomXml = attribute2;
			}
			PostParaItemsCollection.Add(bkmkEnd);
		}
	}

	private bool IsUpdateBkmkEnd(BookmarkEnd bkmkEnd, string bkmkName, IEntity entity, string displacedByCustomXml, bool isAfterTable)
	{
		bool flag = false;
		Entity entity2 = null;
		WTextBody wTextBody = null;
		if (entity != null)
		{
			switch (entity.EntityType)
			{
			case EntityType.TableCell:
				entity2 = (entity as WTableCell).ChildEntities.LastItem;
				if (entity2 != null && entity2 is AlternateChunk)
				{
					flag = true;
				}
				break;
			case EntityType.TableRow:
				entity2 = (entity as WTableRow).ChildEntities.LastItem;
				if (entity2 != null && entity2 is WTableCell)
				{
					entity2 = (entity2 as WTableCell).ChildEntities.LastItem;
					if (entity2 != null && entity2 is AlternateChunk)
					{
						flag = true;
					}
				}
				break;
			case EntityType.Table:
				entity2 = (entity as WTable).LastCell;
				if (entity2 is WTableCell)
				{
					entity2 = (entity2 as WTableCell).ChildEntities.LastItem;
					if (entity2 != null && entity2 is AlternateChunk)
					{
						flag = true;
					}
				}
				break;
			case EntityType.HeaderFooter:
				entity2 = (entity as HeaderFooter).ChildEntities.LastItem;
				if (entity2 != null && entity2 is AlternateChunk)
				{
					flag = true;
				}
				break;
			case EntityType.Footnote:
				wTextBody = (entity as WFootnote).TextBody;
				if (wTextBody.ChildEntities.LastItem != null && wTextBody.ChildEntities.LastItem is AlternateChunk)
				{
					flag = true;
				}
				break;
			case EntityType.Comment:
				wTextBody = (entity as WComment).TextBody;
				if (wTextBody.ChildEntities.LastItem != null && wTextBody.ChildEntities.LastItem is AlternateChunk)
				{
					flag = true;
				}
				break;
			case EntityType.BlockContentControl:
				wTextBody = (entity as BlockContentControl).TextBody;
				if (wTextBody.ChildEntities.LastItem != null && wTextBody.ChildEntities.LastItem is AlternateChunk)
				{
					flag = true;
				}
				break;
			}
		}
		else
		{
			entity2 = m_doc.LastSection.Body.ChildEntities.LastItem;
			if (entity2 != null && entity2 is AlternateChunk)
			{
				flag = true;
			}
			else if (entity2 != null && entity2 is WTable)
			{
				entity2 = (entity2 as WTable).LastCell;
				if (entity2 is WTableCell)
				{
					entity2 = (entity2 as WTableCell).ChildEntities.LastItem;
					if (entity2 != null && entity2 is AlternateChunk)
					{
						flag = true;
					}
				}
			}
		}
		if (m_doc.LastSection != null && flag)
		{
			int count = m_doc.LastSection.Body.AlternateChunkCollection.Count;
			if (count > 0)
			{
				AlternateChunk alternateChunk = m_doc.LastSection.Body.AlternateChunkCollection[count - 1];
				bkmkEnd = new BookmarkEnd(m_doc, bkmkName);
				if (!string.IsNullOrEmpty(displacedByCustomXml))
				{
					bkmkEnd.DisplacedByCustomXml = displacedByCustomXml;
				}
				alternateChunk.AltChunkBookmarks.Add(bkmkEnd);
				bkmkEnd.IsAfterParagraphMark = true;
				if (entity is WTableRow)
				{
					bkmkEnd.IsAfterCellMark = true;
				}
				else if (entity is WTable)
				{
					bkmkEnd.IsAfterRowMark = true;
				}
				else if (isAfterTable)
				{
					bkmkEnd.IsAfterTableMark = true;
				}
				return true;
			}
			return false;
		}
		return false;
	}

	private WParagraph GetEndParagraph(WTableCell cell)
	{
		WParagraph result = null;
		if (cell.Items != null && cell.Items.Count > 0)
		{
			result = cell.Items[cell.Items.Count - 1] as WParagraph;
		}
		return result;
	}

	private WParagraph GetEndParagraph(WTableRow row)
	{
		WParagraph result = null;
		if (row.Cells.Count > 0)
		{
			result = GetEndParagraph(row.Cells[row.Cells.Count - 1]);
		}
		return result;
	}

	private void ParseBookmarkStart(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string attribute = reader.GetAttribute("name", IsStrict ? m_strictNameSpace : m_nameSpace);
		string attribute2 = reader.GetAttribute("id", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		BookmarkStart bookmarkStart = new BookmarkStart(m_doc, attribute);
		string attribute3 = reader.GetAttribute("colFirst", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		if (!string.IsNullOrEmpty(attribute3))
		{
			bookmarkStart.ColumnFirst = (short)ParseIntegerValue(attribute3);
		}
		attribute3 = reader.GetAttribute("colLast", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		if (!string.IsNullOrEmpty(attribute3))
		{
			bookmarkStart.ColumnLast = (short)ParseIntegerValue(attribute3);
		}
		string attribute4 = reader.GetAttribute("displacedByCustomXml", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute4))
		{
			bookmarkStart.DisplacedByCustomXml = attribute4;
		}
		BookmarkInfo item = default(BookmarkInfo);
		item.bookmarName = attribute;
		item.bookmarkId = attribute2;
		BookmarkNames.Add(item);
		if (paraItems == null)
		{
			PostParaItemsCollection.Add(bookmarkStart);
			return;
		}
		paraItems.Add(bookmarkStart);
		if (moveRevision != null)
		{
			moveRevision.Range.Items.Add(bookmarkStart);
		}
	}

	private void ParseMoveRangeEnd(XmlReader reader, IEntity ent)
	{
		WTable ownerTable = GetOwnerTable(ent);
		bool flag = false;
		flag = ((ownerTable != null && ownerTable.LastRow != null) ? true : false);
		WParagraph wParagraph = GetOwnerParagraph(ent, flag);
		if (flag)
		{
			wParagraph = GetEndParagraph(ownerTable.LastRow);
		}
		if (wParagraph != null && moveRevision != null)
		{
			if ((ent == null || ent is WTableCell || ent is BlockContentControl) && !flag)
			{
				moveRevision.IsAfterParagraphMark = true;
			}
			else if (ent is WTableRow)
			{
				moveRevision.IsAfterCellMark = true;
			}
			else if (ent is WTable)
			{
				moveRevision.IsAfterRowMark = true;
			}
			else if (flag)
			{
				moveRevision.IsAfterTableMark = true;
			}
		}
	}

	private void ParseEditableRangeEnd(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute != null)
		{
			EditableRangeEnd entity = new EditableRangeEnd(m_doc, attribute);
			paraItems.Add(entity);
		}
	}

	private void ParseEditableRangeEnd(XmlReader reader, IEntity ent)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		EditableRangeEnd editableRangeEnd = null;
		WTable ownerTable = GetOwnerTable(ent);
		bool flag = false;
		flag = ((ownerTable != null && ownerTable.LastRow != null) ? true : false);
		if (attribute == null)
		{
			return;
		}
		WParagraph wParagraph = GetOwnerParagraph(ent, flag);
		if (flag)
		{
			wParagraph = GetEndParagraph(ownerTable.LastRow);
		}
		if (wParagraph != null)
		{
			editableRangeEnd = wParagraph.AppendEditableRangeEnd(attribute);
			if (ent is WTableCell && !flag)
			{
				editableRangeEnd.IsAfterParagraphMark = true;
			}
			else if (ent is WTableRow)
			{
				editableRangeEnd.IsAfterCellMark = true;
			}
			else if (ent is WTable)
			{
				editableRangeEnd.IsAfterRowMark = true;
			}
			else if (flag)
			{
				editableRangeEnd.IsAfterTableMark = true;
			}
		}
		else
		{
			editableRangeEnd = new EditableRangeEnd(m_doc, attribute);
			PostParaItemsCollection.Add(editableRangeEnd);
		}
	}

	private WTable GetOwnerTable(IEntity entity)
	{
		WTable result = null;
		if (entity == null)
		{
			if (m_doc.LastSection.Body.ChildEntities.Count > 0 && m_doc.LastSection.Body.ChildEntities[m_doc.LastSection.Body.ChildEntities.Count - 1] is WTable)
			{
				result = m_doc.LastSection.Body.ChildEntities[m_doc.LastSection.Body.ChildEntities.Count - 1] as WTable;
			}
		}
		else if (entity is WTableCell)
		{
			WTableCell wTableCell = entity as WTableCell;
			if (wTableCell.ChildEntities.Count > 0 && wTableCell.ChildEntities[wTableCell.ChildEntities.Count - 1] is WTable)
			{
				result = wTableCell.ChildEntities[wTableCell.ChildEntities.Count - 1] as WTable;
			}
		}
		else if (entity is BlockContentControl)
		{
			BlockContentControl blockContentControl = (BlockContentControl)entity;
			if (blockContentControl.ChildEntities.Count > 0 && blockContentControl.ChildEntities[blockContentControl.ChildEntities.Count - 1] is WTable)
			{
				result = blockContentControl.ChildEntities[blockContentControl.ChildEntities.Count - 1] as WTable;
			}
		}
		return result;
	}

	private WParagraph GetOwnerParagraph(IEntity entity, bool isAfterTable)
	{
		WParagraph result = null;
		if (entity is WParagraph)
		{
			result = entity as WParagraph;
		}
		else if (entity == null && !isAfterTable)
		{
			result = ((m_doc.LastSection.Body.ChildEntities.LastItem != null) ? GetOwnerParagraph(m_doc.LastSection.Body.ChildEntities.LastItem, isAfterTable: false) : null);
		}
		else if (entity is WTable && (entity as WTable).OwnerTextBody != null)
		{
			WTableRow lastRow = (entity as WTable).LastRow;
			result = ((lastRow == null) ? ((entity as WTable).OwnerTextBody.AddParagraph() as WParagraph) : GetEndParagraph(lastRow));
		}
		else if (entity is WTableCell && !isAfterTable)
		{
			result = GetEndParagraph(entity as WTableCell);
		}
		else if (entity is WTableRow)
		{
			result = GetEndParagraph(entity as WTableRow);
		}
		else if (entity is BlockContentControl && !isAfterTable)
		{
			result = ((BlockContentControl)entity).GetLastParagraphOfSDTContent();
		}
		return result;
	}

	internal WParagraph GetMathOwnerParagraph(IOfficeMathFunctionBase mathFunctionBase)
	{
		IOfficeMathEntity ownerMathEntity = mathFunctionBase.OwnerMathEntity;
		while (!(ownerMathEntity is OfficeMathParagraph))
		{
			ownerMathEntity = ownerMathEntity.OwnerMathEntity;
		}
		if ((ownerMathEntity as OfficeMathParagraph).Owner is WMath)
		{
			WMath wMath = (ownerMathEntity as OfficeMathParagraph).Owner as WMath;
			if (wMath.Owner is WParagraph)
			{
				return wMath.Owner as WParagraph;
			}
			if (wMath.Owner is InlineContentControl)
			{
				return (wMath.Owner as InlineContentControl).GetOwnerParagraphValue();
			}
			if (wMath.Owner is XmlParagraphItem)
			{
				return (wMath.Owner as XmlParagraphItem).GetOwnerParagraphValue();
			}
		}
		return null;
	}

	private void ParseEditableRangeStart(XmlReader reader, ParagraphItemCollection paraItems)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		EditableRangeStart editableRangeStart = new EditableRangeStart(m_doc, attribute);
		string attribute2 = reader.GetAttribute("colFirst", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute2))
		{
			editableRangeStart.ColumnFirst = (short)ParseIntegerValue(attribute2);
		}
		attribute2 = reader.GetAttribute("colLast", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute2))
		{
			editableRangeStart.ColumnLast = (short)ParseIntegerValue(attribute2);
		}
		string attribute3 = reader.GetAttribute("ed", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute3))
		{
			editableRangeStart.Ed = attribute3;
		}
		string attribute4 = reader.GetAttribute("edGrp", IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute4))
		{
			editableRangeStart.EdGrp = attribute4;
		}
		if (paraItems == null)
		{
			PostParaItemsCollection.Add(editableRangeStart);
		}
		else
		{
			paraItems.Add(editableRangeStart);
		}
	}

	private void CreateRunFormat(ParagraphItemCollection paraItems)
	{
		WParagraph wParagraph = paraItems.OwnerBase as WParagraph;
		if (paraItems.Owner is InlineContentControl)
		{
			wParagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
		}
		else if (paraItems.Owner is XmlParagraphItem)
		{
			wParagraph = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
		}
		else if (paraItems.Owner is XmlParagraphItem)
		{
			wParagraph = paraItems.Owner.Owner as WParagraph;
		}
		m_currentRunFormat = new WCharacterFormat(m_doc);
		ApplyDirectionalOverride(m_currentRunFormat);
		if (wParagraph != null && wParagraph.ParaStyle != null)
		{
			m_currentRunFormat.ApplyBase(wParagraph.ParaStyle.CharacterFormat);
		}
	}

	private void ParseRunValues(XmlReader reader, ParagraphItemCollection paraItems, IOfficeMathRunElement mathParaItem, bool isMappedPictureContentControl, bool isFromBody)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		ParagraphItem paragraphItem = null;
		MemoryStream drawingStream = null;
		bool flag6 = false;
		string text = null;
		string localName = reader.LocalName;
		SkipWhitespaces(reader);
		while ((!(reader.LocalName == "r") || reader.NodeType != XmlNodeType.EndElement) && (!(reader.LocalName == "ins") || reader.NodeType != XmlNodeType.EndElement) && (!(reader.LocalName == "del") || reader.NodeType != XmlNodeType.EndElement) && (!isFromBody || !(reader.LocalName == localName) || reader.NodeType != XmlNodeType.EndElement))
		{
			ParagraphItem paragraphItem2 = null;
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "r":
				{
					ApplyDirectionalOverride(m_currentRunFormat);
					WCharacterFormat currentRunFormat = m_currentRunFormat;
					ParseRun(reader, paraItems, mathParaItem, isAlreadyChecked: false, reader.NodeType, isMappedPictureContentControl);
					m_currentRunFormat = currentRunFormat;
					break;
				}
				case "rPr":
				{
					if (reader.Name == "m:rPr")
					{
						new MathMLParser().ParseMathRunFormat(reader, mathParaItem.MathFormat as OfficeMathFormat);
						break;
					}
					WParagraph wParagraph = null;
					if (mathParaItem != null)
					{
						wParagraph = GetMathOwnerParagraph(mathParaItem);
					}
					else
					{
						wParagraph = paraItems.OwnerBase as WParagraph;
						if (paraItems.Owner is InlineContentControl)
						{
							wParagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
						}
						else if (paraItems.Owner is XmlParagraphItem)
						{
							wParagraph = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
						}
					}
					m_currentRunFormat = new WCharacterFormat(m_doc);
					ApplyDirectionalOverride(m_currentRunFormat);
					if (wParagraph != null && wParagraph.ParaStyle != null)
					{
						m_currentRunFormat.ApplyBase(wParagraph.ParaStyle.CharacterFormat);
					}
					ParseCharacterFormat(reader, m_currentRunFormat, paraItems);
					break;
				}
				case "t":
				case "instrText":
				case "delText":
				case "delInstrText":
				{
					bool flag7 = reader.LocalName == "instrText" || reader.LocalName == "delInstrText";
					paragraphItem2 = ParseText(reader, paraItems, isNestedInRunProperties: false, mathParaItem != null);
					if ((reader.LocalName == "r" && reader.NodeType == XmlNodeType.EndElement) || flag7)
					{
						flag = true;
					}
					break;
				}
				case "drawing":
					if (flag2 && flag3 && !flag4)
					{
						paragraphItem = ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
						paragraphItem2 = paragraphItem;
						if (!(paragraphItem2 is Shape) && !(paragraphItem2 is GroupShape) && !(paragraphItem2 is XmlParagraphItem) && !(paragraphItem2 is WChart) && !(paragraphItem2 is WPicture))
						{
							paragraphItem2 = null;
							if (!(paragraphItem is XmlParagraphItem))
							{
								paragraphItem = null;
							}
						}
						else if (paragraphItem is Shape && (paragraphItem as Shape).AutoShapeType == AutoShapeType.Rectangle && (paragraphItem as Shape).TextBody.Count > 0)
						{
							paragraphItem2 = null;
						}
						if (paragraphItem2 != null)
						{
							flag5 = true;
						}
					}
					else
					{
						paragraphItem2 = ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
						if (flag2 && flag3 && flag4)
						{
							if (paragraphItem != null && paragraphItem2 != null && paragraphItem.EntityType != paragraphItem2.EntityType)
							{
								paragraphItem2 = paragraphItem;
							}
							else if (flag5)
							{
								paragraphItem2 = null;
							}
						}
					}
					flag = true;
					break;
				case "rStyle":
				{
					if (m_currentRunFormat == null)
					{
						CreateRunFormat(paraItems);
					}
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2) && StyleNameId.ContainsKey(attribute2))
					{
						m_currentRunFormat.CharStyleName = StyleNameId[attribute2];
					}
					List<string> list = new List<string>();
					list.AddRange(StyleNameId.Values);
					Dictionary<string, int> dictionary = CountOccurrencesOfValue(list);
					if (m_currentRunFormat.CharStyleName != null && dictionary[m_currentRunFormat.CharStyleName] > 1)
					{
						m_currentRunFormat.CharStyleId = attribute2;
					}
					break;
				}
				case "object":
					paragraphItem2 = ParseObject(reader);
					if (m_doc.Settings.PreserveOleImageAsImage && paragraphItem2 is WOleObject && (paragraphItem2 as WOleObject).LinkType == OleLinkType.Embed && (paragraphItem2 as WOleObject).ObjectType == "PBrush")
					{
						paragraphItem2 = (paragraphItem2 as WOleObject).OlePicture.Clone() as WPicture;
					}
					flag = true;
					break;
				case "pict":
				{
					MemoryStream memoryStream = ReadSingleNodeIntoStream(reader);
					if (paragraphItem != null && paragraphItem is XmlParagraphItem)
					{
						ParseXmlParaItem(memoryStream);
						break;
					}
					if (!IsWord2003ML || !HasOleObject(memoryStream))
					{
						paragraphItem2 = ParseShape(reader, paraItems, drawingStream, memoryStream, paragraphItem);
					}
					if (paragraphItem2 is Shape && paragraphItem is Shape && (paragraphItem as Shape).EffectList.Count == (paragraphItem2 as Shape).EffectList.Count)
					{
						for (int i = 0; i < (paragraphItem2 as Shape).EffectList.Count; i++)
						{
							if ((paragraphItem2 as Shape).EffectList[i].IsShadowEffect && (paragraphItem as Shape).EffectList[i].IsShadowEffect)
							{
								(paragraphItem as Shape).EffectList[i].ShadowFormat.NonChoiceShadowOffsetX = (paragraphItem2 as Shape).EffectList[i].ShadowFormat.ShadowOffsetX;
								(paragraphItem as Shape).EffectList[i].ShadowFormat.NonChoiceShadowOffsetY = (paragraphItem2 as Shape).EffectList[i].ShadowFormat.ShadowOffsetY;
							}
						}
					}
					if (flag2 && flag3 && paragraphItem2 is WTextBox)
					{
						if (paragraphItem is XmlParagraphItem)
						{
							ParseTextBoxGraphics(paragraphItem2 as WTextBox, paragraphItem as XmlParagraphItem);
						}
						else if (paragraphItem != null && paragraphItem is Shape)
						{
							(paragraphItem2 as WTextBox).TextBoxFormat.TextThemeColor = (paragraphItem as Shape).FontRefColor;
							(paragraphItem2 as WTextBox).ApplyCharacterFormat(paragraphItem.ParaItemCharFormat);
						}
						if (m_doc.Settings.CompatibilityMode != CompatibilityMode.Word2007 && paragraphItem != null && paragraphItem is Shape && paragraphItem2 is WTextBox)
						{
							Shape shape = paragraphItem as Shape;
							WTextBox wTextBox = paragraphItem2 as WTextBox;
							InternalMargin internalMargin = shape.TextFrame.InternalMargin;
							InternalMargin internalMargin2 = wTextBox.TextBoxFormat.InternalMargin;
							if (internalMargin.PropertiesHash.ContainsKey(0))
							{
								internalMargin2.Left = internalMargin.Left;
							}
							if (internalMargin.PropertiesHash.ContainsKey(1))
							{
								internalMargin2.Right = internalMargin.Right;
							}
							if (internalMargin.PropertiesHash.ContainsKey(2))
							{
								internalMargin2.Top = internalMargin.Top;
							}
							if (internalMargin.PropertiesHash.ContainsKey(3))
							{
								internalMargin2.Bottom = internalMargin.Bottom;
							}
							if (shape.LineFormat.PropertiesHash.ContainsKey(14))
							{
								wTextBox.TextBoxFormat.NoLine = !shape.LineFormat.Line;
							}
							if (shape.TextFrame.PropertiesHash.ContainsKey(0))
							{
								wTextBox.TextBoxFormat.AutoFit = true;
							}
							if (shape.TextFrame.PropertiesHash.ContainsKey(1))
							{
								wTextBox.TextBoxFormat.AutoFit = false;
							}
							if (shape.TextFrame.PropertiesHash.ContainsKey(2))
							{
								wTextBox.TextBoxFormat.AutoFit = false;
							}
						}
					}
					if (drawingStream != null && paragraphItem2 is WTextBox && paragraphItem is Shape && (paragraphItem as Shape).AutoShapeType == AutoShapeType.Rectangle && (paragraphItem as Shape).TextBody.Count > 0)
					{
						Shape shape2 = paragraphItem as Shape;
						WTextBox wTextBox2 = paragraphItem2 as WTextBox;
						if (!shape2.IsRelativeHorizontalPosition)
						{
							wTextBox2.TextBoxFormat.HorizontalAlignment = shape2.HorizontalAlignment;
							wTextBox2.TextBoxFormat.HorizontalOrigin = shape2.HorizontalOrigin;
						}
						if (!shape2.IsRelativeVerticalPosition)
						{
							wTextBox2.TextBoxFormat.VerticalAlignment = shape2.VerticalAlignment;
							wTextBox2.TextBoxFormat.VerticalOrigin = shape2.VerticalOrigin;
						}
						if (shape2.LineFormat.PropertiesHash.ContainsKey(11))
						{
							wTextBox2.TextBoxFormat.LineWidth = shape2.LineFormat.Weight;
						}
						else
						{
							wTextBox2.TextBoxFormat.m_txbxLineWidth = 0.75f;
						}
						if (!shape2.LineFormat.PropertiesHash.ContainsKey(0))
						{
							shape2.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Round;
						}
						wTextBox2.TextBoxFormat.WrapDistanceTop = shape2.WrapFormat.DistanceTop;
						wTextBox2.TextBoxFormat.WrapDistanceBottom = shape2.WrapFormat.DistanceBottom;
						wTextBox2.TextBoxFormat.WrapDistanceLeft = shape2.WrapFormat.DistanceLeft;
						wTextBox2.TextBoxFormat.WrapDistanceRight = shape2.WrapFormat.DistanceRight;
						wTextBox2.IsShape = true;
						wTextBox2.Shape = paragraphItem.Clone() as Shape;
						if (shape2.TextBody.ChildEntities.Count > 0)
						{
							m_doc.IsCloning = true;
							wTextBox2.m_textBody = shape2.TextBody.Clone() as WTextBody;
							m_doc.IsCloning = false;
							wTextBox2.m_textBody.ChildEntities.UpdateTrackRevision(wTextBox2.m_textBody);
							wTextBox2.m_textBody.SetOwner(paragraphItem2 as WTextBox);
						}
						m_doc.RemoveRevisionFromCollection(shape2.TextBody);
						paragraphItem = null;
					}
					else if (flag4 && paragraphItem != null)
					{
						if (paragraphItem is Shape && paragraphItem2 is Shape)
						{
							ImportDocxPropsAndXMLRelation(paragraphItem as Shape, paragraphItem2, memoryStream);
						}
						if (paragraphItem is GroupShape && paragraphItem2 is GroupShape)
						{
							ImportDocxPropsAndXMLRelation(paragraphItem as GroupShape, paragraphItem2, memoryStream);
							UpdateTextBoxFormat((paragraphItem as GroupShape).ChildShapes, (paragraphItem2 as GroupShape).ChildShapes);
						}
						if (paragraphItem2 is Shape)
						{
							m_doc.RemoveRevisionFromCollection((paragraphItem2 as Shape).TextBody);
						}
						paragraphItem2 = null;
					}
					if (flag2 && flag3 && !flag4 && paragraphItem2 != null)
					{
						flag5 = true;
					}
					flag = true;
					drawingStream = null;
					break;
				}
				case "br":
				case "cr":
					if (flag6)
					{
						WParagraph wParagraph2 = paraItems.OwnerBase as WParagraph;
						if (paraItems.Owner is InlineContentControl)
						{
							wParagraph2 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
						}
						else if (paraItems.Owner is XmlParagraphItem)
						{
							wParagraph2 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
						}
						paraItems = (wParagraph2.OwnerTextBody.AddParagraph() as WParagraph).Items;
					}
					ParseBreak(reader, paraItems, mathParaItem);
					break;
				case "fldChar":
					ParseFieldMark(reader, paraItems, mathParaItem);
					flag = true;
					break;
				case "endnoteReference":
				case "footnoteReference":
				{
					WCharacterFormat wCharacterFormat = null;
					if (m_currentRunFormat != null)
					{
						ApplyDirectionalOverride(m_currentRunFormat);
						wCharacterFormat = m_currentRunFormat;
					}
					paragraphItem2 = ParseFootnote(reader);
					if ((paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection.Count > 0)
					{
						foreach (AlternateChunk item in (paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection)
						{
							m_doc.LastSection.Body.AlternateChunkCollection.Add(item);
						}
					}
					(paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection.Clear();
					if (paragraphItem2 is WFootnote && !(paragraphItem2 as WFootnote).IsAutoNumbered)
					{
						flag = true;
					}
					if (wCharacterFormat != null)
					{
						(paragraphItem2 as WFootnote).MarkerCharacterFormat.ImportContainer(wCharacterFormat);
					}
					break;
				}
				case "endnoteRef":
				case "footnoteRef":
					paragraphItem2 = ParseFootnoteMarker();
					break;
				case "tab":
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 9);
					paragraphItem2 = new WTextRange(m_doc);
					string text2 = '\t'.ToString();
					UpdateTextRange(paragraphItem2 as WTextRange, text2, m_currentRunFormat);
					break;
				}
				case "sym":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 8);
					paragraphItem2 = ParseSymbol(reader, paraItems);
					break;
				case "noBreakHyphen":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 28);
					paragraphItem2 = new WTextRange(m_doc);
					UpdateTextRange(paragraphItem2 as WTextRange, '\u001e'.ToString(), m_currentRunFormat);
					break;
				case "softHyphen":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 7);
					paragraphItem2 = new WTextRange(m_doc);
					UpdateTextRange(paragraphItem2 as WTextRange, '\u001f'.ToString(), m_currentRunFormat);
					break;
				case "commentReference":
				{
					string attribute3 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (Comments.ContainsKey(attribute3))
					{
						paragraphItem2 = Comments[attribute3];
					}
					break;
				}
				case "AlternateContent":
					flag2 = true;
					break;
				case "Choice":
					if (flag2)
					{
						flag3 = true;
					}
					break;
				case "symEx":
					if (flag3)
					{
						text = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2015/wordml/symex");
					}
					break;
				case "Fallback":
					if (flag2 && !reader.IsEmptyElement)
					{
						string localName2 = reader.LocalName;
						reader.Read();
						if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							flag4 = true;
							flag = true;
						}
					}
					break;
				case "ptab":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 1);
					paragraphItem2 = ParseAbsoluteTab(reader);
					break;
				case "separator":
					paragraphItem2 = new WTextRange(m_doc);
					UpdateTextRange(paragraphItem2 as WTextRange, '\u0003'.ToString(), m_currentRunFormat);
					(paragraphItem2 as WTextRange).CharacterFormat.Special = true;
					break;
				case "continuationSeparator":
					paragraphItem2 = new WTextRange(m_doc);
					UpdateTextRange(paragraphItem2 as WTextRange, '\u0004'.ToString(), m_currentRunFormat);
					(paragraphItem2 as WTextRange).CharacterFormat.Special = true;
					break;
				case "fldSimple":
					flag = ParseFieldSimple(reader, paraItems);
					break;
				case "annotationRef":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 4);
					break;
				case "dayLong":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 13);
					break;
				case "dayShort":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 14);
					break;
				case "monthLong":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 22);
					break;
				case "monthShort":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 23);
					break;
				case "pgNum":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 18);
					AppendPageFieldForPgNum(paraItems);
					break;
				case "yearLong":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 0);
					break;
				case "yearShort":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 1);
					break;
				case "oMathPara":
				case "oMath":
					ParseMathMlElement(reader, paraItems);
					flag = true;
					break;
				case "p":
					ParseNestedParagraph(reader, paraItems, flag6);
					flag6 = true;
					break;
				case "tbl":
					ParseTableInsideParagraph(reader, paraItems);
					break;
				case "del":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 12);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateInsDelRevision(reader, paraItems, RevisionType.Deletions, mathParaItem, isParsingRun: true);
					break;
				case "ins":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 24);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					UpdateInsDelRevision(reader, paraItems, RevisionType.Insertions, mathParaItem, isParsingRun: true);
					break;
				case "altChunk":
				{
					Entity entity = null;
					Entity owner = paraItems.Owner;
					if (owner != null)
					{
						owner = owner.Owner;
						if (owner is WTableCell)
						{
							entity = owner;
						}
						else if (owner is WTextBody && ((owner as WTextBody).Owner is WTextBox || (owner as WTextBody).Owner is Shape || (owner as WTextBody).Owner is BlockContentControl))
						{
							entity = owner.Owner;
						}
					}
					AlternateChunk alternateChunk = AddAlternateChunk(entity);
					AddBookmark(alternateChunk);
					ParseAlternateChunk(reader, alternateChunk);
					alternateChunk.IsParagraphItem = true;
					break;
				}
				default:
					if (!IsWord2003ML)
					{
						break;
					}
					switch (reader.LocalName)
					{
					case "annotation":
					{
						string? attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
						reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
						if (attribute == "Word.Comment")
						{
							paragraphItem2 = Parse2003Comment(reader);
						}
						break;
					}
					case "footnote":
						paragraphItem2 = Parse2003FootnotePart(reader, isFootnote: true);
						break;
					case "endnote":
						paragraphItem2 = Parse2003FootnotePart(reader, isFootnote: false);
						break;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else if (reader.LocalName == "AlternateContent" && reader.NodeType == XmlNodeType.EndElement)
			{
				flag2 = false;
				if (flag3 && !flag4 && paragraphItem != null && IsChoiceItemNotAdded(paragraphItem))
				{
					if (paraItems != null)
					{
						AddToParagraph(paragraphItem, paraItems);
						CheckTrackChange(paragraphItem);
					}
					else
					{
						PostParaItemsCollection.Add(paragraphItem2);
					}
				}
				flag3 = false;
				paragraphItem = null;
				flag4 = false;
				flag5 = false;
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
			if (paragraphItem2 == null)
			{
				continue;
			}
			if (!string.IsNullOrEmpty(text) && paragraphItem2 is WTextRange)
			{
				(paragraphItem2 as WTextRange).CharacterFormat.SymExFontName = text;
				text = null;
			}
			if (mathParaItem != null)
			{
				mathParaItem.Item = paragraphItem2;
			}
			else if (paraItems != null)
			{
				AddToParagraph(paragraphItem2, paraItems);
				CheckTrackChange(paragraphItem2);
				if (paragraphItem2 is WOleObject && paragraphItem2.m_revisions != null)
				{
					for (int j = paragraphItem2.Index + 1; j < paraItems.Count; j++)
					{
						CheckTrackChange(paraItems[j]);
					}
				}
				if (paragraphItem2 is WPicture)
				{
					(paragraphItem2 as WPicture).CheckTextWrappingStyle();
				}
			}
			else
			{
				PostParaItemsCollection.Add(paragraphItem2);
			}
		}
	}

	private void ParseRun(XmlReader reader, ParagraphItemCollection paraItems, IOfficeMathRunElement mathParaItem, bool isAlreadyChecked, XmlNodeType nodeType, bool isMappedPictureContentControl)
	{
		while (nodeType != XmlNodeType.Element)
		{
			reader.Read();
			nodeType = reader.NodeType;
		}
		if (isAlreadyChecked)
		{
			ParseRunValues(reader, paraItems, mathParaItem, isMappedPictureContentControl, isFromBody: false);
		}
		else if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseRunValues(reader, paraItems, mathParaItem, isMappedPictureContentControl, isFromBody: false);
			}
		}
	}

	private void UpdateTextBoxFormat(ChildShapeCollection choiceCollection, ChildShapeCollection fallbackCollection)
	{
		for (int i = 0; i < fallbackCollection.Count; i++)
		{
			ChildShape childShape = fallbackCollection[i];
			if (childShape.ElementType == EntityType.TextBox)
			{
				for (int j = 0; j < choiceCollection.Count; j++)
				{
					ChildShape childShape2 = choiceCollection[j];
					if (childShape2.ElementType != EntityType.TextBox || !(childShape2.Name == childShape.Name) || childShape2.TextBody.Count <= 0)
					{
						continue;
					}
					childShape2.FillFormat.Fill = childShape.FillFormat.Fill;
					if (childShape2.FillFormat.IsDefaultFill)
					{
						childShape2.FillFormat.IsDefaultFill = childShape.FillFormat.IsDefaultFill;
					}
					childShape2.LineFormat.Line = childShape.LineFormat.Line;
					childShape2.FontRefColor = childShape.FontRefColor;
					if (m_doc.Settings.CompatibilityMode != CompatibilityMode.Word2007)
					{
						InternalMargin internalMargin = childShape2.TextFrame.InternalMargin;
						InternalMargin internalMargin2 = childShape.TextFrame.InternalMargin;
						if (internalMargin2.PropertiesHash.ContainsKey(0))
						{
							internalMargin.Left = internalMargin2.Left;
						}
						if (internalMargin2.PropertiesHash.ContainsKey(1))
						{
							internalMargin.Right = internalMargin2.Right;
						}
						if (internalMargin2.PropertiesHash.ContainsKey(2))
						{
							internalMargin.Top = internalMargin2.Top;
						}
						if (internalMargin2.PropertiesHash.ContainsKey(3))
						{
							internalMargin.Bottom = internalMargin2.Bottom;
						}
					}
				}
			}
			else
			{
				if (childShape.ElementType != EntityType.ChildGroupShape)
				{
					continue;
				}
				for (int k = 0; k < choiceCollection.Count; k++)
				{
					ChildShape childShape3 = choiceCollection[k];
					if (childShape3.ElementType == EntityType.ChildGroupShape && childShape3.Name == childShape.Name)
					{
						UpdateTextBoxFormat((childShape3 as ChildGroupShape).ChildShapes, (childShape as ChildGroupShape).ChildShapes);
					}
				}
			}
		}
	}

	private bool IsChoiceItemNotAdded(ParagraphItem item)
	{
		if (!(item is Shape))
		{
			return true;
		}
		if ((item as Shape).AutoShapeType == AutoShapeType.Rectangle)
		{
			return (item as Shape).TextBody.Count > 0;
		}
		return false;
	}

	private bool GetShapeLineFillType(Shape shape)
	{
		LineFormatType lineFormatType = shape.LineFormat.LineFormatType;
		if ((uint)(lineFormatType - 1) <= 2u)
		{
			return true;
		}
		return false;
	}

	private void ImportDocxPropsAndXMLRelation(Shape shape, ParagraphItem item, Stream shapeStream)
	{
		shape.DocxProps.Add("pict", shapeStream);
		if (!(item is Shape))
		{
			return;
		}
		Shape shape2 = item as Shape;
		shape.Docx2007Props = shape2.Docx2007Props;
		if (shape.LineFormat.Color.IsEmpty && !shape2.LineFormat.Color.IsEmpty)
		{
			shape.LineFormat.Color = shape2.LineFormat.Color;
		}
		if (shape.FillFormat.Color.IsEmpty && !shape2.FillFormat.Color.IsEmpty)
		{
			shape.FillFormat.Color = shape2.FillFormat.Color;
		}
		if (shape.FillFormat.ForeColor.IsEmpty && !shape2.FillFormat.ForeColor.IsEmpty)
		{
			shape.FillFormat.ForeColor = shape2.FillFormat.ForeColor;
		}
		string[] array = new string[shape2.ImageRelations.Count];
		(item as Shape).ImageRelations.Keys.CopyTo(array, 0);
		for (int i = 0; i < array.Length; i++)
		{
			if (!shape.ImageRelations.ContainsKey(array[i]))
			{
				shape.ImageRelations.Add(array[i], shape2.ImageRelations[array[i]]);
			}
		}
		array = new string[shape2.Relations.Count];
		shape2.Relations.Keys.CopyTo(array, 0);
		for (int j = 0; j < array.Length; j++)
		{
			if (!shape.Relations.ContainsKey(array[j]))
			{
				shape.Relations.Add(array[j], shape2.Relations[array[j]]);
			}
		}
	}

	private void ImportDocxPropsAndXMLRelation(GroupShape shape, ParagraphItem item, Stream shapeStream)
	{
		shape.DocxProps.Add("pict", shapeStream);
		if (!(item is GroupShape))
		{
			return;
		}
		GroupShape groupShape = item as GroupShape;
		if (shape.LineFormat.Color.IsEmpty && !groupShape.LineFormat.Color.IsEmpty)
		{
			shape.LineFormat.Color = groupShape.LineFormat.Color;
		}
		if (shape.FillFormat.Color.IsEmpty && !groupShape.FillFormat.Color.IsEmpty)
		{
			shape.FillFormat.Color = groupShape.FillFormat.Color;
		}
		if (shape.FillFormat.ForeColor.IsEmpty && !groupShape.FillFormat.ForeColor.IsEmpty)
		{
			shape.FillFormat.ForeColor = groupShape.FillFormat.ForeColor;
		}
		string[] array = new string[groupShape.ImageRelations.Count];
		(item as GroupShape).ImageRelations.Keys.CopyTo(array, 0);
		for (int i = 0; i < array.Length; i++)
		{
			if (!shape.ImageRelations.ContainsKey(array[i]))
			{
				shape.ImageRelations.Add(array[i], groupShape.ImageRelations[array[i]]);
			}
		}
		array = new string[groupShape.Relations.Count];
		groupShape.Relations.Keys.CopyTo(array, 0);
		for (int j = 0; j < array.Length; j++)
		{
			if (!shape.Relations.ContainsKey(array[j]))
			{
				shape.Relations.Add(array[j], groupShape.Relations[array[j]]);
			}
		}
	}

	private ParagraphItem ParseAbsoluteTab(XmlReader reader)
	{
		string attribute = reader.GetAttribute("relativeTo", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string attribute2 = reader.GetAttribute("alignment", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string attribute3 = reader.GetAttribute("leader", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		WAbsoluteTab wAbsoluteTab = new WAbsoluteTab(m_doc);
		if (!string.IsNullOrEmpty(attribute))
		{
			string text = attribute.ToLower();
			if (!(text == "margin"))
			{
				if (text == "indent")
				{
					wAbsoluteTab.Relation = AbsoluteTabRelation.Indent;
				}
			}
			else
			{
				wAbsoluteTab.Relation = AbsoluteTabRelation.Margin;
			}
		}
		if (!string.IsNullOrEmpty(attribute2))
		{
			switch (attribute2.ToLower())
			{
			case "left":
				wAbsoluteTab.Alignment = AbsoluteTabAlignment.Left;
				break;
			case "right":
				wAbsoluteTab.Alignment = AbsoluteTabAlignment.Right;
				break;
			case "center":
				wAbsoluteTab.Alignment = AbsoluteTabAlignment.Center;
				break;
			}
		}
		wAbsoluteTab.TabLeader = GetTabLeader(attribute3);
		wAbsoluteTab.CharacterFormat = m_currentRunFormat;
		ApplyDirectionalOverride(wAbsoluteTab.CharacterFormat);
		return wAbsoluteTab;
	}

	private void ParseFieldMark(XmlReader reader, ParagraphItemCollection paraItems, IOfficeMathRunElement mathRunElement)
	{
		string attribute = reader.GetAttribute("fldCharType", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == null)
		{
			return;
		}
		Stream stream = ReadSingleNodeIntoStream(reader);
		if (HasFFData(stream))
		{
			XmlReader reader2 = UtilityMethods.CreateReader(stream);
			ParseFieldData(reader2, paraItems);
			return;
		}
		switch (attribute)
		{
		case "begin":
			InitFieldMarkBegin(paraItems, mathRunElement);
			break;
		case "separate":
			ProcessFieldMarkSeperator(paraItems, mathRunElement);
			break;
		case "end":
			ProcessFieldMarkEnd(paraItems, mathRunElement);
			break;
		}
	}

	private bool HasFFData(Stream fieldNode)
	{
		if (IsWord2003ML)
		{
			return false;
		}
		XmlReader xmlReader = UtilityMethods.CreateReader(fieldNode);
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == "ffData")
			{
				return true;
			}
		}
		return false;
	}

	private bool HasOleObject(Stream fieldNode)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(fieldNode);
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == "OLEObject")
			{
				return true;
			}
		}
		return false;
	}

	private void ProcessFieldMarkSeperator(ParagraphItemCollection paraItems, IOfficeMathRunElement mathRunElement)
	{
		if (CurrentField != null)
		{
			WFieldMark wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
			if (m_currentRunFormat != null)
			{
				wFieldMark.CharacterFormat.ImportContainer(m_currentRunFormat);
				ApplyDirectionalOverride(wFieldMark.CharacterFormat);
			}
			if (mathRunElement != null)
			{
				mathRunElement.Item = wFieldMark;
			}
			else
			{
				AddItem(wFieldMark, paraItems);
			}
			CheckTrackChange(wFieldMark);
			WField currentField = CurrentField;
			if (currentField != null)
			{
				currentField.FieldSeparator = wFieldMark;
			}
		}
	}

	private void ProcessFieldMarkEnd(ParagraphItemCollection paraItems, IOfficeMathRunElement mathRunElement)
	{
		if (CurrentField == null)
		{
			return;
		}
		WFieldMark wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
		if (m_currentRunFormat != null)
		{
			wFieldMark.CharacterFormat.ImportContainer(m_currentRunFormat);
			ApplyDirectionalOverride(wFieldMark.CharacterFormat);
		}
		if (mathRunElement != null)
		{
			mathRunElement.Item = wFieldMark;
		}
		else
		{
			AddItem(wFieldMark, paraItems);
		}
		CheckTrackChange(wFieldMark);
		if (CurrentField != null)
		{
			WField currentField = CurrentField;
			currentField.FieldEnd = wFieldMark;
			m_doc.UpdateFieldRevision(currentField);
			if (currentField.IsFieldWithoutSeparator && currentField.FieldSeparator != null)
			{
				currentField.RemoveFieldSeparator(wFieldMark);
				currentField.FieldSeparator = null;
			}
			if (currentField.FieldType == FieldType.FieldUnknown)
			{
				UpdateFieldType(currentField, wFieldMark);
			}
			if (m_fieldStack != null && m_fieldStack.Count > 0)
			{
				WField wField = m_fieldStack.Pop();
				if (wField.FieldType != FieldType.FieldTOC)
				{
					wField.UpdateFieldCode(wField.GetFieldCodeForUnknownFieldType());
				}
				if (wField.FieldType == FieldType.FieldDate || wField.FieldType == FieldType.FieldTime)
				{
					wField.Update();
				}
			}
		}
		m_currentRunFormat = null;
	}

	private void InitFieldMarkBegin(ParagraphItemCollection paraItems, IOfficeMathRunElement mathRunElement)
	{
		WField wField = new WField(m_doc);
		wField.FieldType = FieldType.FieldUnknown;
		if (m_currentRunFormat != null)
		{
			wField.ApplyCharacterFormat(m_currentRunFormat);
			ApplyDirectionalOverride(wField.CharacterFormat);
		}
		if (mathRunElement != null)
		{
			mathRunElement.Item = wField;
		}
		else
		{
			AddToParagraph(wField, paraItems);
		}
		CheckTrackChange(wField);
		FieldStack.Push(wField);
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 18);
	}

	private void UpdateFieldType(WField parentField, WFieldMark fieldMark)
	{
		parentField.SetUnknownFieldType();
		if (parentField.FieldType != FieldType.FieldUnknown)
		{
			if (parentField.FieldType == FieldType.FieldTOC)
			{
				parentField.ReplaceAsTOCField();
			}
			else if (parentField.FieldType == FieldType.FieldIf || parentField.FieldType == FieldType.FieldMergeField || parentField.IsFormField() || parentField.FieldType == FieldType.FieldSequence)
			{
				parentField = parentField.ReplaceValidField();
				FieldStack.Pop();
				FieldStack.Push(parentField);
			}
		}
	}

	private void AppendPageFieldForPgNum(ParagraphItemCollection paraItems)
	{
		WField wField = new WField(m_doc);
		wField.SetFieldTypeValue(FieldType.FieldPage);
		wField.m_fieldValue = "";
		paraItems.Add(wField);
		WTextRange wTextRange = new WTextRange(m_doc);
		wTextRange.Text = FieldTypeDefiner.GetFieldCode(FieldType.FieldPage) + " ";
		paraItems.Add(wTextRange);
		wTextRange.ApplyCharacterFormat(m_currentRunFormat);
		WFieldMark wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldSeparator);
		paraItems.Add(wFieldMark);
		wField.FieldSeparator = wFieldMark;
		wTextRange = new WTextRange(m_doc);
		paraItems.Add(wTextRange);
		WFieldMark wFieldMark2 = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
		paraItems.Add(wFieldMark2);
		wField.FieldEnd = wFieldMark2;
		wField.IsPgNum = true;
		wField.ApplyCharacterFormat(m_currentRunFormat);
	}

	private void ParseFieldData(XmlReader reader, ParagraphItemCollection paraItems)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		reader.MoveToContent();
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "ffData")
				{
					if (reader.IsEmptyElement)
					{
						continue;
					}
					localName = reader.LocalName;
					Stream stream = ReadSingleNodeIntoStream(reader);
					if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
					{
						continue;
					}
					WFormField formField = GetFormField(stream);
					if (formField != null)
					{
						FieldStack.Push(formField);
						stream.Position = 0L;
						XmlReader reader2 = UtilityMethods.CreateReader(stream);
						ParseFormField(reader2, formField);
						if (m_currentRunFormat != null)
						{
							formField.ApplyCharacterFormat(m_currentRunFormat);
							ApplyDirectionalOverride(formField.CharacterFormat);
						}
						m_currentRunFormat = null;
						AddToParagraph(formField, paraItems);
						CheckTrackChange(formField);
					}
				}
				else
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseFormField(XmlReader reader, WFormField formField)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		reader.MoveToContent();
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "checkBox":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 9);
					ParseCheckBox(reader, formField as WCheckBox);
					break;
				case "textInput":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 14);
					ParseTextInput(reader, formField as WTextFormField);
					break;
				case "ddList":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 15);
					ParseDropDown(reader, formField as WDropDownFormField);
					break;
				case "name":
					formField.Name = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "enabled":
					formField.Enabled = GetBooleanValue(reader);
					break;
				case "calcOnExit":
					formField.CalculateOnExit = GetBooleanValue(reader);
					break;
				case "helpText":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute))
					{
						formField.Help = attribute;
					}
					break;
				}
				case "statusText":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute2))
					{
						formField.StatusBarHelp = attribute2;
					}
					break;
				}
				case "entryMacro":
					formField.MacroOnStart = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "exitMacro":
					formField.MacroOnEnd = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseDropDown(XmlReader reader, WDropDownFormField dropDownFormField)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		reader.MoveToContent();
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "listEntry":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					dropDownFormField.DropDownItems.Add(attribute2);
					break;
				}
				case "result":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute3))
					{
						dropDownFormField.DropDownSelectedIndex = (int)GetNumericValue(attribute3);
					}
					break;
				}
				case "default":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute))
					{
						dropDownFormField.DefaultDropDownValue = (int)GetNumericValue(attribute);
					}
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseTextInput(XmlReader reader, WTextFormField textFormField)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		reader.MoveToContent();
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "type":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					textFormField.SetTextFormFieldType(GetTextFieldType(attribute3));
					break;
				}
				case "default":
					textFormField.DefaultText = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "maxLength":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute2))
					{
						float result = 0f;
						if (float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							textFormField.MaximumLength = (int)result;
						}
						else
						{
							textFormField.MaximumLength = ((attribute2.Trim(ControlChar.SpaceChar) == string.Empty) ? 1 : "\u2002\u2002\u2002\u2002\u2002".Length);
						}
					}
					break;
				}
				case "format":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (textFormField.Type == TextFormFieldType.RegularText)
					{
						textFormField.TextFormat = GetTextFormat(attribute);
					}
					else
					{
						textFormField.StringFormat = attribute;
					}
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private TextFormat GetTextFormat(string format)
	{
		if (!string.IsNullOrEmpty(format))
		{
			switch (format.ToUpper())
			{
			case "UPPERCASE":
			case "UPPER CASE":
				return TextFormat.Uppercase;
			case "LOWERCASE":
			case "LOWER CASE":
				return TextFormat.Lowercase;
			case "FIRSTCAPITAL":
			case "FIRST CAPITAL":
				return TextFormat.FirstCapital;
			case "TITLECASE":
			case "TITLE CASE":
				return TextFormat.Titlecase;
			default:
				return TextFormat.None;
			}
		}
		return TextFormat.None;
	}

	private TextFormFieldType GetTextFieldType(string type)
	{
		return type switch
		{
			"number" => TextFormFieldType.NumberText, 
			"currentDate" => TextFormFieldType.CurrentDateText, 
			"currentTime" => TextFormFieldType.CurrentTimeText, 
			"date" => TextFormFieldType.DateText, 
			"calculated" => TextFormFieldType.Calculation, 
			_ => TextFormFieldType.RegularText, 
		};
	}

	private void ParseCheckBox(XmlReader reader, WCheckBox checkBox)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		reader.MoveToContent();
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sizeAuto":
				{
					bool booleanValue = GetBooleanValue(reader);
					checkBox.SizeType = ((!booleanValue) ? CheckBoxSizeType.Exactly : CheckBoxSizeType.Auto);
					break;
				}
				case "default":
					checkBox.DefaultCheckBoxValue = GetBooleanValue(reader);
					break;
				case "checked":
					checkBox.Checked = GetBooleanValue(reader);
					break;
				case "size":
				{
					float result = 0f;
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute))
					{
						if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							checkBox.SetCheckBoxSizeValue((int)result / 2);
							checkBox.SizeType = CheckBoxSizeType.Exactly;
						}
						else
						{
							checkBox.SizeType = CheckBoxSizeType.Auto;
						}
					}
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private WFormField GetFormField(Stream ffDataStream)
	{
		ffDataStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(ffDataStream);
		while (xmlReader.Read())
		{
			switch (xmlReader.LocalName)
			{
			case "checkBox":
				return new WCheckBox(m_doc);
			case "ddList":
				return new WDropDownFormField(m_doc);
			case "textInput":
				return new WTextFormField(m_doc);
			}
		}
		return new WTextFormField(m_doc);
	}

	private WFootnote Parse2003FootnotePart(XmlReader reader, bool isFootnote)
	{
		if (isFootnote)
		{
			WFootnote wFootnote = new WFootnote(m_doc);
			ParseBody(reader, wFootnote, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
			return wFootnote;
		}
		WFootnote wFootnote2 = new WFootnote(m_doc);
		wFootnote2.FootnoteType = FootnoteType.Endnote;
		ParseBody(reader, wFootnote2, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
		return wFootnote2;
	}

	private void ParseFootnotePart(bool isFootnote)
	{
		string empty = string.Empty;
		empty = (isFootnote ? "footnotes.xml" : "endnotes.xml");
		m_currentFile = empty + ".rels";
		Part part = FindPart("word/", empty);
		if (part == null)
		{
			return;
		}
		XmlReader xmlReader = UtilityMethods.CreateReader(part.DataStream);
		xmlReader.MoveToContent();
		string empty2 = string.Empty;
		string empty3 = string.Empty;
		do
		{
			xmlReader.Read();
			empty2 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
			empty3 = xmlReader.GetAttribute("type", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
			if (string.IsNullOrEmpty(empty2))
			{
				continue;
			}
			if (empty3 != null && empty3 != string.Empty && empty3 != "normal")
			{
				if (isFootnote)
				{
					switch (empty3)
					{
					case "separator":
						m_doc.Footnotes.Separator = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Footnotes.Separator, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					case "continuationSeparator":
						m_doc.Footnotes.ContinuationSeparator = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Footnotes.ContinuationSeparator, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					case "continuationNotice":
						m_doc.Footnotes.ContinuationNotice = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Footnotes.ContinuationNotice, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					}
				}
				else
				{
					switch (empty3)
					{
					case "separator":
						m_doc.Endnotes.Separator = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Endnotes.Separator, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					case "continuationSeparator":
						m_doc.Endnotes.ContinuationSeparator = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Endnotes.ContinuationSeparator, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					case "continuationNotice":
						m_doc.Endnotes.ContinuationNotice = new WTextBody(m_doc, null);
						ParseBody(xmlReader, m_doc.Endnotes.ContinuationNotice, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
						break;
					}
				}
			}
			else
			{
				WFootnote wFootnote = new WFootnote(m_doc);
				ParseBody(xmlReader, wFootnote, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
				DictionaryEntry item = new DictionaryEntry(empty2, wFootnote);
				if (isFootnote)
				{
					Footnote.Add(item);
					continue;
				}
				wFootnote.FootnoteType = FootnoteType.Endnote;
				Endnote.Add(item);
			}
		}
		while (!xmlReader.EOF);
		m_currentFile = "";
	}

	private WFootnote ParseFootnote(XmlReader reader)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace);
		string attribute2 = reader.GetAttribute("customMarkFollows", IsStrict ? m_strictNameSpace : m_nameSpace);
		bool flag = true;
		string localName = reader.LocalName;
		bool flag2 = StartsWithExt(localName, "footnote");
		if (attribute == null)
		{
			return null;
		}
		int bitPosition = (flag2 ? 21 : 17);
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, bitPosition);
		if (attribute2 != null)
		{
			flag = attribute2 == "0";
		}
		WFootnote footnote = GetFootnote(flag2, attribute);
		if (!flag)
		{
			ParseFootnoteSymbol(reader, footnote);
		}
		return footnote;
	}

	private WFootnote GetFootnote(bool isFootnote, string id)
	{
		WFootnote result = null;
		if (isFootnote)
		{
			int i = 0;
			for (int count = Footnote.Count; i < count; i++)
			{
				if (Footnote[i].Key.ToString() == id)
				{
					result = (WFootnote)Footnote[i].Value;
					break;
				}
			}
		}
		else
		{
			int j = 0;
			for (int count2 = Endnote.Count; j < count2; j++)
			{
				if (Endnote[j].Key.ToString() == id)
				{
					result = (WFootnote)Endnote[j].Value;
					break;
				}
			}
		}
		return result;
	}

	private void ParseFootnoteSymbol(XmlReader reader, WFootnote footnote)
	{
		footnote.IsAutoNumbered = false;
		SkipWhitespaces(reader);
		MoveToNextLine(reader);
		string attribute = reader.GetAttribute("font", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string attribute2 = reader.GetAttribute("char", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string text = reader.ReadInnerXml();
		if (attribute != null && attribute2 != null)
		{
			footnote.SymbolFontName = attribute;
			attribute2 = attribute2.Replace("F0", string.Empty);
			byte symbolCode = byte.Parse(attribute2, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
			footnote.SymbolCode = symbolCode;
		}
		else if (text != null)
		{
			footnote.CustomMarker = text;
		}
	}

	private void MoveToNextLine(XmlReader reader)
	{
		do
		{
			reader.Read();
		}
		while (reader.LocalName == string.Empty || reader.NodeType == XmlNodeType.Whitespace);
	}

	private WTextRange ParseFootnoteMarker()
	{
		WTextRange wTextRange = new WTextRange(m_doc);
		wTextRange.Text = '\u0002'.ToString();
		if (m_currentRunFormat != null)
		{
			wTextRange.ApplyCharacterFormat(m_currentRunFormat);
		}
		return wTextRange;
	}

	private ParagraphItem ParseObject(XmlReader reader)
	{
		Stream stream = ReadSingleNodeIntoStream(reader);
		bool flag = HasNode(stream, "control");
		if (HasNode(stream, "OLEObject"))
		{
			m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 29);
			return ParseOleObject(stream);
		}
		if (flag || isResultFromLinkField())
		{
			m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 16);
			stream.Position = 0L;
			return ParseXmlParaItem(stream);
		}
		return null;
	}

	private bool isResultFromLinkField()
	{
		WParagraph wParagraph = m_doc.LastParagraph;
		if ((m_doc.LastParagraph.ChildEntities.Count == 0) & (m_doc.LastParagraph.PreviousSibling is WParagraph))
		{
			wParagraph = m_doc.LastParagraph.PreviousSibling as WParagraph;
		}
		if (wParagraph.ChildEntities.Count != 0)
		{
			if (wParagraph.LastItem is WFieldMark)
			{
				return (wParagraph.LastItem as WFieldMark).Type == FieldMarkType.FieldSeparator;
			}
			return false;
		}
		return false;
	}

	private ParagraphItem ParseOleObject(Stream objectStream)
	{
		WOleObject wOleObject = new WOleObject(m_doc);
		XmlReader xmlReader = UtilityMethods.CreateReader(objectStream);
		if (!xmlReader.IsEmptyElement)
		{
			string localName = xmlReader.LocalName;
			string localName2 = xmlReader.LocalName;
			xmlReader.Read();
			if (!(localName == xmlReader.LocalName) || xmlReader.NodeType != XmlNodeType.EndElement)
			{
				SkipWhitespaces(xmlReader);
				while (xmlReader.LocalName != localName2)
				{
					if (xmlReader.NodeType == XmlNodeType.Element)
					{
						switch (xmlReader.LocalName)
						{
						case "shape":
						case "rect":
						{
							WPicture wPicture = new WPicture(m_doc);
							wPicture.PictureShape.ShapeContainer = new MsofbtSpContainer(m_doc);
							wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtOPT(m_doc));
							wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtTertiaryFOPT(m_doc));
							ParsePictureShapeProperties(xmlReader, wPicture);
							wPicture.IsShape = true;
							wPicture.SetOwner(wOleObject);
							wOleObject.SetOlePicture(wPicture);
							if (m_currentRunFormat != null)
							{
								wPicture.CharacterFormat.ImportContainer(m_currentRunFormat);
								ApplyDirectionalOverride(wPicture.CharacterFormat);
							}
							ParsePictureShapeImage(xmlReader, wPicture, xmlReader.LocalName, isAlreadyRead: false, isAlreadyChecked: false);
							break;
						}
						case "OLEObject":
							ParseOleData(xmlReader, wOleObject);
							break;
						}
						xmlReader.Read();
					}
					else
					{
						xmlReader.Read();
					}
				}
				return wOleObject;
			}
			return null;
		}
		return null;
	}

	private void ParseOlePictureWrapStyle(XmlReader reader, WPicture picture)
	{
		switch (reader.GetAttribute("type").ToLower())
		{
		case "square":
			picture.SetTextWrappingStyleValue(TextWrappingStyle.Square);
			break;
		case "through":
			picture.SetTextWrappingStyleValue(TextWrappingStyle.Through);
			break;
		case "tight":
			picture.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
			break;
		case "topandbottom":
			picture.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
			break;
		}
	}

	private void ParseOleData(XmlReader reader, WOleObject oleObject)
	{
		if (reader.LocalName != "OLEObject")
		{
			throw new XmlException("OLE Object data");
		}
		string attribute = reader.GetAttribute("Type");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "Link")
			{
				oleObject.SetLinkType(OleLinkType.Link);
			}
			else
			{
				oleObject.SetLinkType(OleLinkType.Embed);
			}
		}
		string attribute2 = reader.GetAttribute("ProgID");
		if (!string.IsNullOrEmpty(attribute2))
		{
			oleObject.ObjectType = attribute2;
		}
		string attribute3 = reader.GetAttribute("ObjectID");
		if (!string.IsNullOrEmpty(attribute3))
		{
			oleObject.OleStorageName = attribute3.Replace("_", string.Empty);
		}
		string attribute4 = reader.GetAttribute("DrawAspect");
		if (!string.IsNullOrEmpty(attribute4) && attribute4 == "Content")
		{
			oleObject.DisplayAsIcon = false;
		}
		string attribute5 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		string attribute6 = reader.GetAttribute("UpdateMode");
		if (!string.IsNullOrEmpty(attribute6))
		{
			if (attribute6.ToLower() == "oncall")
			{
				oleObject.UpdateMode = UpdateMode.OnCall;
			}
			else
			{
				oleObject.UpdateMode = UpdateMode.Always;
			}
		}
		if (oleObject.LinkType == OleLinkType.Embed)
		{
			Part olePart = GetOlePart(attribute5);
			if (olePart != null)
			{
				olePart.DataStream.Position = 0L;
				if (!m_doc.Settings.PreserveOleImageAsImage || !(oleObject.ObjectType == "PBrush") || oleObject.LinkType != 0 || oleObject.DisplayAsIcon)
				{
					oleObject.ParseOlePartStream(olePart.DataStream);
				}
				ClearParsedImage(olePart.Name, "word/embeddings/");
			}
		}
		else
		{
			oleObject.SetLinkPathValue(GetOleLinkPath(attribute5));
		}
	}

	private Part GetOlePart(string oleId)
	{
		Dictionary<string, DictionaryEntry> dictionary = ((StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer")) ? GetFileRelations(m_currentFile) : m_docRelations);
		DictionaryEntry dictionaryEntry = default(DictionaryEntry);
		if (dictionary != null && dictionary.ContainsKey(oleId))
		{
			dictionaryEntry = dictionary[oleId];
		}
		string fileName = ((dictionaryEntry.Value != null) ? dictionaryEntry.Value.ToString() : null);
		if (fileName == null)
		{
			return null;
		}
		string partName = GetPartName(ref fileName);
		return FindPart(partName, fileName);
	}

	private string GetOleLinkPath(string id)
	{
		string text = null;
		if (m_docRelations.ContainsKey(id))
		{
			text = m_docRelations[id].Value.ToString();
		}
		return text?.Replace("file:///", string.Empty);
	}

	private bool IsNativeDataInside(OleObjectType type)
	{
		bool result = false;
		if (type == OleObjectType.Excel_97_2003_Worksheet || type == OleObjectType.ExcelBinaryWorksheet || type == OleObjectType.ExcelChart || type == OleObjectType.ExcelMacroWorksheet || type == OleObjectType.ExcelWorksheet || type == OleObjectType.PowerPoint_97_2003_Presentation || type == OleObjectType.PowerPoint_97_2003_Slide || type == OleObjectType.PowerPointMacroPresentation || type == OleObjectType.PowerPointMacroSlide || type == OleObjectType.PowerPointPresentation || type == OleObjectType.PowerPointSlide || type == OleObjectType.VisioDrawing || type == OleObjectType.Word_97_2003_Document || type == OleObjectType.WordDocument || type == OleObjectType.WordMacroDocument)
		{
			result = true;
		}
		return result;
	}

	private bool HasNode(Stream objectStream, string elementName)
	{
		objectStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(objectStream);
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == elementName)
			{
				objectStream.Position = 0L;
				return true;
			}
		}
		objectStream.Position = 0L;
		return false;
	}

	private ParagraphItem ParseShape(XmlReader reader, ParagraphItemCollection paraItems, MemoryStream drawingStream, MemoryStream shapeStream, ParagraphItem choiceItem)
	{
		shapeStream.Position = 0L;
		AutoShapeType autoShapeType = AutoShapeType.Unknown;
		Dictionary<string, Stream> docxProps = new Dictionary<string, Stream>();
		string shapeTypeId = null;
		ShapeType shapeType = DetectShapeType(shapeStream, ref autoShapeType, ref docxProps, ref shapeTypeId, choiceItem);
		Entity entity = paraItems?.Owner;
		if (shapeType == ShapeType.WatermarkShape && entity != null && !(entity.GetBaseEntity(entity) is HeaderFooter))
		{
			shapeType = ShapeType.PictureShape;
		}
		shapeStream.Position = 0L;
		XmlReader reader2 = UtilityMethods.CreateReader(shapeStream);
		if ((autoShapeType != AutoShapeType.Unknown || (shapeType == ShapeType.XmlParagraphItem && IsVMLCustomShape(autoShapeType, shapeStream))) && (autoShapeType != AutoShapeType.Rectangle || shapeType != 0))
		{
			m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 6);
			Shape shape = ParseShape(shapeStream, drawingStream);
			shape.Docx2007Props = docxProps;
			for (int i = 1; i <= docxProps.Count; i++)
			{
				if (shape.Docx2007Props.ContainsKey("shadow" + i))
				{
					ParseDocx2007ShadowEffect(shape, shape.Docx2007Props["shadow" + i]);
				}
				if (shape.Docx2007Props.ContainsKey("extrusion"))
				{
					ParseDocx2007Extrusion(shape, shape.Docx2007Props["extrusion"]);
				}
			}
			shape.ShapeTypeID = shapeTypeId;
			ParseXMLRelations(shape, shapeStream);
			shape.DocxProps.Add("pict", shapeStream);
			if (drawingStream == null)
			{
				shape.Is2007Shape = true;
			}
			shape.AutoShapeType = autoShapeType;
			if (shape.Is2007Shape)
			{
				shape.VMLPathPoints = shape.Parse2007CustomShapePoints(shape.Path);
				if (shape.VMLPathPoints == null && (shape.Path != null || shape.Adjustments != null))
				{
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 10);
				}
			}
			return shape;
		}
		switch (shapeType)
		{
		case ShapeType.TextboxShape:
			return ParseTextboxShape(shapeStream, drawingStream);
		case ShapeType.PictureShape:
			m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 31);
			return ParsePictureShape(shapeStream);
		case ShapeType.WatermarkShape:
			ParseWatermark(shapeStream, paraItems);
			return null;
		case ShapeType.OleObject:
			return ParseOleObject(shapeStream);
		case ShapeType.GroupedShape:
		{
			GroupShape groupShape = new GroupShape(m_doc);
			groupShape.InitializeVMLDefaultValues();
			groupShape.ApplyCharacterFormat(m_currentRunFormat);
			ApplyDirectionalOverride(groupShape.GetCharFormat());
			if (drawingStream == null)
			{
				groupShape.Is2007Shape = true;
			}
			Parse2007GroupShape(reader2, groupShape);
			return groupShape;
		}
		default:
			if (IsWord2003ML)
			{
				return null;
			}
			if (shapeType == ShapeType.XmlParagraphItem && (choiceItem == null || !(choiceItem is Shape)))
			{
				m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 10);
			}
			shapeStream.Position = 0L;
			return ParseXmlParaItem(shapeStream);
		}
	}

	private bool IsVMLCustomShape(AutoShapeType shapeType, MemoryStream shapeStream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(shapeStream);
		xmlReader.ReadToFollowing("shape", "urn:schemas-microsoft-com:vml");
		if (shapeType == AutoShapeType.Unknown && xmlReader.GetAttribute("path") != null)
		{
			return true;
		}
		return false;
	}

	private void ParseDocx2007Extrusion(Shape shape, Stream extrusionStream)
	{
		EffectFormat effectFormat = new EffectFormat(shape);
		effectFormat.IsShapeProperties = true;
		extrusionStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(extrusionStream);
		if (xmlReader.HasAttributes)
		{
			string text = null;
			text = xmlReader.GetAttribute("v:ext");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Extension = text;
			}
			text = xmlReader.GetAttribute("color");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.ExtrusionColor = GetColorValue(text);
			}
			text = xmlReader.GetAttribute("colormode");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.ColorMode = text;
			}
			text = xmlReader.GetAttribute("on");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Visible = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("metal");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Metal = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("lightharsh");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LightHarsh = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("lightharsh2");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LightHarsh2 = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("lightface");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LightFace = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("lockrotationcenter");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LockRotationCenter = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("autorotationcenter");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.AutoRotationCenter = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("rotationangle");
			if (!string.IsNullOrEmpty(text))
			{
				ParseExtrusionAxis(effectFormat, text, "rotationangle");
			}
			text = xmlReader.GetAttribute("orientationangle");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.OrientationAngle = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.OrientationAngle = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("orientation");
			if (!string.IsNullOrEmpty(text))
			{
				ParseExtrusionAxis(effectFormat, text, "orientation");
			}
			text = xmlReader.GetAttribute("viewpoint");
			if (!string.IsNullOrEmpty(text))
			{
				ParseExtrusionAxis(effectFormat, text, "viewpoint");
			}
			text = xmlReader.GetAttribute("viewpointorigin");
			if (!string.IsNullOrEmpty(text))
			{
				ParseExtrusionAxis(effectFormat, text, "viewpointorigin");
			}
			text = xmlReader.GetAttribute("skewangle");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.SkewAngle = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.SkewAngle = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("skewamt");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.SkewAmount = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.SkewAmount = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("shininess");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.Shininess = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.Shininess = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("lightposition");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.Contains(","))
				{
					if (StartsWithExt(text, ",") && text.IndexOf(',') == text.LastIndexOf(','))
					{
						text = text.Substring(1);
						if (text.EndsWith("%"))
						{
							effectFormat.ThreeDFormat.LightRigRotationY = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotationY = GetEffectsPointValue(text);
						}
					}
					else if (text.EndsWith(",") && text.IndexOf(',') == text.LastIndexOf(','))
					{
						text = text.Substring(0, text.Length - 1);
						if (text.EndsWith("%"))
						{
							effectFormat.ThreeDFormat.LightRigRotationX = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotationX = GetEffectsPointValue(text);
						}
					}
					else
					{
						ParseExtrusionAxis(effectFormat, text, "lightposition");
					}
				}
				else if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.LightRigRotationX = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.LightRigRotationX = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("lightposition2");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.Contains(","))
				{
					if (StartsWithExt(text, ",") && text.IndexOf(',') == text.LastIndexOf(','))
					{
						text = text.Substring(1);
						if (text.EndsWith("%"))
						{
							effectFormat.ThreeDFormat.LightRigRotation2Y = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotation2Y = GetEffectsPointValue(text);
						}
					}
					else if (text.EndsWith(",") && text.IndexOf(',') == text.LastIndexOf(','))
					{
						text = text.Substring(0, text.Length - 1);
						if (text.EndsWith("%"))
						{
							effectFormat.ThreeDFormat.LightRigRotation2X = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else
						{
							effectFormat.ThreeDFormat.LightRigRotation2X = GetEffectsPointValue(text);
						}
					}
					else
					{
						ParseExtrusionAxis(effectFormat, text, "lightposition2");
					}
				}
				else if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.LightRigRotation2X = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.LightRigRotation2X = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("rotationcenter");
			if (!string.IsNullOrEmpty(text))
			{
				ParseExtrusionAxis(effectFormat, text, "rotationcenter");
			}
			text = xmlReader.GetAttribute("type");
			if (!string.IsNullOrEmpty(text) && text.Length > 2 && Enum.IsDefined(typeof(ExtrusionType), char.ToUpper(text[0]) + text.Substring(1)))
			{
				effectFormat.ThreeDFormat.ExtrusionType = (ExtrusionType)Enum.Parse(typeof(ExtrusionType), text, ignoreCase: true);
			}
			text = xmlReader.GetAttribute("render");
			if (!string.IsNullOrEmpty(text) && text.Length > 2 && Enum.IsDefined(typeof(ExtrusionRenderMode), char.ToUpper(text[0]) + text.Substring(1)))
			{
				effectFormat.ThreeDFormat.ExtrusionRenderMode = (ExtrusionRenderMode)Enum.Parse(typeof(ExtrusionRenderMode), text, ignoreCase: true);
			}
			text = xmlReader.GetAttribute("plane");
			if (!string.IsNullOrEmpty(text) && text.Length > 2 && Enum.IsDefined(typeof(ExtrusionPlane), char.ToUpper(text[0]) + text.Substring(1)))
			{
				effectFormat.ThreeDFormat.ExtrusionPlane = (ExtrusionPlane)Enum.Parse(typeof(ExtrusionPlane), text, ignoreCase: true);
			}
			text = xmlReader.GetAttribute("specularity");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Specularity = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("brightness");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Brightness = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("lightlevel");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LightLevel = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("lightlevel2");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.LightLevel2 = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("facet");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Facet = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("diffusity");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ThreeDFormat.Diffusity = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("foredepth");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ForeDepth = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ForeDepth = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("backdepth");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.BackDepth = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.BackDepth = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("edge");
			if (!string.IsNullOrEmpty(text))
			{
				if (text.EndsWith("%"))
				{
					effectFormat.ThreeDFormat.Edge = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.Edge = GetEffectsPointValue(text);
				}
			}
		}
		shape.EffectList.Add(effectFormat);
	}

	private float GetPropertyValue(string value)
	{
		float result = 0f;
		if (value.Trim(ControlChar.SpaceChar, '%', 'f') == string.Empty)
		{
			return result;
		}
		if (value.EndsWith("f"))
		{
			float.TryParse(value.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = (float)Math.Round(result / 65536f, 5);
		}
		else if (value.EndsWith("%"))
		{
			result = (float)(GetPercentage(value) * 65536.0 / 100.0);
		}
		else
		{
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		return result;
	}

	private void ParseExtrusionAxis(EffectFormat effectFormat, string value, string attribute)
	{
		List<string> list = new List<string>();
		string[] array = new string[3];
		value = value.Replace(" ", "");
		if (value.Contains(","))
		{
			if (value.IndexOf(',') == value.LastIndexOf(","))
			{
				if (StartsWithExt(value, ","))
				{
					value = value.Insert(0, " ");
				}
				if (value.EndsWith(","))
				{
					value = value.Insert(value.IndexOf(',') + 1, " ");
				}
				array = value.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			}
			else if (value.IndexOf(',') + 1 == value.LastIndexOf(","))
			{
				if (StartsWithExt(value, ","))
				{
					value = value.Insert(0, " ");
					value = value.Insert(value.IndexOf(',') + 1, " ");
				}
				else if (value.EndsWith(","))
				{
					value = value.Insert(value.IndexOf(',') + 1, " ");
					value = value.Insert(value.LastIndexOf(',') + 1, " ");
				}
				else
				{
					value = value.Insert(value.IndexOf(',') + 1, " ");
				}
				array = value.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			}
			else
			{
				if (StartsWithExt(value, ",") && value.EndsWith(","))
				{
					value = value.Insert(0, " ");
					value = value.Insert(value.LastIndexOf(',') + 1, " ");
				}
				else if (StartsWithExt(value, ","))
				{
					value = value.Insert(0, " ");
				}
				else if (value.EndsWith(","))
				{
					value = value.Insert(value.LastIndexOf(',') + 1, " ");
				}
				array = value.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			}
		}
		else
		{
			array[0] = value;
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (text != null)
			{
				list.Add(text);
			}
		}
		if (attribute == null)
		{
			return;
		}
		switch (attribute.Length)
		{
		case 13:
			switch (attribute[0])
			{
			case 'r':
				if (!(attribute == "rotationangle"))
				{
					break;
				}
				if (list.Count > 0 && list[0] != " ")
				{
					if (list[0].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.RotationAngleX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.RotationAngleX = GetEffectsPointValue(list[0]);
					}
				}
				if (list.Count > 1 && list[1] != " ")
				{
					if (list[1].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.RotationAngleY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.RotationAngleY = GetEffectsPointValue(list[1]);
					}
				}
				break;
			case 'l':
				if (!(attribute == "lightposition"))
				{
					break;
				}
				if (list.Count > 0 && list[0] != " ")
				{
					if (list[0].EndsWith("%") && list[0] != " ")
					{
						effectFormat.ThreeDFormat.LightRigRotationX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotationX = GetEffectsPointValue(list[0]);
					}
				}
				if (list.Count > 1 && list[1] != " ")
				{
					if (list[1].EndsWith("%") && list[1] != " ")
					{
						effectFormat.ThreeDFormat.LightRigRotationY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotationY = GetEffectsPointValue(list[1]);
					}
				}
				if (list.Count > 2 && list[2] != " ")
				{
					if (list[2].EndsWith("%") && list[2] != " ")
					{
						effectFormat.ThreeDFormat.LightRigRotationZ = (float)(GetPercentage(list[2]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotationZ = GetEffectsPointValue(list[2]);
					}
				}
				break;
			}
			break;
		case 14:
			switch (attribute[0])
			{
			case 'r':
				if (!(attribute == "rotationcenter"))
				{
					break;
				}
				if (list.Count > 0 && list[0] != " ")
				{
					if (list[0].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.RotationCenterX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.RotationCenterX = GetEffectsPointValue(list[0]);
					}
				}
				if (list.Count > 1 && list[1] != " ")
				{
					if (list[1].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.RotationCenterY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.RotationCenterY = GetEffectsPointValue(list[1]);
					}
				}
				if (list.Count > 2 && list[2] != " ")
				{
					if (list[2].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.RotationCenterZ = (float)(GetPercentage(list[2]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.RotationCenterZ = GetEffectsPointValue(list[2]);
					}
				}
				break;
			case 'l':
				if (!(attribute == "lightposition2"))
				{
					break;
				}
				if (list.Count > 0 && list[0] != " ")
				{
					if (list[0].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.LightRigRotation2X = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotation2X = GetEffectsPointValue(list[0]);
					}
				}
				if (list.Count > 1 && list[1] != " ")
				{
					if (list[1].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.LightRigRotation2Y = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotation2Y = GetEffectsPointValue(list[1]);
					}
				}
				if (list.Count > 2 && list[2] != " ")
				{
					if (list[2].EndsWith("%"))
					{
						effectFormat.ThreeDFormat.LightRigRotation2Z = (float)(GetPercentage(list[2]) * 65536.0 / 100.0);
					}
					else
					{
						effectFormat.ThreeDFormat.LightRigRotation2Z = GetEffectsPointValue(list[2]);
					}
				}
				break;
			}
			break;
		case 11:
			if (!(attribute == "orientation"))
			{
				break;
			}
			if (list.Count > 0 && list[0] != " ")
			{
				if (list[0].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.RotationX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.RotationX = GetEffectsPointValue(list[0]);
				}
			}
			if (list.Count > 1 && list[1] != " ")
			{
				if (list[1].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.RotationY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.RotationY = GetEffectsPointValue(list[1]);
				}
			}
			if (list.Count > 2 && list[2] != " ")
			{
				if (list[2].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.RotationZ = (float)(GetPercentage(list[2]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.RotationZ = GetEffectsPointValue(list[2]);
				}
			}
			break;
		case 9:
			if (!(attribute == "viewpoint"))
			{
				break;
			}
			if (list.Count > 0 && list[0] != " ")
			{
				if (list[0].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ViewPointX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ViewPointX = GetEffectsPointValue(list[0]);
				}
			}
			if (list.Count > 1 && list[1] != " ")
			{
				if (list[1].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ViewPointY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ViewPointY = GetEffectsPointValue(list[1]);
				}
			}
			if (list.Count > 2 && list[2] != " ")
			{
				if (list[2].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ViewPointZ = (float)(GetPercentage(list[2]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ViewPointZ = GetEffectsPointValue(list[2]);
				}
			}
			break;
		case 15:
			if (!(attribute == "viewpointorigin"))
			{
				break;
			}
			if (list.Count > 0 && list[0] != " ")
			{
				if (list[0].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ViewPointOriginX = (float)(GetPercentage(list[0]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ViewPointOriginX = GetEffectsPointValue(list[0]);
				}
			}
			if (list.Count > 1 && list[1] != " ")
			{
				if (list[1].EndsWith("%"))
				{
					effectFormat.ThreeDFormat.ViewPointOriginY = (float)(GetPercentage(list[1]) * 65536.0 / 100.0);
				}
				else
				{
					effectFormat.ThreeDFormat.ViewPointOriginY = GetEffectsPointValue(list[1]);
				}
			}
			break;
		case 10:
		case 12:
			break;
		}
	}

	private void ParseDocx2007ShadowEffect(Shape shape, Stream shadowStream)
	{
		EffectFormat effectFormat = new EffectFormat(shape);
		effectFormat.IsShadowEffect = true;
		shadowStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(shadowStream);
		if (xmlReader.HasAttributes)
		{
			string text = null;
			text = xmlReader.GetAttribute("on");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.Visible = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("color");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.Color = GetColorValue(text);
			}
			text = xmlReader.GetAttribute("color2");
			if (!string.IsNullOrEmpty(text))
			{
				if (text == "shadow add(102)")
				{
					effectFormat.ShadowFormat.Color2 = Color.LightGray;
				}
				else
				{
					effectFormat.ShadowFormat.Color2 = GetColorValue(text);
				}
			}
			text = xmlReader.GetAttribute("id");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.Name = text;
			}
			text = xmlReader.GetAttribute("obscured");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.Obscured = GetBoolValue(text);
			}
			text = xmlReader.GetAttribute("offset");
			if (!string.IsNullOrEmpty(text))
			{
				text = text.Trim(new char[1] { ControlChar.SpaceChar });
				if (text.Contains(","))
				{
					if (StartsWithExt(text, ","))
					{
						text = text.Substring(1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.ShadowOffsetY = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.ShadowOffsetY = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.ShadowOffsetY = GetEffectsPointValue(text);
						}
					}
					else if (text.EndsWith(","))
					{
						text = text.Substring(0, text.Length - 1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.ShadowOffsetX = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.ShadowOffsetX = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.ShadowOffsetX = GetEffectsPointValue(text);
						}
					}
					else
					{
						ParseShadowOffsets(effectFormat, text, "offset");
					}
				}
				else if (text.EndsWith("%"))
				{
					effectFormat.ShadowFormat.ShadowOffsetX = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else if (text.EndsWith("f"))
				{
					text = text.Replace("f", "");
					effectFormat.ShadowFormat.ShadowOffsetX = GetEffectsPointValue(text);
				}
				else
				{
					effectFormat.ShadowFormat.ShadowOffsetX = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("offset2");
			if (!string.IsNullOrEmpty(text))
			{
				text = text.Trim(new char[1] { ControlChar.SpaceChar });
				if (text.Contains(","))
				{
					if (StartsWithExt(text, ","))
					{
						text = text.Substring(1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.ShadowOffset2Y = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.ShadowOffset2Y = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.ShadowOffset2Y = GetEffectsPointValue(text);
						}
					}
					else if (text.EndsWith(","))
					{
						text = text.Substring(0, text.Length - 1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.ShadowOffset2X = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.ShadowOffset2X = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.ShadowOffset2X = GetEffectsPointValue(text);
						}
					}
					else
					{
						ParseShadowOffsets(effectFormat, text, "offset2");
					}
				}
				else if (text.EndsWith("%"))
				{
					effectFormat.ShadowFormat.ShadowOffset2X = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else if (text.EndsWith("f"))
				{
					text = text.Replace("f", "");
					effectFormat.ShadowFormat.ShadowOffset2X = GetEffectsPointValue(text);
				}
				else
				{
					effectFormat.ShadowFormat.ShadowOffset2X = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("origin");
			if (!string.IsNullOrEmpty(text))
			{
				text = text.Trim(new char[1] { ControlChar.SpaceChar });
				if (text.Contains(","))
				{
					if (StartsWithExt(text, ","))
					{
						text = text.Substring(1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.OriginY = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.OriginY = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.OriginY = GetEffectsPointValue(text);
						}
					}
					else if (text.EndsWith(","))
					{
						text = text.Substring(0, text.Length - 1);
						if (text.EndsWith("%"))
						{
							effectFormat.ShadowFormat.OriginX = (float)(GetPercentage(text) * 65536.0 / 100.0);
						}
						else if (text.EndsWith("f"))
						{
							text = text.Replace("f", "");
							effectFormat.ShadowFormat.OriginX = GetEffectsPointValue(text);
						}
						else
						{
							effectFormat.ShadowFormat.OriginX = GetEffectsPointValue(text);
						}
					}
					else
					{
						ParseShadowOffsets(effectFormat, text, "origin");
					}
				}
				else if (text.EndsWith("%"))
				{
					effectFormat.ShadowFormat.OriginX = (float)(GetPercentage(text) * 65536.0 / 100.0);
				}
				else if (text.EndsWith("f"))
				{
					text = text.Replace("f", "");
					effectFormat.ShadowFormat.OriginX = GetEffectsPointValue(text);
				}
				else
				{
					effectFormat.ShadowFormat.OriginX = GetEffectsPointValue(text);
				}
			}
			text = xmlReader.GetAttribute("type");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.ShadowType = GetShadowType(text);
			}
			text = xmlReader.GetAttribute("opacity");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.Transparency = GetPropertyValue(text);
			}
			text = xmlReader.GetAttribute("matrix");
			if (!string.IsNullOrEmpty(text))
			{
				effectFormat.ShadowFormat.ShadowPerspectiveMatrix = text;
			}
		}
		shape.EffectList.Add(effectFormat);
	}

	private void ParseShadowOffsets(EffectFormat effectFormat, string value, string attribute)
	{
		float num = 0f;
		float num2 = 0f;
		string[] array = value.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		num = ((!array[0].EndsWith("%")) ? GetEffectsPointValue(array[0]) : ((float)(GetPercentage(array[0]) * 65536.0 / 100.0)));
		num2 = ((!array[1].EndsWith("%")) ? GetEffectsPointValue(array[1]) : ((float)(GetPercentage(array[1]) * 65536.0 / 100.0)));
		if (attribute == "offset")
		{
			effectFormat.ShadowFormat.ShadowOffsetX = num;
			effectFormat.ShadowFormat.ShadowOffsetY = num2;
		}
		else if (attribute == "offset2")
		{
			effectFormat.ShadowFormat.ShadowOffset2X = num;
			effectFormat.ShadowFormat.ShadowOffset2Y = num2;
		}
		else
		{
			effectFormat.ShadowFormat.OriginX = num;
			effectFormat.ShadowFormat.OriginY = num2;
		}
	}

	private void ParseFillOffsets(FillFormat fillFormat, string value, string attribute)
	{
		float num = 0f;
		float num2 = 0f;
		string[] array = value.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		num = ((!array[0].EndsWith("%")) ? GetEffectsPointValue(array[0]) : ((float)(GetPercentage(array[0]) * 65536.0 / 100.0)));
		num2 = ((!array[1].EndsWith("%")) ? GetEffectsPointValue(array[1]) : ((float)(GetPercentage(array[1]) * 65536.0 / 100.0)));
		if (attribute == "focusposition")
		{
			fillFormat.FocusPositionX = num;
			fillFormat.FocusPositionY = num2;
		}
		else if (attribute == "focussize")
		{
			fillFormat.FocusSizeX = num;
			fillFormat.FocusSizeY = num2;
		}
		else
		{
			fillFormat.PositionX = num;
			fillFormat.PositionY = num2;
		}
	}

	private float GetEffectsPointValue(string value)
	{
		if (StartsWithExt(value, "."))
		{
			value = "0" + value;
		}
		float result = 0f;
		if (value.EndsWith("pt"))
		{
			value = value.Replace("pt", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)(Math.Ceiling((double)result * 10.0) / 10.0);
		}
		if (value.EndsWith("mm"))
		{
			value = value.Replace("mm", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)(Math.Ceiling((double)(result / 25.4f * 72f) * 10.0) / 10.0);
		}
		if (value.EndsWith("px"))
		{
			value = value.Replace("px", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)(Math.Ceiling((double)(result / 4f * 3f) * 10.0) / 10.0);
		}
		if (value.EndsWith("in"))
		{
			value = value.Replace("in", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)Math.Ceiling((double)(result * 72f) * 10.0 / 10.0);
		}
		if (value.EndsWith("cm"))
		{
			value = value.Replace("cm", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)Math.Ceiling((double)(result / 2.54f * 72f) * 10.0 / 10.0);
		}
		if (value.EndsWith("emu"))
		{
			value = value.Replace("emu", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result /= 12700f;
			return (float)(Math.Ceiling((double)result * 10.0) / 10.0);
		}
		if (value.EndsWith("fd"))
		{
			value = value.Replace("fd", string.Empty);
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = result / 32768f / 2f;
			if (!(result < 0f))
			{
				return Math.Abs(result);
			}
			return 360f - Math.Abs(result);
		}
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		return (float)(Math.Ceiling((double)result * 10.0) / 10.0);
	}

	private ShadowType GetShadowType(string value)
	{
		return value.ToLower() switch
		{
			"double" => ShadowType.Double, 
			"shaperelative" => ShadowType.ShapeRelative, 
			"drawingrelative" => ShadowType.DrawingRelative, 
			"emboss" => ShadowType.Emboss, 
			"perspective" => ShadowType.Perspective, 
			"single" => ShadowType.Single, 
			_ => ShadowType.Single, 
		};
	}

	private void ParseXMLRelations(Shape shape, MemoryStream shapeStream)
	{
		List<string> list = FindRelationshipIds(shapeStream);
		if (list.Count <= 0 || m_docRelations == null)
		{
			return;
		}
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			string text = list[i];
			if (ParseImageRelation(shape, text))
			{
				continue;
			}
			DictionaryEntry value = default(DictionaryEntry);
			if (!string.IsNullOrEmpty(m_currentFile))
			{
				Dictionary<string, DictionaryEntry> fileRelations = GetFileRelations(m_currentFile);
				if (fileRelations != null && fileRelations.ContainsKey(text))
				{
					value = fileRelations[text];
				}
			}
			else if (m_docRelations.ContainsKey(text))
			{
				value = m_docRelations[text];
			}
			if (!shape.Relations.ContainsKey(text))
			{
				shape.Relations.Add(text, value);
			}
		}
	}

	private void ParseXMLRelations(GroupShape shape, MemoryStream shapeStream)
	{
		List<string> list = FindRelationshipIds(shapeStream);
		if (list.Count <= 0 || m_docRelations == null)
		{
			return;
		}
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			string text = list[i];
			if (ParseImageRelation(shape, text))
			{
				continue;
			}
			DictionaryEntry value = default(DictionaryEntry);
			if (!string.IsNullOrEmpty(m_currentFile))
			{
				Dictionary<string, DictionaryEntry> fileRelations = GetFileRelations(m_currentFile);
				if (fileRelations != null)
				{
					value = fileRelations[text];
				}
			}
			else if (m_docRelations.ContainsKey(text))
			{
				value = m_docRelations[text];
			}
			if (!shape.Relations.ContainsKey(text))
			{
				shape.Relations.Add(text, value);
			}
		}
	}

	private GroupShape ParseGroupShape(Stream groupShape)
	{
		groupShape.Position = 0L;
		GroupShape groupShape2 = new GroupShape(m_doc);
		groupShape2.ApplyCharacterFormat(m_currentRunFormat);
		ApplyDirectionalOverride(groupShape2.GetCharFormat());
		ParseXMLRelations(groupShape2, groupShape as MemoryStream);
		XmlReader xmlReader = UtilityMethods.CreateReader(groupShape);
		groupShape2.FillFormat.Color = Color.White;
		groupShape2.LineFormat.ForeColor = Color.Black;
		groupShape2.LineFormat.Color = Color.Empty;
		xmlReader.Read();
		ParseShapeBaseProperties(xmlReader, groupShape2, groupShape as MemoryStream);
		Parse2007GroupShape(xmlReader, groupShape2);
		return groupShape2;
	}

	private Shape ParseShape(MemoryStream shapeStream, MemoryStream drawingStream)
	{
		shapeStream.Position = 0L;
		XmlReader reader = UtilityMethods.CreateReader(shapeStream);
		Shape shape = new Shape(m_doc);
		shape.InitializeVMLDefaultValues();
		shape.ApplyCharacterFormat(m_currentRunFormat);
		ApplyDirectionalOverride(shape.GetCharFormat());
		if (drawingStream != null)
		{
			drawingStream.Position = 0L;
			XmlReader reader2 = UtilityMethods.CreateReader(drawingStream);
			ParseDrawingProperties(reader2, shape);
		}
		Parse2007Shape(reader, shape);
		return shape;
	}

	private void Parse2007Shape(XmlReader reader, Shape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (!reader.EOF && reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "shape":
				case "rect":
				case "oval":
				case "line":
				case "roundrect":
					ParseShape2007Properties(reader, shape);
					ParseTextbox(reader, shape);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void Parse2007GroupShape(XmlReader reader, GroupShape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (!reader.EOF && reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "group")
				{
					string attribute = reader.GetAttribute("id");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Name = attribute;
					}
					string attribute2 = reader.GetAttribute("coordsize");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.CoordinateSize = attribute2;
					}
					string text = reader.GetAttribute("coordorigin");
					if (!string.IsNullOrEmpty(text))
					{
						if (text.EndsWith(","))
						{
							text = text.Insert(text.LastIndexOf(',') + 1, " ");
						}
						else if (text.StartsWith(","))
						{
							text = text.Insert(0, " ");
						}
						else if (!text.Contains(","))
						{
							text = text.Insert(text.Length, ",0");
						}
						string[] array = text.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
						shape.CoordinateXOrigin = GetChildShapePointValue(array[0]);
						shape.CoordinateYOrigin = GetChildShapePointValue(array[1]);
					}
					ParseShape2007Properties(reader, shape);
					Parse2007GroupShapeItems(reader, shape);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void Parse2007GroupShapeItems(XmlReader reader, GroupShape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		bool flag = false;
		ChildGroupShape childGroupShape = null;
		while ((!reader.EOF && reader.LocalName != localName2) || (reader.LocalName == localName2 && reader.NodeType == XmlNodeType.Element))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName3 = reader.LocalName;
				if (localName3 != null)
				{
					int length = localName3.Length;
					if (length != 4)
					{
						if (length != 5)
						{
							if (length == 9)
							{
								char c = localName3[0];
								if (c != 'r')
								{
									if (c == 's' && localName3 == "shapetype")
									{
										reader.GetAttribute("id");
										ReadSingleNodeIntoStream(reader);
										flag = true;
									}
								}
								else if (localName3 == "roundrect")
								{
									goto IL_01f3;
								}
							}
						}
						else
						{
							char c = localName3[0];
							if (c != 'g')
							{
								if (c == 's' && localName3 == "shape")
								{
									goto IL_01f3;
								}
							}
							else if (localName3 == "group")
							{
								childGroupShape = new ChildGroupShape(m_doc);
								childGroupShape.ElementType = EntityType.ChildGroupShape;
								childGroupShape.SetOwner(shape);
								if (shape.Is2007Shape)
								{
									childGroupShape.Is2007Shape = true;
								}
								ParseCoordinatesOfNestedGroupShape(reader, childGroupShape);
								ParseShape2007Properties(reader, childGroupShape);
								shape.Add(childGroupShape);
								Parse2007GroupShapeItems(reader, childGroupShape);
							}
						}
					}
					else
					{
						char c = localName3[0];
						if ((uint)c <= 111u)
						{
							if (c != 'l')
							{
								if (c == 'o' && localName3 == "oval")
								{
									goto IL_01f3;
								}
							}
							else if (localName3 == "line")
							{
								goto IL_01f3;
							}
						}
						else if (c != 'r')
						{
							if (c == 'w' && localName3 == "wrap")
							{
								string attribute = reader.GetAttribute("type");
								if (attribute != null && (!(attribute == "none") || shape.WrapFormat.TextWrappingStyle == TextWrappingStyle.Inline))
								{
									shape.WrapFormat.SetTextWrappingStyleValue(GetWrapStyle(attribute));
								}
							}
						}
						else if (localName3 == "rect")
						{
							goto IL_01f3;
						}
					}
				}
				goto IL_04c6;
			}
			reader.Read();
			continue;
			IL_04c6:
			if (!flag)
			{
				reader.Read();
			}
			continue;
			IL_01f3:
			string attribute2 = reader.GetAttribute("type");
			string attribute3 = reader.GetAttribute("id");
			string attribute4 = reader.GetAttribute("alt");
			string localName4 = reader.LocalName;
			string attribute5 = reader.GetAttribute("coordsize");
			string attribute6 = reader.GetAttribute("coordorigin");
			MemoryStream memoryStream = ReadSingleNodeIntoStream(reader);
			ShapeType shapeType = ShapeType.XmlParagraphItem;
			if (!string.IsNullOrEmpty(attribute2) && AutoShapeHelper.GetAutoShapeType(attribute2.Replace("#", "").Replace("_x0000_t", "")) == AutoShapeType.Unknown && (attribute2 == "#_x0000_t75" || attribute2 == "#_x0000_t202"))
			{
				shapeType = DetectShapeType(memoryStream);
			}
			if (localName4 == "shape" && shapeType == ShapeType.PictureShape)
			{
				memoryStream.Position = 0L;
				WPicture wPicture = ParsePictureShape(memoryStream);
				if (!string.IsNullOrEmpty(attribute3))
				{
					wPicture.AlternativeText = attribute3;
				}
				if (!string.IsNullOrEmpty(attribute4))
				{
					wPicture.AlternativeText = attribute4;
				}
				wPicture.SetOwner(shape);
				shape.Add(wPicture);
				memoryStream.Position = 0L;
				ChildShape childShape = shape.ChildShapes[shape.ChildShapes.Count - 1];
				childShape.Type = attribute2;
				if (shape.Is2007Shape)
				{
					childShape.Is2007Shape = true;
				}
				if (!string.IsNullOrEmpty(attribute5))
				{
					childShape.CoordinateSize = attribute5;
				}
				if (!string.IsNullOrEmpty(attribute6))
				{
					GetCoordinateOrigin(attribute6, childShape);
				}
				XmlReader reader2 = UtilityMethods.CreateReader(memoryStream);
				ParseShape2007Properties(reader2, childShape);
				if (childShape.Is2007Shape)
				{
					childShape.VMLPathPoints = childShape.Parse2007CustomShapePoints(childShape.Path);
				}
			}
			else
			{
				memoryStream.Position = 0L;
				XmlReader xmlReader = UtilityMethods.CreateReader(memoryStream);
				ChildShape childShape2 = new ChildShape(m_doc);
				childShape2.ElementType = EntityType.AutoShape;
				childShape2.SetOwner(shape);
				if (shape.Is2007Shape)
				{
					childShape2.Is2007Shape = true;
				}
				if (!string.IsNullOrEmpty(attribute3))
				{
					childShape2.Name = attribute3;
				}
				if (!string.IsNullOrEmpty(attribute4))
				{
					childShape2.AlternativeText = attribute4;
				}
				UpdateAutoShapeType(xmlReader, childShape2, attribute2, localName4, shapeType);
				if (!string.IsNullOrEmpty(attribute5))
				{
					childShape2.CoordinateSize = attribute5;
				}
				if (!string.IsNullOrEmpty(attribute6))
				{
					GetCoordinateOrigin(attribute6, childShape2);
				}
				ParseShape2007Properties(xmlReader, childShape2);
				ParseTextbox(xmlReader, childShape2);
				shape.Add(childShape2);
				if (childShape2.Is2007Shape)
				{
					childShape2.VMLPathPoints = childShape2.Parse2007CustomShapePoints(childShape2.Path);
				}
			}
			flag = true;
			goto IL_04c6;
		}
	}

	private ShapeType DetectShapeType(MemoryStream shapeStream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(shapeStream);
		string text = null;
		string text2 = null;
		string text3 = null;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		xmlReader.Read();
		while (xmlReader.LocalName != "shape" && !xmlReader.EOF)
		{
			SkipWhitespaces(xmlReader);
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "shape":
					text = xmlReader.GetAttribute("type");
					xmlReader.GetAttribute("id");
					break;
				case "imagedata":
					flag = true;
					text2 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					text3 = xmlReader.GetAttribute("href", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					break;
				case "textbox":
					flag2 = true;
					break;
				case "txbxContent":
					flag3 = true;
					xmlReader.Skip();
					break;
				}
			}
			xmlReader.Read();
		}
		if ((flag2 && text == "#_x0000_t202") || (flag2 && flag3 && (text == null || text2 != null)))
		{
			return ShapeType.TextboxShape;
		}
		if (text != null && text == "#_x0000_t75" && flag)
		{
			return ShapeType.PictureShape;
		}
		if ((text3 != null && text3 != string.Empty) || (text2 != null && GetRelation(text2).Key != null))
		{
			return ShapeType.PictureShape;
		}
		return ShapeType.XmlParagraphItem;
	}

	private void UpdateAutoShapeType(XmlReader shapeReader, ChildShape childShape, string shapetype, string node, ShapeType shapeType)
	{
		if (shapeReader.LocalName == "rect")
		{
			childShape.AutoShapeType = AutoShapeType.Rectangle;
		}
		else if (shapeReader.LocalName == "oval")
		{
			childShape.AutoShapeType = AutoShapeType.Oval;
		}
		else if (shapeReader.LocalName == "line")
		{
			childShape.AutoShapeType = AutoShapeType.Line;
		}
		else if (shapeReader.LocalName == "roundrect")
		{
			childShape.AutoShapeType = AutoShapeType.RoundedRectangle;
		}
		else if (!string.IsNullOrEmpty(shapetype))
		{
			childShape.AutoShapeType = AutoShapeHelper.GetAutoShapeType(shapetype.Replace("#", "").Replace("_x0000_t", ""));
			childShape.Type = shapetype;
			if (node == "shape" && shapeType == ShapeType.TextboxShape)
			{
				childShape.AutoShapeType = AutoShapeType.Rectangle;
			}
		}
	}

	private void Parse2007GroupShapeItems(XmlReader reader, ChildGroupShape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		bool flag = false;
		while ((!reader.EOF && reader.LocalName != localName2) || (reader.LocalName == localName2 && reader.NodeType == XmlNodeType.Element))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName3 = reader.LocalName;
				if (localName3 != null)
				{
					int length = localName3.Length;
					if (length != 4)
					{
						if (length != 5)
						{
							if (length == 9)
							{
								char c = localName3[0];
								if (c != 'r')
								{
									if (c == 's' && localName3 == "shapetype")
									{
										reader.GetAttribute("id");
										ReadSingleNodeIntoStream(reader);
										flag = true;
									}
								}
								else if (localName3 == "roundrect")
								{
									goto IL_01c1;
								}
							}
						}
						else
						{
							char c = localName3[0];
							if (c != 'g')
							{
								if (c == 's' && localName3 == "shape")
								{
									goto IL_01c1;
								}
							}
							else if (localName3 == "group")
							{
								ChildGroupShape childGroupShape = new ChildGroupShape(m_doc);
								childGroupShape.ElementType = EntityType.ChildGroupShape;
								childGroupShape.SetOwner(shape);
								if (shape.Is2007Shape)
								{
									childGroupShape.Is2007Shape = true;
								}
								ParseCoordinatesOfNestedGroupShape(reader, childGroupShape);
								ParseShape2007Properties(reader, childGroupShape);
								Parse2007GroupShapeItems(reader, childGroupShape);
								shape.Add(childGroupShape);
							}
						}
					}
					else
					{
						char c = localName3[0];
						if (c != 'l')
						{
							if (c != 'o')
							{
								if (c == 'r' && localName3 == "rect")
								{
									goto IL_01c1;
								}
							}
							else if (localName3 == "oval")
							{
								goto IL_01c1;
							}
						}
						else if (localName3 == "line")
						{
							goto IL_01c1;
						}
					}
				}
				goto IL_0414;
			}
			reader.Read();
			continue;
			IL_0414:
			if (!flag)
			{
				reader.Read();
			}
			continue;
			IL_01c1:
			string attribute = reader.GetAttribute("type");
			string attribute2 = reader.GetAttribute("id");
			string attribute3 = reader.GetAttribute("alt");
			string localName4 = reader.LocalName;
			string attribute4 = reader.GetAttribute("coordsize");
			string attribute5 = reader.GetAttribute("coordorigin");
			MemoryStream memoryStream = ReadSingleNodeIntoStream(reader);
			ShapeType shapeType = ShapeType.XmlParagraphItem;
			if (!string.IsNullOrEmpty(attribute) && AutoShapeHelper.GetAutoShapeType(attribute.Replace("#", "").Replace("_x0000_t", "")) == AutoShapeType.Unknown && (attribute == "#_x0000_t75" || attribute == "#_x0000_t202"))
			{
				shapeType = DetectShapeType(memoryStream);
			}
			if (localName4 == "shape" && shapeType == ShapeType.PictureShape)
			{
				memoryStream.Position = 0L;
				WPicture wPicture = ParsePictureShape(memoryStream);
				if (!string.IsNullOrEmpty(attribute2))
				{
					wPicture.AlternativeText = attribute2;
				}
				if (!string.IsNullOrEmpty(attribute3))
				{
					wPicture.AlternativeText = attribute3;
				}
				wPicture.SetOwner(shape);
				shape.Add(wPicture);
				memoryStream.Position = 0L;
				ChildShape childShape = shape.ChildShapes[shape.ChildShapes.Count - 1];
				childShape.Type = attribute;
				if (shape.Is2007Shape)
				{
					childShape.Is2007Shape = true;
				}
				if (!string.IsNullOrEmpty(attribute4))
				{
					childShape.CoordinateSize = attribute4;
				}
				if (!string.IsNullOrEmpty(attribute5))
				{
					GetCoordinateOrigin(attribute5, childShape);
				}
				XmlReader reader2 = UtilityMethods.CreateReader(memoryStream);
				ParseShape2007Properties(reader2, childShape);
			}
			else
			{
				memoryStream.Position = 0L;
				XmlReader xmlReader = UtilityMethods.CreateReader(memoryStream);
				ChildShape childShape2 = new ChildShape(m_doc);
				childShape2.ElementType = EntityType.AutoShape;
				childShape2.SetOwner(shape);
				if (shape.Is2007Shape)
				{
					childShape2.Is2007Shape = true;
				}
				if (!string.IsNullOrEmpty(attribute2))
				{
					childShape2.Name = attribute2;
				}
				if (!string.IsNullOrEmpty(attribute3))
				{
					childShape2.AlternativeText = attribute3;
				}
				UpdateAutoShapeType(xmlReader, childShape2, attribute, localName4, shapeType);
				if (!string.IsNullOrEmpty(attribute4))
				{
					childShape2.CoordinateSize = attribute4;
				}
				if (!string.IsNullOrEmpty(attribute5))
				{
					GetCoordinateOrigin(attribute5, childShape2);
				}
				ParseShape2007Properties(xmlReader, childShape2);
				ParseTextbox(xmlReader, childShape2);
				shape.Add(childShape2);
			}
			flag = true;
			goto IL_0414;
		}
	}

	private void ParseCoordinatesOfNestedGroupShape(XmlReader reader, ChildGroupShape nestedGroup)
	{
		string attribute = reader.GetAttribute("id");
		if (!string.IsNullOrEmpty(attribute))
		{
			nestedGroup.Name = attribute;
		}
		string attribute2 = reader.GetAttribute("coordsize");
		if (!string.IsNullOrEmpty(attribute2))
		{
			nestedGroup.CoordinateSize = attribute2;
		}
		string attribute3 = reader.GetAttribute("coordorigin");
		if (!string.IsNullOrEmpty(attribute3))
		{
			GetCoordinateOrigin(attribute3, nestedGroup);
		}
	}

	private void GetCoordinateOrigin(string coordOrigin, Entity shapeEntity)
	{
		if (coordOrigin.EndsWith(","))
		{
			coordOrigin = coordOrigin.Insert(coordOrigin.LastIndexOf(',') + 1, " ");
		}
		else if (coordOrigin.StartsWith(","))
		{
			coordOrigin = coordOrigin.Insert(0, " ");
		}
		else if (!coordOrigin.Contains(","))
		{
			coordOrigin = coordOrigin.Insert(coordOrigin.Length, ",0");
		}
		string[] array = coordOrigin.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		if (shapeEntity is ShapeCommon)
		{
			(shapeEntity as ShapeCommon).CoordinateXOrigin = GetChildShapePointValue(array[0]);
			(shapeEntity as ShapeCommon).CoordinateYOrigin = GetChildShapePointValue(array[1]);
		}
		else if (shapeEntity is WTextBox)
		{
			(shapeEntity as WTextBox).TextBoxFormat.CoordinateXOrigin = GetChildShapePointValue(array[0]);
			(shapeEntity as WTextBox).TextBoxFormat.CoordinateYOrigin = GetChildShapePointValue(array[1]);
		}
	}

	private void ParseTextBoxWrapStyle(XmlReader reader, Shape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (!reader.EOF && reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "wrap")
				{
					string attribute = reader.GetAttribute("type");
					if (attribute != null)
					{
						shape.WrapFormat.SetTextWrappingStyleValue(GetWrapStyle(attribute));
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextbox(XmlReader reader, ChildShape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (!reader.EOF && !(reader.LocalName == localName2))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "stroke":
					ParseStroke(reader, shape);
					break;
				case "textbox":
				{
					if (shape.AutoShapeType == AutoShapeType.Unknown)
					{
						shape.IsTextBoxShape = true;
					}
					if (shape.AutoShapeType == AutoShapeType.Rectangle)
					{
						shape.ElementType = EntityType.TextBox;
					}
					else
					{
						shape.ElementType = EntityType.AutoShape;
					}
					ParseTextBoxStyle(reader, shape.TextFrame);
					if (!string.IsNullOrEmpty(reader.GetAttribute("inset")))
					{
						shape.TextFrame.HasInternalMargin = true;
						ParseTextFrameInternalMargins(reader, shape.TextFrame);
					}
					m_currentRunFormat = null;
					RevisionType trackChangeType = m_trackChangeType;
					m_trackChangeType = RevisionType.None;
					Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
					m_trackchangeRevisionDetails.Clear();
					Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
					m_trackchangeStack.Clear();
					Parse2007TextboxContent(reader, shape.TextBody);
					m_trackChangeType = trackChangeType;
					m_trackchangeRevisionDetails = new Stack<Revision>(stack);
					stack.Clear();
					m_trackchangeStack = new Stack<RevisionType>(stack2);
					stack2.Clear();
					break;
				}
				case "fill":
					shape.IsFillStyleInline = true;
					flag = ParseFillEffects(reader, shape);
					break;
				case "textpath":
					if (!shape.Docx2007Props.ContainsKey("textpath"))
					{
						shape.Docx2007Props.Add("textpath", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "shadow":
					if (!shape.Docx2007Props.ContainsKey("shadow"))
					{
						shape.Docx2007Props.Add("shadow", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "path":
					if (!shape.Docx2007Props.ContainsKey("path"))
					{
						shape.Docx2007Props.Add("path", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "imagedata":
				{
					string attribute = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (!string.IsNullOrEmpty(attribute))
					{
						ImageRecord imageRecord = GetImageRecord(attribute);
						if (attribute != null && imageRecord != null && !shape.ImageRelations.ContainsKey(attribute))
						{
							bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
							bool isImageRelation = true;
							string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
							shape.FillFormat.ImageRecord = imageRecord;
							shape.ImageRelations.Add(attribute, imageRecord);
							ImageRecord imageRecord2 = null;
							if (!ImageIds.ContainsKey(imageName))
							{
								imageRecord2 = m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
								ImageIds.Add(imageName, imageRecord2.ImageId);
							}
						}
					}
					string attribute2 = reader.GetAttribute("gain");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.FillFormat.Contrast = GetOpacityValue(attribute2);
					}
					string attribute3 = reader.GetAttribute("recolortarget");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shape.FillFormat.ReColorTarget = GetColorValue(attribute3);
					}
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextbox(XmlReader reader, Shape shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (!reader.EOF && !(reader.LocalName == localName2))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "stroke":
					ParseStroke(reader, shape);
					break;
				case "textbox":
				{
					ParseTextboxIntMargins(reader, shape);
					ParseTextBoxStyle(reader, shape.TextFrame);
					m_currentRunFormat = null;
					RevisionType trackChangeType = m_trackChangeType;
					m_trackChangeType = RevisionType.None;
					Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
					m_trackchangeRevisionDetails.Clear();
					Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
					m_trackchangeStack.Clear();
					Parse2007TextboxContent(reader, shape.TextBody);
					m_trackChangeType = trackChangeType;
					m_trackchangeRevisionDetails = new Stack<Revision>(stack);
					stack.Clear();
					m_trackchangeStack = new Stack<RevisionType>(stack2);
					stack2.Clear();
					break;
				}
				case "fill":
					flag = ParseFillEffects(reader, shape);
					break;
				case "wrap":
				{
					string attribute = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute) && (shape.WrapFormat.TextWrappingStyle == TextWrappingStyle.Behind || shape.WrapFormat.TextWrappingStyle == TextWrappingStyle.InFrontOfText))
					{
						TextWrappingStyle wrapStyle = GetWrapStyle(attribute);
						if (wrapStyle == TextWrappingStyle.Square || wrapStyle == TextWrappingStyle.Tight || wrapStyle == TextWrappingStyle.Through || wrapStyle == TextWrappingStyle.TopAndBottom)
						{
							shape.WrapFormat.SetTextWrappingStyleValue(wrapStyle);
						}
					}
					string attribute2 = reader.GetAttribute("side");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.WrapFormat.TextWrappingType = GetTextWrapType(attribute2);
					}
					break;
				}
				case "textpath":
					shape.Docx2007Props.Add("textpath", ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private bool ParseFillEffects(XmlReader reader, GroupShape shape)
	{
		bool result = false;
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("opacity2");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.SecondaryOpacity = GetOpacityValue(attribute);
		}
		string attribute2 = reader.GetAttribute("color2");
		if (!string.IsNullOrEmpty(attribute2) && !shape.FillFormat.Color.IsEmpty)
		{
			shape.FillFormat.ForeColor = shape.FillFormat.Color;
			shape.FillFormat.Color = GetColorValue(attribute2);
		}
		string attribute3 = reader.GetAttribute("rotate");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.FillFormat.RotateWithObject = GetBoolValue(attribute3);
		}
		string attribute4 = reader.GetAttribute("on");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.FillFormat.Visible = GetBoolValue(attribute4);
		}
		string attribute5 = reader.GetAttribute("alignshape");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.FillFormat.AlignWithShape = GetBoolValue(attribute5);
		}
		string attribute6 = reader.GetAttribute("althref");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.FillFormat.AlternateHRef = attribute6.ToString();
		}
		string attribute7 = reader.GetAttribute("aspect");
		if (!string.IsNullOrEmpty(attribute7) && attribute7.Length > 2 && Enum.IsDefined(typeof(FillAspect), char.ToUpper(attribute7[0]) + attribute7.Substring(1)))
		{
			shape.FillFormat.Aspect = (FillAspect)Enum.Parse(typeof(FillAspect), attribute7, ignoreCase: true);
		}
		string attribute8 = reader.GetAttribute("detectmouseclick");
		if (!string.IsNullOrEmpty(attribute8))
		{
			shape.FillFormat.DetectMouseClick = GetBoolValue(attribute8);
		}
		string attribute9 = reader.GetAttribute("recolor");
		if (!string.IsNullOrEmpty(attribute9))
		{
			shape.FillFormat.ReColor = GetBoolValue(attribute9);
		}
		string attribute10 = reader.GetAttribute("focus");
		if (!string.IsNullOrEmpty(attribute10))
		{
			if (attribute10.EndsWith("%"))
			{
				shape.FillFormat.Focus = (float)(GetPercentage(attribute10) * 65536.0 / 100.0);
			}
			else if (attribute10.EndsWith("f"))
			{
				attribute10 = attribute10.Replace("f", "");
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
			else
			{
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
		}
		string attribute11 = reader.GetAttribute("position");
		if (!string.IsNullOrEmpty(attribute11))
		{
			attribute11 = attribute11.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute11.Contains(","))
			{
				if (attribute11.StartsWith(","))
				{
					attribute11 = attribute11.Substring(1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionY = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
				}
				else if (attribute11.EndsWith(","))
				{
					attribute11 = attribute11.Substring(0, attribute11.Length - 1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute11, "position");
				}
			}
			else if (attribute11.EndsWith("%"))
			{
				shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
			}
			else if (attribute11.EndsWith("f"))
			{
				attribute11 = attribute11.Replace("f", "");
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
			else
			{
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
		}
		string attribute12 = reader.GetAttribute("focusposition");
		if (!string.IsNullOrEmpty(attribute12))
		{
			attribute12 = attribute12.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute12.Contains(","))
			{
				if (attribute12.StartsWith(","))
				{
					attribute12 = attribute12.Substring(1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionY = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
				}
				else if (attribute12.EndsWith(","))
				{
					attribute12 = attribute12.Substring(0, attribute12.Length - 1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute12, "focusposition");
				}
			}
			else if (attribute12.EndsWith("%"))
			{
				shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
			}
			else if (attribute12.EndsWith("f"))
			{
				attribute12 = attribute12.Replace("f", "");
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
			else
			{
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
		}
		string attribute13 = reader.GetAttribute("focussize");
		if (!string.IsNullOrEmpty(attribute13))
		{
			attribute13 = attribute13.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute13.Contains(","))
			{
				if (attribute13.StartsWith(","))
				{
					attribute13 = attribute13.Substring(1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeY = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
				}
				else if (attribute13.EndsWith(","))
				{
					attribute13 = attribute13.Substring(0, attribute13.Length - 1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute13, "focussize");
				}
			}
			else if (attribute13.EndsWith("%"))
			{
				shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
			}
			else if (attribute13.EndsWith("f"))
			{
				attribute13 = attribute13.Replace("f", "");
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
			else
			{
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
		}
		string attribute14 = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute14))
		{
			switch (attribute14)
			{
			case "solid":
			case "tile":
			case "frame":
			case "pattern":
			{
				switch (attribute14)
				{
				case "pattern":
					shape.FillFormat.FillType = FillType.FillPatterned;
					break;
				case "frame":
					shape.FillFormat.FillType = FillType.FillPicture;
					break;
				case "tile":
					shape.FillFormat.FillType = FillType.FillTextured;
					break;
				case "solid":
					shape.FillFormat.FillType = FillType.FillSolid;
					break;
				}
				string attribute16 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (string.IsNullOrEmpty(attribute16))
				{
					break;
				}
				bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
				bool isImageRelation = true;
				string imageName = GetImageName(attribute16, isHeaderFooter, isPicBullet: false, ref isImageRelation);
				shape.FillFormat.ImageRecord = GetImageRecord(attribute16);
				if (shape.FillFormat.ImageRecord != null)
				{
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
			case "gradient":
			case "gradientRadial":
				attribute2 = reader.GetAttribute("color2");
				shape.FillFormat.FillType = FillType.FillGradient;
				if (attribute14 == "gradient")
				{
					shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
					string attribute15 = reader.GetAttribute("angle");
					if (!string.IsNullOrEmpty(attribute15))
					{
						int angle = GetAngle(attribute15);
						if (attribute15.StartsWith("-"))
						{
							shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
						}
						if (angle != int.MaxValue)
						{
							shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16(angle, CultureInfo.InvariantCulture);
						}
					}
				}
				else
				{
					shape.FillFormat.GradientFill.PathGradient = new PathGradient();
					shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
				}
				Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
				break;
			}
		}
		return result;
	}

	private bool ParseFillEffects(XmlReader reader, ChildShape shape)
	{
		bool result = false;
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("opacity2");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.SecondaryOpacity = GetOpacityValue(attribute);
		}
		string attribute2 = reader.GetAttribute("color2");
		if (!string.IsNullOrEmpty(attribute2) && !shape.FillFormat.Color.IsEmpty)
		{
			shape.FillFormat.ForeColor = shape.FillFormat.Color;
			shape.FillFormat.Color = GetColorValue(attribute2);
		}
		string attribute3 = reader.GetAttribute("rotate");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.FillFormat.RotateWithObject = GetBoolValue(attribute3);
		}
		string attribute4 = reader.GetAttribute("on");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.FillFormat.Visible = GetBoolValue(attribute4);
		}
		string attribute5 = reader.GetAttribute("alignshape");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.FillFormat.AlignWithShape = GetBoolValue(attribute5);
		}
		string attribute6 = reader.GetAttribute("althref");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.FillFormat.AlternateHRef = attribute6.ToString();
		}
		string attribute7 = reader.GetAttribute("aspect");
		if (!string.IsNullOrEmpty(attribute7) && attribute7.Length > 2 && Enum.IsDefined(typeof(FillAspect), char.ToUpper(attribute7[0]) + attribute7.Substring(1)))
		{
			shape.FillFormat.Aspect = (FillAspect)Enum.Parse(typeof(FillAspect), attribute7, ignoreCase: true);
		}
		string attribute8 = reader.GetAttribute("detectmouseclick");
		if (!string.IsNullOrEmpty(attribute8))
		{
			shape.FillFormat.DetectMouseClick = GetBoolValue(attribute8);
		}
		string attribute9 = reader.GetAttribute("recolor");
		if (!string.IsNullOrEmpty(attribute9))
		{
			shape.FillFormat.ReColor = GetBoolValue(attribute9);
		}
		string attribute10 = reader.GetAttribute("focus");
		if (!string.IsNullOrEmpty(attribute10))
		{
			if (attribute10.EndsWith("%"))
			{
				shape.FillFormat.Focus = (float)(GetPercentage(attribute10) * 65536.0 / 100.0);
			}
			else if (attribute10.EndsWith("f"))
			{
				attribute10 = attribute10.Replace("f", "");
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
			else
			{
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
		}
		string attribute11 = reader.GetAttribute("position");
		if (!string.IsNullOrEmpty(attribute11))
		{
			attribute11 = attribute11.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute11.Contains(","))
			{
				if (attribute11.StartsWith(","))
				{
					attribute11 = attribute11.Substring(1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionY = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
				}
				else if (attribute11.EndsWith(","))
				{
					attribute11 = attribute11.Substring(0, attribute11.Length - 1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute11, "position");
				}
			}
			else if (attribute11.EndsWith("%"))
			{
				shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
			}
			else if (attribute11.EndsWith("f"))
			{
				attribute11 = attribute11.Replace("f", "");
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
			else
			{
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
		}
		string attribute12 = reader.GetAttribute("focusposition");
		if (!string.IsNullOrEmpty(attribute12))
		{
			attribute12 = attribute12.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute12.Contains(","))
			{
				if (attribute12.StartsWith(","))
				{
					attribute12 = attribute12.Substring(1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionY = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
				}
				else if (attribute12.EndsWith(","))
				{
					attribute12 = attribute12.Substring(0, attribute12.Length - 1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute12, "focusposition");
				}
			}
			else if (attribute12.EndsWith("%"))
			{
				shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
			}
			else if (attribute12.EndsWith("f"))
			{
				attribute12 = attribute12.Replace("f", "");
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
			else
			{
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
		}
		string attribute13 = reader.GetAttribute("focussize");
		if (!string.IsNullOrEmpty(attribute13))
		{
			attribute13 = attribute13.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute13.Contains(","))
			{
				if (attribute13.StartsWith(","))
				{
					attribute13 = attribute13.Substring(1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeY = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
				}
				else if (attribute13.EndsWith(","))
				{
					attribute13 = attribute13.Substring(0, attribute13.Length - 1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute13, "focussize");
				}
			}
			else if (attribute13.EndsWith("%"))
			{
				shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
			}
			else if (attribute13.EndsWith("f"))
			{
				attribute13 = attribute13.Replace("f", "");
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
			else
			{
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
		}
		string attribute14 = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute14))
		{
			switch (attribute14)
			{
			case "solid":
			case "tile":
			case "frame":
			case "pattern":
			{
				switch (attribute14)
				{
				case "pattern":
					shape.FillFormat.FillType = FillType.FillPatterned;
					break;
				case "frame":
					shape.FillFormat.FillType = FillType.FillPicture;
					break;
				case "tile":
					shape.FillFormat.FillType = FillType.FillTextured;
					break;
				case "solid":
					shape.FillFormat.FillType = FillType.FillSolid;
					break;
				}
				string attribute16 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (string.IsNullOrEmpty(attribute16))
				{
					break;
				}
				bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
				bool isImageRelation = true;
				string imageName = GetImageName(attribute16, isHeaderFooter, isPicBullet: false, ref isImageRelation);
				shape.FillFormat.ImageRecord = GetImageRecord(attribute16);
				if (shape.FillFormat.ImageRecord != null)
				{
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
			case "gradient":
			case "gradientRadial":
				attribute2 = reader.GetAttribute("color2");
				shape.FillFormat.FillType = FillType.FillGradient;
				if (attribute14 == "gradient")
				{
					shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
					string attribute15 = reader.GetAttribute("angle");
					if (!string.IsNullOrEmpty(attribute15))
					{
						int angle = GetAngle(attribute15);
						if (attribute15.StartsWith("-"))
						{
							shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
						}
						if (angle != int.MaxValue)
						{
							shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16(angle, CultureInfo.InvariantCulture);
						}
					}
					shape.FillFormat.GradientFill.LinearGradient.IsAngleDefined = attribute15 != null;
				}
				else
				{
					shape.FillFormat.GradientFill.PathGradient = new PathGradient();
					shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
				}
				Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
				break;
			}
		}
		return result;
	}

	private bool ParseFillEffects(XmlReader reader, Shape shape)
	{
		bool result = false;
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("opacity2");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.FillFormat.SecondaryOpacity = GetOpacityValue(attribute);
		}
		string attribute2 = reader.GetAttribute("color2");
		string attribute3 = reader.GetAttribute("rotate");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.FillFormat.RotateWithObject = GetBoolValue(attribute3);
		}
		string attribute4 = reader.GetAttribute("on");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.FillFormat.Visible = GetBoolValue(attribute4);
		}
		string attribute5 = reader.GetAttribute("alignshape");
		if (!string.IsNullOrEmpty(attribute5))
		{
			shape.FillFormat.AlignWithShape = GetBoolValue(attribute5);
		}
		string attribute6 = reader.GetAttribute("althref");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.FillFormat.AlternateHRef = attribute6.ToString();
		}
		string attribute7 = reader.GetAttribute("aspect");
		if (!string.IsNullOrEmpty(attribute7) && attribute7.Length > 2 && Enum.IsDefined(typeof(FillAspect), char.ToUpper(attribute7[0]) + attribute7.Substring(1)))
		{
			shape.FillFormat.Aspect = (FillAspect)Enum.Parse(typeof(FillAspect), attribute7, ignoreCase: true);
		}
		string attribute8 = reader.GetAttribute("detectmouseclick");
		if (!string.IsNullOrEmpty(attribute8))
		{
			shape.FillFormat.DetectMouseClick = GetBoolValue(attribute8);
		}
		string attribute9 = reader.GetAttribute("recolor");
		if (!string.IsNullOrEmpty(attribute9))
		{
			shape.FillFormat.ReColor = GetBoolValue(attribute9);
		}
		string attribute10 = reader.GetAttribute("focus");
		if (!string.IsNullOrEmpty(attribute10))
		{
			if (attribute10.EndsWith("%"))
			{
				shape.FillFormat.Focus = (float)(GetPercentage(attribute10) * 65536.0 / 100.0);
			}
			else if (attribute10.EndsWith("f"))
			{
				attribute10 = attribute10.Replace("f", "");
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
			else
			{
				shape.FillFormat.Focus = GetEffectsPointValue(attribute10);
			}
		}
		string attribute11 = reader.GetAttribute("position");
		if (!string.IsNullOrEmpty(attribute11))
		{
			attribute11 = attribute11.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute11.Contains(","))
			{
				if (StartsWithExt(attribute11, ","))
				{
					attribute11 = attribute11.Substring(1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionY = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionY = GetEffectsPointValue(attribute11);
					}
				}
				else if (attribute11.EndsWith(","))
				{
					attribute11 = attribute11.Substring(0, attribute11.Length - 1);
					if (attribute11.EndsWith("%"))
					{
						shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
					}
					else if (attribute11.EndsWith("f"))
					{
						attribute11 = attribute11.Replace("f", "");
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
					else
					{
						shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute11, "position");
				}
			}
			else if (attribute11.EndsWith("%"))
			{
				shape.FillFormat.PositionX = (float)(GetPercentage(attribute11) * 65536.0 / 100.0);
			}
			else if (attribute11.EndsWith("f"))
			{
				attribute11 = attribute11.Replace("f", "");
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
			else
			{
				shape.FillFormat.PositionX = GetEffectsPointValue(attribute11);
			}
		}
		string attribute12 = reader.GetAttribute("focusposition");
		if (!string.IsNullOrEmpty(attribute12))
		{
			attribute12 = attribute12.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute12.Contains(","))
			{
				if (StartsWithExt(attribute12, ","))
				{
					attribute12 = attribute12.Substring(1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionY = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionY = GetEffectsPointValue(attribute12);
					}
				}
				else if (attribute12.EndsWith(","))
				{
					attribute12 = attribute12.Substring(0, attribute12.Length - 1);
					if (attribute12.EndsWith("%"))
					{
						shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
					}
					else if (attribute12.EndsWith("f"))
					{
						attribute12 = attribute12.Replace("f", "");
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
					else
					{
						shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute12, "focusposition");
				}
			}
			else if (attribute12.EndsWith("%"))
			{
				shape.FillFormat.FocusPositionX = (float)(GetPercentage(attribute12) * 65536.0 / 100.0);
			}
			else if (attribute12.EndsWith("f"))
			{
				attribute12 = attribute12.Replace("f", "");
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
			else
			{
				shape.FillFormat.FocusPositionX = GetEffectsPointValue(attribute12);
			}
		}
		string attribute13 = reader.GetAttribute("focussize");
		if (!string.IsNullOrEmpty(attribute13))
		{
			attribute13 = attribute13.Trim(new char[1] { ControlChar.SpaceChar });
			if (attribute13.Contains(","))
			{
				if (StartsWithExt(attribute13, ","))
				{
					attribute13 = attribute13.Substring(1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeY = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeY = GetEffectsPointValue(attribute13);
					}
				}
				else if (attribute13.EndsWith(","))
				{
					attribute13 = attribute13.Substring(0, attribute13.Length - 1);
					if (attribute13.EndsWith("%"))
					{
						shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
					}
					else if (attribute13.EndsWith("f"))
					{
						attribute13 = attribute13.Replace("f", "");
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
					else
					{
						shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
					}
				}
				else
				{
					ParseFillOffsets(shape.FillFormat, attribute13, "focussize");
				}
			}
			else if (attribute13.EndsWith("%"))
			{
				shape.FillFormat.FocusSizeX = (float)(GetPercentage(attribute13) * 65536.0 / 100.0);
			}
			else if (attribute13.EndsWith("f"))
			{
				attribute13 = attribute13.Replace("f", "");
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
			else
			{
				shape.FillFormat.FocusSizeX = GetEffectsPointValue(attribute13);
			}
		}
		string attribute14 = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute14))
		{
			switch (attribute14.ToLower())
			{
			case "solid":
			case "tile":
			case "frame":
			case "pattern":
			{
				switch (attribute14)
				{
				case "pattern":
					shape.FillFormat.FillType = FillType.FillPatterned;
					if (!string.IsNullOrEmpty(attribute2) && !shape.FillFormat.Color.IsEmpty)
					{
						shape.FillFormat.ForeColor = shape.FillFormat.Color;
						shape.FillFormat.Color = GetColorValue(attribute2);
					}
					break;
				case "frame":
					shape.FillFormat.FillType = FillType.FillPicture;
					break;
				case "tile":
					shape.FillFormat.FillType = FillType.FillTextured;
					break;
				case "solid":
					shape.FillFormat.FillType = FillType.FillSolid;
					break;
				}
				string attribute16 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (string.IsNullOrEmpty(attribute16))
				{
					break;
				}
				bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
				bool isImageRelation = true;
				string imageName = GetImageName(attribute16, isHeaderFooter, isPicBullet: false, ref isImageRelation);
				shape.FillFormat.ImageRecord = GetImageRecord(attribute16);
				if (shape.FillFormat.ImageRecord != null)
				{
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
			case "gradient":
			case "gradientradial":
				attribute2 = reader.GetAttribute("color2");
				if (!string.IsNullOrEmpty(attribute2) && !shape.FillFormat.Color.IsEmpty)
				{
					shape.FillFormat.ForeColor = shape.FillFormat.Color;
					shape.FillFormat.Color = GetColorValue(attribute2);
				}
				shape.FillFormat.FillType = FillType.FillGradient;
				if (attribute14 == "gradient")
				{
					shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
					string attribute15 = reader.GetAttribute("angle");
					if (!string.IsNullOrEmpty(attribute15))
					{
						int angle = GetAngle(attribute15);
						if (StartsWithExt(attribute15, "-"))
						{
							shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
						}
						if (angle != int.MaxValue)
						{
							shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16(angle, CultureInfo.InvariantCulture);
						}
					}
				}
				else
				{
					shape.FillFormat.GradientFill.PathGradient = new PathGradient();
					shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
				}
				Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
				break;
			}
		}
		return result;
	}

	private float GetOpacityValue(string value)
	{
		float result = 0f;
		if (value.Trim(ControlChar.SpaceChar, '%', 'f') == string.Empty)
		{
			return result;
		}
		if (value.EndsWith("%"))
		{
			return float.TryParse(value.Replace("%", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? (100f - result) : 0f;
		}
		if (value.EndsWith("f"))
		{
			return float.TryParse(value.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((float)Math.Round(1f - result / 65536f, 2) * 100f) : 0f;
		}
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		if (result >= 0f && result < 1f)
		{
			result = 100f - result * 100f;
		}
		return (result < 0f || result > 100f) ? 0f : result;
	}

	private int GetAngle(string angle)
	{
		int result = 0;
		int.TryParse(angle, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		int num = int.MaxValue;
		if (result < 0)
		{
			result = -result;
			if (result >= 0 && result <= 90)
			{
				num = 270 + result;
			}
			else if (result > 90 && result <= 180)
			{
				num = result - 90;
			}
			else if (result > 180 && result <= 270)
			{
				num = 90 + (result - 180);
			}
			else if (result > 270 && result <= 360)
			{
				num = 180 + (result - 270);
			}
			return (num != 360) ? num : 0;
		}
		if (result >= 0 && result <= 90)
		{
			num = 90 - result;
		}
		else if (result > 90 && result <= 180)
		{
			num = 270 + (180 - result);
		}
		else if (result > 180 && result <= 270)
		{
			num = 180 + (270 - result);
		}
		else if (result > 270 && result <= 360)
		{
			num = 90 + (360 - result);
		}
		return (num != 360) ? num : 0;
	}

	private void Parse2007GradientFill(XmlReader reader, GradientFill gradientFill)
	{
		string attribute = reader.GetAttribute("rotate");
		if (!string.IsNullOrEmpty(attribute))
		{
			gradientFill.RotateWithShape = attribute == "t";
		}
		ParseFocus(reader, gradientFill);
		ParseGradientStops(reader, gradientFill);
		if (gradientFill.PathGradient != null)
		{
			ParseFocusPosition(reader, gradientFill);
		}
	}

	private void ParseFocusPosition(XmlReader reader, GradientFill gradientFill)
	{
		string attribute = reader.GetAttribute("focusposition");
		if (attribute == null)
		{
			gradientFill.TileRectangle.TopOffset = -100f;
			gradientFill.TileRectangle.LeftOffset = -100f;
			gradientFill.PathGradient.RightOffset = 100;
			gradientFill.PathGradient.BottomOffset = 100;
			return;
		}
		switch (attribute)
		{
		case "1":
			gradientFill.TileRectangle.TopOffset = -100f;
			gradientFill.TileRectangle.LeftOffset = 100f;
			gradientFill.PathGradient.RightOffset = -100;
			gradientFill.PathGradient.BottomOffset = 100;
			break;
		case "1,1":
			gradientFill.TileRectangle.TopOffset = 100f;
			gradientFill.TileRectangle.LeftOffset = 100f;
			gradientFill.PathGradient.RightOffset = -100;
			gradientFill.PathGradient.BottomOffset = -100;
			break;
		case ",1":
			gradientFill.TileRectangle.TopOffset = 100f;
			gradientFill.TileRectangle.LeftOffset = -100f;
			gradientFill.PathGradient.RightOffset = 100;
			gradientFill.PathGradient.BottomOffset = -100;
			break;
		case ".5,.5":
		{
			TileRectangle tileRectangle = gradientFill.TileRectangle;
			TileRectangle tileRectangle2 = gradientFill.TileRectangle;
			PathGradient pathGradient = gradientFill.PathGradient;
			short num2 = (gradientFill.PathGradient.BottomOffset = 50);
			short num4 = (pathGradient.RightOffset = num2);
			float topOffset = (tileRectangle2.LeftOffset = num4);
			tileRectangle.TopOffset = topOffset;
			break;
		}
		}
	}

	private void ParseGradientStops(XmlReader reader, GradientFill gradientFill)
	{
		string attribute = reader.GetAttribute("colors");
		if (string.IsNullOrEmpty(attribute))
		{
			return;
		}
		string[] array = attribute.Split(new char[1] { ';' });
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(new char[1] { ' ' });
			GradientStop gradientStop = new GradientStop();
			double result = 0.0;
			if (array2[0].Contains("f"))
			{
				double.TryParse(array2[0].Replace("f", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				result = result * 100.0 / 65536.0;
			}
			else
			{
				double.TryParse(array2[0], NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				result *= 100.0;
			}
			gradientStop.Position = Convert.ToByte(result);
			gradientStop.Color = GetColorValue(array2[1]);
			gradientFill.GradientStops.Add(gradientStop);
		}
	}

	private void ParseFocus(XmlReader reader, GradientFill gradientFill)
	{
		gradientFill.Focus = reader.GetAttribute("focus");
	}

	private ImageRecord GetImageRecord(string imageId)
	{
		bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
		bool isImageRelation = true;
		string imageName = GetImageName(imageId, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (isImageRelation)
		{
			if (ImageIds.ContainsKey(imageName))
			{
				return m_doc.Images[ImageIds[imageName]];
			}
			byte[] imageBytes = GetImageBytes(imageName);
			if (imageBytes != null)
			{
				return new ImageRecord(m_doc, imageBytes);
			}
		}
		return null;
	}

	private void Parse2007TextboxContent(XmlReader reader, WTextBody textBody)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		SkipWhitespaces(reader);
		if ((localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement) || reader.NodeType != XmlNodeType.Element || reader.IsEmptyElement)
		{
			return;
		}
		string localName3 = reader.LocalName;
		reader.Read();
		SkipWhitespaces(reader);
		if ((localName3 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement) || reader.NodeType != XmlNodeType.Element)
		{
			return;
		}
		while (reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "p":
				{
					IWParagraph iWParagraph = textBody.AddParagraph();
					ParseParagraphItems(reader, iWParagraph.Items, null, null, isMappedPictureContentControl: false);
					m_doc.UpdateLastItemRevision(iWParagraph, iWParagraph.Items);
					break;
				}
				case "tbl":
				{
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 11);
					IWTable iWTable = textBody.AddTable();
					iWTable.TableFormat.IsAutoResized = true;
					short gridCount = m_gridCount;
					ParseTable(reader, iWTable as WTable, isAlreadyCheck: false, reader.LocalName);
					m_gridCount = gridCount;
					if (iWTable.Rows.Count == 0)
					{
						(iWTable.Owner as WTextBody).ChildEntities.RemoveAt((iWTable as WTable).Index);
					}
					break;
				}
				case "sdt":
				{
					IBlockContentControl blockContentControl = textBody.AddStructureDocumentTag();
					ParseStructureDocumentTagBlock(reader, blockContentControl as BlockContentControl);
					break;
				}
				case "altChunk":
				{
					AlternateChunk altChunk = AddAlternateChunk(textBody.Owner);
					ParseAlternateChunk(reader, altChunk);
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseTextBoxStyle(XmlReader reader, TextFrame textFrame)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		string[] array = attribute.Split(';');
		string text = string.Empty;
		if (array.Length == 0)
		{
			return;
		}
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(':');
			if (array2.Length > 1)
			{
				switch (array2[0])
				{
				case "mso-fit-shape-to-text":
					textFrame.ShapeAutoFit = array2[1] == "t";
					break;
				case "layout-flow":
				case "mso-layout-flow-alt":
					text = array2[1];
					break;
				}
			}
		}
		if (!string.IsNullOrEmpty(text))
		{
			textFrame.TextDirection = GetTextDirection(text);
		}
	}

	private TextDirection GetTextDirection(string textDirection)
	{
		return textDirection switch
		{
			"vertical" => TextDirection.VerticalTopToBottom, 
			"horizontal-ideographic" => TextDirection.HorizontalFarEast, 
			"vertical-ideographic" => TextDirection.VerticalFarEast, 
			"bottom-to-top" => TextDirection.VerticalBottomToTop, 
			"top-to-bottom" => TextDirection.Vertical, 
			_ => TextDirection.Horizontal, 
		};
	}

	private void ParseTextboxIntMargins(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("inset");
		if (attribute != null && !string.IsNullOrEmpty(attribute))
		{
			shape.TextFrame.HasInternalMargin = true;
			ParseTextFrameInternalMargins(reader, shape.TextFrame);
		}
	}

	private void ParseStroke(XmlReader reader, GroupShape shape)
	{
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("color2");
		if (!string.IsNullOrEmpty(attribute) && !shape.LineFormat.Color.IsEmpty)
		{
			shape.LineFormat.ForeColor = shape.LineFormat.Color;
			shape.LineFormat.Color = GetColorValue(attribute);
		}
		attribute = reader.GetAttribute("filltype");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "tile":
			case "frame":
			case "pattern":
				shape.LineFormat.LineFormatType = LineFormatType.Patterned;
				attribute = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(attribute))
				{
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					bool isImageRelation = true;
					string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
					shape.LineFormat.ImageRecord = GetImageRecord(attribute);
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
		}
		attribute = reader.GetAttribute("dashstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.DashStyle = GetDashStyle(attribute);
		}
		attribute = reader.GetAttribute("linestyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Style = GetShapeLineStyle(attribute);
		}
		attribute = reader.GetAttribute("joinstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineJoin = GetLineJoinStyle(attribute);
		}
		attribute = reader.GetAttribute("endcap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineCap = GetLineCapStyle(attribute);
		}
		attribute = reader.GetAttribute("startarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("startarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("startarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadLength = GetLineEndLength(attribute);
		}
		attribute = reader.GetAttribute("endarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("endarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("endarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadLength = GetLineEndLength(attribute);
		}
	}

	private void ParseStroke(XmlReader reader, ChildShape shape)
	{
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("color2");
		if (!string.IsNullOrEmpty(attribute) && !shape.LineFormat.Color.IsEmpty)
		{
			shape.LineFormat.ForeColor = GetColorValue(attribute);
		}
		attribute = reader.GetAttribute("filltype");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "tile":
			case "frame":
			case "pattern":
				shape.LineFormat.LineFormatType = LineFormatType.Patterned;
				attribute = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(attribute))
				{
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					bool isImageRelation = true;
					string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
					shape.LineFormat.ImageRecord = GetImageRecord(attribute);
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
		}
		attribute = reader.GetAttribute("dashstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.DashStyle = GetDashStyle(attribute);
		}
		attribute = reader.GetAttribute("linestyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Style = GetShapeLineStyle(attribute);
		}
		attribute = reader.GetAttribute("joinstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineJoin = GetLineJoinStyle(attribute);
		}
		attribute = reader.GetAttribute("endcap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineCap = GetLineCapStyle(attribute);
		}
		attribute = reader.GetAttribute("startarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("startarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("startarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadLength = GetLineEndLength(attribute);
		}
		attribute = reader.GetAttribute("endarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("endarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("endarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadLength = GetLineEndLength(attribute);
		}
	}

	private void ParseStroke(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Transparency = GetOpacityValue(attribute);
		}
		attribute = reader.GetAttribute("color2");
		if (!string.IsNullOrEmpty(attribute) && !shape.LineFormat.Color.IsEmpty)
		{
			shape.LineFormat.ForeColor = shape.LineFormat.Color;
			shape.LineFormat.Color = GetColorValue(attribute);
		}
		attribute = reader.GetAttribute("filltype");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "tile":
			case "frame":
			case "pattern":
				shape.LineFormat.LineFormatType = LineFormatType.Patterned;
				attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(attribute))
				{
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					bool isImageRelation = true;
					string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
					shape.LineFormat.ImageRecord = GetImageRecord(attribute);
					ImageRecord imageRecord = null;
					if (!ImageIds.ContainsKey(imageName))
					{
						imageRecord = m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
						ImageIds.Add(imageName, imageRecord.ImageId);
					}
				}
				break;
			}
		}
		attribute = reader.GetAttribute("dashstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.DashStyle = GetDashStyle(attribute);
		}
		attribute = reader.GetAttribute("linestyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Style = GetShapeLineStyle(attribute);
		}
		attribute = reader.GetAttribute("joinstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineJoin = GetLineJoinStyle(attribute);
		}
		attribute = reader.GetAttribute("endcap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineCap = GetLineCapStyle(attribute);
		}
		attribute = reader.GetAttribute("startarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("startarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("startarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.BeginArrowheadLength = GetLineEndLength(attribute);
		}
		attribute = reader.GetAttribute("endarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("endarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("endarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.EndArrowheadLength = GetLineEndLength(attribute);
		}
	}

	private LineStyle GetShapeLineStyle(string lineStyle)
	{
		switch (lineStyle)
		{
		case "dbl":
		case "thinThin":
			return LineStyle.ThinThin;
		case "thinThick":
			return LineStyle.ThinThick;
		case "thickThin":
			return LineStyle.ThickThin;
		case "thickBetweenThin":
		case "tri":
			return LineStyle.ThickBetweenThin;
		default:
			return LineStyle.Single;
		}
	}

	private void ParseShape2007Properties(XmlReader reader, GroupShape shape)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Trim();
		char[] separator = new char[1] { ';' };
		string[] array = attribute.Split(separator);
		string[] array2 = new string[2];
		bool flag = false;
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				Apply2007ShapeProperties(shape, array2[0], array2[1]);
				if (array2[0].Equals("position"))
				{
					flag = true;
				}
			}
		}
		if (!flag)
		{
			shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.Inline;
		}
		ParseHorizontalRule(reader, shape);
		string attribute2 = reader.GetAttribute("arcsize");
		if (!string.IsNullOrEmpty(attribute2))
		{
			double result = 0.0;
			double.TryParse(attribute2.Replace("f", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		ParseLineShapeProperties(reader, shape);
		Parse2007ShapeEffects(reader, shape);
	}

	private void ParseShape2007Properties(XmlReader reader, ChildShape shape)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Trim();
		char[] separator = new char[1] { ';' };
		string[] array = attribute.Split(separator);
		string[] array2 = new string[2];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				Apply2007ShapeProperties(shape, array2[0], array2[1]);
			}
		}
		string attribute2 = reader.GetAttribute("arcsize");
		if (!string.IsNullOrEmpty(attribute2))
		{
			double result = 0.0;
			double.TryParse(attribute2.Replace("f", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			shape.ArcSize = result;
			result /= 65536.0;
			if (result > 0.5)
			{
				result = 0.5;
			}
			shape.ShapeGuide.Add("adj", "val " + Math.Round(result * 100000.0));
		}
		string attribute3 = reader.GetAttribute("adj");
		if (!string.IsNullOrEmpty(attribute3))
		{
			shape.Adjustments = attribute3;
		}
		string attribute4 = reader.GetAttribute("path");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.Path = attribute4;
		}
		ParseLineShapeProperties(reader, shape);
		Parse2007ShapeEffects(reader, shape);
	}

	private void ParseShape2007Properties(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Trim();
		char[] separator = new char[1] { ';' };
		string[] array = attribute.Split(separator);
		string[] array2 = new string[2];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				Apply2007ShapeProperties(shape, array2[0], array2[1]);
			}
		}
		if (!attribute.Contains("position:absolute"))
		{
			shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.Inline;
		}
		shape.Adjustments = reader.GetAttribute("adj");
		string attribute2 = reader.GetAttribute("coordorigin");
		if (!string.IsNullOrEmpty(attribute2))
		{
			GetCoordinateOrigin(attribute2, shape);
		}
		shape.CoordinateSize = reader.GetAttribute("coordsize");
		shape.Path = reader.GetAttribute("path");
		ParseHorizontalRule(reader, shape);
		string attribute3 = reader.GetAttribute("arcsize");
		if (!string.IsNullOrEmpty(attribute3))
		{
			double result = 0.0;
			double.TryParse(attribute3.Replace("f", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			shape.ArcSize = result;
			result /= 65536.0;
			if (result > 0.5)
			{
				result = 0.5;
			}
			shape.ShapeGuide.Add("adj", "val " + Math.Round(result * 100000.0));
		}
		ParseLineShapeProperties(reader, shape);
		Parse2007ShapeEffects(reader, shape);
	}

	private void ParseLineShapeProperties(XmlReader reader, GroupShape shape)
	{
		if (!(reader.LocalName == "line"))
		{
			return;
		}
		string attribute = reader.GetAttribute("from");
		string attribute2 = reader.GetAttribute("to");
		if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 0f;
			string[] array = attribute.Split(new char[1] { ',' });
			num = GetChildShapePointValue(array[0]);
			num2 = GetChildShapePointValue(array[1]);
			shape.HorizontalPosition = num;
			shape.VerticalPosition = num2;
			string[] array2 = attribute2.Split(new char[1] { ',' });
			num3 = GetPointValue(array2[0]);
			num4 = GetPointValue(array2[1]);
			shape.Height = (((num5 = num4 - num2) > 0f) ? num5 : (0f - num5));
			shape.Width = (((num6 = num3 - num) > 0f) ? num6 : (0f - num6));
		}
		string attribute3 = reader.GetAttribute("style");
		if (string.IsNullOrEmpty(attribute3))
		{
			return;
		}
		string[] array3 = attribute3.Split(';');
		if (array3.Length == 0)
		{
			return;
		}
		for (int i = 0; i < array3.Length; i++)
		{
			string[] array4 = array3[i].Split(':');
			if (array4.Length > 1 && array4[0] == "flip")
			{
				shape.FillFormat.FlipOrientation = GetFlipOrientation(array4[1]);
			}
		}
	}

	private void ParseLineShapeProperties(XmlReader reader, ChildShape shape)
	{
		if (!(reader.LocalName == "line"))
		{
			return;
		}
		string attribute = reader.GetAttribute("from");
		string attribute2 = reader.GetAttribute("to");
		if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
		{
			string[] array = attribute.Split(new char[1] { ',' });
			shape.LineFromXPosition = GetChildShapePointValue(array[0]);
			shape.LineFromYPosition = GetChildShapePointValue(array[1]);
			shape.LeftMargin = shape.LineFromXPosition;
			shape.TopMargin = shape.LineFromYPosition;
			string[] array2 = attribute2.Split(new char[1] { ',' });
			shape.LineToXPosition = GetChildShapePointValue(array2[0]);
			shape.LineToYPosition = GetChildShapePointValue(array2[1]);
			float num = 0f;
			float num2 = 0f;
			shape.Height = (((num = shape.LineToYPosition - shape.LineFromYPosition) > 0f) ? num : (0f - num));
			shape.Width = (((num2 = shape.LineToXPosition - shape.LineFromXPosition) > 0f) ? num2 : (0f - num2));
		}
		string attribute3 = reader.GetAttribute("style");
		if (string.IsNullOrEmpty(attribute3))
		{
			return;
		}
		string[] array3 = attribute3.Split(';');
		if (array3.Length == 0)
		{
			return;
		}
		for (int i = 0; i < array3.Length; i++)
		{
			string[] array4 = array3[i].Split(':');
			if (array4.Length > 1 && array4[0] == "flip")
			{
				switch (array4[1])
				{
				case "x":
					shape.FlipHorizantal = true;
					break;
				case "y":
					shape.FlipVertical = true;
					break;
				case "x y":
				case "xy":
					shape.FlipHorizantal = true;
					shape.FlipVertical = true;
					break;
				}
			}
		}
	}

	private void ParseLineShapeProperties(XmlReader reader, Shape shape)
	{
		if (reader.LocalName == "line")
		{
			string attribute = reader.GetAttribute("from");
			string attribute2 = reader.GetAttribute("to");
			if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
			{
				float num = 0f;
				float num2 = 0f;
				float num3 = 0f;
				float num4 = 0f;
				float num5 = 0f;
				float num6 = 0f;
				string[] array = attribute.Split(new char[1] { ',' });
				num = GetPointValue(array[0]);
				num2 = GetPointValue(array[1]);
				shape.HorizontalPosition = num;
				shape.VerticalPosition = num2;
				string[] array2 = attribute2.Split(new char[1] { ',' });
				num3 = GetPointValue(array2[0]);
				num4 = GetPointValue(array2[1]);
				shape.Height = (((num5 = num4 - num2) > 0f) ? num5 : (0f - num5));
				shape.Width = (((num6 = num3 - num) > 0f) ? num6 : (0f - num6));
			}
		}
	}

	private void ParseHorizontalRule(XmlReader reader, GroupShape shape)
	{
		string attribute = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			attribute = reader.GetAttribute("hrstd", "urn:schemas-microsoft-com:office:office");
		}
		if (!string.IsNullOrEmpty(attribute))
		{
			attribute = reader.GetAttribute("hrnoshade", "urn:schemas-microsoft-com:office:office");
		}
		if (!string.IsNullOrEmpty(attribute))
		{
			attribute = reader.GetAttribute("hralign", "urn:schemas-microsoft-com:office:office");
		}
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.HorizontalAlignment = GetHorizAlign(attribute);
		}
	}

	private void ParseHorizontalRule(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.IsHorizontalRule = GetBoolValue(attribute);
		}
		attribute = reader.GetAttribute("hrpct", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.WidthScale = (float)Math.Round(GetNumericValue(attribute) / 10f);
		}
		attribute = reader.GetAttribute("hrstd", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.UseStandardColorHR = GetBoolValue(attribute);
		}
		attribute = reader.GetAttribute("hrnoshade", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.UseNoShadeHR = GetBoolValue(attribute);
		}
		attribute = reader.GetAttribute("hralign", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.HorizontalAlignment = GetHorizAlign(attribute);
		}
	}

	private void Parse2007ShapeEffects(XmlReader reader, GroupShape shape)
	{
		string attribute = reader.GetAttribute("strokecolor");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Color = GetColorValue(attribute);
		}
		string attribute2 = reader.GetAttribute("strokeweight");
		if (!string.IsNullOrEmpty(attribute2))
		{
			shape.LineFormat.Weight = GetPointValue(attribute2);
		}
		else
		{
			shape.LineFormat.Weight = 0.75f;
		}
		string attribute3 = reader.GetAttribute("filled");
		if (!string.IsNullOrEmpty(attribute3) && !GetBoolValue(attribute3.ToLower()))
		{
			shape.FillFormat.Fill = false;
			shape.FillFormat.IsDefaultFill = false;
		}
		string attribute4 = reader.GetAttribute("fillcolor");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.FillFormat.Color = GetColorValue(attribute4);
			shape.FillFormat.FillType = FillType.FillSolid;
			shape.FillFormat.IsDefaultFill = false;
		}
		string attribute5 = reader.GetAttribute("stroked");
		if (!string.IsNullOrEmpty(attribute5))
		{
			shape.LineFormat.Line = GetBoolValue(attribute5.ToLower());
			shape.LineFormat.Is2007StrokeDefined = GetBoolValue(attribute5.ToLower());
		}
		string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.LayoutInCell = !(attribute6 == "f");
		}
		string attribute7 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute7))
		{
			shape.WrapFormat.AllowOverlap = ((!(attribute7 == "f") && !(attribute7 == "false")) ? true : false);
		}
	}

	private void Parse2007ShapeEffects(XmlReader reader, ChildShape shape)
	{
		string attribute = reader.GetAttribute("strokecolor");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Color = GetColorValue(attribute);
		}
		string attribute2 = reader.GetAttribute("strokeweight");
		if (!string.IsNullOrEmpty(attribute2))
		{
			shape.LineFormat.Weight = GetPointValue(attribute2);
		}
		else
		{
			shape.LineFormat.Weight = 0.75f;
		}
		string attribute3 = reader.GetAttribute("filled");
		if (!string.IsNullOrEmpty(attribute3) && !GetBoolValue(attribute3.ToLower()))
		{
			shape.FillFormat.Fill = false;
			shape.FillFormat.IsDefaultFill = false;
		}
		string attribute4 = reader.GetAttribute("fillcolor");
		if (!string.IsNullOrEmpty(attribute4))
		{
			shape.FillFormat.Color = GetColorValue(attribute4);
			shape.FillFormat.FillType = FillType.FillSolid;
			shape.FillFormat.IsDefaultFill = false;
		}
		string attribute5 = reader.GetAttribute("stroked");
		if (!string.IsNullOrEmpty(attribute5))
		{
			shape.LineFormat.Line = GetBoolValue(attribute5.ToLower());
			shape.LineFormat.Is2007StrokeDefined = GetBoolValue(attribute5.ToLower());
		}
		string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.LayoutInCell = !(attribute6 == "f");
		}
	}

	private void Parse2007ShapeEffects(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("strokecolor");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Color = GetColorValue(attribute);
		}
		string attribute2 = reader.GetAttribute("strokeweight");
		if (!string.IsNullOrEmpty(attribute2))
		{
			shape.LineFormat.Weight = GetPointValue(attribute2);
		}
		else
		{
			shape.LineFormat.Weight = 0.75f;
		}
		string attribute3 = reader.GetAttribute("filled");
		if (!string.IsNullOrEmpty(attribute3) && !GetBoolValue(attribute3.ToLower()))
		{
			shape.FillFormat.Fill = false;
			shape.FillFormat.IsDefaultFill = false;
		}
		else
		{
			string attribute4 = reader.GetAttribute("fillcolor");
			if (!string.IsNullOrEmpty(attribute4))
			{
				shape.FillFormat.Color = GetColorValue(attribute4);
				shape.FillFormat.FillType = FillType.FillSolid;
				shape.FillFormat.IsDefaultFill = false;
			}
		}
		string attribute5 = reader.GetAttribute("stroked");
		if (!string.IsNullOrEmpty(attribute5))
		{
			shape.LineFormat.Line = GetBoolValue(attribute5.ToLower());
		}
		string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute6))
		{
			shape.LayoutInCell = !(attribute6 == "f");
		}
		string attribute7 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute7))
		{
			shape.WrapFormat.AllowOverlap = ((!(attribute7 == "f") && !(attribute7 == "false")) ? true : false);
		}
	}

	private void Apply2007ShapeProperties(GroupShape shape, string propertyName, string propertyValue)
	{
		switch (propertyName)
		{
		case "left":
			shape.LeftMargin = GetPointValue(propertyValue);
			break;
		case "margin-left":
			shape.HorizontalPosition = GetPointValue(propertyValue);
			break;
		case "top":
			shape.TopMargin = GetPointValue(propertyValue);
			break;
		case "margin-top":
			shape.VerticalPosition = GetPointValue(propertyValue);
			break;
		case "width":
			shape.Width = GetPointValue(propertyValue);
			break;
		case "height":
			shape.Height = GetPointValue(propertyValue);
			break;
		case "z-index":
		{
			int result = 0;
			int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
			if (shape.ZOrderPosition == int.MaxValue)
			{
				shape.ZOrderPosition = result;
			}
			shape.IsBelowText = result <= 0;
			if (shape.IsBelowText)
			{
				shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.Behind;
			}
			else
			{
				shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
			}
			break;
		}
		case "mso-position-horizontal":
			shape.HorizontalAlignment = GetHorizAlign(propertyValue);
			break;
		case "mso-position-vertical":
			shape.VerticalAlignment = GetVertAlign(propertyValue);
			break;
		case "mso-position-vertical-relative":
			shape.VerticalOrigin = GetVertOrigin(propertyValue);
			break;
		case "mso-position-horizontal-relative":
			shape.HorizontalOrigin = GetHorizOrigin(propertyValue);
			break;
		case "mso-wrap-distance-left":
			shape.WrapFormat.DistanceLeft = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-top":
			shape.WrapFormat.DistanceTop = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-right":
			shape.WrapFormat.DistanceRight = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-bottom":
			shape.WrapFormat.DistanceBottom = GetPointValue(propertyValue);
			break;
		case "flip":
			switch (propertyValue)
			{
			case "x":
				shape.FlipHorizontal = true;
				break;
			case "y":
				shape.FlipVertical = true;
				break;
			case "x y":
				shape.FlipHorizontal = true;
				shape.FlipVertical = true;
				break;
			default:
				shape.DocxStyleProps.Add(propertyName + ":" + propertyValue);
				break;
			}
			break;
		case "rotation":
		{
			if (string.IsNullOrEmpty(propertyValue))
			{
				break;
			}
			float result2 = 0f;
			if (propertyValue.EndsWith("fd"))
			{
				float.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				result2 = result2 / 32768f / 2f;
				if (result2 < 0f)
				{
					shape.Rotation = 360f - Math.Abs(result2);
				}
				else
				{
					shape.Rotation = Math.Abs(result2);
				}
			}
			else
			{
				float.TryParse(propertyValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				shape.Rotation = result2;
			}
			break;
		}
		default:
			if (propertyName == "position" && (propertyValue == "absolute" || propertyValue == "relative") && shape.WrapFormat.TextWrappingStyle == TextWrappingStyle.Inline)
			{
				shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
			}
			break;
		}
	}

	private void Apply2007ShapeProperties(ChildShape shape, string propertyName, string propertyValue)
	{
		if (propertyName == null)
		{
			return;
		}
		switch (propertyName.Length)
		{
		case 4:
			switch (propertyName[0])
			{
			case 'l':
				if (propertyName == "left")
				{
					shape.LeftMargin = GetChildShapePointValue(propertyValue);
				}
				break;
			case 'f':
				if (propertyName == "flip")
				{
					switch (propertyValue)
					{
					case "x":
						shape.FlipHorizantal = true;
						break;
					case "y":
						shape.FlipVertical = true;
						break;
					case "x y":
						shape.FlipHorizantal = true;
						shape.FlipVertical = true;
						break;
					default:
						shape.DocxStyleProps.Add(propertyName + ":" + propertyValue);
						break;
					}
				}
				break;
			}
			break;
		case 3:
			if (propertyName == "top")
			{
				shape.TopMargin = GetChildShapePointValue(propertyValue);
			}
			break;
		case 5:
			if (propertyName == "width")
			{
				shape.Width = GetChildShapePointValue(propertyValue);
			}
			break;
		case 6:
			if (propertyName == "height")
			{
				shape.Height = GetChildShapePointValue(propertyValue);
			}
			break;
		case 13:
			if (propertyName == "v-text-anchor")
			{
				shape.TextFrame.TextVerticalAlignment = GetTextVertAlign(propertyValue);
			}
			break;
		case 8:
		{
			if (!(propertyName == "rotation") || string.IsNullOrEmpty(propertyValue))
			{
				break;
			}
			float result = 0f;
			if (propertyValue.EndsWith("fd"))
			{
				float.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				result = result / 32768f / 2f;
				if (result < 0f)
				{
					shape.Rotation = 360f - Math.Abs(result);
				}
				else
				{
					shape.Rotation = Math.Abs(result);
				}
			}
			else
			{
				float.TryParse(propertyValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				shape.Rotation = result;
			}
			break;
		}
		case 7:
		case 9:
		case 10:
		case 11:
		case 12:
			break;
		}
	}

	private void Apply2007ShapeProperties(Shape shape, string propertyName, string propertyValue)
	{
		switch (propertyName)
		{
		case "margin-left":
			shape.HorizontalPosition = GetPointValue(propertyValue);
			break;
		case "margin-top":
			shape.VerticalPosition = GetPointValue(propertyValue);
			break;
		case "width":
			shape.Width = GetPointValue(propertyValue);
			break;
		case "height":
			shape.Height = GetPointValue(propertyValue);
			break;
		case "z-index":
		{
			int result2 = 0;
			int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
			if (shape.ZOrderPosition == int.MaxValue)
			{
				shape.ZOrderPosition = result2;
			}
			shape.IsBelowText = result2 <= 0;
			if (shape.IsBelowText)
			{
				shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
			}
			else
			{
				shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
			}
			break;
		}
		case "mso-position-horizontal":
			shape.HorizontalAlignment = GetHorizAlign(propertyValue);
			break;
		case "mso-position-vertical":
			shape.VerticalAlignment = GetVertAlign(propertyValue);
			break;
		case "v-text-anchor":
			shape.TextFrame.TextVerticalAlignment = GetTextVertAlign(propertyValue);
			break;
		case "mso-position-vertical-relative":
			shape.VerticalOrigin = GetVertOrigin(propertyValue);
			break;
		case "mso-position-horizontal-relative":
			shape.HorizontalOrigin = GetHorizOrigin(propertyValue);
			break;
		case "mso-left-percent":
			shape.TextFrame.HorizontalRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-top-percent":
			shape.TextFrame.VerticalRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-width-percent":
			shape.TextFrame.WidthRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-height-percent":
			shape.TextFrame.HeightRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-height-relative":
			shape.TextFrame.HeightOrigin = GetHeightOrigin(propertyValue);
			break;
		case "mso-width-relative":
			shape.TextFrame.WidthOrigin = GetWidthOrigin(propertyValue);
			break;
		case "mso-wrap-distance-left":
			shape.WrapFormat.DistanceLeft = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-top":
			shape.WrapFormat.DistanceTop = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-right":
			shape.WrapFormat.DistanceRight = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-bottom":
			shape.WrapFormat.DistanceBottom = GetPointValue(propertyValue);
			break;
		case "rotation":
		{
			if (string.IsNullOrEmpty(propertyValue))
			{
				break;
			}
			int result = 0;
			if (propertyValue.EndsWith("fd"))
			{
				int.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				result = result / 32768 / 2;
				if (result < 0)
				{
					shape.Rotation = 360 - Math.Abs(result);
				}
				else
				{
					shape.Rotation = Math.Abs(result);
				}
			}
			else
			{
				int.TryParse(propertyValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				shape.Rotation = result;
			}
			break;
		}
		case "flip":
			switch (propertyValue)
			{
			case "x":
				shape.FlipHorizontal = true;
				break;
			case "y":
				shape.FlipVertical = true;
				break;
			case "x y":
				shape.FlipHorizontal = true;
				shape.FlipVertical = true;
				break;
			default:
				shape.DocxStyleProps.Add(propertyName + ":" + propertyValue);
				break;
			}
			break;
		case "position":
			if (propertyValue == "absolute")
			{
				if (shape.ZOrderPosition == int.MaxValue)
				{
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
				}
			}
			else
			{
				shape.DocxStyleProps.Add(propertyName + ":" + propertyValue);
			}
			break;
		default:
			shape.DocxStyleProps.Add(propertyName + ":" + propertyValue);
			break;
		}
	}

	private void ParseDrawingProperties(XmlReader reader, Shape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "drawing")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "drawing")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "wrapSquare":
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
					break;
				case "wrapTight":
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
					ParseWrapPolygon(reader, shape);
					break;
				case "wrapThrough":
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
					ParseWrapPolygon(reader, shape);
					break;
				case "wrapTopAndBottom":
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
					break;
				case "wrapNone":
					if (shape.IsBelowText)
					{
						shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
					}
					else
					{
						shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
					}
					break;
				case "anchor":
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("behindDoc");
						shape.IsBelowText = ((attribute == "1" || attribute == "true") ? true : false);
						attribute = reader.GetAttribute("allowOverlap");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.WrapFormat.AllowOverlap = ((attribute == "1" || attribute == "true") ? true : false);
						}
						attribute = reader.GetAttribute("relativeHeight");
						if (!string.IsNullOrEmpty(attribute))
						{
							int result = 0;
							int.TryParse(attribute, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
							shape.ZOrderPosition = result;
						}
					}
					break;
				case "inline":
					shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
					break;
				case "bodypr":
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("vert");
						shape.TextFrame.TextDirection = GetTextDirection(attribute);
						attribute = reader.GetAttribute("anchor");
						shape.TextFrame.TextVerticalAlignment = GetTextVertAlign(attribute);
						attribute = reader.GetAttribute("wrap");
						if (attribute == "none")
						{
							shape.TextFrame.NoWrap = true;
						}
					}
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseWatermark(MemoryStream shapeStream, ParagraphItemCollection paraItems)
	{
		Entity baseEntity = GetBaseEntity(paraItems.OwnerBase as Entity);
		if (baseEntity != null && baseEntity is HeaderFooter && (baseEntity as HeaderFooter).Watermark != null && (baseEntity as HeaderFooter).Watermark.Type == WatermarkType.NoWatermark)
		{
			string text = FindAttributeValue(shapeStream, "shape", "id", null, readEmpty: false);
			if (StartsWithExt(text, "PowerPlusWaterMarkObject"))
			{
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 17);
				ParseTextWatermark(shapeStream, baseEntity as HeaderFooter);
			}
			else if (StartsWithExt(text, "WordPictureWatermark"))
			{
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 0);
				ParsePictureWatermark(shapeStream, baseEntity as HeaderFooter);
			}
		}
		if (baseEntity is HeaderFooter)
		{
			(baseEntity as HeaderFooter).WriteWatermark = true;
		}
	}

	private Entity GetBaseEntity(Entity entity)
	{
		Entity entity2 = entity;
		do
		{
			if (entity2.Owner == null)
			{
				return entity2;
			}
			entity2 = entity2.Owner;
		}
		while (!(entity2 is WSection) && !(entity2 is HeaderFooter));
		return entity2;
	}

	private void ParsePictureWatermark(MemoryStream shapeStream, HeaderFooter header)
	{
		PictureWatermark pictureWatermark = header.InsertWatermark(WatermarkType.PictureWatermark) as PictureWatermark;
		pictureWatermark.SetOwner(header);
		WPicture wPicture = null;
		if (IsWord2003ML)
		{
			string s = FindElementValue(shapeStream, "binData", "http://schemas.microsoft.com/office/word/2003/wordml");
			string text = FindAttributeValue(shapeStream, "binData", "name", "http://schemas.microsoft.com/office/word/2003/wordml", readEmpty: false);
			if (!string.IsNullOrEmpty(text) && !text.ToLower().Contains(".wmz") && !text.ToLower().Contains(".emz"))
			{
				try
				{
					byte[] imageBytes = Convert.FromBase64String(s);
					wPicture = new WPicture(m_doc);
					wPicture.LoadImage(imageBytes);
				}
				catch
				{
					wPicture = new WPicture(m_doc);
				}
			}
			else
			{
				wPicture = new WPicture(m_doc);
			}
		}
		else
		{
			string id = FindAttributeValue(shapeStream, "imagedata", "id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships", readEmpty: false);
			wPicture = new WPicture(m_doc);
			LoadImage(wPicture, id, isHeaderFooter: true, isPicBullet: false);
		}
		pictureWatermark.WordPicture = wPicture;
		string text2 = FindAttributeValue(shapeStream, "imagedata", "title", "urn:schemas-microsoft-com:office:office", readEmpty: true);
		if (text2 != null)
		{
			pictureWatermark.WordPicture.Title = text2;
		}
		string text3 = FindAttributeValue(shapeStream, "imagedata", "gain", null, readEmpty: false);
		string text4 = FindAttributeValue(shapeStream, "imagedata", "blacklevel", null, readEmpty: false);
		string value = FindAttributeValue(shapeStream, "imagedata", "cropbottom", null, readEmpty: false);
		if (!string.IsNullOrEmpty(value))
		{
			pictureWatermark.WordPicture.FillRectangle.BottomOffset = GetCroppingValues(value);
		}
		value = FindAttributeValue(shapeStream, "imagedata", "cropleft", null, readEmpty: false);
		if (!string.IsNullOrEmpty(value))
		{
			pictureWatermark.WordPicture.FillRectangle.LeftOffset = GetCroppingValues(value);
		}
		value = FindAttributeValue(shapeStream, "imagedata", "cropright", null, readEmpty: false);
		if (!string.IsNullOrEmpty(value))
		{
			pictureWatermark.WordPicture.FillRectangle.RightOffset = GetCroppingValues(value);
		}
		value = FindAttributeValue(shapeStream, "imagedata", "croptop", null, readEmpty: false);
		if (!string.IsNullOrEmpty(value))
		{
			pictureWatermark.WordPicture.FillRectangle.TopOffset = GetCroppingValues(value);
		}
		if (text3 == null && text4 == null)
		{
			pictureWatermark.Washout = false;
		}
		shapeStream.Position = 0L;
		XmlReader reader = UtilityMethods.CreateReader(shapeStream);
		ParsePictureWatermarkProperties(reader, pictureWatermark);
		pictureWatermark.OrderIndex = pictureWatermark.WordPicture.OrderIndex;
		if (m_doc.Watermark != null && m_doc.Watermark.Type == WatermarkType.NoWatermark)
		{
			m_doc.Watermark = pictureWatermark;
		}
	}

	private void ParsePictureWatermarkProperties(XmlReader reader, PictureWatermark watermark)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "shape")
				{
					ParsePictureShapeProperties(reader, watermark.WordPicture);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextWatermark(Stream stream, HeaderFooter header)
	{
		TextWatermark textWatermark = header.InsertWatermark(WatermarkType.TextWatermark) as TextWatermark;
		textWatermark.SetOwner(header);
		if (FindAttributeValue(stream, "fill", "opacity", null, readEmpty: false) == null)
		{
			textWatermark.Semitransparent = false;
		}
		XmlReader reader = UtilityMethods.CreateReader(stream);
		ParseTextWatermarkProperties(reader, textWatermark);
		if (m_doc.Watermark != null && m_doc.Watermark.Type == WatermarkType.NoWatermark)
		{
			m_doc.Watermark = textWatermark;
		}
	}

	private void ParseTextWatermarkProperties(XmlReader reader, TextWatermark watermark)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName3 = reader.LocalName;
				if (!(localName3 == "textpath"))
				{
					if (localName3 == "shape")
					{
						string attribute = reader.GetAttribute("fillcolor");
						if (attribute == null)
						{
							break;
						}
						if (attribute == "auto")
						{
							watermark.Color = Color.Empty;
						}
						else
						{
							watermark.Color = GetColorValue(attribute);
						}
						ParseTextWatermarkPosition(reader, watermark);
					}
				}
				else
				{
					if (!string.IsNullOrEmpty(reader.GetAttribute("string")))
					{
						watermark.Text = reader.GetAttribute("string");
					}
					if (!string.IsNullOrEmpty(reader.GetAttribute("style")))
					{
						ParseTextWatermarkStyleAndSize(reader, watermark);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextWatermarkPosition(XmlReader reader, TextWatermark watermark)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute.Length == 0)
		{
			return;
		}
		watermark.Layout = WatermarkLayout.Horizontal;
		attribute = attribute.Trim();
		char[] separator = new char[1] { ';' };
		string[] array = attribute.Split(separator);
		string[] array2 = new string[2];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				ParseTextWatermarkProperties(watermark, array2[0], array2[1]);
			}
		}
	}

	private void ParseTextWatermarkProperties(TextWatermark waterMark, string propertyName, string propertyValue)
	{
		if (propertyName == null)
		{
			return;
		}
		switch (propertyName.Length)
		{
		case 10:
			switch (propertyName[0])
			{
			case 'm':
				if (propertyName == "margin-top")
				{
					waterMark.VerticalPosition = GetPointValue(propertyValue);
				}
				break;
			case 'v':
				if (propertyName == "visibility" && propertyValue != null && propertyValue.ToLower() == "hidden")
				{
					waterMark.Visible = false;
				}
				break;
			}
			break;
		case 8:
			switch (propertyName[0])
			{
			case 'p':
				if (!(propertyName == "position"))
				{
					break;
				}
				if (!(propertyValue == "absolute"))
				{
					if (propertyValue == "relative")
					{
						waterMark.Position = ShapePosition.Relative;
					}
				}
				else
				{
					waterMark.Position = ShapePosition.Absolute;
				}
				break;
			case 'r':
				if (propertyName == "rotation")
				{
					int result2 = 0;
					int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
					waterMark.Rotation = result2;
					if (result2 != 0)
					{
						waterMark.Layout = WatermarkLayout.Diagonal;
					}
				}
				break;
			}
			break;
		case 11:
			if (propertyName == "margin-left")
			{
				waterMark.HorizontalPosition = GetPointValue(propertyValue);
			}
			break;
		case 5:
			if (propertyName == "width")
			{
				waterMark.Width = GetPointValue(propertyValue);
			}
			break;
		case 6:
			if (propertyName == "height")
			{
				waterMark.Height = GetPointValue(propertyValue);
			}
			break;
		case 7:
			if (propertyName == "z-index")
			{
				int result = 0;
				int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
				if (waterMark.OrderIndex == int.MaxValue)
				{
					waterMark.OrderIndex = result;
				}
			}
			break;
		case 23:
			if (propertyName == "mso-position-horizontal")
			{
				waterMark.HorizontalAlignment = GetHorizAlign(propertyValue);
			}
			break;
		case 21:
			if (propertyName == "mso-position-vertical")
			{
				waterMark.VerticalAlignment = GetVertAlign(propertyValue);
			}
			break;
		case 30:
			if (propertyName == "mso-position-vertical-relative")
			{
				waterMark.VerticalOrigin = GetVertOrigin(propertyValue);
			}
			break;
		case 32:
			if (propertyName == "mso-position-horizontal-relative")
			{
				waterMark.HorizontalOrigin = GetHorizOrigin(propertyValue);
			}
			break;
		}
	}

	private void ParseTextWatermarkStyleAndSize(XmlReader reader, TextWatermark watermark)
	{
		float height = watermark.Height;
		float width = watermark.Width;
		string attribute = reader.GetAttribute("style");
		if (attribute.Length == 0)
		{
			return;
		}
		string[] array = attribute.Split(new char[1] { ';' });
		string text = array[0];
		text = text.Replace("\"", string.Empty);
		watermark.FontName = text.Replace("font-family:", string.Empty);
		string text2 = ((array.Length == 2) ? array[1] : string.Empty);
		if (text2 != string.Empty)
		{
			if (text2 == "font-size:2in")
			{
				watermark.Size = 144f;
			}
			else
			{
				text2 = text2.Replace("font-size:", string.Empty);
				watermark.Size = ParseSize(text2);
			}
		}
		watermark.Height = height;
		watermark.Width = width;
	}

	private string FindAttributeValue(Stream stream, string elementName, string attributeName, string namspace, bool readEmpty)
	{
		stream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == elementName)
			{
				string attribute = xmlReader.GetAttribute(attributeName, namspace);
				if (!string.IsNullOrEmpty(attribute) || (readEmpty && attribute != null))
				{
					stream.Position = 0L;
					return attribute;
				}
			}
		}
		stream.Position = 0L;
		return null;
	}

	private string FindElementValue(Stream stream, string elementName, string namspace)
	{
		stream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		while (xmlReader.Read())
		{
			if (xmlReader.LocalName == elementName)
			{
				string text = Read2003ImageBase64String(xmlReader, null);
				if (!string.IsNullOrEmpty(text))
				{
					stream.Position = 0L;
					return text;
				}
			}
		}
		stream.Position = 0L;
		return null;
	}

	private WPicture ParsePictureShape(MemoryStream shapeStream)
	{
		XmlReader reader = UtilityMethods.CreateReader(shapeStream);
		WPicture wPicture = new WPicture(m_doc);
		if (m_currentRunFormat != null)
		{
			wPicture.CharacterFormat.ImportContainer(m_currentRunFormat);
			ApplyDirectionalOverride(wPicture.CharacterFormat);
		}
		m_currentRunFormat = null;
		wPicture.PictureShape.ShapeContainer = new MsofbtSpContainer(m_doc);
		wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtOPT(m_doc));
		wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtTertiaryFOPT(m_doc));
		ParsePictureShape(reader, wPicture);
		return wPicture;
	}

	private void ParsePictureShape(XmlReader reader, IEntity entity)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		bool flag = false;
		if (reader.LocalName != "shape")
		{
			reader.Read();
			SkipWhitespaces(reader);
			flag = true;
			localName = reader.LocalName;
		}
		bool flag2 = false;
		bool isAlreadyChecked = false;
		if (!flag)
		{
			ParsePictureShapeProperties(reader, entity);
			reader.Read();
			SkipWhitespaces(reader);
			isAlreadyChecked = true;
			flag2 = true;
		}
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (!reader.EOF && (!(reader.LocalName == localName2) || reader.NodeType != XmlNodeType.EndElement))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (localName == "shape")
				{
					if (!flag2)
					{
						ParsePictureShapeProperties(reader, entity);
					}
					(entity as WPicture).IsShape = true;
					ParsePictureShapeImage(reader, entity, localName, flag2, isAlreadyChecked);
					localName = reader.LocalName;
				}
				else
				{
					if (IsWord2003ML && reader.LocalName == "binData")
					{
						string attribute = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
						if (!string.IsNullOrEmpty(attribute) && !attribute.ToLower().Contains(".wmz") && !attribute.ToLower().Contains(".emz"))
						{
							WPicture wPicture = entity as WPicture;
							try
							{
								byte[] imageBytes = Convert.FromBase64String(Read2003ImageBase64String(reader, null));
								wPicture.LoadImage(imageBytes);
							}
							catch
							{
								break;
							}
						}
					}
					localName = reader.LocalName;
				}
				reader.Read();
				localName = reader.LocalName;
				flag2 = false;
				isAlreadyChecked = true;
			}
			else
			{
				reader.Read();
				localName = reader.LocalName;
				flag2 = false;
				isAlreadyChecked = true;
			}
		}
	}

	private string Read2003ImageBase64String(XmlReader reader, string endNode)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			if (endNode == null)
			{
				endNode = reader.LocalName;
				reader.Read();
			}
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				string result = null;
				while (reader.LocalName != endNode)
				{
					if (reader.NodeType == XmlNodeType.Text)
					{
						result = reader.Value;
						result = result.Replace(ControlChar.CarriegeReturn, "");
						result = result.Replace(ControlChar.LineFeed, "");
						result = result.Replace(" ", "");
					}
					reader.Read();
				}
				return result;
			}
			return string.Empty;
		}
		return string.Empty;
	}

	private void ParsePictureShapeImageValues(XmlReader reader, IEntity ent, string localName, bool isAlreadyRead)
	{
		if (!isAlreadyRead)
		{
			reader.Read();
		}
		WPicture wPicture = ent as WPicture;
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName.ToLower())
				{
				case "imagedata":
				{
					string attribute3 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					string attribute4 = reader.GetAttribute("href", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (!string.IsNullOrEmpty(attribute3))
					{
						bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
						float width = wPicture.Width;
						float height = wPicture.Height;
						if (!string.IsNullOrEmpty(attribute4))
						{
							bool isImageRelation = true;
							string imageName = GetImageName(attribute4, isHeaderFooter, isPicBullet: false, ref isImageRelation);
							if (isImageRelation && !string.IsNullOrEmpty(imageName) && m_isExternalHyperlink != null && m_docRelations.ContainsKey(attribute3) && IsExternalHyperlink.ContainsKey(attribute3) && IsExternalHyperlink[attribute3])
							{
								wPicture.ExternalLink = imageName;
							}
						}
						LoadImage(wPicture, attribute3, isHeaderFooter, isPicBullet: false);
						wPicture.Width = width;
						wPicture.Height = height;
					}
					string attribute5 = reader.GetAttribute("title", "urn:schemas-microsoft-com:office:office");
					if (attribute5 != null)
					{
						wPicture.Title = attribute5;
					}
					string attribute6 = reader.GetAttribute("croptop");
					if (!string.IsNullOrEmpty(attribute6))
					{
						wPicture.FillRectangle.TopOffset = GetCroppingValues(attribute6);
					}
					attribute6 = reader.GetAttribute("cropleft");
					if (!string.IsNullOrEmpty(attribute6))
					{
						wPicture.FillRectangle.LeftOffset = GetCroppingValues(attribute6);
					}
					attribute6 = reader.GetAttribute("cropbottom");
					if (!string.IsNullOrEmpty(attribute6))
					{
						wPicture.FillRectangle.BottomOffset = GetCroppingValues(attribute6);
					}
					attribute6 = reader.GetAttribute("cropright");
					if (!string.IsNullOrEmpty(attribute6))
					{
						wPicture.FillRectangle.RightOffset = GetCroppingValues(attribute6);
					}
					string attribute7 = reader.GetAttribute("chromakey");
					if (!string.IsNullOrEmpty(attribute7))
					{
						wPicture.ChromaKeyColor = GetColorValue(attribute7);
					}
					string attribute8 = reader.GetAttribute("gain");
					if (!string.IsNullOrEmpty(attribute8))
					{
						double result = 0.0;
						if (!attribute8.EndsWith("%") && !attribute8.EndsWith("f"))
						{
							if (double.TryParse(attribute8, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
							{
								SetContrastFromDecimal(wPicture, result);
							}
						}
						else if (attribute8.EndsWith("f") && double.TryParse(attribute8.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							SetContrastFromFloatRange(wPicture, result);
						}
					}
					string attribute9 = reader.GetAttribute("blacklevel");
					if (!string.IsNullOrEmpty(attribute9))
					{
						float result2 = 0f;
						if (!attribute9.EndsWith("%") && !attribute9.EndsWith("f"))
						{
							if (float.TryParse(attribute9, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
							{
								SetBrightnessFromDecimal(wPicture, result2);
							}
						}
						else if (attribute9.EndsWith("f") && float.TryParse(attribute9.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
						{
							SetBrightnessFromFloatRange(wPicture, result2);
						}
					}
					string attribute10 = reader.GetAttribute("grayscale");
					if (!string.IsNullOrEmpty(attribute10))
					{
						wPicture.FillFormat.BlipFormat.GrayScale = GetBoolValue(attribute10.ToLower());
					}
					string attribute11 = reader.GetAttribute("bilevel");
					if (!string.IsNullOrEmpty(attribute11))
					{
						wPicture.FillFormat.BlipFormat.BiLevel = GetBoolValue(attribute11.ToLower());
					}
					break;
				}
				case "wrap":
				{
					string attribute = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute) && wPicture.Owner is WOleObject)
					{
						ParseOlePictureWrapStyle(reader, wPicture);
					}
					else if (!string.IsNullOrEmpty(attribute) && wPicture.Position != 0 && attribute != "none")
					{
						wPicture.SetTextWrappingStyleValue(GetWrapStyle(attribute));
					}
					string attribute2 = reader.GetAttribute("side");
					if (!string.IsNullOrEmpty(attribute2))
					{
						wPicture.TextWrappingType = GetWrapType(attribute2);
					}
					break;
				}
				case "bordertop":
					ParseShapeBorder(reader, wPicture.PictureShape.PictureDescriptor.BorderTop);
					break;
				case "borderleft":
					ParseShapeBorder(reader, wPicture.PictureShape.PictureDescriptor.BorderLeft);
					break;
				case "borderbottom":
					ParseShapeBorder(reader, wPicture.PictureShape.PictureDescriptor.BorderBottom);
					break;
				case "borderright":
					ParseShapeBorder(reader, wPicture.PictureShape.PictureDescriptor.BorderRight);
					break;
				case "stroke":
					ParseStrokeProps(reader, wPicture.PictureShape);
					break;
				case "lock":
					wPicture.SignatureLineElements.Add(ReadSingleNodeIntoStream(reader));
					continue;
				case "signatureline":
					wPicture.SignatureLineElements.Add(ReadSingleNodeIntoStream(reader));
					continue;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void SetBrightnessFromFloatRange(WPicture pict, float value)
	{
		Dictionary<float, List<float>> brightnessValueRanges = pict.GetBrightnessValueRanges();
		int num = 0;
		if (value >= 0f)
		{
			num = 50;
		}
		for (int i = num; i < brightnessValueRanges.Count; i++)
		{
			List<float> list = brightnessValueRanges[i];
			if (list[0] <= value && value <= list[1])
			{
				pict.FillFormat.BlipFormat.ImageEffect.Brightness = i;
				break;
			}
		}
		brightnessValueRanges.Clear();
		brightnessValueRanges = null;
	}

	private void SetBrightnessFromDecimal(WPicture pict, float value)
	{
		Dictionary<float, float> dictionary = new Dictionary<float, float>();
		dictionary.Add(-0.5f, 0f);
		dictionary.Add(-0.25f, 25f);
		dictionary.Add(0.25f, 75f);
		dictionary.Add(0.5f, 100f);
		if (dictionary.ContainsKey(value))
		{
			pict.FillFormat.BlipFormat.ImageEffect.Brightness = dictionary[value];
		}
		dictionary.Clear();
		dictionary = null;
	}

	private void SetContrastFromFloatRange(WPicture pict, double value)
	{
		Dictionary<float, List<double>> contrastValueRanges = pict.GetContrastValueRanges();
		foreach (KeyValuePair<float, List<double>> item in contrastValueRanges)
		{
			float key = item.Key;
			List<double> value2 = item.Value;
			if (value2[0] <= value && value <= value2[1])
			{
				pict.FillFormat.BlipFormat.ImageEffect.Contrast = key;
				break;
			}
		}
		contrastValueRanges.Clear();
		contrastValueRanges = null;
	}

	private void SetContrastFromDecimal(WPicture pict, double value)
	{
		Dictionary<double, float> dictionary = new Dictionary<double, float>();
		dictionary.Add(0.0, 0f);
		dictionary.Add(0.5, 25f);
		dictionary.Add(1.25, 60f);
		dictionary.Add(2.0, 75f);
		dictionary.Add(2.5, 80f);
		dictionary.Add(5.0, 90f);
		dictionary.Add(10.0, 95f);
		if (dictionary.ContainsKey(value))
		{
			pict.FillFormat.BlipFormat.ImageEffect.Contrast = dictionary[value];
		}
		dictionary.Clear();
		dictionary = null;
	}

	private void ParsePictureShapeImage(XmlReader reader, IEntity ent, string localName, bool isAlreadyRead, bool isAlreadyChecked)
	{
		if (isAlreadyChecked)
		{
			ParsePictureShapeImageValues(reader, ent, localName, isAlreadyRead);
		}
		else if (!reader.IsEmptyElement)
		{
			localName = reader.LocalName;
			_ = reader.LocalName;
			reader.Read();
			isAlreadyRead = true;
			if (reader.NodeType != XmlNodeType.EndElement)
			{
				ParsePictureShapeImageValues(reader, ent, localName, isAlreadyRead: true);
			}
		}
	}

	private float GetCroppingValues(string value)
	{
		float result = 0f;
		if (value.EndsWith("f"))
		{
			if (float.TryParse(value.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				result = (float)Math.Round((float)((double)result * 1.5259) / 1000f, 3);
			}
		}
		else if (value.EndsWith("%"))
		{
			if (float.TryParse(value.Replace("%", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				result = result * 65536f / 100f;
				result = (float)Math.Round((float)((double)result * 1.5259) / 1000f, 3);
			}
		}
		else if (StartsWithExt(value, "."))
		{
			if (float.TryParse(value.Replace(".", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				result = result * 65536f / 100f;
				result = (float)Math.Round((float)((double)result * 1.5259) / 1000f, 3);
			}
		}
		else if (StartsWithExt(value, "0.") && float.TryParse(value.Replace("0.", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result))
		{
			result = result * 65536f / 100f;
			result = (float)Math.Round((float)((double)result * 1.5259) / 1000f, 3);
		}
		return result;
	}

	private void ParseStrokeProps(XmlReader reader, InlineShapeObject shape)
	{
		if (!shape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
			shape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
			shape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
		}
		string attribute = reader.GetAttribute("on");
		if (!string.IsNullOrEmpty(attribute))
		{
			bool boolValue = GetBoolValue(attribute);
			shape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = boolValue;
			shape.ShapeContainer.ShapeOptions.LineProperties.Line = boolValue;
		}
		attribute = reader.GetAttribute("color");
		if (!string.IsNullOrEmpty(attribute))
		{
			Color hexColor = GetHexColor(attribute);
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(hexColor));
		}
		attribute = reader.GetAttribute("dashstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(462, (uint)GetDashStyle(attribute));
		}
		attribute = reader.GetAttribute("endarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(465, (uint)GetLineEnd(attribute));
		}
		attribute = reader.GetAttribute("endarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(469, (uint)GetLineEndLength(attribute));
		}
		attribute = reader.GetAttribute("endarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(468, (uint)GetLineEndWidth(attribute));
		}
		attribute = reader.GetAttribute("endcap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(471, (uint)GetLineCapStyle(attribute));
		}
		attribute = reader.GetAttribute("forcedash");
		if (!string.IsNullOrEmpty(attribute))
		{
			bool boolValue2 = GetBoolValue(attribute);
			shape.ShapeContainer.ShapeOptions.LineProperties.UsefNoLineDrawDash = boolValue2;
			shape.ShapeContainer.ShapeOptions.LineProperties.NoLineDrawDash = boolValue2;
		}
		attribute = reader.GetAttribute("insetpen");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = GetBoolValue(attribute);
		}
		attribute = reader.GetAttribute("joinstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, (uint)GetLineJoinStyle(attribute));
		}
		attribute = reader.GetAttribute("linestyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(461, (uint)GetLineStyle(attribute));
		}
		attribute = reader.GetAttribute("miterlimit");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute.EndsWith("f"))
			{
				attribute = attribute.Replace("f", "");
				uint.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out var result);
				shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, result);
			}
			else if (attribute.EndsWith("%"))
			{
				uint result = (uint)(GetPercentage(attribute) * 65536.0 / 100.0);
				shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, result);
			}
		}
		attribute = reader.GetAttribute("opacity");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute.EndsWith("f"))
			{
				uint.TryParse(attribute.Replace("f", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out var result2);
				shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, result2);
			}
			else if (attribute.EndsWith("%"))
			{
				uint result2 = (uint)(GetPercentage(attribute) * 65536.0 / 100.0);
				shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, result2);
			}
		}
		attribute = reader.GetAttribute("startarrow");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(464, (uint)GetLineEnd(attribute));
		}
		attribute = reader.GetAttribute("startarrowlength");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(467, (uint)GetLineEndLength(attribute));
		}
		attribute = reader.GetAttribute("startarrowwidth");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(466, (uint)GetLineEndWidth(attribute));
		}
		attribute = reader.GetAttribute("weight");
		if (!string.IsNullOrEmpty(attribute))
		{
			uint value = (uint)(GetPointValue(attribute) * 12700f);
			shape.ShapeContainer.ShapeOptions.SetPropertyValue(459, value);
		}
	}

	private DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin GetLineJoinStyle(string lineJoinStyle)
	{
		if (!(lineJoinStyle == "bevel"))
		{
			if (lineJoinStyle == "round")
			{
				return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Round;
			}
			return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Miter;
		}
		return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Bevel;
	}

	private void ParseShapeBorder(XmlReader reader, BorderCode brc)
	{
		string attribute = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute))
		{
			BorderStyle shapeBorderStyle = GetShapeBorderStyle(attribute);
			brc.BorderType = (byte)shapeBorderStyle;
		}
		attribute = reader.GetAttribute("width");
		if (!string.IsNullOrEmpty(attribute))
		{
			int result = 0;
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			brc.LineWidth = (byte)result;
		}
		attribute = reader.GetAttribute("shadow");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "on":
			case "1":
			case "true":
				brc.Shadow = true;
				break;
			}
		}
	}

	private BorderStyle GetShapeBorderStyle(string boderStyle)
	{
		BorderStyle result = BorderStyle.None;
		switch (boderStyle)
		{
		case "single":
			result = BorderStyle.Single;
			break;
		case "thick":
			result = BorderStyle.Thick;
			break;
		case "double":
			result = BorderStyle.Double;
			break;
		case "hairline":
			result = BorderStyle.Hairline;
			break;
		case "dot":
			result = BorderStyle.Dot;
			break;
		case "dash":
			result = BorderStyle.DashLargeGap;
			break;
		case "dotDash":
			result = BorderStyle.DotDash;
			break;
		case "dashDotDot":
			result = BorderStyle.DotDotDash;
			break;
		case "triple":
			result = BorderStyle.Triple;
			break;
		case "thinThickSmall":
			result = BorderStyle.ThinThickSmallGap;
			break;
		case "thickThinSmall":
			result = BorderStyle.ThinThinSmallGap;
			break;
		case "thickBetweenThinSmall":
			result = BorderStyle.ThinThickThinSmallGap;
			break;
		case "thinThick":
			result = BorderStyle.ThinThickMediumGap;
			break;
		case "thickThin":
			result = BorderStyle.ThickThinMediumGap;
			break;
		case "thickBetweenThin":
			result = BorderStyle.ThickThickThinMediumGap;
			break;
		case "thinThickLarge":
			result = BorderStyle.ThinThickLargeGap;
			break;
		case "thickThinLarge":
			result = BorderStyle.ThickThinLargeGap;
			break;
		case "thickBetweenThinLarge":
			result = BorderStyle.ThinThickThinLargeGap;
			break;
		case "wave":
			result = BorderStyle.Wave;
			break;
		case "doubleWave":
			result = BorderStyle.DoubleWave;
			break;
		case "dashedSmall":
			result = BorderStyle.DashSmallGap;
			break;
		case "dashDotStroked":
			result = BorderStyle.DashDotStroker;
			break;
		case "threeDEmboss":
			result = BorderStyle.Emboss3D;
			break;
		case "threeDEngrave":
			result = BorderStyle.Engrave3D;
			break;
		case "HTMLOutset":
			result = BorderStyle.Outset;
			break;
		case "HTMLInset":
			result = BorderStyle.Inset;
			break;
		}
		return result;
	}

	private void ParsePictureShapeProperties(XmlReader reader, IEntity ent)
	{
		WPicture wPicture = ent as WPicture;
		wPicture.PictureShape.ShapeContainer = new MsofbtSpContainer(m_doc);
		wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtOPT(m_doc));
		wPicture.PictureShape.ShapeContainer.Children.Add(new MsofbtTertiaryFOPT(m_doc));
		string attribute = reader.GetAttribute("style");
		if (attribute != null && attribute != string.Empty)
		{
			ParsePictureShapeStyle(attribute, wPicture);
		}
		string attribute2 = reader.GetAttribute("bordertopcolor", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			Color hexColor = GetHexColor(attribute2);
			int num = WordColor.ConvertColorToId(hexColor);
			wPicture.PictureShape.PictureDescriptor.BorderTop.LineColor = (byte)num;
			wPicture.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(923, WordColor.ConvertColorToRGB(hexColor));
		}
		attribute2 = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			wPicture.PictureShape.IsHorizontalRule = GetBoolValue(attribute2);
		}
		attribute2 = reader.GetAttribute("borderleftcolor", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			Color hexColor2 = GetHexColor(attribute2);
			int num2 = WordColor.ConvertColorToId(hexColor2);
			wPicture.PictureShape.PictureDescriptor.BorderLeft.LineColor = (byte)num2;
			wPicture.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(924, WordColor.ConvertColorToRGB(hexColor2));
		}
		attribute2 = reader.GetAttribute("borderbottomcolor", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			Color hexColor3 = GetHexColor(attribute2);
			int num3 = WordColor.ConvertColorToId(hexColor3);
			wPicture.PictureShape.PictureDescriptor.BorderBottom.LineColor = (byte)num3;
			wPicture.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(925, WordColor.ConvertColorToRGB(hexColor3));
		}
		attribute2 = reader.GetAttribute("borderrightcolor", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			Color hexColor4 = GetHexColor(attribute2);
			int num4 = WordColor.ConvertColorToId(hexColor4);
			wPicture.PictureShape.PictureDescriptor.BorderRight.LineColor = (byte)num4;
			wPicture.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(926, WordColor.ConvertColorToRGB(hexColor4));
		}
		attribute2 = reader.GetAttribute("stroked");
		if (!string.IsNullOrEmpty(attribute2))
		{
			wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
			if (GetBoolValue(attribute2))
			{
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
			}
		}
		attribute2 = reader.GetAttribute("strokecolor");
		if (!string.IsNullOrEmpty(attribute2))
		{
			if (!wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
			{
				wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
			}
			Color hexColor5 = GetHexColor(attribute2);
			wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(hexColor5));
		}
		attribute2 = reader.GetAttribute("strokeweight");
		if (!string.IsNullOrEmpty(attribute2))
		{
			if (!wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
			{
				wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
			}
			uint value = (uint)(GetPointValue(attribute2) * 12700f);
			wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(459, value);
		}
		attribute2 = reader.GetAttribute("insetpen");
		if (!string.IsNullOrEmpty(attribute2))
		{
			if (!wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
			{
				wPicture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
				wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
			}
			wPicture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = GetBoolValue(attribute2);
		}
		wPicture.Href = reader.GetAttribute("href");
		wPicture.AlternativeText = reader.GetAttribute("alt");
		wPicture.Name = reader.GetAttribute("name");
		attribute2 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute2))
		{
			wPicture.LayoutInCell = GetBoolValue(attribute2);
		}
	}

	public void ParsePictureShapeStyle(string style, WPicture pic)
	{
		style = style.Trim();
		string[] array = SortShapeStyle(style);
		string[] array2 = new string[2];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				ParsePictureShapeProperties(pic, array2[0], array2[1]);
			}
		}
	}

	private string[] SortShapeStyle(string style)
	{
		char separator = ';';
		char separator2 = ':';
		List<string> list = new List<string>();
		string[] array = style.Split(separator);
		string[] array2 = new string[12]
		{
			"position", "margin-left", "margin-top", "width", "height", "rotation", "z-index", "mso-position-horizontal", "mso-position-vertical", "mso-position-horizontal-relative",
			"mso-position-vertical-relative", "visibility"
		};
		for (int i = 0; i < array2.Length; i++)
		{
			for (int j = 0; j < array.Length; j++)
			{
				string[] array3 = array[j].Split(separator2);
				if (array2[i] == array3[0])
				{
					list.Add(array[j]);
				}
			}
		}
		string[] array4 = new string[list.Count];
		for (int k = 0; k < list.Count; k++)
		{
			array4[k] = list[k];
		}
		return array4;
	}

	private void ParsePictureShapeProperties(WPicture pic, string propertyName, string propertyValue)
	{
		if (propertyName == null)
		{
			return;
		}
		switch (propertyName.Length)
		{
		case 10:
			switch (propertyName[0])
			{
			case 'm':
				if (propertyName == "margin-top")
				{
					pic.VerticalPosition = GetPointValue(propertyValue);
				}
				break;
			case 'v':
				if (propertyName == "visibility" && propertyValue != null && propertyValue.ToLower() == "hidden")
				{
					pic.Visible = false;
				}
				break;
			}
			break;
		case 8:
			switch (propertyName[0])
			{
			case 'p':
				if (!(propertyName == "position"))
				{
					break;
				}
				if (!string.IsNullOrEmpty(propertyValue) && propertyValue == "absolute")
				{
					pic.HorizontalOrigin = HorizontalOrigin.Column;
					pic.VerticalOrigin = VerticalOrigin.Paragraph;
				}
				if (!(propertyValue == "absolute"))
				{
					if (propertyValue == "relative")
					{
						pic.Position = ShapePosition.Relative;
					}
				}
				else
				{
					pic.Position = ShapePosition.Absolute;
				}
				if (pic.Position != 0)
				{
					pic.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
				}
				break;
			case 'r':
			{
				if (!(propertyName == "rotation") || string.IsNullOrEmpty(propertyValue))
				{
					break;
				}
				double result = 0.0;
				if (propertyValue.EndsWith("fd"))
				{
					double.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					result = result / 32768.0 / 2.0;
					result = Math.Round(result);
					if (result < 0.0)
					{
						pic.Rotation = (float)(360.0 - Math.Abs(result));
					}
					else
					{
						pic.Rotation = (float)Math.Abs(result);
					}
				}
				else
				{
					double.TryParse(propertyValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					pic.Rotation = (float)result;
				}
				break;
			}
			}
			break;
		case 11:
			if (propertyName == "margin-left")
			{
				pic.HorizontalPosition = GetPointValue(propertyValue);
			}
			break;
		case 5:
			if (propertyName == "width")
			{
				pic.Width = GetPointValue(propertyValue);
			}
			break;
		case 6:
			if (propertyName == "height")
			{
				pic.Height = GetPointValue(propertyValue);
			}
			break;
		case 7:
		{
			if (!(propertyName == "z-index"))
			{
				break;
			}
			int result2 = 0;
			int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
			if (pic.OrderIndex == int.MaxValue)
			{
				pic.OrderIndex = result2;
			}
			pic.IsBelowText = result2 <= 0;
			if (pic.Position != 0)
			{
				if (pic.IsBelowText)
				{
					pic.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
				}
				else
				{
					pic.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
				}
			}
			break;
		}
		case 23:
			if (propertyName == "mso-position-horizontal")
			{
				pic.HorizontalAlignment = GetHorizAlign(propertyValue);
			}
			break;
		case 21:
			if (propertyName == "mso-position-vertical")
			{
				pic.VerticalAlignment = GetVertAlign(propertyValue);
			}
			break;
		case 30:
			if (propertyName == "mso-position-vertical-relative")
			{
				pic.VerticalOrigin = GetVertOrigin(propertyValue);
			}
			break;
		case 32:
			if (propertyName == "mso-position-horizontal-relative")
			{
				pic.HorizontalOrigin = GetHorizOrigin(propertyValue);
			}
			break;
		}
	}

	private WTextBox ParseTextboxShape(MemoryStream shapeStream, MemoryStream drawingStream)
	{
		shapeStream.Position = 0L;
		XmlReader reader = UtilityMethods.CreateReader(shapeStream);
		WTextBox wTextBox = new WTextBox(m_doc);
		wTextBox.InitializeVMLDefaultValues();
		wTextBox.ApplyCharacterFormat(m_currentRunFormat);
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 13);
		if (drawingStream != null)
		{
			drawingStream.Position = 0L;
			XmlReader reader2 = UtilityMethods.CreateReader(drawingStream);
			ParseTextboxProperties(reader2, wTextBox);
		}
		ParseTextboxShape(reader, wTextBox);
		return wTextBox;
	}

	private void ParseTextboxProperties(XmlReader reader, WTextBox textbox)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "drawing")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "drawing")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "wsp":
				{
					string attribute2 = reader.GetAttribute("normalEastAsianFlow");
					if (!string.IsNullOrEmpty(attribute2) && !flag2)
					{
						textbox.TextBoxFormat.TextDirection = (GetBoolValue(attribute2) ? TextDirection.HorizontalFarEast : TextDirection.Horizontal);
						flag2 = textbox.TextBoxFormat.TextDirection == TextDirection.HorizontalFarEast;
					}
					break;
				}
				case "wrapSquare":
					textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
					break;
				case "wrapTight":
					textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
					ParseWrapPolygon(reader, textbox);
					break;
				case "wrapThrough":
					textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
					ParseWrapPolygon(reader, textbox);
					break;
				case "wrapTopAndBottom":
					textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
					break;
				case "wrapNone":
					if (!flag3)
					{
						if (textbox.TextBoxFormat.IsBelowText)
						{
							textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
						}
						else
						{
							textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
						}
					}
					break;
				case "anchor":
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("behindDoc");
						textbox.TextBoxFormat.IsBelowText = ((attribute == "1" || attribute == "true") ? true : false);
						attribute = reader.GetAttribute("allowOverlap");
						if (!string.IsNullOrEmpty(attribute))
						{
							textbox.TextBoxFormat.AllowOverlap = ((attribute == "1" || attribute == "true") ? true : false);
						}
						attribute = reader.GetAttribute("relativeHeight");
						if (!string.IsNullOrEmpty(attribute))
						{
							int result = 0;
							int.TryParse(attribute, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
							textbox.TextBoxFormat.OrderIndex = result;
						}
					}
					break;
				case "inline":
					flag3 = true;
					textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
					break;
				case "bodypr":
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("vert");
						textbox.TextBoxFormat.TextDirection = GetTextDirection(attribute, flag2);
						attribute = reader.GetAttribute("anchor");
						textbox.TextBoxFormat.TextVerticalAlignment = GetTextVertAlign(attribute);
					}
					break;
				case "docPr":
				{
					string attribute = reader.GetAttribute("name");
					if (!string.IsNullOrEmpty(attribute))
					{
						textbox.Name = attribute;
					}
					attribute = reader.GetAttribute("hidden");
					if (!string.IsNullOrEmpty(attribute))
					{
						textbox.Visible = !GetBoolValue(attribute);
					}
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseTextboxShape(XmlReader reader, WTextBox textBox)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (!reader.EOF && reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "shape":
				case "rect":
				case "roundrect":
					if (!string.IsNullOrEmpty(reader.GetAttribute("id")))
					{
						textBox.Name = reader.GetAttribute("id");
					}
					ParseShapeProperties(reader, textBox);
					ParseTextbox(reader, textBox);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextBoxWrappingStyle(XmlReader reader, IEntity entity)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (!(reader.LocalName == localName2))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "wrap")
				{
					string attribute = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute))
					{
						(entity as WTextBox).TextBoxFormat.SetTextWrappingStyleValue(GetWrapStyle(attribute));
					}
					string attribute2 = reader.GetAttribute("side");
					if (!string.IsNullOrEmpty(attribute2))
					{
						(entity as WTextBox).TextBoxFormat.TextWrappingType = GetTextWrapType(attribute2);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseTextbox(XmlReader reader, WTextBox textbox)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (!(reader.LocalName == localName2))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "stroke":
					ParseStroke(reader, textbox);
					break;
				case "shadow":
					if (!IsWord2003ML)
					{
						textbox.TextBoxFormat.DocxProps.Add(ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "textbox":
				{
					ParseTextboxIntMargins(reader, textbox);
					ParseTextBoxStyle(reader, textbox);
					m_currentRunFormat = null;
					RevisionType trackChangeType = m_trackChangeType;
					m_trackChangeType = RevisionType.None;
					Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
					m_trackchangeRevisionDetails.Clear();
					Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
					m_trackchangeStack.Clear();
					ParseTextboxContent(reader, textbox);
					m_trackChangeType = trackChangeType;
					m_trackchangeRevisionDetails = new Stack<Revision>(stack);
					stack.Clear();
					m_trackchangeStack = new Stack<RevisionType>(stack2);
					stack2.Clear();
					break;
				}
				case "fill":
					flag = ParseFillEffects(reader, textbox);
					break;
				case "wrap":
				{
					string attribute = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute) && (!(attribute == "none") || !textbox.TextBoxFormat.DocxStyleProps.Contains("position:absolute")))
					{
						textbox.TextBoxFormat.SetTextWrappingStyleValue(GetWrapStyle(attribute));
					}
					string attribute2 = reader.GetAttribute("side");
					if (!string.IsNullOrEmpty(attribute2))
					{
						textbox.TextBoxFormat.TextWrappingType = GetTextWrapType(attribute2);
					}
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private bool ParseFillEffects(XmlReader reader, WTextBox textbox)
	{
		bool result = false;
		string attribute = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "tile":
			case "frame":
				ParsePictureFill(reader, textbox, attribute);
				break;
			case "gradient":
			case "gradientRadial":
				ParseGradientFill(reader, textbox.TextBoxFormat.FillEfects);
				if (reader.LocalName != "fill")
				{
					result = true;
				}
				break;
			case "pattern":
				if (!IsWord2003ML)
				{
					ParsePatternFill(reader, textbox.TextBoxFormat.FillEfects);
					result = true;
				}
				break;
			}
		}
		if (reader.GetAttribute("opacity") == "0")
		{
			textbox.TextBoxFormat.FillColor = Color.Empty;
		}
		return result;
	}

	private void ParseGradientFill(XmlReader reader, Background background)
	{
		string? attribute = reader.GetAttribute("type");
		background.Type = BackgroundType.Gradient;
		ParseGradientColor(reader, background);
		if (attribute == "gradientRadial")
		{
			ParseRadialGradient(reader, background.Gradient);
		}
		else
		{
			ParseGradient(reader, background.Gradient);
		}
	}

	private void ParseGradientColor(XmlReader reader, Background background)
	{
		BackgroundGradient gradient = background.Gradient;
		if (background.Color == Color.Empty)
		{
			gradient.Color1 = Color.White;
		}
		else
		{
			gradient.Color1 = background.Color;
		}
		string attribute = reader.GetAttribute("color2");
		if (attribute == null)
		{
			gradient.Color2 = Color.Black;
		}
		else
		{
			gradient.Color2 = GetColorValue(attribute);
		}
	}

	private void ParseGradient(XmlReader reader, BackgroundGradient gradient)
	{
		string attribute = reader.GetAttribute("focus");
		string attribute2 = reader.GetAttribute("angle");
		if (attribute2 == null)
		{
			gradient.ShadingStyle = GradientShadingStyle.Horizontal;
		}
		else
		{
			switch (attribute2)
			{
			case "-90":
				gradient.ShadingStyle = GradientShadingStyle.Vertical;
				break;
			case "-135":
				gradient.ShadingStyle = GradientShadingStyle.DiagonalUp;
				break;
			case "-45":
				gradient.ShadingStyle = GradientShadingStyle.DiagonalDown;
				break;
			}
		}
		gradient.ShadingVariant = ParseShadingVariant(attribute);
	}

	private void ParseRadialGradient(XmlReader reader, BackgroundGradient gradient)
	{
		string attribute = reader.GetAttribute("focusposition");
		string attribute2 = reader.GetAttribute("focus");
		if (reader.ReadInnerXml() != string.Empty)
		{
			gradient.ShadingStyle = GradientShadingStyle.FromCorner;
			if (attribute == null)
			{
				gradient.ShadingVariant = GradientShadingVariant.ShadingUp;
				return;
			}
			switch (attribute)
			{
			case "1":
				gradient.ShadingVariant = GradientShadingVariant.ShadingDown;
				break;
			case "1,1":
				gradient.ShadingVariant = GradientShadingVariant.ShadingMiddle;
				break;
			case ",1":
				gradient.ShadingVariant = GradientShadingVariant.ShadingOut;
				break;
			}
		}
		else
		{
			gradient.ShadingStyle = GradientShadingStyle.FromCenter;
			gradient.ShadingVariant = ParseShadingVariant(attribute2);
		}
	}

	private GradientShadingVariant ParseShadingVariant(string focus)
	{
		if (focus == null)
		{
			return GradientShadingVariant.ShadingDown;
		}
		if (focus == "100%")
		{
			return GradientShadingVariant.ShadingUp;
		}
		if (focus == "50%")
		{
			return GradientShadingVariant.ShadingMiddle;
		}
		return GradientShadingVariant.ShadingOut;
	}

	private void ParsePatternFill(XmlReader reader, Background background)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		background.SetPatternFillValue(ReadSingleNodeIntoStream(reader));
		if (!string.IsNullOrEmpty(attribute))
		{
			bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
			bool isImageRelation = true;
			string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
			if (isImageRelation)
			{
				background.PatternImageBytes = GetImageBytes(imageName);
			}
		}
	}

	private void ParsePatternFill(XmlReader reader, FillFormat fillFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		uint opacity = uint.MaxValue;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == localName2))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName3 = reader.LocalName;
				if (!(localName3 == "fgClr"))
				{
					if (localName3 == "bgClr")
					{
						fillFormat.Color = ParseColor(reader, "bgClr", ref opacity, reader.LocalName, isAlreadyChecked: false);
						if (opacity != uint.MaxValue)
						{
							fillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
						}
					}
				}
				else
				{
					fillFormat.ForeColor = ParseColor(reader, "fgClr", ref opacity, reader.LocalName, isAlreadyChecked: false);
					opacity = uint.MaxValue;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParsePictureFill(XmlReader reader, WTextBox textbox, string fillType)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		if (attribute == null)
		{
			return;
		}
		textbox.TextBoxFormat.FillEfects.Type = ((fillType == "frame") ? BackgroundType.Picture : BackgroundType.Texture);
		bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
		bool isImageRelation = true;
		string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (isImageRelation)
		{
			if (ImageIds.ContainsKey(imageName))
			{
				textbox.TextBoxFormat.FillEfects.ImageRecord = m_doc.Images[ImageIds[imageName]];
				return;
			}
			textbox.TextBoxFormat.FillEfects.ImageBytes = GetImageBytes(imageName);
			ImageIds.Add(imageName, textbox.TextBoxFormat.FillEfects.ImageRecord.ImageId);
		}
	}

	private TextWrappingType GetTextWrapType(string wrapType)
	{
		return wrapType.ToLower() switch
		{
			"left" => TextWrappingType.Left, 
			"right" => TextWrappingType.Right, 
			"largest" => TextWrappingType.Largest, 
			_ => TextWrappingType.Both, 
		};
	}

	private TextWrappingStyle GetWrapStyle(string wrapStyle)
	{
		return wrapStyle.ToLower() switch
		{
			"square" => TextWrappingStyle.Square, 
			"tight" => TextWrappingStyle.Tight, 
			"through" => TextWrappingStyle.Through, 
			"topandbottom" => TextWrappingStyle.TopAndBottom, 
			"none" => TextWrappingStyle.Inline, 
			_ => TextWrappingStyle.InFrontOfText, 
		};
	}

	private TextWrappingType GetWrapType(string wrapType)
	{
		if (!(wrapType == "left"))
		{
			if (wrapType == "right")
			{
				return TextWrappingType.Right;
			}
			return TextWrappingType.Both;
		}
		return TextWrappingType.Left;
	}

	private void ParseTextboxContent(XmlReader reader, WTextBox textbox)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			string localName2 = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				while (!(reader.LocalName == localName2))
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "p":
						{
							IWParagraph iWParagraph = textbox.TextBoxBody.AddParagraph();
							ParseParagraphItems(reader, iWParagraph.Items, null, null, isMappedPictureContentControl: false);
							m_doc.UpdateLastItemRevision(iWParagraph, iWParagraph.Items);
							if (iWParagraph.NextSibling != null && !(iWParagraph.NextSibling is AlternateChunk))
							{
								UpdateNestedParaItems(iWParagraph as WParagraph);
							}
							if (!string.IsNullOrEmpty(iWParagraph.StyleName))
							{
								(iWParagraph as WParagraph).ApplyStyle(iWParagraph.StyleName, isDomChanges: false);
							}
							break;
						}
						case "tbl":
						{
							m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 11);
							IWTable iWTable = textbox.TextBoxBody.AddTable();
							iWTable.TableFormat.IsAutoResized = true;
							short gridCount = m_gridCount;
							ParseTable(reader, iWTable as WTable, isAlreadyCheck: false, reader.LocalName);
							m_gridCount = gridCount;
							if (iWTable.Rows.Count == 0)
							{
								(iWTable.Owner as WTextBody).ChildEntities.RemoveAt((iWTable as WTable).Index);
							}
							break;
						}
						case "sdt":
						{
							IBlockContentControl blockContentControl = textbox.TextBoxBody.AddStructureDocumentTag();
							ParseStructureDocumentTagBlock(reader, blockContentControl as BlockContentControl);
							break;
						}
						case "altChunk":
						{
							AlternateChunk altChunk = AddAlternateChunk(textbox);
							ParseAlternateChunk(reader, altChunk);
							break;
						}
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
			}
			else if (localName == reader.LocalName)
			{
				textbox.TextBoxBody.AddParagraph();
			}
		}
		else if (reader.LocalName == "txbxContent")
		{
			textbox.TextBoxBody.AddParagraph();
		}
	}

	private void ParseTextBoxStyle(XmlReader reader, WTextBox textbox)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		string[] array = attribute.Split(';');
		string text = string.Empty;
		if (array.Length == 0)
		{
			return;
		}
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(':');
			if (array2.Length > 1)
			{
				switch (array2[0])
				{
				case "mso-fit-shape-to-text":
					textbox.TextBoxFormat.AutoFit = GetBoolValue(array2[1]);
					break;
				case "layout-flow":
				case "mso-layout-flow-alt":
					text = array2[1];
					break;
				}
			}
		}
		if (!string.IsNullOrEmpty(text))
		{
			textbox.TextBoxFormat.TextDirection = GetTextDirection(text);
		}
	}

	private void ParseTextboxIntMargins(XmlReader reader, WTextBox textbox)
	{
		string attribute = reader.GetAttribute("inset");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Replace("mm", string.Empty);
		string[] array = attribute.Split(new char[1] { ',' });
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			if (!(array[i] == string.Empty))
			{
				float textboxMargin = GetTextboxMargin(array[i]);
				switch (i)
				{
				case 0:
					textbox.TextBoxFormat.InternalMargin.Left = textboxMargin;
					break;
				case 1:
					textbox.TextBoxFormat.InternalMargin.Top = textboxMargin;
					break;
				case 2:
					textbox.TextBoxFormat.InternalMargin.Right = textboxMargin;
					break;
				case 3:
					textbox.TextBoxFormat.InternalMargin.Bottom = textboxMargin;
					break;
				}
			}
		}
	}

	private void ParseTextFrameInternalMargins(XmlReader reader, TextFrame textFrame)
	{
		string attribute = reader.GetAttribute("inset");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Replace("mm", string.Empty);
		string[] array = attribute.Split(new char[1] { ',' });
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			if (!(array[i] == string.Empty))
			{
				float textboxMargin = GetTextboxMargin(array[i]);
				switch (i)
				{
				case 0:
					textFrame.InternalMargin.Left = textboxMargin;
					break;
				case 1:
					textFrame.InternalMargin.Top = textboxMargin;
					break;
				case 2:
					textFrame.InternalMargin.Right = textboxMargin;
					break;
				case 3:
					textFrame.InternalMargin.Bottom = textboxMargin;
					break;
				}
			}
		}
	}

	private float GetTextboxMargin(string margin)
	{
		if (margin == string.Empty)
		{
			return 0f;
		}
		float result = float.MaxValue;
		float result2 = float.MaxValue;
		if (margin.EndsWith("pt"))
		{
			margin = margin.Replace("pt", string.Empty);
			float.TryParse(margin, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
		}
		else if (margin.EndsWith("in"))
		{
			margin = margin.Replace("in", string.Empty);
			result = (float)UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(margin, CultureInfo.InvariantCulture), PrintUnits.Inch, PrintUnits.Point);
		}
		else if (margin.EndsWith("emu"))
		{
			float.TryParse(margin.Replace("emu", string.Empty), NumberStyles.Float, CultureInfo.InvariantCulture, out result2);
			result = (float)UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(result2, CultureInfo.InvariantCulture), PrintUnits.EMU, PrintUnits.Point);
		}
		else
		{
			float.TryParse(margin, NumberStyles.Float, CultureInfo.InvariantCulture, out result2);
			result = (float)UnitsConvertor.Instance.ConvertUnits(result2, PrintUnits.Millimeter, PrintUnits.Point);
		}
		return result;
	}

	private float GetShapeInternalMargin(string margin)
	{
		if (margin == string.Empty)
		{
			return 0f;
		}
		float result = float.MaxValue;
		float result2 = float.MaxValue;
		if (margin.EndsWith("pt"))
		{
			margin = margin.Replace("pt", string.Empty);
			float.TryParse(margin, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
		}
		else if (margin.EndsWith("in"))
		{
			margin = margin.Replace("in", string.Empty);
			result = (float)UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(margin, CultureInfo.InvariantCulture), PrintUnits.Inch, PrintUnits.Point);
		}
		else if (margin.EndsWith("mm"))
		{
			float.TryParse(margin, NumberStyles.Float, CultureInfo.InvariantCulture, out result2);
			result = (float)UnitsConvertor.Instance.ConvertUnits(result2, PrintUnits.Millimeter, PrintUnits.Point);
		}
		else
		{
			float.TryParse(margin.Replace("emu", string.Empty), NumberStyles.Float, CultureInfo.InvariantCulture, out result2);
			result = (float)UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(result2, CultureInfo.InvariantCulture), PrintUnits.EMU, PrintUnits.Point);
		}
		return result;
	}

	private void ParseStroke(XmlReader reader, WTextBox textBox)
	{
		string attribute = reader.GetAttribute("dashstyle");
		if (!string.IsNullOrEmpty(attribute))
		{
			textBox.TextBoxFormat.LineDashing = GetDashStyle(attribute);
		}
		string attribute2 = reader.GetAttribute("linestyle");
		if (!string.IsNullOrEmpty(attribute2))
		{
			textBox.TextBoxFormat.LineStyle = GetLineStyle(attribute2);
		}
	}

	private LineDashing GetDashStyle(string dashstyle)
	{
		switch (dashstyle)
		{
		case "sysDash":
			return LineDashing.Dash;
		case "sysDashDot":
			return LineDashing.DashDot;
		case "sysDashDotDot":
			return LineDashing.DashDotDot;
		case "sysDot":
			return LineDashing.Dot;
		case "dash":
			return LineDashing.DashGEL;
		case "dashDot":
			return LineDashing.DashDotGEL;
		case "1 1":
		case "dot":
			return LineDashing.DotGEL;
		case "lgDash":
		case "longDash":
			return LineDashing.LongDashGEL;
		case "lgDashDot":
		case "longDashDot":
			return LineDashing.LongDashDotGEL;
		case "lgDashDotDot":
		case "longDashDotDot":
			return LineDashing.LongDashDotDotGEL;
		default:
			return LineDashing.Solid;
		}
	}

	private TextBoxLineStyle GetLineStyle(string lineStyle)
	{
		switch (lineStyle)
		{
		case "dbl":
		case "thinThin":
			return TextBoxLineStyle.Double;
		case "thinThick":
			return TextBoxLineStyle.ThinThick;
		case "thickThin":
			return TextBoxLineStyle.ThickThin;
		case "thickBetweenThin":
		case "tri":
			return TextBoxLineStyle.Triple;
		default:
			return TextBoxLineStyle.Simple;
		}
	}

	private void ParseShapeProperties(XmlReader reader, WTextBox textbox)
	{
		string attribute = reader.GetAttribute("style");
		if (attribute == null)
		{
			return;
		}
		attribute = attribute.Trim();
		char[] separator = new char[1] { ';' };
		string[] array = attribute.Split(separator);
		string[] array2 = new string[2];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array2 = GetPropertyValues(array[i]);
			if (array2 != null)
			{
				ApplyShapeProperties(textbox, array2[0], array2[1]);
			}
		}
		ParseTextboxEffects(reader, textbox);
	}

	private void ParseTextboxEffects(XmlReader reader, WTextBox textbox)
	{
		string attribute = reader.GetAttribute("coordorigin");
		if (!string.IsNullOrEmpty(attribute))
		{
			GetCoordinateOrigin(attribute, textbox);
		}
		textbox.TextBoxFormat.Path = reader.GetAttribute("path");
		textbox.TextBoxFormat.VMLPathPoints = textbox.Parse2007CustomShapePoints(textbox.TextBoxFormat.Path);
		textbox.TextBoxFormat.CoordinateSize = reader.GetAttribute("coordsize");
		string attribute2 = reader.GetAttribute("wrapcoords");
		if (!string.IsNullOrEmpty(attribute2))
		{
			textbox.TextBoxFormat.WrapPolygon = new WrapPolygon();
			char[] separator = new char[1] { ' ' };
			string[] array = attribute2.Split(separator);
			for (int i = 0; i < array.Length - 1; i += 2)
			{
				float result = 0f;
				float result2 = 0f;
				float.TryParse(array[i], NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				float.TryParse(array[i + 1], NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				textbox.TextBoxFormat.WrapPolygon.Vertices.Add(new PointF(result, result2));
			}
		}
		string attribute3 = reader.GetAttribute("strokecolor");
		if (!string.IsNullOrEmpty(attribute3))
		{
			textbox.TextBoxFormat.LineColor = GetColorValue(attribute3);
		}
		string attribute4 = reader.GetAttribute("strokeweight");
		if (!string.IsNullOrEmpty(attribute4))
		{
			textbox.TextBoxFormat.LineWidth = GetPointValue(attribute4);
		}
		string attribute5 = reader.GetAttribute("filled");
		if (!string.IsNullOrEmpty(attribute5) && !GetBoolValue(attribute5.ToLower()))
		{
			textbox.TextBoxFormat.FillColor = Color.Empty;
		}
		else
		{
			string attribute6 = reader.GetAttribute("fillcolor");
			if (!string.IsNullOrEmpty(attribute6))
			{
				textbox.TextBoxFormat.FillEfects.SetBackgroundColor(GetColorValue(attribute6));
				textbox.TextBoxFormat.FillEfects.Type = BackgroundType.Color;
			}
		}
		string attribute7 = reader.GetAttribute("stroked");
		if (!string.IsNullOrEmpty(attribute7))
		{
			textbox.TextBoxFormat.NoLine = !GetBoolValue(attribute7.ToLower());
		}
		string attribute8 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute8))
		{
			textbox.TextBoxFormat.AllowInCell = !(attribute8 == "f");
		}
		string attribute9 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
		if (!string.IsNullOrEmpty(attribute9))
		{
			textbox.TextBoxFormat.AllowOverlap = ((!(attribute9 == "f") && !(attribute9 == "false")) ? true : false);
		}
	}

	private float GetPointValue(string value)
	{
		if (StartsWithExt(value, "."))
		{
			value = "0" + value;
		}
		double result;
		if (value.EndsWith("pt"))
		{
			value = value.Replace("pt", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result, 2);
		}
		else if (value.EndsWith("mm"))
		{
			value = value.Replace("mm", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 25.399999618530273 * 72.0, 2);
		}
		else if (value.EndsWith("px"))
		{
			value = value.Replace("px", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 4.0 * 3.0, 2);
		}
		else if (value.EndsWith("in"))
		{
			value = value.Replace("in", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result * 72.0, 2);
		}
		else if (value.EndsWith("cm"))
		{
			value = value.Replace("cm", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 2.5399999618530273 * 72.0, 2);
		}
		else
		{
			if (value.EndsWith("emu"))
			{
				value = value.Replace("emu", string.Empty);
			}
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 12700.0, 2);
		}
		return (float)result;
	}

	private float GetChildShapePointValue(string value)
	{
		if (value.StartsWith("."))
		{
			value = "0" + value;
		}
		double result;
		if (value.EndsWith("pt"))
		{
			value = value.Replace("pt", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result, 2);
		}
		else if (value.EndsWith("mm"))
		{
			value = value.Replace("mm", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 25.399999618530273 * 72.0, 2);
		}
		else if (value.EndsWith("px"))
		{
			value = value.Replace("px", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 4.0 * 3.0, 2);
		}
		else if (value.EndsWith("in"))
		{
			value = value.Replace("in", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result * 72.0, 2);
		}
		else if (value.EndsWith("cm"))
		{
			value = value.Replace("cm", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result / 2.5399999618530273 * 72.0, 2);
		}
		else if (value.EndsWith("emu"))
		{
			value = value.Replace("emu", string.Empty);
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result /= 20.0;
		}
		else
		{
			double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result = Math.Round(result, 2);
		}
		return (float)result;
	}

	private void ApplyShapeProperties(WTextBox textbox, string propertyName, string propertyValue)
	{
		switch (propertyName)
		{
		case "margin-left":
			textbox.TextBoxFormat.HorizontalPosition = GetPointValue(propertyValue);
			break;
		case "margin-top":
			textbox.TextBoxFormat.VerticalPosition = GetPointValue(propertyValue);
			break;
		case "width":
			textbox.TextBoxFormat.Width = GetPointValue(propertyValue);
			break;
		case "height":
			textbox.TextBoxFormat.Height = GetPointValue(propertyValue);
			break;
		case "rotation":
		{
			if (string.IsNullOrEmpty(propertyValue))
			{
				break;
			}
			int result2 = 0;
			if (propertyValue.EndsWith("fd"))
			{
				int.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				result2 = result2 / 32768 / 2;
				if (result2 < 0)
				{
					textbox.TextBoxFormat.Rotation = 360 - Math.Abs(result2);
				}
				else
				{
					textbox.TextBoxFormat.Rotation = Math.Abs(result2);
				}
			}
			else
			{
				int.TryParse(propertyValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				textbox.TextBoxFormat.Rotation = result2;
			}
			break;
		}
		case "flip":
			switch (propertyValue)
			{
			case "x":
				textbox.TextBoxFormat.FlipHorizontal = true;
				break;
			case "y":
				textbox.TextBoxFormat.FlipVertical = true;
				break;
			case "x y":
				textbox.TextBoxFormat.FlipHorizontal = true;
				textbox.TextBoxFormat.FlipVertical = true;
				break;
			default:
				textbox.TextBoxFormat.DocxStyleProps.Add(propertyName + ":" + propertyValue);
				break;
			}
			break;
		case "z-index":
		{
			int result = 0;
			int.TryParse(propertyValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
			if (textbox.TextBoxFormat.OrderIndex == int.MaxValue)
			{
				textbox.TextBoxFormat.OrderIndex = result;
			}
			textbox.TextBoxFormat.IsBelowText = result <= 0;
			if (textbox.TextBoxFormat.IsBelowText)
			{
				textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
			}
			else
			{
				textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
			}
			break;
		}
		case "visibility":
			if (!string.IsNullOrEmpty(propertyValue) && propertyValue.ToLower() == "hidden")
			{
				textbox.Visible = false;
			}
			break;
		case "mso-position-horizontal":
			textbox.TextBoxFormat.HorizontalAlignment = GetHorizAlign(propertyValue);
			break;
		case "mso-width-percent":
			textbox.TextBoxFormat.WidthRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-height-percent":
			textbox.TextBoxFormat.HeightRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-position-vertical":
			textbox.TextBoxFormat.VerticalAlignment = GetVertAlign(propertyValue);
			break;
		case "v-text-anchor":
			textbox.TextBoxFormat.TextVerticalAlignment = GetTextVertAlign(propertyValue);
			break;
		case "mso-height-relative":
			textbox.TextBoxFormat.HeightOrigin = GetHeightOrigin(propertyValue);
			break;
		case "mso-width-relative":
			textbox.TextBoxFormat.WidthOrigin = GetWidthOrigin(propertyValue);
			break;
		case "mso-position-vertical-relative":
			textbox.TextBoxFormat.VerticalOrigin = GetVertOrigin(propertyValue);
			break;
		case "mso-position-horizontal-relative":
			textbox.TextBoxFormat.HorizontalOrigin = GetHorizOrigin(propertyValue);
			break;
		case "mso-left-percent":
			textbox.TextBoxFormat.HorizontalRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-top-percent":
			textbox.TextBoxFormat.VerticalRelativePercent = ParseFloatVal(propertyValue) / 10f;
			break;
		case "mso-wrap-distance-left":
			textbox.TextBoxFormat.WrapDistanceLeft = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-top":
			textbox.TextBoxFormat.WrapDistanceTop = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-right":
			textbox.TextBoxFormat.WrapDistanceRight = GetPointValue(propertyValue);
			break;
		case "mso-wrap-distance-bottom":
			textbox.TextBoxFormat.WrapDistanceBottom = GetPointValue(propertyValue);
			break;
		case "mso-wrap-style":
			ParseTextBoxWrapType(textbox, propertyValue);
			break;
		default:
			if (propertyName == "position" && (propertyValue == "absolute" || propertyValue == "relative") && textbox.TextBoxFormat.TextWrappingStyle == TextWrappingStyle.Inline)
			{
				textbox.TextBoxFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
			}
			textbox.TextBoxFormat.DocxStyleProps.Add(propertyName + ":" + propertyValue);
			break;
		}
	}

	private void ParseTextBoxWrapType(WTextBox textbox, string value)
	{
		switch (value)
		{
		case "square":
			textbox.TextBoxFormat.WrappingMode = WrapMode.Square;
			break;
		case "through":
			textbox.TextBoxFormat.WrappingMode = WrapMode.Through;
			break;
		case "top-and-bottom":
			textbox.TextBoxFormat.WrappingMode = WrapMode.TopBottom;
			break;
		case "none":
			textbox.TextBoxFormat.WrappingMode = WrapMode.None;
			break;
		}
	}

	private string[] GetPropertyValues(string value)
	{
		char[] separator = new char[1] { ':' };
		string[] array = value.Split(separator);
		if (array.Length == 2)
		{
			return array;
		}
		return null;
	}

	private ShapeType DetectShapeType(MemoryStream shapeStream, ref AutoShapeType autoShapeType, ref Dictionary<string, Stream> docxProps, ref string shapeTypeId, ParagraphItem choiceItem)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(shapeStream);
		if (xmlReader.LocalName != "pict")
		{
			throw new XmlException("picture shape element");
		}
		string text = null;
		string text2 = null;
		string text3 = null;
		string text4 = null;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		int num = 0;
		string text5 = null;
		bool flag5 = false;
		xmlReader.Read();
		while (xmlReader.LocalName != "pict" && !xmlReader.EOF)
		{
			flag5 = false;
			SkipWhitespaces(xmlReader);
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "group":
					return ShapeType.GroupedShape;
				case "OLEObject":
					return ShapeType.OleObject;
				case "shape":
				{
					text2 = xmlReader.GetAttribute("type");
					text = xmlReader.GetAttribute("id");
					string attribute = xmlReader.GetAttribute("style");
					flag4 = ((attribute.Contains("position:absolute") || attribute.Contains("position:relative")) ? true : false);
					break;
				}
				case "textbox":
				case "rect":
					flag2 = true;
					if (xmlReader.LocalName == "rect")
					{
						autoShapeType = AutoShapeType.Rectangle;
					}
					break;
				case "txbxContent":
					flag3 = true;
					xmlReader.Skip();
					break;
				case "shapetype":
					if (!IsWord2003ML)
					{
						shapeTypeId = xmlReader.GetAttribute("id");
						text5 = xmlReader.GetAttribute("path");
						ReadSingleNodeIntoStream(xmlReader);
						flag5 = true;
					}
					break;
				case "imagedata":
					flag = true;
					text3 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					text4 = xmlReader.GetAttribute("href", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					break;
				case "roundrect":
					autoShapeType = AutoShapeType.RoundedRectangle;
					break;
				case "oval":
					autoShapeType = AutoShapeType.Oval;
					break;
				case "line":
					autoShapeType = AutoShapeType.Line;
					break;
				case "extrusion":
				case "callout":
				case "wrap":
				case "fill":
				case "stroke":
					if (!IsWord2003ML && !docxProps.ContainsKey(xmlReader.LocalName))
					{
						docxProps.Add(xmlReader.LocalName, ReadSingleNodeIntoStream(xmlReader));
						flag5 = true;
					}
					break;
				case "shadow":
					if (!IsWord2003ML)
					{
						num++;
						if (!docxProps.ContainsKey(xmlReader.LocalName))
						{
							docxProps.Add(xmlReader.LocalName + num, ReadSingleNodeIntoStream(xmlReader));
							flag5 = true;
						}
					}
					break;
				case "textpath":
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 31);
					break;
				}
			}
			if (!flag5)
			{
				xmlReader.Read();
			}
		}
		if (flag4 && text != null && (StartsWithExt(text, "PowerPlusWaterMarkObject") || StartsWithExt(text, "WordPictureWatermark")))
		{
			return ShapeType.WatermarkShape;
		}
		if (flag2)
		{
			switch (text2)
			{
			case "_s13":
			case "_s62":
			case "#_x0000_t202":
				goto IL_05a4;
			}
		}
		if ((!(flag2 && flag3) || (text2 != null && text3 == null)) && (!flag2 || choiceItem == null || !(choiceItem is Shape) || (choiceItem as Shape).AutoShapeType != AutoShapeType.Rectangle || (choiceItem as Shape).TextBody.Count <= 0) && (!(flag2 && flag3) || text2 == null || shapeTypeId == null || !(text5 == "m,l,21600r21600,l21600,xe")))
		{
			if (shapeTypeId != null && text2 != null && shapeTypeId == "_x0000_t75" && text2 == "#_x0000_t75" && flag && !flag2)
			{
				return ShapeType.PictureShape;
			}
			if (shapeTypeId == null && text2 == "#_x0000_t75" && !flag2)
			{
				return ShapeType.PictureShape;
			}
			if ((text4 != null && text4 != string.Empty) || (text3 != null && GetRelation(text3).Key != null))
			{
				return ShapeType.PictureShape;
			}
			if (!string.IsNullOrEmpty(text2))
			{
				autoShapeType = AutoShapeHelper.GetAutoShapeType(text2.Replace("#", "").Replace("_x0000_t", ""));
			}
			return ShapeType.XmlParagraphItem;
		}
		goto IL_05a4;
		IL_05a4:
		return ShapeType.TextboxShape;
	}

	private void ParseTextBoxGraphics(WTextBox textbox, XmlParagraphItem choiceItem)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(choiceItem.DataNode);
		xmlReader.ReadToFollowing("fontRef", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
		if (xmlReader.NodeType != 0)
		{
			xmlReader.Read();
			if (xmlReader.LocalName == "schemeClr")
			{
				textbox.TextBoxFormat.TextThemeColor = GetSchemeColor(xmlReader);
			}
		}
	}

	private ParagraphItem ParseDrawing(XmlReader reader, ParagraphItemCollection paraItems, ref MemoryStream drawingStream, bool isMappedPictureContentControl)
	{
		if (reader.LocalName != "drawing")
		{
			throw new XmlException("Drawing element");
		}
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 14);
		drawingStream = ReadSingleNodeIntoStream(reader);
		XmlReader xmlReader = UtilityMethods.CreateReader(drawingStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		GraphicDataContentType graphicDataContentType = CheckPicture(xmlReader);
		switch (graphicDataContentType)
		{
		case GraphicDataContentType.Group:
			drawingStream.Position = 0L;
			return ParseGroupShape(drawingStream);
		case GraphicDataContentType.None:
			drawingStream.Position = 0L;
			return ParseXmlParaItem(drawingStream);
		case GraphicDataContentType.Chart:
			m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 33);
			drawingStream.Position = 0L;
			if (IsValid2016Chart(drawingStream))
			{
				drawingStream.Position = 0L;
				return ParseChart(xmlReader, paraItems, drawingStream);
			}
			return null;
		default:
		{
			bool flag = false;
			if (graphicDataContentType == GraphicDataContentType.Picture)
			{
				xmlReader = UtilityMethods.CreateReader(drawingStream);
				flag = ParseImageHyperlink(xmlReader, paraItems);
			}
			xmlReader = UtilityMethods.CreateReader(drawingStream);
			while (xmlReader.NodeType != XmlNodeType.Element)
			{
				xmlReader.Read();
			}
			if (graphicDataContentType == GraphicDataContentType.Picture)
			{
				WPicture wPicture = new WPicture(m_doc);
				xmlReader.ReadToFollowing("blip", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
				string attribute = xmlReader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				string attribute2 = xmlReader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
				if (!string.IsNullOrEmpty(attribute))
				{
					LoadImage(wPicture, attribute, isHeaderFooter, isPicBullet: false);
				}
				if (!string.IsNullOrEmpty(attribute2))
				{
					DocGen.DocIO.DLS.Entities.Image image = null;
					bool isImageRelation = true;
					string imageName = GetImageName(attribute2, isHeaderFooter, isPicBullet: false, ref isImageRelation);
					if (isImageRelation && m_isExternalHyperlink != null && m_docRelations.ContainsKey(attribute2) && IsExternalHyperlink.ContainsKey(attribute2) && IsExternalHyperlink[attribute2])
					{
						wPicture.ExternalLink = imageName;
					}
					if (!string.IsNullOrEmpty(attribute))
					{
						wPicture.HasImageRecordReference = true;
					}
					if (image != null)
					{
						wPicture.LoadImage(image);
					}
					else if (wPicture.ExternalLink != null && !wPicture.HasImageRecordReference)
					{
						byte[] imageBytes = new byte[0];
						image = wPicture.GetImage(imageBytes, isImageFromScratch: false);
						wPicture.LoadImage(image);
					}
				}
				if (wPicture.ImageRecord == null && wPicture.ImageBytes == null && isMappedPictureContentControl)
				{
					DocGen.DocIO.DLS.Entities.Image image2 = null;
					Stream manifestResourceStream = WPicture.GetManifestResourceStream("ImageNotFound.jpg");
					MemoryStream memoryStream = new MemoryStream();
					manifestResourceStream.CopyTo(memoryStream);
					image2 = DocGen.DocIO.DLS.Entities.Image.FromStream(memoryStream);
					wPicture.LoadImage(image2);
				}
				if (wPicture.ImageRecord == null && wPicture.ImageBytes == null)
				{
					return null;
				}
				xmlReader.Dispose();
				xmlReader = UtilityMethods.CreateReader(drawingStream);
				ParagraphItem paragraphItem = ParsePicture(xmlReader, wPicture);
				if (flag && paragraphItem != null)
				{
					paraItems.Add(paragraphItem);
					CheckTrackChange(paragraphItem);
					WFieldMark wFieldMark = new WFieldMark(m_doc, FieldMarkType.FieldEnd);
					AddToParagraph(wFieldMark, paraItems);
					FieldStack.Pop().FieldEnd = wFieldMark;
					return null;
				}
				return paragraphItem;
			}
			return ParseShape(xmlReader, paraItems, drawingStream);
		}
		}
	}

	private ParagraphItem ParseShape(XmlReader picReader, ParagraphItemCollection paraItems, MemoryStream drawingStream)
	{
		picReader = UtilityMethods.CreateReader(drawingStream);
		if (picReader.ReadToFollowing("prstGeom", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main"))
		{
			string attribute = picReader.GetAttribute("prst");
			if (!string.IsNullOrEmpty(attribute) && attribute.Length > 0)
			{
				AutoShapeConstant autoShapeConstant = AutoShapeHelper.GetAutoShapeConstant(attribute);
				if (AutoShapeHelper.GetAutoShapeType(autoShapeConstant) == AutoShapeType.Unknown)
				{
					m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 10);
					return ParseXmlParaItem(drawingStream);
				}
			}
		}
		Shape shape = new Shape(m_doc);
		shape.ApplyCharacterFormat(m_currentRunFormat);
		ApplyDirectionalOverride(shape.GetCharFormat());
		ParseXMLRelations(shape, drawingStream);
		picReader = UtilityMethods.CreateReader(drawingStream);
		picReader.Read();
		ParseShapeBaseProperties(picReader, shape, drawingStream);
		return shape;
	}

	private void ParseCustomGeometry(XmlReader reader, ShapeCommon shape)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		Dictionary<string, string> gdValues = ((shape is Shape) ? (shape as Shape).GetGuideList() : (shape as ChildShape).GetGuideList());
		Dictionary<string, string> gdValues2 = ((shape is Shape) ? (shape as Shape).GetAvList() : (shape as ChildShape).GetAvList());
		while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "avLst":
					ParseGuideList(reader, gdValues2);
					reader.Skip();
					break;
				case "gdLst":
					ParseGuideList(reader, gdValues);
					reader.Skip();
					break;
				case "pathLst":
					if (shape is Shape)
					{
						(shape as Shape).Path2DList = new List<Path2D>();
					}
					else
					{
						(shape as ChildShape).Path2DList = new List<Path2D>();
					}
					ParsePath2D(reader, shape);
					reader.Skip();
					break;
				default:
					shape.DocxProps.Add(reader.LocalName, ReadSingleNodeIntoStream(reader));
					break;
				}
			}
			else
			{
				reader.Skip();
			}
		}
		SetReaderPosition(reader);
	}

	internal static void SetReaderPosition(XmlReader reader)
	{
		while (reader.LocalName != "custGeom")
		{
			reader.Read();
		}
	}

	internal static void ParseGuideList(XmlReader reader, Dictionary<string, string> gdValues)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "gd")
				{
					string text = null;
					string text2 = null;
					if (reader.MoveToAttribute("name"))
					{
						text = reader.Value;
					}
					if (reader.MoveToAttribute("fmla"))
					{
						text2 = reader.Value;
					}
					if (gdValues != null && text != null && text2 != null && !gdValues.ContainsKey(text))
					{
						gdValues.Add(text, text2);
					}
					else if (gdValues != null && text != null && text2 != null)
					{
						gdValues[text] = text2;
					}
				}
				reader.Skip();
			}
			else
			{
				reader.Skip();
			}
		}
	}

	internal static void ParsePath2D(XmlReader reader, ShapeCommon shape)
	{
		List<Path2D> list = ((shape is Shape) ? (shape as Shape).Path2DList : (shape as ChildShape).Path2DList);
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "path")
				{
					Path2D path2D = new Path2D();
					if (reader.MoveToAttribute("w"))
					{
						path2D.Width = double.Parse(reader.Value, CultureInfo.InvariantCulture);
					}
					if (reader.MoveToAttribute("h"))
					{
						path2D.Height = double.Parse(reader.Value, CultureInfo.InvariantCulture);
					}
					if (reader.MoveToAttribute("stroke"))
					{
						path2D.IsStroke = reader.Value == "1";
					}
					if (path2D.Width == 0.0)
					{
						path2D.Width = (int)Math.Round(shape.Width * shape.WidthScale / 100f * 12700f);
					}
					if (path2D.Height == 0.0)
					{
						path2D.Height = (int)Math.Round(shape.Height * shape.HeightScale / 100f * 12700f);
					}
					reader.MoveToElement();
					Parse2DElements(reader, path2D);
					list.Add(path2D);
				}
				reader.Skip();
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private static void Parse2DElements(XmlReader reader, Path2D path)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "close":
					path.PathElements.Add(((ushort)1).ToString());
					path.PathElements.Add("0");
					reader.Skip();
					break;
				case "moveTo":
					path.PathElements.Add(((ushort)2).ToString());
					path.PathElements.Add("1");
					ParsePath2DPoint(reader, path.PathElements);
					reader.Skip();
					break;
				case "lnTo":
					path.PathElements.Add(((ushort)3).ToString());
					path.PathElements.Add("1");
					ParsePath2DPoint(reader, path.PathElements);
					reader.Skip();
					break;
				case "quadBezTo":
					path.PathElements.Add(((ushort)5).ToString());
					path.PathElements.Add("2");
					ParsePath2DPoint(reader, path.PathElements);
					reader.Skip();
					break;
				case "cubicBezTo":
					path.PathElements.Add(((ushort)6).ToString());
					path.PathElements.Add("3");
					ParsePath2DPoint(reader, path.PathElements);
					reader.Skip();
					break;
				case "arcTo":
					path.PathElements.Add(((ushort)4).ToString());
					path.PathElements.Add("4");
					if (reader.MoveToAttribute("wR"))
					{
						path.PathElements.Add(reader.Value);
					}
					if (reader.MoveToAttribute("hR"))
					{
						path.PathElements.Add(reader.Value);
					}
					if (reader.MoveToAttribute("stAng"))
					{
						path.PathElements.Add(reader.Value);
					}
					if (reader.MoveToAttribute("swAng"))
					{
						path.PathElements.Add(reader.Value);
					}
					reader.Skip();
					break;
				default:
					reader.Skip();
					break;
				}
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private static void ParsePath2DPoint(XmlReader reader, List<string> pathElements)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (!(reader.LocalName == "pt"))
				{
					break;
				}
				if (reader.MoveToAttribute("x"))
				{
					pathElements.Add(reader.Value);
				}
				if (reader.MoveToAttribute("y"))
				{
					pathElements.Add(reader.Value);
				}
				reader.Skip();
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private ShapeBase ParseShapeBaseProperties(XmlReader picReader, ShapeBase shapeBase, MemoryStream drawingStream)
	{
		bool flag = false;
		while (!picReader.EOF && picReader.LocalName != "drawing")
		{
			if (picReader.LocalName == "drawing")
			{
				picReader.Read();
			}
			bool flag2 = false;
			SkipWhitespaces(picReader);
			if (picReader.NodeType == XmlNodeType.Element)
			{
				switch (picReader.LocalName)
				{
				case "effectExtent":
					if (!IsWord2003ML)
					{
						ProcessEffectExtent(picReader, shapeBase);
						shapeBase.DocxProps.Add("effectExtent", ReadSingleNodeIntoStream(picReader));
						flag2 = true;
					}
					break;
				case "extent":
				{
					string attribute3 = picReader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shapeBase.Width = GetPropertyValue(attribute3, "cx");
					}
					attribute3 = picReader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shapeBase.Height = GetPropertyValue(attribute3, "cy");
					}
					break;
				}
				case "positionH":
					ParsePictureHorizontalPosition(picReader, shapeBase);
					break;
				case "positionV":
					ParsePictureVerticalPosition(picReader, shapeBase);
					break;
				case "docPr":
				{
					shapeBase.Title = picReader.GetAttribute("title");
					shapeBase.AlternativeText = picReader.GetAttribute("descr");
					string attribute4 = picReader.GetAttribute("id");
					if (!string.IsNullOrEmpty(attribute4))
					{
						shapeBase.ShapeID = XmlConvert.ToInt64(attribute4);
						if (m_doc.maxShapeId < shapeBase.ShapeID)
						{
							m_doc.maxShapeId = shapeBase.ShapeID;
						}
					}
					shapeBase.Name = picReader.GetAttribute("name");
					string attribute3 = picReader.GetAttribute("hidden");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shapeBase.Visible = !GetBoolValue(attribute3);
					}
					else
					{
						shapeBase.Visible = true;
					}
					break;
				}
				case "wrapSquare":
					shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
					ParseWrappingType(picReader, shapeBase.WrapFormat);
					break;
				case "wrapTight":
					shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
					ParseWrappingType(picReader, shapeBase.WrapFormat);
					ParseWrapPolygon(picReader, shapeBase);
					break;
				case "wrapThrough":
					shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
					ParseWrappingType(picReader, shapeBase.WrapFormat);
					ParseWrapPolygon(picReader, shapeBase);
					break;
				case "wrapTopAndBottom":
					shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
					break;
				case "wrapNone":
					if (!flag)
					{
						if (shapeBase.IsBelowText)
						{
							shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
						}
						else
						{
							shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
						}
					}
					break;
				case "anchor":
					shapeBase.WrapFormat.DistanceLeft = 9f;
					shapeBase.WrapFormat.DistanceRight = 9f;
					if (picReader.AttributeCount != 0)
					{
						if (picReader.MoveToAttribute("distT"))
						{
							shapeBase.WrapFormat.DistanceTop = GetPointValue(picReader.Value);
						}
						if (picReader.MoveToAttribute("distB"))
						{
							shapeBase.WrapFormat.DistanceBottom = GetPointValue(picReader.Value);
						}
						if (picReader.MoveToAttribute("distL"))
						{
							shapeBase.WrapFormat.DistanceLeft = GetPointValue(picReader.Value);
						}
						if (picReader.MoveToAttribute("distR"))
						{
							shapeBase.WrapFormat.DistanceRight = GetPointValue(picReader.Value);
						}
						if (picReader.MoveToAttribute("relativeHeight") && !string.IsNullOrEmpty(picReader.Value))
						{
							int result2 = 0;
							int.TryParse(picReader.Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
							shapeBase.ZOrderPosition = result2;
						}
						if (picReader.MoveToAttribute("behindDoc"))
						{
							shapeBase.IsBelowText = XmlConvert.ToBoolean(picReader.Value);
						}
						if (picReader.MoveToAttribute("locked"))
						{
							shapeBase.LockAnchor = XmlConvert.ToBoolean(picReader.Value);
						}
						if (picReader.MoveToAttribute("layoutInCell"))
						{
							shapeBase.LayoutInCell = XmlConvert.ToBoolean(picReader.Value);
						}
						if (picReader.MoveToAttribute("allowOverlap"))
						{
							shapeBase.WrapFormat.AllowOverlap = XmlConvert.ToBoolean(picReader.Value);
						}
					}
					break;
				case "graphic":
					picReader.Read();
					if (shapeBase is Shape)
					{
						ParseGraphicData(picReader, shapeBase as Shape);
					}
					else if (shapeBase is GroupShape)
					{
						ParseGraphicData(picReader, shapeBase as GroupShape);
					}
					else
					{
						ParseGraphicData(picReader, shapeBase as WChart, drawingStream);
					}
					break;
				case "sizeRelH":
				{
					shapeBase.IsRelativeWidth = true;
					string attribute2 = picReader.GetAttribute("relativeFrom");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shapeBase.RelativeWidthHorizontalOrigin = GetHorizOrigin(attribute2);
					}
					picReader.Read();
					SkipWhitespaces(picReader);
					if (picReader.LocalName == "pctWidth")
					{
						float result3 = float.MaxValue;
						float.TryParse(picReader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result3);
						flag2 = true;
						if (result3 != float.MaxValue)
						{
							shapeBase.RelativeWidth = (float)Math.Round(result3 / 1000f, 2);
						}
					}
					break;
				}
				case "sizeRelV":
				{
					shapeBase.IsRelativeHeight = true;
					string attribute = picReader.GetAttribute("relativeFrom");
					if (!string.IsNullOrEmpty(attribute))
					{
						shapeBase.RelativeHeightVerticalOrigin = GetVertOrigin(attribute);
					}
					picReader.Read();
					SkipWhitespaces(picReader);
					if (picReader.LocalName == "pctHeight")
					{
						float result = float.MaxValue;
						float.TryParse(picReader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						flag2 = true;
						if (result != float.MaxValue)
						{
							shapeBase.RelativeHeight = (float)Math.Round(result / 1000f, 2);
						}
					}
					break;
				}
				case "inline":
					flag = true;
					shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
					break;
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(picReader);
						flag2 = true;
					}
					break;
				case "Choice":
				case "AlternateContent":
				case "Fallback":
					break;
				}
				if (!flag2)
				{
					picReader.Read();
				}
			}
			else
			{
				picReader.Read();
			}
		}
		return shapeBase;
	}

	private void ParsePictureHorizontalPosition(XmlReader reader, ShapeBase shapeBase)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "positionH")
		{
			throw new XmlException("positionH");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("relativeFrom");
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		HorizontalOrigin horizontalOrigin = HorizontalOrigin.Margin;
		if (!string.IsNullOrEmpty(attribute))
		{
			horizontalOrigin = GetHorizOrigin(attribute);
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "positionH")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "align":
				{
					string text = reader.ReadInnerXml();
					flag = true;
					if (text != null)
					{
						shapeBase.HorizontalAlignment = GetHorizAlign(text);
					}
					shapeBase.HorizontalOrigin = horizontalOrigin;
					break;
				}
				case "posOffset":
				{
					float result2 = float.MaxValue;
					float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
					flag = true;
					if (result2 != float.MaxValue)
					{
						shapeBase.HorizontalPosition = (float)Math.Round(result2 / 12700f, 2);
					}
					shapeBase.HorizontalOrigin = horizontalOrigin;
					break;
				}
				case "pctPosHOffset":
				{
					shapeBase.IsRelativeHorizontalPosition = true;
					float result = float.MaxValue;
					float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					flag = true;
					if (result != float.MaxValue)
					{
						shapeBase.RelativeHorizontalPosition = (float)Math.Round(result / 1000f, 2);
					}
					shapeBase.RelativeHorizontalOrigin = horizontalOrigin;
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParsePictureVerticalPosition(XmlReader reader, ShapeBase shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "positionV")
		{
			throw new XmlException("PositionV");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("relativeFrom");
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		VerticalOrigin verticalOrigin = VerticalOrigin.Margin;
		if (!string.IsNullOrEmpty(attribute))
		{
			verticalOrigin = GetVertOrigin(attribute);
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "positionV")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "align":
				{
					string text = reader.ReadInnerXml();
					flag = true;
					if (text != null)
					{
						shape.VerticalAlignment = GetVertAlign(text);
					}
					shape.VerticalOrigin = verticalOrigin;
					break;
				}
				case "posOffset":
				{
					float result2 = float.MaxValue;
					float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
					flag = true;
					if (result2 != float.MaxValue)
					{
						shape.VerticalPosition = (float)Math.Round(result2 / 12700f, 2);
					}
					shape.VerticalOrigin = verticalOrigin;
					break;
				}
				case "pctPosVOffset":
				{
					shape.IsRelativeVerticalPosition = true;
					float result = float.MaxValue;
					float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					flag = true;
					if (result != float.MaxValue)
					{
						shape.RelativeVerticalPosition = (float)Math.Round(result / 1000f, 2);
					}
					shape.RelativeVerticalOrigin = verticalOrigin;
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseWrappingType(XmlReader reader, WrapFormat wrapFormat)
	{
		string attribute = reader.GetAttribute("wrapText");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "bothSides":
				wrapFormat.TextWrappingType = TextWrappingType.Both;
				break;
			case "left":
				wrapFormat.TextWrappingType = TextWrappingType.Left;
				break;
			case "right":
				wrapFormat.TextWrappingType = TextWrappingType.Right;
				break;
			case "largest":
				wrapFormat.TextWrappingType = TextWrappingType.Largest;
				break;
			}
		}
	}

	private void ParseWrapPolygon(XmlReader reader, IEntity entity)
	{
		reader.Read();
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "wrapPolygon")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		WrapPolygon wrapPolygon = null;
		if (entity is WPicture)
		{
			(entity as WPicture).WrapPolygon = new WrapPolygon();
			wrapPolygon = (entity as WPicture).WrapPolygon;
		}
		else if (entity is Shape)
		{
			(entity as Shape).WrapFormat.WrapPolygon = new WrapPolygon();
			wrapPolygon = (entity as Shape).WrapFormat.WrapPolygon;
		}
		else if (entity is GroupShape)
		{
			(entity as GroupShape).WrapFormat.WrapPolygon = new WrapPolygon();
			wrapPolygon = (entity as GroupShape).WrapFormat.WrapPolygon;
		}
		else if (entity is WChart)
		{
			(entity as WChart).WrapFormat.WrapPolygon = new WrapPolygon();
			wrapPolygon = (entity as WChart).WrapFormat.WrapPolygon;
		}
		else if (entity is WTextBox)
		{
			(entity as WTextBox).TextBoxFormat.WrapPolygon = new WrapPolygon();
			wrapPolygon = (entity as WTextBox).TextBoxFormat.WrapPolygon;
		}
		string attribute = reader.GetAttribute("edited");
		if (!string.IsNullOrEmpty(attribute))
		{
			wrapPolygon.Edited = ((!(attribute == "0") && !(attribute == "false")) ? true : false);
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "wrapPolygon")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (localName2 == "start" || localName2 == "lineTo")
				{
					float result = float.MaxValue;
					float result2 = float.MaxValue;
					string attribute2 = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(attribute2))
					{
						float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					}
					attribute2 = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(attribute2))
					{
						float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
					}
					if (result != 4.2949673E+09f && result2 != 4.2949673E+09f)
					{
						wrapPolygon.Vertices.Add(new PointF(result, result2));
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		reader.Read();
	}

	private ParagraphItem ParseChart(XmlReader picReader, ParagraphItemCollection paraItems, MemoryStream drawingStream)
	{
		WChart wChart = new WChart(m_doc);
		picReader = UtilityMethods.CreateReader(drawingStream);
		picReader.Read();
		ParseShapeBaseProperties(picReader, wChart, drawingStream);
		return wChart;
	}

	private void ParseChartRelations(Stream stream, Dictionary<string, DictionaryEntry> relations)
	{
		XmlReader relReader = UtilityMethods.CreateReader(stream);
		ParseRelations(relReader, relations);
	}

	private void ParseGraphicData(XmlReader reader, WChart chart, MemoryStream drawingStream)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "graphicData")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		string text;
		if (StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer") || false || IsInFootnote || IsInEndnote || IsInComments)
		{
			Dictionary<string, DictionaryEntry> dictionary = ((!IsInComments) ? GetFileRelations(m_currentFile) : GetFileRelations("comments.xml.rels"));
			text = (string)dictionary[attribute].Value;
		}
		else
		{
			text = m_docRelations[attribute].Value.ToString();
		}
		int num = text.LastIndexOf('/');
		if (num > 0 && text.Substring(num + 1, text.Length - (num + 1)).Length > 0)
		{
			text = text.Replace(text.Substring(0, num + 1), null);
		}
		if (text.Contains("chartEx"))
		{
			chart.Is2016Chart = true;
		}
		PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("word/charts/");
		if (partContainer != null && partContainer.Relations.ContainsKey("word/charts/_rels/" + text + ".rels"))
		{
			Relations relations = partContainer.Relations["word/charts/_rels/" + text + ".rels"];
			ParseChartRelations(relations.DataStream, ChartRelations);
		}
		XmlReader xmlReader = UtilityMethods.CreateReader(partContainer.XmlParts[text].DataStream);
		if (chart.Is2016Chart)
		{
			xmlReader.ReadToDescendant("cx:externalData");
		}
		else
		{
			xmlReader.ReadToDescendant("c:externalData");
		}
		string attribute2 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		string text2 = string.Empty;
		ChartImpl chartImpl = chart.OfficeChart as ChartImpl;
		while (xmlReader.Read())
		{
			SkipWhitespaces(xmlReader);
			if (xmlReader.LocalName == "chartSpace")
			{
				break;
			}
			if (xmlReader.LocalName == "userShapes")
			{
				text2 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				break;
			}
		}
		foreach (string key in ChartRelations.Keys)
		{
			DictionaryEntry dictionaryEntry = ChartRelations[key];
			string text3 = dictionaryEntry.Value.ToString();
			int num2 = text3.Length - (text3.Contains(".") ? text3.LastIndexOf('.') : 0);
			string text4 = text3.Substring(0, text3.Length - num2);
			if ((!object.Equals(dictionaryEntry.Key, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && string.Equals(GetExtension(text3), ".xlsx")) || (object.Equals(dictionaryEntry.Key, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && text3.EndsWith(".xltx")))
			{
				int num3 = (text3.Contains("/") ? text3.LastIndexOf('/') : 0);
				text3 = text3.Substring(num3 + 1, text3.Length - num3 - 1);
				num2 = text3.Length - (text3.Contains(".") ? text3.LastIndexOf('.') : 0);
				text4 = text3.Substring(0, text3.Length - num2);
				PartContainer partContainer2 = m_doc.DocxPackage.FindPartContainer("word/embeddings/");
				if (partContainer2 != null && partContainer2.XmlParts.ContainsKey(text3))
				{
					Stream dataStream = partContainer2.XmlParts[text3].DataStream;
					chart.DocxProps.Add(text4, dataStream);
					chartImpl.ChartIteams.Add(dictionaryEntry.Value.ToString(), dataStream);
				}
				if (key == attribute2)
				{
					chart.InternalDataPath = (text3.EndsWith(".xltx") ? text3 : text4);
				}
			}
			else if (object.Equals(dictionaryEntry.Key, "http://schemas.microsoft.com/office/2011/relationships/chartColorStyle"))
			{
				if (partContainer != null && partContainer.XmlParts.ContainsKey(text3))
				{
					Stream dataStream2 = partContainer.XmlParts[text3].DataStream;
					chart.DocxProps.Add(text4 + "/chartColorStyle", dataStream2);
					chartImpl.ChartIteams.Add(dictionaryEntry.Value.ToString(), dataStream2);
				}
			}
			else if (object.Equals(dictionaryEntry.Key, "http://schemas.microsoft.com/office/2011/relationships/chartStyle"))
			{
				if (partContainer != null && partContainer.XmlParts.ContainsKey(text3))
				{
					Stream dataStream3 = partContainer.XmlParts[text3].DataStream;
					chart.DocxProps.Add(text4 + "/chartStyle", dataStream3);
					chartImpl.ChartIteams.Add(dictionaryEntry.Value.ToString(), dataStream3);
				}
			}
			else if (object.Equals(dictionaryEntry.Key, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes"))
			{
				int num4 = (text3.Contains("/") ? text3.LastIndexOf('/') : 0);
				text3 = text3.Substring(num4 + 1, text3.Length - num4 - 1);
				num2 = text3.Length - (text3.Contains(".") ? text3.LastIndexOf('.') : 0);
				text4 = text3.Substring(0, text3.Length - num2);
				PartContainer partContainer3 = m_doc.DocxPackage.FindPartContainer("word/drawings/");
				if (partContainer3 != null && partContainer3.XmlParts.ContainsKey(text3))
				{
					Stream dataStream4 = partContainer3.XmlParts[text3].DataStream;
					chart.DocxProps.Add(text4 + "/chartUserShapes", dataStream4);
					chartImpl.ChartIteams.Add(dictionaryEntry.Value.ToString(), dataStream4);
					if (partContainer3.Relations.Count > 0 && partContainer3.Relations.ContainsKey("word/drawings/_rels/" + text3 + ".rels"))
					{
						chartImpl.ChartIteams.Add(dictionaryEntry.Value.ToString() + "/relation", partContainer3.Relations["word/drawings/_rels/" + text3 + ".rels"].DataStream);
						chart.DocxProps.Add(text4 + "/relation", partContainer3.Relations["word/drawings/_rels/" + text3 + ".rels"].DataStream);
					}
				}
				if (key == text2)
				{
					chart.UserShapes = text4;
				}
			}
			else if (object.Equals(dictionaryEntry.Key, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && IsExcelSheet(text3) && IsExternalHyperlink.ContainsKey(key) && IsExternalHyperlink[key])
			{
				chart.ExternalDataPath = text3;
				chart.IsExternalRelation = true;
			}
			else if (object.Equals(dictionaryEntry.Key, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"))
			{
				int num5 = (text3.Contains("/") ? text3.LastIndexOf('/') : 0);
				text3 = text3.Substring(num5 + 1, text3.Length - num5 - 1);
				num2 = text3.Length - (text3.Contains(".") ? text3.LastIndexOf('.') : 0);
				text4 = text3.Substring(0, text3.Length - num2);
				PartContainer partContainer4 = m_doc.DocxPackage.FindPartContainer("word/media/");
				if (partContainer4 != null && partContainer4.XmlParts.ContainsKey(text3))
				{
					chartImpl.RelationPreservedStreamCollection.Add(key, partContainer4.XmlParts[text3].DataStream);
				}
			}
		}
		xmlReader = UtilityMethods.CreateReader(partContainer.XmlParts[text].DataStream);
		RelationCollection relationCollection = new RelationCollection();
		foreach (KeyValuePair<string, DictionaryEntry> chartRelation in ChartRelations)
		{
			DictionaryEntry value = chartRelation.Value;
			Relation value2 = new Relation(value.Value.ToString(), value.Key.ToString());
			relationCollection[chartRelation.Key] = value2;
		}
		if (!string.IsNullOrEmpty(chart.InternalDataPath) && chart.DocxProps.ContainsKey(chart.InternalDataPath))
		{
			chart.Workbook.DataHolder.ParseDocument(chart.DocxProps[chart.InternalDataPath]);
		}
		else
		{
			chartImpl.HasExternalWorkbook = true;
		}
		ParseChartWorkbookThemes(chart.Workbook);
		double appVersion = (string.IsNullOrEmpty(m_appVersion) ? 16.0 : Convert.ToDouble(m_appVersion, CultureInfo.InvariantCulture));
		if (chart.Is2016Chart)
		{
			new ChartExParser(chart.Workbook).ParseChartEx(xmlReader, chartImpl, relationCollection);
		}
		else
		{
			new ChartParser(chart.Workbook).ParseChart(xmlReader, chart.OfficeChart as ChartImpl, relationCollection, appVersion);
		}
		ChartRelations.Clear();
		string[] array = new string[chartImpl.RelationPreservedStreamCollection.Keys.Count];
		chartImpl.RelationPreservedStreamCollection.Keys.CopyTo(array, 0);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].StartsWith("rId") && chartImpl.RelationPreservedStreamCollection.ContainsKey(array[i]))
			{
				chartImpl.RelationPreservedStreamCollection.Remove(array[i]);
			}
		}
	}

	private bool IsExcelSheet(string relation)
	{
		string extension = GetExtension(relation);
		if (!string.Equals(extension, ".xlsx"))
		{
			return string.Equals(extension, ".xlsm");
		}
		return true;
	}

	private string GetExtension(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			return string.Empty;
		}
		if (!path.Contains("."))
		{
			return path;
		}
		return path.Substring(path.LastIndexOf("."));
	}

	private void ParseChartWorkbookThemes(WorkbookImpl workBook)
	{
		workBook.DataHolder.Parser.m_dicThemeColors = new Dictionary<string, Color>(m_doc.Themes.SchemeColor.Count);
		foreach (KeyValuePair<string, Color> item in m_doc.Themes.SchemeColor)
		{
			workBook.DataHolder.Parser.m_dicThemeColors.Add(item.Key, item.Value);
		}
		if (!workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("tx1") && workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("dk1"))
		{
			workBook.DataHolder.Parser.m_dicThemeColors.Add("tx1", workBook.DataHolder.Parser.m_dicThemeColors["dk1"]);
		}
		if (!workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("tx2") && workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("dk2"))
		{
			workBook.DataHolder.Parser.m_dicThemeColors.Add("tx2", workBook.DataHolder.Parser.m_dicThemeColors["dk2"]);
		}
		if (workBook.MajorFonts != null)
		{
			workBook.MajorFonts.Clear();
		}
		else
		{
			workBook.MajorFonts = new Dictionary<string, FontImpl>();
		}
		if (workBook.MinorFonts != null)
		{
			workBook.MinorFonts.Clear();
		}
		else
		{
			workBook.MinorFonts = new Dictionary<string, FontImpl>();
		}
		string[] array = new string[3] { "latin", "ea", "cs" };
		for (int i = 0; i < array.Length; i++)
		{
			switch (array[i])
			{
			case "latin":
			{
				FontImpl fontImpl5 = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl5.Size = 11.0;
				fontImpl5.FontName = m_majorLatinFontName;
				workBook.MajorFonts.Add(array[i], fontImpl5);
				FontImpl fontImpl6 = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl6.Size = 11.0;
				fontImpl6.FontName = m_minorLatinFontName;
				workBook.MinorFonts.Add(array[i], fontImpl6);
				break;
			}
			case "ea":
			{
				FontImpl fontImpl3 = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl3.Size = 11.0;
				fontImpl3.FontName = m_majorEaFontName;
				workBook.MajorFonts.Add(array[i], fontImpl3);
				FontImpl fontImpl4 = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl4.Size = 11.0;
				fontImpl4.FontName = m_minorEaFontName;
				workBook.MinorFonts.Add(array[i], fontImpl4);
				break;
			}
			case "cs":
			{
				FontImpl fontImpl = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl.Size = 11.0;
				fontImpl.FontName = m_minorCsFontName;
				workBook.MajorFonts.Add(array[i], fontImpl);
				FontImpl fontImpl2 = workBook.CreateFont(null, bAddToCollection: false) as FontImpl;
				fontImpl2.Size = 11.0;
				fontImpl2.FontName = m_minorCsFontName;
				workBook.MinorFonts.Add(array[i], fontImpl2);
				break;
			}
			}
		}
	}

	private void SetCategortyRange(string categoryRange, WorksheetImpl chartSheet, ChartImpl chart)
	{
		List<string> list = new List<string>();
		if (categoryRange.Contains(","))
		{
			string[] array = categoryRange.Split(',');
			for (int i = 0; i < array.Length; i++)
			{
				list.Add(categoryRange.Split(',')[i]);
			}
		}
		else
		{
			list.Add(categoryRange);
		}
		string[] array2 = list.ToArray();
		if (array2.Length == 0)
		{
			return;
		}
		int j = 0;
		int num = 0;
		for (; j < array2.Length; j++)
		{
			foreach (IRange item in chartSheet[array2[j].Split('!')[1]])
			{
				if (chart.CategoryLabelValues == null)
				{
					if ((chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels == null || num >= (chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels.Length)
					{
						break;
					}
					chartSheet[item.AddressLocal].Value2 = (chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels[num++];
				}
				else
				{
					if (num >= chart.CategoryLabelValues.Length)
					{
						break;
					}
					chartSheet[item.AddressLocal].Value2 = chart.CategoryLabelValues[num++];
				}
			}
		}
	}

	private void ParseGraphicData(XmlReader reader, Shape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "graphicData")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		shape.LineFormat = new LineFormat((ShapeBase)shape);
		shape.LineFormat.m_Line = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "graphicData")
		{
			EffectFormat effectFormat = null;
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "wsp":
				{
					string attribute2 = reader.GetAttribute("normalEastAsianFlow");
					if (!string.IsNullOrEmpty(attribute2) && !flag2)
					{
						shape.TextFrame.TextDirection = (GetBoolValue(attribute2) ? TextDirection.HorizontalFarEast : TextDirection.Horizontal);
						flag2 = shape.TextFrame.TextDirection == TextDirection.HorizontalFarEast;
					}
					break;
				}
				case "xfrm":
				{
					string attribute = reader.GetAttribute("flipH");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipHorizontal = ((attribute == "1" || attribute == "true") ? true : false);
					}
					attribute = reader.GetAttribute("flipV");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipVertical = ((attribute == "1" || attribute == "true") ? true : false);
					}
					attribute = reader.GetAttribute("rot");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Rotation = GetNumericValue(attribute) / 60000f;
					}
					break;
				}
				case "prstGeom":
				{
					string attribute = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute) && attribute.Length > 0)
					{
						AutoShapeConstant autoShapeConstant = AutoShapeHelper.GetAutoShapeConstant(attribute);
						AutoShapeType autoShapeType = AutoShapeHelper.GetAutoShapeType(autoShapeConstant);
						shape.AutoShapeType = autoShapeType;
					}
					break;
				}
				case "avLst":
					ParseShapeAdjustValues(reader, shape);
					break;
				case "custGeom":
					if (!IsWord2003ML)
					{
						shape.AutoShapeType = AutoShapeType.Unknown;
						ParseCustomGeometry(reader, shape);
					}
					break;
				case "ln":
					shape.IsLineStyleInline = true;
					ParseLineFormat(reader, shape);
					break;
				case "pattFill":
				{
					shape.IsFillStyleInline = true;
					shape.FillFormat.Fill = true;
					shape.FillFormat.IsDefaultFill = false;
					shape.FillFormat.FillType = FillType.FillPatterned;
					string attribute = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FillFormat.Pattern = GetPatternType(attribute);
					}
					ParsePatternFill(reader, shape.FillFormat);
					break;
				}
				case "gradFill":
					shape.IsFillStyleInline = true;
					shape.FillFormat.Fill = true;
					shape.FillFormat.IsDefaultFill = false;
					shape.FillFormat.FillType = FillType.FillGradient;
					ParseGradientFill(reader, shape.FillFormat.GradientFill);
					break;
				case "blipFill":
					shape.IsFillStyleInline = true;
					shape.FillFormat.Fill = true;
					shape.FillFormat.IsDefaultFill = false;
					shape.FillFormat.FillType = FillType.FillPicture;
					ParseBlipFill(reader, shape.FillFormat);
					break;
				case "solidFill":
				{
					shape.IsFillStyleInline = true;
					shape.FillFormat.Fill = true;
					shape.FillFormat.IsDefaultFill = false;
					shape.FillFormat.FillType = FillType.FillSolid;
					uint opacity = uint.MaxValue;
					Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
					shape.FillFormat.Color = color;
					if (opacity != uint.MaxValue)
					{
						shape.FillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					break;
				}
				case "noFill":
					shape.IsFillStyleInline = true;
					shape.FillFormat.Fill = false;
					shape.FillFormat.IsDefaultFill = false;
					break;
				case "effectLst":
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							shape.IsEffectStyleInline = true;
							ParseEffectList(reader, shape, localName);
						}
					}
					break;
				case "scene3d":
					effectFormat = new EffectFormat(shape);
					shape.IsScenePropertiesInline = true;
					effectFormat.IsSceneProperties = true;
					effectFormat = ParseSceneProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "sp3d":
					effectFormat = new EffectFormat(shape);
					shape.IsShapePropertiesInline = true;
					effectFormat.IsShapeProperties = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("contourW");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(attribute, "contourW");
						}
						attribute = reader.GetAttribute("extrusionH");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(attribute, "extrusionH");
						}
						attribute = reader.GetAttribute("z");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(attribute, "z");
						}
						attribute = reader.GetAttribute("prstMaterial");
						if (!string.IsNullOrEmpty(attribute) && attribute.Length > 2)
						{
							effectFormat.ThreeDFormat.PresetMaterialType = (Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(attribute[0]) + attribute.Substring(1)) ? ((PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), attribute, ignoreCase: true)) : PresetMaterialType.None);
						}
					}
					effectFormat = ParseShapeProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "style":
				{
					MemoryStream memoryStream = new MemoryStream();
					memoryStream = ReadSingleNodeIntoStream(reader);
					if (m_doc.DocHasThemes)
					{
						ParseStyleItems(memoryStream, shape);
					}
					shape.DocxProps.Add("style", memoryStream);
					flag = true;
					break;
				}
				case "bodyPr":
					if ((!shape.IsLineStyleInline || shape.LineFormat.LineFormatType == (LineFormatType)0) && !shape.DocxProps.ContainsKey("style"))
					{
						shape.LineFormat.Line = false;
					}
					if (!shape.IsFillStyleInline && !shape.DocxProps.ContainsKey("style"))
					{
						shape.FillFormat.Fill = false;
					}
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("vert");
						shape.TextFrame.TextDirection = GetTextDirection(attribute, flag2);
						attribute = reader.GetAttribute("anchor");
						shape.TextFrame.TextVerticalAlignment = GetTextVertAlign(attribute);
						attribute = reader.GetAttribute("lIns");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.TextFrame.InternalMargin.Left = GetShapeInternalMargin(attribute);
						}
						attribute = reader.GetAttribute("tIns");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.TextFrame.InternalMargin.Top = GetShapeInternalMargin(attribute);
						}
						attribute = reader.GetAttribute("rIns");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.TextFrame.InternalMargin.Right = GetShapeInternalMargin(attribute);
						}
						attribute = reader.GetAttribute("bIns");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.TextFrame.InternalMargin.Bottom = GetShapeInternalMargin(attribute);
						}
						attribute = reader.GetAttribute("fromWordArt");
						if (GetBoolValue(attribute))
						{
							m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 31);
						}
						attribute = reader.GetAttribute("wrap");
						if (attribute == "none")
						{
							shape.TextFrame.NoWrap = true;
						}
						attribute = reader.GetAttribute("upright");
						if (!string.IsNullOrEmpty(attribute))
						{
							shape.TextFrame.Upright = ((attribute == "1" || attribute == "true") ? true : false);
						}
						MemoryStream memoryStream2 = ReadSingleNodeIntoStream(reader);
						shape.DocxProps.Add("BodyPr", memoryStream2);
						ParseBodyProperties(memoryStream2, shape);
						flag = true;
					}
					break;
				case "txbx":
				{
					reader.Read();
					SkipWhitespaces(reader);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 13);
					WTextBox wTextBox = new WTextBox(m_doc);
					RevisionType trackChangeType = m_trackChangeType;
					Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
					m_trackchangeRevisionDetails.Clear();
					Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
					m_trackchangeStack.Clear();
					m_trackChangeType = RevisionType.None;
					m_currentRunFormat = null;
					ParseTextboxContent(reader, wTextBox);
					shape.TextBody = wTextBox.TextBoxBody;
					shape.TextBody.SetOwner(shape);
					m_trackChangeType = trackChangeType;
					m_trackchangeRevisionDetails = new Stack<Revision>(stack);
					stack.Clear();
					m_trackchangeStack = new Stack<RevisionType>(stack2);
					stack2.Clear();
					reader.Read();
					break;
				}
				case "extLst":
					if (shape != null)
					{
						if (!shape.DocxProps.ContainsKey("extLst"))
						{
							shape.DocxProps.Add("extLst", ReadSingleNodeIntoStream(reader));
						}
						else
						{
							ReadSingleNodeIntoStream(reader);
						}
						flag = true;
					}
					break;
				case "grpFill":
					if (shape != null)
					{
						shape.DocxProps.Add("grpFill", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseGraphicData(XmlReader reader, GroupShape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "graphicData")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		shape.LineFormat = new LineFormat(shape);
		SkipWhitespaces(reader);
		ChildShape childShape = null;
		while (reader.LocalName != "graphicData")
		{
			EffectFormat effectFormat = null;
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "grpSpPr":
					ParseGroupShapeProperties(reader, shape);
					break;
				case "wsp":
				{
					childShape = new ChildShape(m_doc);
					childShape.LineFormat = new LineFormat(childShape);
					string attribute4 = reader.GetAttribute("normalEastAsianFlow");
					if (!string.IsNullOrEmpty(attribute4) && !flag2)
					{
						childShape.TextFrame.TextDirection = (GetBoolValue(attribute4) ? TextDirection.HorizontalFarEast : TextDirection.Horizontal);
						flag2 = childShape.TextFrame.TextDirection == TextDirection.HorizontalFarEast;
					}
					break;
				}
				case "contentPart":
					SkipCurrentElement(reader, reader.LocalName);
					break;
				case "graphicFrame":
				{
					MemoryStream graphicStream = ReadSingleNodeIntoStream(reader);
					ParseGraphicFrame(graphicStream, shape, null);
					flag = true;
					break;
				}
				case "cNvPr":
					if (childShape != null)
					{
						ParseGraphicFrameNonVisualProperties(reader, childShape);
						shape.Add(childShape);
						childShape.SetOwner(shape);
					}
					break;
				case "xfrm":
					Parse2DTransform(reader, childShape);
					break;
				case "ext":
					ParseExtent(reader, childShape);
					break;
				case "off":
					ParseOffset(reader, childShape);
					break;
				case "prstGeom":
				{
					string attribute3 = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute3) && attribute3.Length > 0)
					{
						AutoShapeConstant autoShapeConstant = AutoShapeHelper.GetAutoShapeConstant(attribute3);
						AutoShapeType autoShapeType = AutoShapeHelper.GetAutoShapeType(autoShapeConstant);
						childShape.AutoShapeType = autoShapeType;
						childShape.ElementType = EntityType.AutoShape;
					}
					break;
				}
				case "avLst":
					ParseShapeAdjustValues(reader, childShape);
					break;
				case "custGeom":
					if (!IsWord2003ML)
					{
						childShape.ElementType = EntityType.AutoShape;
						childShape.AutoShapeType = AutoShapeType.Unknown;
						ParseCustomGeometry(reader, childShape);
					}
					break;
				case "ln":
					childShape.IsLineStyleInline = true;
					childShape.LineFormat = new LineFormat(childShape);
					childShape.LineFormat.m_Line = false;
					ParseLineFormat(reader, childShape);
					break;
				case "pattFill":
				{
					childShape.IsFillStyleInline = true;
					childShape.FillFormat.Fill = true;
					childShape.FillFormat.IsDefaultFill = false;
					childShape.FillFormat.FillType = FillType.FillPatterned;
					string attribute3 = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(attribute3))
					{
						childShape.FillFormat.Pattern = GetPatternType(attribute3);
					}
					ParsePatternFill(reader, childShape.FillFormat);
					break;
				}
				case "gradFill":
					childShape.IsFillStyleInline = true;
					childShape.FillFormat.Fill = true;
					childShape.FillFormat.IsDefaultFill = false;
					childShape.FillFormat.FillType = FillType.FillGradient;
					ParseGradientFill(reader, childShape.FillFormat.GradientFill);
					break;
				case "blipFill":
					childShape.IsFillStyleInline = true;
					childShape.FillFormat.Fill = true;
					childShape.FillFormat.IsDefaultFill = false;
					childShape.FillFormat.FillType = FillType.FillPicture;
					ParseBlipFill(reader, childShape.FillFormat);
					break;
				case "solidFill":
				{
					childShape.IsFillStyleInline = true;
					childShape.FillFormat.Fill = true;
					childShape.FillFormat.IsDefaultFill = false;
					childShape.FillFormat.FillType = FillType.FillSolid;
					uint opacity = uint.MaxValue;
					Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
					childShape.FillFormat.Color = color;
					if (opacity != uint.MaxValue)
					{
						childShape.FillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					break;
				}
				case "noFill":
					childShape.IsFillStyleInline = true;
					childShape.FillFormat.Fill = false;
					childShape.FillFormat.IsDefaultFill = false;
					break;
				case "grpFill":
					if (childShape != null)
					{
						childShape.FillFormat.IsGrpFill = true;
						childShape.DocxProps.Add("grpFill", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "effectLst":
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && reader.NodeType == XmlNodeType.Element)
						{
							childShape.IsEffectStyleInline = true;
							ParseEffectList(reader, childShape, localName);
						}
					}
					break;
				case "scene3d":
					effectFormat = new EffectFormat(childShape);
					childShape.IsScenePropertiesInline = true;
					effectFormat.IsSceneProperties = true;
					childShape.EffectList.Add(ParseSceneProperties(reader, effectFormat));
					break;
				case "sp3d":
					effectFormat = new EffectFormat(childShape);
					childShape.IsShapePropertiesInline = true;
					effectFormat.IsShapeProperties = true;
					if (reader.HasAttributes)
					{
						string attribute3 = reader.GetAttribute("contourW");
						if (!string.IsNullOrEmpty(attribute3))
						{
							effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(attribute3, "contourW");
						}
						attribute3 = reader.GetAttribute("extrusionH");
						if (!string.IsNullOrEmpty(attribute3))
						{
							effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(attribute3, "extrusionH");
						}
						attribute3 = reader.GetAttribute("z");
						if (!string.IsNullOrEmpty(attribute3))
						{
							effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(attribute3, "z");
						}
						attribute3 = reader.GetAttribute("prstMaterial");
						if (!string.IsNullOrEmpty(attribute3) && attribute3.Length > 2)
						{
							effectFormat.ThreeDFormat.PresetMaterialType = ParsePresetMaterialType(attribute3);
						}
					}
					effectFormat = ParseShapeProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						childShape.EffectList.Add(effectFormat);
					}
					break;
				case "style":
				{
					MemoryStream memoryStream = new MemoryStream();
					memoryStream = ReadSingleNodeIntoStream(reader);
					if (m_doc.DocHasThemes && childShape != null)
					{
						ParseStyleItems(memoryStream, childShape);
						childShape.DocxProps.Add("style", memoryStream);
					}
					flag = true;
					break;
				}
				case "bodyPr":
					if (childShape != null && !childShape.IsLineStyleInline && !childShape.DocxProps.ContainsKey("style"))
					{
						childShape.LineFormat.Line = false;
					}
					if (childShape != null && !childShape.IsFillStyleInline && !childShape.DocxProps.ContainsKey("style"))
					{
						childShape.FillFormat.Fill = false;
					}
					if (reader.AttributeCount != 0)
					{
						string attribute3 = reader.GetAttribute("vert");
						childShape.TextFrame.TextDirection = GetTextDirection(attribute3, flag2);
						attribute3 = reader.GetAttribute("anchor");
						childShape.TextFrame.TextVerticalAlignment = GetTextVertAlign(attribute3);
						attribute3 = reader.GetAttribute("lIns");
						if (!string.IsNullOrEmpty(attribute3))
						{
							childShape.TextFrame.InternalMargin.Left = GetShapeInternalMargin(attribute3);
						}
						attribute3 = reader.GetAttribute("tIns");
						if (!string.IsNullOrEmpty(attribute3))
						{
							childShape.TextFrame.InternalMargin.Top = GetShapeInternalMargin(attribute3);
						}
						attribute3 = reader.GetAttribute("rIns");
						if (!string.IsNullOrEmpty(attribute3))
						{
							childShape.TextFrame.InternalMargin.Right = GetShapeInternalMargin(attribute3);
						}
						attribute3 = reader.GetAttribute("bIns");
						if (!string.IsNullOrEmpty(attribute3))
						{
							childShape.TextFrame.InternalMargin.Bottom = GetShapeInternalMargin(attribute3);
						}
						attribute3 = reader.GetAttribute("wrap");
						if (attribute3 == "none")
						{
							childShape.TextFrame.NoWrap = true;
						}
						attribute3 = reader.GetAttribute("upright");
						if (!string.IsNullOrEmpty(attribute3))
						{
							childShape.TextFrame.Upright = ((attribute3 == "1" || attribute3 == "true") ? true : false);
						}
						MemoryStream value = ReadSingleNodeIntoStream(reader);
						childShape.DocxProps.Add("BodyPr", value);
						flag = true;
					}
					break;
				case "txbx":
				{
					reader.Read();
					SkipWhitespaces(reader);
					WTextBox wTextBox = new WTextBox(m_doc);
					m_currentRunFormat = null;
					RevisionType trackChangeType = m_trackChangeType;
					m_trackChangeType = RevisionType.None;
					Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
					m_trackchangeRevisionDetails.Clear();
					Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
					m_trackchangeStack.Clear();
					ParseTextboxContent(reader, wTextBox);
					m_trackChangeType = trackChangeType;
					m_trackchangeRevisionDetails = new Stack<Revision>(stack);
					stack.Clear();
					m_trackchangeStack = new Stack<RevisionType>(stack2);
					stack2.Clear();
					childShape.TextBody = wTextBox.TextBoxBody;
					childShape.TextBody.SetOwner(childShape);
					if (childShape.AutoShapeType == AutoShapeType.Rectangle)
					{
						childShape.ElementType = EntityType.TextBox;
					}
					else
					{
						childShape.ElementType = EntityType.AutoShape;
					}
					reader.Read();
					break;
				}
				case "grpSp":
				{
					ChildGroupShape childGroupShape = new ChildGroupShape(m_doc);
					childGroupShape.ElementType = EntityType.ChildGroupShape;
					childGroupShape.SetOwner(shape);
					ParseNestedGroup(reader, childGroupShape);
					shape.Add(childGroupShape);
					flag = true;
					break;
				}
				case "extLst":
					if (childShape != null)
					{
						if (!childShape.DocxProps.ContainsKey("extLst"))
						{
							childShape.DocxProps.Add("extLst", ReadSingleNodeIntoStream(reader));
						}
						else
						{
							ReadSingleNodeIntoStream(reader);
						}
						flag = true;
					}
					break;
				case "pic":
				{
					WPicture wPicture = new WPicture(m_doc);
					MemoryStream data = ReadSingleNodeIntoStream(reader);
					flag = true;
					XmlReader xmlReader = UtilityMethods.CreateReader(data);
					xmlReader.ReadToFollowing("blip", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
					string attribute = xmlReader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					string attribute2 = xmlReader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					bool isHeaderFooter = ((m_currentFile.StartsWith("header") || m_currentFile.StartsWith("footer")) ? true : false);
					if (!string.IsNullOrEmpty(attribute))
					{
						LoadImage(wPicture, attribute, isHeaderFooter, isPicBullet: false);
					}
					if (!string.IsNullOrEmpty(attribute2))
					{
						DocGen.DocIO.DLS.Entities.Image image = null;
						bool isImageRelation = true;
						wPicture.ExternalLink = GetImageName(attribute2, isHeaderFooter, isPicBullet: false, ref isImageRelation);
						if (!string.IsNullOrEmpty(attribute))
						{
							wPicture.HasImageRecordReference = true;
						}
						if (image != null)
						{
							wPicture.LoadImage(image);
						}
					}
					if (wPicture.ImageRecord != null || wPicture.ImageBytes != null)
					{
						xmlReader.Dispose();
						xmlReader = UtilityMethods.CreateReader(data);
						ParseGroupShapePictureData(xmlReader, wPicture);
						wPicture.SetOwner(shape);
						shape.Add(wPicture);
						flag = true;
					}
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private PresetMaterialType ParsePresetMaterialType(string value)
	{
		if (!(value == "dkEdge"))
		{
			if (value == "softmetal")
			{
				return PresetMaterialType.SoftMetal;
			}
			if (!Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(value[0]) + value.Substring(1)))
			{
				return PresetMaterialType.None;
			}
			return (PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), value, ignoreCase: true);
		}
		return PresetMaterialType.DarkEdge;
	}

	private void ParseGraphicFrame(MemoryStream graphicStream, GroupShape groupShape, ChildGroupShape childGroupShape)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(graphicStream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "graphicFrame")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		GraphicDataContentType graphicDataContentType = CheckPicture(xmlReader);
		graphicStream.Position = 0L;
		ChildShape childShape = new ChildShape(m_doc);
		if (groupShape != null)
		{
			groupShape.Add(childShape);
			childShape.SetOwner(groupShape);
		}
		else
		{
			childGroupShape.Add(childShape);
			childShape.SetOwner(childGroupShape);
		}
		switch (graphicDataContentType)
		{
		case GraphicDataContentType.None:
			childShape.XmlParagraphItem = ParseXmlParaItem(graphicStream);
			childShape.ElementType = EntityType.XmlParaItem;
			break;
		case GraphicDataContentType.Chart:
		{
			graphicStream.Position = 0L;
			XmlReader xmlReader2 = UtilityMethods.CreateReader(graphicStream);
			xmlReader2.Read();
			bool flag = false;
			childShape.ElementType = EntityType.Chart;
			while (xmlReader2.LocalName != "graphicFrame")
			{
				flag = false;
				if (xmlReader2.NodeType == XmlNodeType.Element)
				{
					switch (xmlReader2.LocalName)
					{
					case "graphic":
						xmlReader2.Read();
						ParseGraphicData(xmlReader2, childShape.Chart, null);
						xmlReader2.Read();
						if (xmlReader2.LocalName != "graphicData")
						{
							xmlReader2.Read();
						}
						break;
					case "cNvPr":
						ParseGraphicFrameNonVisualProperties(xmlReader2, childShape);
						break;
					case "xfrm":
						Parse2DTransform(xmlReader2, childShape);
						break;
					case "ext":
						ParseExtent(xmlReader2, childShape);
						break;
					case "off":
						ParseOffset(xmlReader2, childShape);
						break;
					case "extLst":
						if (!childShape.DocxProps.ContainsKey("extLst"))
						{
							childShape.DocxProps.Add("extLst", ReadSingleNodeIntoStream(xmlReader2));
						}
						else
						{
							ReadSingleNodeIntoStream(xmlReader2);
						}
						flag = true;
						break;
					}
					if (!flag)
					{
						xmlReader2.Read();
					}
				}
				else
				{
					xmlReader2.Read();
				}
				SkipWhitespaces(xmlReader2);
			}
			break;
		}
		}
	}

	private void ParseGraphicFrameNonVisualProperties(XmlReader reader, ChildShape childShape)
	{
		string attribute = reader.GetAttribute("id");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.ShapeID = Convert.ToInt64(attribute.ToString());
			if (m_doc.maxShapeId < childShape.ShapeID)
			{
				m_doc.maxShapeId = childShape.ShapeID;
			}
		}
		attribute = reader.GetAttribute("name");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Name = attribute.ToString();
		}
		attribute = reader.GetAttribute("descr");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.AlternativeText = attribute.ToString();
		}
		attribute = reader.GetAttribute("title");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Title = attribute.ToString();
		}
		attribute = reader.GetAttribute("hidden");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Visible = !GetBoolValue(attribute);
		}
		if (childShape.ElementType == EntityType.WordDocument)
		{
			childShape.ElementType = EntityType.AutoShape;
		}
	}

	private void Parse2DTransform(XmlReader reader, ChildShape childShape)
	{
		string attribute = reader.GetAttribute("flipH");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.FlipHorizantal = ((attribute == "1" || attribute == "true") ? true : false);
		}
		attribute = reader.GetAttribute("flipV");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.FlipVertical = ((attribute == "1" || attribute == "true") ? true : false);
		}
		attribute = reader.GetAttribute("rot");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Rotation = GetNumericValue(attribute) / 60000f;
		}
	}

	private void ParseExtent(XmlReader reader, ChildShape childShape)
	{
		string attribute = reader.GetAttribute("cx");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Width = GetPropertyValue(attribute, "cx");
		}
		attribute = reader.GetAttribute("cy");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Height = GetPropertyValue(attribute, "cy");
		}
	}

	private void ParseOffset(XmlReader reader, ChildShape childShape)
	{
		string attribute = reader.GetAttribute("x");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.X = GetPropertyValue(attribute, "x");
		}
		attribute = reader.GetAttribute("y");
		if (!string.IsNullOrEmpty(attribute))
		{
			childShape.Y = GetPropertyValue(attribute, "y");
		}
	}

	private void ParseNestedGroup(XmlReader reader, ChildGroupShape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "grpSp")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		shape.LineFormat = new LineFormat(shape);
		SkipWhitespaces(reader);
		ChildShape childShape = null;
		while (reader.LocalName != "grpSp" || (reader.LocalName == "grpSp" && reader.NodeType == XmlNodeType.Element))
		{
			EffectFormat effectFormat = null;
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string empty = string.Empty;
				switch (reader.LocalName)
				{
				case "grpSpPr":
					if (childShape == null)
					{
						ParseGroupShapeProperties(reader, shape);
					}
					break;
				case "wsp":
				{
					childShape = new ChildShape(m_doc);
					childShape.LineFormat = new LineFormat(childShape);
					string attribute = reader.GetAttribute("normalEastAsianFlow");
					if (!string.IsNullOrEmpty(attribute) && !flag2)
					{
						childShape.TextFrame.TextDirection = (GetBoolValue(attribute) ? TextDirection.HorizontalFarEast : TextDirection.Horizontal);
						flag2 = childShape.TextFrame.TextDirection == TextDirection.HorizontalFarEast;
					}
					break;
				}
				case "grpSp":
				{
					ChildGroupShape childGroupShape = new ChildGroupShape(m_doc);
					childGroupShape.ElementType = EntityType.ChildGroupShape;
					childGroupShape.SetOwner(shape);
					ParseNestedGroup(reader, childGroupShape);
					shape.Add(childGroupShape);
					break;
				}
				case "graphicFrame":
				{
					MemoryStream graphicStream = ReadSingleNodeIntoStream(reader);
					ParseGraphicFrame(graphicStream, null, shape);
					flag = true;
					break;
				}
				case "pic":
				{
					WPicture wPicture = new WPicture(m_doc);
					MemoryStream data = ReadSingleNodeIntoStream(reader);
					XmlReader xmlReader = UtilityMethods.CreateReader(data);
					xmlReader.ReadToFollowing("blip", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
					string attribute2 = xmlReader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					string attribute3 = xmlReader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					bool isHeaderFooter = ((m_currentFile.StartsWith("header") || m_currentFile.StartsWith("footer")) ? true : false);
					if (!string.IsNullOrEmpty(attribute2))
					{
						LoadImage(wPicture, attribute2, isHeaderFooter, isPicBullet: false);
					}
					if (!string.IsNullOrEmpty(attribute3))
					{
						DocGen.DocIO.DLS.Entities.Image image = null;
						bool isImageRelation = true;
						wPicture.ExternalLink = GetImageName(attribute3, isHeaderFooter, isPicBullet: false, ref isImageRelation);
						if (!string.IsNullOrEmpty(attribute2))
						{
							wPicture.HasImageRecordReference = true;
						}
						if (image != null)
						{
							wPicture.LoadImage(image);
						}
					}
					if (wPicture.ImageRecord != null || wPicture.ImageBytes != null)
					{
						xmlReader.Dispose();
						xmlReader = UtilityMethods.CreateReader(data);
						ParseGroupShapePictureData(xmlReader, wPicture);
						wPicture.SetOwner(shape);
						shape.Add(wPicture);
						flag = true;
					}
					break;
				}
				case "cNvPr":
					if (childShape != null)
					{
						empty = reader.GetAttribute("id");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.ShapeID = Convert.ToInt64(empty.ToString());
							if (m_doc.maxShapeId < childShape.ShapeID)
							{
								m_doc.maxShapeId = childShape.ShapeID;
							}
						}
						empty = reader.GetAttribute("name");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.Name = empty.ToString();
						}
						shape.Add(childShape);
						childShape.SetOwner(shape);
					}
					else
					{
						if (shape == null)
						{
							break;
						}
						empty = reader.GetAttribute("id");
						if (!string.IsNullOrEmpty(empty))
						{
							shape.ShapeID = Convert.ToInt64(empty.ToString());
							if (m_doc.maxShapeId < shape.ShapeID)
							{
								m_doc.maxShapeId = shape.ShapeID;
							}
						}
						empty = reader.GetAttribute("name");
						if (!string.IsNullOrEmpty(empty))
						{
							shape.Name = empty.ToString();
						}
					}
					break;
				case "xfrm":
					if (childShape != null)
					{
						empty = reader.GetAttribute("flipH");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.FlipHorizantal = ((empty == "1" || empty == "true") ? true : false);
						}
						empty = reader.GetAttribute("flipV");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.FlipVertical = ((empty == "1" || empty == "true") ? true : false);
						}
						empty = reader.GetAttribute("rot");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.Rotation = GetNumericValue(empty) / 60000f;
						}
					}
					break;
				case "ext":
					if (childShape != null)
					{
						empty = reader.GetAttribute("cx");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.Width = GetPropertyValue(empty, "cx");
						}
						empty = reader.GetAttribute("cy");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.Height = GetPropertyValue(empty, "cy");
						}
					}
					break;
				case "off":
					if (childShape != null)
					{
						empty = reader.GetAttribute("x");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.X = GetPropertyValue(empty, "x");
						}
						empty = reader.GetAttribute("y");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.Y = GetPropertyValue(empty, "y");
						}
					}
					break;
				case "prstGeom":
					if (childShape != null)
					{
						empty = reader.GetAttribute("prst");
						if (!string.IsNullOrEmpty(empty) && empty.Length > 0)
						{
							AutoShapeConstant autoShapeConstant = AutoShapeHelper.GetAutoShapeConstant(empty);
							AutoShapeType autoShapeType = AutoShapeHelper.GetAutoShapeType(autoShapeConstant);
							childShape.AutoShapeType = autoShapeType;
							childShape.ElementType = EntityType.AutoShape;
						}
					}
					break;
				case "avLst":
					if (childShape != null)
					{
						ParseShapeAdjustValues(reader, childShape);
					}
					break;
				case "custGeom":
					if (childShape != null && !IsWord2003ML)
					{
						childShape.ElementType = EntityType.AutoShape;
						childShape.AutoShapeType = AutoShapeType.Unknown;
						ParseCustomGeometry(reader, childShape);
					}
					break;
				case "ln":
					if (childShape != null)
					{
						childShape.IsLineStyleInline = true;
						ParseLineFormat(reader, childShape);
					}
					break;
				case "pattFill":
					if (childShape != null)
					{
						childShape.IsFillStyleInline = true;
						childShape.FillFormat.Fill = true;
						childShape.FillFormat.IsDefaultFill = false;
						childShape.FillFormat.FillType = FillType.FillPatterned;
						empty = reader.GetAttribute("prst");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.FillFormat.Pattern = GetPatternType(empty);
						}
						ParsePatternFill(reader, childShape.FillFormat);
					}
					break;
				case "gradFill":
					if (childShape != null)
					{
						childShape.IsFillStyleInline = true;
						childShape.FillFormat.Fill = true;
						childShape.FillFormat.IsDefaultFill = false;
						childShape.FillFormat.FillType = FillType.FillGradient;
						ParseGradientFill(reader, childShape.FillFormat.GradientFill);
					}
					break;
				case "blipFill":
					if (childShape != null)
					{
						childShape.IsFillStyleInline = true;
						childShape.FillFormat.Fill = true;
						childShape.FillFormat.IsDefaultFill = false;
						childShape.FillFormat.FillType = FillType.FillPicture;
						ParseBlipFill(reader, childShape.FillFormat);
					}
					break;
				case "solidFill":
					if (childShape != null)
					{
						childShape.IsFillStyleInline = true;
						childShape.FillFormat.Fill = true;
						childShape.FillFormat.IsDefaultFill = false;
						childShape.FillFormat.FillType = FillType.FillSolid;
						uint opacity = uint.MaxValue;
						Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
						childShape.FillFormat.Color = color;
						if (opacity != uint.MaxValue)
						{
							childShape.FillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
						}
					}
					break;
				case "noFill":
					if (childShape != null)
					{
						childShape.IsFillStyleInline = true;
						childShape.FillFormat.Fill = false;
						childShape.FillFormat.IsDefaultFill = false;
					}
					break;
				case "effectLst":
					if (childShape != null && !reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							childShape.IsEffectStyleInline = true;
							ParseEffectList(reader, childShape, localName);
						}
					}
					break;
				case "scene3d":
					if (childShape != null)
					{
						effectFormat = new EffectFormat(childShape);
						childShape.IsScenePropertiesInline = true;
						effectFormat.IsSceneProperties = true;
						childShape.EffectList.Add(ParseSceneProperties(reader, effectFormat));
					}
					break;
				case "sp3d":
					if (childShape == null)
					{
						break;
					}
					effectFormat = new EffectFormat(childShape);
					childShape.IsShapePropertiesInline = true;
					effectFormat.IsShapeProperties = true;
					if (reader.HasAttributes)
					{
						empty = reader.GetAttribute("contourW");
						if (!string.IsNullOrEmpty(empty))
						{
							effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(empty, "contourW");
						}
						empty = reader.GetAttribute("extrusionH");
						if (!string.IsNullOrEmpty(empty))
						{
							effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(empty, "extrusionH");
						}
						empty = reader.GetAttribute("z");
						if (!string.IsNullOrEmpty(empty))
						{
							effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(empty, "z");
						}
						empty = reader.GetAttribute("prstMaterial");
						if (!string.IsNullOrEmpty(empty) && empty.Length > 2)
						{
							effectFormat.ThreeDFormat.PresetMaterialType = (Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(empty[0]) + empty.Substring(1)) ? ((PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), empty, ignoreCase: true)) : PresetMaterialType.None);
						}
					}
					effectFormat = ParseShapeProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						childShape.EffectList.Add(effectFormat);
					}
					break;
				case "style":
					if (childShape != null)
					{
						MemoryStream memoryStream = new MemoryStream();
						memoryStream = ReadSingleNodeIntoStream(reader);
						if (m_doc.DocHasThemes && childShape != null)
						{
							ParseStyleItems(memoryStream, childShape);
							childShape.DocxProps.Add("style", memoryStream);
						}
					}
					flag = true;
					break;
				case "bodyPr":
					if (childShape == null)
					{
						break;
					}
					if (!childShape.IsLineStyleInline && !childShape.DocxProps.ContainsKey("style"))
					{
						childShape.LineFormat.Line = false;
					}
					if (!childShape.IsFillStyleInline && !childShape.DocxProps.ContainsKey("style"))
					{
						childShape.FillFormat.Fill = false;
					}
					if (reader.AttributeCount != 0)
					{
						empty = reader.GetAttribute("vert");
						childShape.TextFrame.TextDirection = GetTextDirection(empty, flag2);
						empty = reader.GetAttribute("anchor");
						childShape.TextFrame.TextVerticalAlignment = GetTextVertAlign(empty);
						empty = reader.GetAttribute("lIns");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.TextFrame.InternalMargin.Left = GetShapeInternalMargin(empty);
						}
						empty = reader.GetAttribute("tIns");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.TextFrame.InternalMargin.Top = GetShapeInternalMargin(empty);
						}
						empty = reader.GetAttribute("rIns");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.TextFrame.InternalMargin.Right = GetShapeInternalMargin(empty);
						}
						empty = reader.GetAttribute("bIns");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.TextFrame.InternalMargin.Bottom = GetShapeInternalMargin(empty);
						}
						empty = reader.GetAttribute("wrap");
						if (empty == "none")
						{
							childShape.TextFrame.NoWrap = true;
						}
						empty = reader.GetAttribute("upright");
						if (!string.IsNullOrEmpty(empty))
						{
							childShape.TextFrame.Upright = ((empty == "1" || empty == "true") ? true : false);
						}
						MemoryStream value = ReadSingleNodeIntoStream(reader);
						childShape.DocxProps.Add("BodyPr", value);
						flag = true;
					}
					break;
				case "txbx":
					if (childShape != null)
					{
						reader.Read();
						SkipWhitespaces(reader);
						WTextBox wTextBox = new WTextBox(m_doc);
						m_currentRunFormat = null;
						RevisionType trackChangeType = m_trackChangeType;
						m_trackChangeType = RevisionType.None;
						Stack<Revision> stack = new Stack<Revision>(m_trackchangeRevisionDetails);
						m_trackchangeRevisionDetails.Clear();
						Stack<RevisionType> stack2 = new Stack<RevisionType>(m_trackchangeStack);
						m_trackchangeStack.Clear();
						ParseTextboxContent(reader, wTextBox);
						m_trackChangeType = trackChangeType;
						m_trackchangeRevisionDetails = new Stack<Revision>(stack);
						stack.Clear();
						m_trackchangeStack = new Stack<RevisionType>(stack2);
						stack2.Clear();
						childShape.TextBody = wTextBox.TextBoxBody;
						childShape.TextBody.SetOwner(childShape);
						if (childShape.AutoShapeType == AutoShapeType.Rectangle)
						{
							childShape.ElementType = EntityType.TextBox;
						}
						else
						{
							childShape.ElementType = EntityType.AutoShape;
						}
						reader.Read();
					}
					break;
				case "extLst":
					if (childShape != null)
					{
						if (!childShape.DocxProps.ContainsKey("extLst"))
						{
							childShape.DocxProps.Add("extLst", ReadSingleNodeIntoStream(reader));
						}
						else
						{
							ReadSingleNodeIntoStream(reader);
						}
						flag = true;
					}
					break;
				case "grpFill":
					if (childShape != null)
					{
						childShape.FillFormat.IsGrpFill = true;
						childShape.DocxProps.Add("grpFill", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private long GenerateShapeID()
	{
		return shapeID++;
	}

	private void ParseGroupShapeProperties(XmlReader reader, ChildGroupShape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "grpSpPr")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "grpSpPr")
		{
			EffectFormat effectFormat = null;
			if (reader.NodeType == XmlNodeType.Element)
			{
				bool flag = false;
				switch (reader.LocalName)
				{
				case "xfrm":
				{
					string attribute = reader.GetAttribute("rot");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Rotation = GetNumericValue(attribute) / 60000f;
					}
					attribute = reader.GetAttribute("flipH");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipHorizantal = ((attribute == "1" || attribute == "true") ? true : false);
					}
					attribute = reader.GetAttribute("flipV");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipVertical = ((attribute == "1" || attribute == "true") ? true : false);
					}
					break;
				}
				case "chOff":
				{
					string attribute = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.X = GetPropertyValue(attribute, "x");
					}
					attribute = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Y = GetPropertyValue(attribute, "y");
					}
					break;
				}
				case "off":
				{
					string attribute = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.OffsetXValue = GetPropertyValue(attribute, "x");
					}
					attribute = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.OffsetYValue = GetPropertyValue(attribute, "y");
					}
					break;
				}
				case "ext":
				{
					string attribute = reader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Width = GetPropertyValue(attribute, "cx");
					}
					attribute = reader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Height = GetPropertyValue(attribute, "cy");
					}
					break;
				}
				case "chExt":
				{
					string attribute = reader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.ExtentXValue = GetPropertyValue(attribute, "x");
					}
					attribute = reader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.ExtentYValue = GetPropertyValue(attribute, "y");
					}
					break;
				}
				case "effectLst":
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && reader.NodeType == XmlNodeType.Element)
						{
							shape.IsEffectStyleInline = true;
							ParseEffectList(reader, shape, localName);
						}
					}
					break;
				case "scene3d":
					effectFormat = new EffectFormat(shape);
					shape.IsScenePropertiesInline = true;
					effectFormat.IsSceneProperties = true;
					shape.EffectList.Add(ParseSceneProperties(reader, effectFormat));
					break;
				case "sp3d":
					effectFormat = new EffectFormat(shape);
					shape.IsShapePropertiesInline = true;
					effectFormat.IsShapeProperties = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("contourW");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(attribute, "contourW");
						}
						attribute = reader.GetAttribute("extrusionH");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(attribute, "extrusionH");
						}
						attribute = reader.GetAttribute("z");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(attribute, "z");
						}
						attribute = reader.GetAttribute("prstMaterial");
						if (!string.IsNullOrEmpty(attribute) && attribute.Length > 2)
						{
							effectFormat.ThreeDFormat.PresetMaterialType = (Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(attribute[0]) + attribute.Substring(1)) ? ((PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), attribute, ignoreCase: true)) : PresetMaterialType.None);
						}
					}
					effectFormat = ParseShapeProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "solidFill":
					if (shape != null)
					{
						shape.IsFillStyleInline = true;
						shape.FillFormat.Fill = true;
						shape.FillFormat.IsDefaultFill = false;
						shape.FillFormat.FillType = FillType.FillSolid;
						uint opacity = uint.MaxValue;
						Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
						shape.FillFormat.Color = color;
						if (opacity != uint.MaxValue)
						{
							shape.FillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
						}
					}
					break;
				case "blipFill":
					if (shape != null)
					{
						shape.IsFillStyleInline = true;
						shape.FillFormat.Fill = true;
						shape.FillFormat.IsDefaultFill = false;
						shape.FillFormat.FillType = FillType.FillPicture;
						ParseBlipFill(reader, shape.FillFormat);
					}
					break;
				case "grpFill":
					if (shape != null)
					{
						shape.FillFormat.IsGrpFill = true;
						shape.DocxProps.Add("grpfill", ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseGroupShapeProperties(XmlReader reader, GroupShape shape)
	{
		reader.Read();
		while (reader.LocalName != "grpSpPr")
		{
			EffectFormat effectFormat = null;
			if (reader.NodeType == XmlNodeType.Element)
			{
				bool flag = false;
				switch (reader.LocalName)
				{
				case "xfrm":
				{
					string attribute = reader.GetAttribute("rot");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Rotation = GetNumericValue(attribute) / 60000f;
					}
					attribute = reader.GetAttribute("flipH");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipHorizontal = ((attribute == "1" || attribute == "true") ? true : false);
					}
					attribute = reader.GetAttribute("flipV");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.FlipVertical = ((attribute == "1" || attribute == "true") ? true : false);
					}
					break;
				}
				case "chOff":
				{
					string attribute = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.X = GetPropertyValue(attribute, "x");
					}
					attribute = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.Y = GetPropertyValue(attribute, "y");
					}
					break;
				}
				case "chExt":
				{
					string attribute = reader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.ExtentXValue = GetPropertyValue(attribute, "x");
					}
					attribute = reader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.ExtentYValue = GetPropertyValue(attribute, "y");
					}
					break;
				}
				case "effectLst":
					if (!reader.IsEmptyElement)
					{
						string localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							shape.IsEffectStyleInline = true;
							ParseEffectList(reader, shape, localName);
						}
					}
					break;
				case "scene3d":
					effectFormat = new EffectFormat(shape);
					shape.IsScenePropertiesInline = true;
					effectFormat.IsSceneProperties = true;
					shape.EffectList.Add(ParseSceneProperties(reader, effectFormat));
					break;
				case "sp3d":
					effectFormat = new EffectFormat(shape);
					shape.IsShapePropertiesInline = true;
					effectFormat.IsShapeProperties = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("contourW");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ContourWidth = GetPropertyValue(attribute, "contourW");
						}
						attribute = reader.GetAttribute("extrusionH");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.ExtrusionHeight = GetPropertyValue(attribute, "extrusionH");
						}
						attribute = reader.GetAttribute("z");
						if (!string.IsNullOrEmpty(attribute))
						{
							effectFormat.ThreeDFormat.DistanceFromGround = GetPropertyValue(attribute, "z");
						}
						attribute = reader.GetAttribute("prstMaterial");
						if (!string.IsNullOrEmpty(attribute) && attribute.Length > 2)
						{
							effectFormat.ThreeDFormat.PresetMaterialType = (Enum.IsDefined(typeof(PresetMaterialType), char.ToUpper(attribute[0]) + attribute.Substring(1)) ? ((PresetMaterialType)Enum.Parse(typeof(PresetMaterialType), attribute, ignoreCase: true)) : PresetMaterialType.None);
						}
					}
					effectFormat = ParseShapeProperties(reader, effectFormat);
					if (effectFormat != null)
					{
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "solidFill":
					if (shape != null)
					{
						shape.IsFillStyleInline = true;
						shape.FillFormat.Fill = true;
						shape.FillFormat.IsDefaultFill = false;
						shape.FillFormat.FillType = FillType.FillSolid;
						uint opacity = uint.MaxValue;
						Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
						shape.FillFormat.Color = color;
						if (opacity != uint.MaxValue)
						{
							shape.FillFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
						}
					}
					break;
				case "blipFill":
					if (shape != null)
					{
						shape.IsFillStyleInline = true;
						shape.FillFormat.Fill = true;
						shape.FillFormat.IsDefaultFill = false;
						shape.FillFormat.FillType = FillType.FillPicture;
						ParseBlipFill(reader, shape.FillFormat);
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseEffectList(XmlReader reader, GroupShape shape, string localName)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != "effectLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		uint opacity = uint.MaxValue;
		while (reader.LocalName != "effectLst")
		{
			EffectFormat effectFormat = new EffectFormat(shape);
			effectFormat.IsEffectListItem = true;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "outerShdw":
				case "innerShdw":
					effectFormat.ShadowFormat.m_type = reader.LocalName;
					effectFormat.IsShadowEffect = true;
					ParseShadowEffect(reader, reader.LocalName, effectFormat);
					shape.EffectList.Add(effectFormat);
					break;
				case "reflection":
					if (reader.HasAttributes)
					{
						effectFormat.IsReflection = true;
						ParseReflectionEffect(reader, effectFormat);
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "glow":
					effectFormat.IsGlowEffect = true;
					if (reader.HasAttributes)
					{
						string attribute2 = reader.GetAttribute("rad");
						if (!string.IsNullOrEmpty(attribute2))
						{
							effectFormat.GlowFormat.IsInlineRadius = true;
							effectFormat.GlowFormat.Radius = GetPropertyValue(attribute2, "rad");
						}
					}
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							effectFormat.GlowFormat.Color = ParseColor(reader, reader.LocalName, ref opacity, localName, isAlreadyChecked: true);
							effectFormat.GlowFormat.IsInlineColor = true;
							if (opacity != uint.MaxValue)
							{
								float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
								effectFormat.GlowFormat.Transparency = (float)Math.Round(1f - num, 2);
								effectFormat.GlowFormat.IsInlineTransparency = true;
							}
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				case "softEdge":
					effectFormat.IsSoftEdge = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("rad");
						effectFormat.SoftEdgeRadius = GetPropertyValue(attribute, "rad");
						if (effectFormat.SoftEdgeRadius == 0f)
						{
							effectFormat.NoSoftEdges = true;
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseEffectList(XmlReader reader, ChildShape shape, string localName)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != "effectLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		uint opacity = uint.MaxValue;
		while (reader.LocalName != "effectLst")
		{
			EffectFormat effectFormat = new EffectFormat(shape);
			effectFormat.IsEffectListItem = true;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "outerShdw":
				case "innerShdw":
					effectFormat.ShadowFormat.m_type = reader.LocalName;
					effectFormat.IsShadowEffect = true;
					ParseShadowEffect(reader, reader.LocalName, effectFormat);
					shape.EffectList.Add(effectFormat);
					break;
				case "reflection":
					if (reader.HasAttributes)
					{
						effectFormat.IsReflection = true;
						ParseReflectionEffect(reader, effectFormat);
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "glow":
					effectFormat.IsGlowEffect = true;
					if (reader.HasAttributes)
					{
						string attribute2 = reader.GetAttribute("rad");
						if (!string.IsNullOrEmpty(attribute2))
						{
							effectFormat.GlowFormat.IsInlineRadius = true;
							effectFormat.GlowFormat.Radius = GetPropertyValue(attribute2, "rad");
						}
					}
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							effectFormat.GlowFormat.Color = ParseColor(reader, localName, ref opacity, localName, isAlreadyChecked: true);
							effectFormat.GlowFormat.IsInlineColor = true;
							if (opacity != uint.MaxValue)
							{
								float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
								effectFormat.GlowFormat.Transparency = (float)Math.Round(1f - num, 2);
								effectFormat.GlowFormat.IsInlineTransparency = true;
							}
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				case "softEdge":
					effectFormat.IsSoftEdge = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("rad");
						effectFormat.SoftEdgeRadius = GetPropertyValue(attribute, "rad");
						if (effectFormat.SoftEdgeRadius == 0f)
						{
							effectFormat.NoSoftEdges = true;
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseEffectList(XmlReader reader, Shape shape, string localName)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != "effectLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		uint opacity = uint.MaxValue;
		while (reader.LocalName != "effectLst")
		{
			EffectFormat effectFormat = new EffectFormat(shape);
			effectFormat.IsEffectListItem = true;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "outerShdw":
				case "innerShdw":
					effectFormat.ShadowFormat.m_type = reader.LocalName;
					effectFormat.IsShadowEffect = true;
					ParseShadowEffect(reader, reader.LocalName, effectFormat);
					shape.EffectList.Add(effectFormat);
					break;
				case "reflection":
					if (reader.HasAttributes)
					{
						effectFormat.IsReflection = true;
						ParseReflectionEffect(reader, effectFormat);
						shape.EffectList.Add(effectFormat);
					}
					break;
				case "glow":
					effectFormat.IsGlowEffect = true;
					if (reader.HasAttributes)
					{
						string attribute2 = reader.GetAttribute("rad");
						if (!string.IsNullOrEmpty(attribute2))
						{
							effectFormat.GlowFormat.IsInlineRadius = true;
							effectFormat.GlowFormat.Radius = GetPropertyValue(attribute2, "rad");
						}
					}
					if (!reader.IsEmptyElement)
					{
						localName = reader.LocalName;
						reader.Read();
						if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
						{
							effectFormat.GlowFormat.Color = ParseColor(reader, localName, ref opacity, localName, isAlreadyChecked: true);
							effectFormat.GlowFormat.IsInlineColor = true;
							if (opacity != uint.MaxValue)
							{
								float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
								effectFormat.GlowFormat.Transparency = (float)Math.Round(1f - num, 2);
								effectFormat.GlowFormat.IsInlineTransparency = true;
							}
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				case "softEdge":
					effectFormat.IsSoftEdge = true;
					if (reader.HasAttributes)
					{
						string attribute = reader.GetAttribute("rad");
						effectFormat.SoftEdgeRadius = GetPropertyValue(attribute, "rad");
						if (effectFormat.SoftEdgeRadius == 0f)
						{
							effectFormat.NoSoftEdges = true;
						}
					}
					shape.EffectList.Add(effectFormat);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseReflectionEffect(XmlReader reader, EffectFormat effectFormat)
	{
		string attribute = reader.GetAttribute("blurRad");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Blur = GetPointValue(attribute);
		}
		attribute = reader.GetAttribute("stA");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Transparency = 100f - (float)GetPercentage(attribute);
			if (!(effectFormat.ReflectionFormat.Transparency < 0f) && !(effectFormat.ReflectionFormat.Transparency <= 100f))
			{
				effectFormat.ReflectionFormat.Transparency = 0f;
			}
		}
		attribute = reader.GetAttribute("stPos");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.StartPosition = (float)GetPercentage(attribute);
			if (!(effectFormat.ReflectionFormat.StartPosition < 0f) && !(effectFormat.ReflectionFormat.StartPosition <= 100f))
			{
				effectFormat.ReflectionFormat.StartPosition = 0f;
			}
		}
		attribute = reader.GetAttribute("endA");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.EndOpacity = (float)GetPercentage(attribute);
			if (!(effectFormat.ReflectionFormat.EndOpacity < 0f) && !(effectFormat.ReflectionFormat.EndOpacity <= 100f))
			{
				effectFormat.ReflectionFormat.EndOpacity = 0f;
			}
		}
		attribute = reader.GetAttribute("endPos");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Size = (float)GetPercentage(attribute);
			if (!(effectFormat.ReflectionFormat.Size < 0f) && !(effectFormat.ReflectionFormat.Size <= 100f))
			{
				effectFormat.ReflectionFormat.Size = 0f;
			}
		}
		attribute = reader.GetAttribute("dist");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Offset = GetPointValue(attribute);
		}
		attribute = reader.GetAttribute("dir");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Direction = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute, CultureInfo.InvariantCulture) / 60000.0, 0));
		}
		attribute = reader.GetAttribute("fadeDir");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.FadeDirection = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute, CultureInfo.InvariantCulture) / 60000.0, 0));
		}
		attribute = reader.GetAttribute("rotWithShape");
		effectFormat.ReflectionFormat.RotateWithShape = ((attribute == "1" || attribute == "true") ? true : false);
		attribute = reader.GetAttribute("algn");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.Alignment = GetTextureAlignment(attribute);
		}
		attribute = reader.GetAttribute("kx");
		if (!string.IsNullOrEmpty(attribute))
		{
			int num = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute, CultureInfo.InvariantCulture) / 60000.0, 0));
			if (num > -90 && num < 90)
			{
				effectFormat.ReflectionFormat.HorizontalSkew = num;
			}
		}
		attribute = reader.GetAttribute("ky");
		if (!string.IsNullOrEmpty(attribute))
		{
			int num2 = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute, CultureInfo.InvariantCulture) / 60000.0, 0));
			if (num2 > -90 && num2 < 90)
			{
				effectFormat.ReflectionFormat.VerticalSkew = num2;
			}
		}
		attribute = reader.GetAttribute("sx");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.HorizontalRatio = (float)GetPercentage(attribute) / 100f;
			if (!(effectFormat.ReflectionFormat.HorizontalRatio < -100f) && !(effectFormat.ReflectionFormat.HorizontalRatio <= 100f))
			{
				effectFormat.ReflectionFormat.HorizontalRatio = 0f;
			}
		}
		attribute = reader.GetAttribute("sy");
		if (!string.IsNullOrEmpty(attribute))
		{
			effectFormat.ReflectionFormat.VerticalRatio = (float)GetPercentage(attribute) / 100f;
			if (!(effectFormat.ReflectionFormat.VerticalRatio < -100f) && !(effectFormat.ReflectionFormat.VerticalRatio <= 100f))
			{
				effectFormat.ReflectionFormat.VerticalRatio = 0f;
			}
		}
	}

	private void ParseShadowEffect(XmlReader reader, string localName, EffectFormat effectFormat)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != localName)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName2 = reader.LocalName;
		if (reader.HasAttributes)
		{
			ParseShadowAttributes(reader, effectFormat.ShadowFormat);
		}
		reader.Read();
		if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			SkipWhitespaces(reader);
			uint opacity = uint.MaxValue;
			effectFormat.ShadowFormat.Color = ParseColor(reader, localName2, ref opacity, localName2, isAlreadyChecked: true);
			if (opacity != uint.MaxValue)
			{
				float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
				effectFormat.ShadowFormat.Transparency = 1f - num;
			}
		}
	}

	private void ParseShadowAttributes(XmlReader reader, ShadowFormat shadowFormat)
	{
		string text = null;
		text = reader.GetAttribute("blurRad");
		if (!string.IsNullOrEmpty(text))
		{
			shadowFormat.Blur = GetPropertyValue(text, "blurRad");
		}
		text = reader.GetAttribute("dist");
		if (!string.IsNullOrEmpty(text))
		{
			shadowFormat.Distance = GetPropertyValue(text, "dist");
		}
		text = reader.GetAttribute("dir");
		if (!string.IsNullOrEmpty(text))
		{
			uint.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out var result);
			shadowFormat.Direction = (short)Math.Round((double)result / 60000.0);
		}
		text = reader.GetAttribute("rotWithShape");
		if (!string.IsNullOrEmpty(text))
		{
			shadowFormat.RotateWithShape = GetBoolValue(text);
		}
		text = reader.GetAttribute("kx");
		if (!string.IsNullOrEmpty(text))
		{
			uint.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out var result2);
			shadowFormat.HorizontalSkewAngle = (short)Math.Round((double)result2 / 60000.0);
		}
		text = reader.GetAttribute("ky");
		if (!string.IsNullOrEmpty(text))
		{
			uint.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out var result3);
			shadowFormat.VerticalSkewAngle = (short)Math.Round((double)result3 / 60000.0);
		}
		text = reader.GetAttribute("sx");
		if (!string.IsNullOrEmpty(text))
		{
			shadowFormat.HorizontalScalingFactor = GetPropertyValue(text, "sx");
		}
		text = reader.GetAttribute("sy");
		if (!string.IsNullOrEmpty(text))
		{
			shadowFormat.VerticalScalingFactor = GetPropertyValue(text, "sy");
		}
	}

	private void ParseBodyProperties(MemoryStream stream, Shape shape)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "bodyPr")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(xmlReader);
		while (xmlReader.LocalName != "bodyPr")
		{
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "noAutofit":
					shape.TextFrame.NoAutoFit = true;
					break;
				case "normAutofit":
					shape.TextFrame.NormalAutoFit = true;
					break;
				case "spAutoFit":
					shape.TextFrame.ShapeAutoFit = true;
					break;
				case "prstTxWarp":
					if (xmlReader.AttributeCount != 0)
					{
						string attribute = xmlReader.GetAttribute("prst");
						if (!string.IsNullOrEmpty(attribute) && attribute.Trim() != "textNoShape")
						{
							m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 31);
						}
					}
					break;
				}
				xmlReader.Read();
			}
			else
			{
				xmlReader.Read();
			}
		}
	}

	private void ParseStyleItems(MemoryStream stream, Shape shape)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "style")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		ShapeStyleReference shapeStyleReference = new ShapeStyleReference();
		SkipWhitespaces(xmlReader);
		while (!(xmlReader.LocalName == "style") || xmlReader.NodeType != XmlNodeType.EndElement)
		{
			_ = string.Empty;
			_ = Color.Empty;
			uint opacity = uint.MaxValue;
			shapeStyleReference = new ShapeStyleReference();
			flag = true;
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "lnRef":
				{
					int num = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num;
					shapeStyleReference.StyleRefColor = color;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (num > m_doc.Themes.FmtScheme.LnStyleScheme.Count)
					{
						num = m_doc.Themes.FmtScheme.LnStyleScheme.Count;
					}
					if (num != 0)
					{
						LineFormat lineFormat = m_doc.Themes.FmtScheme.LnStyleScheme[num - 1];
						if (!shape.LineFormat.HasKey(14) && lineFormat.HasKey(14))
						{
							shape.LineFormat.Line = lineFormat.Line;
						}
						if (!shape.LineFormat.HasKey(11) && lineFormat.HasKey(11))
						{
							shape.LineFormat.Weight = lineFormat.Weight;
						}
						if (!shape.LineFormat.HasKey(0) && lineFormat.HasKey(0))
						{
							shape.LineFormat.LineJoin = lineFormat.LineJoin;
						}
						if (!shape.LineFormat.HasKey(1) && lineFormat.HasKey(1))
						{
							shape.LineFormat.LineCap = lineFormat.LineCap;
						}
						if (!shape.LineFormat.HasKey(2) && lineFormat.HasKey(2))
						{
							shape.LineFormat.BeginArrowheadLength = lineFormat.BeginArrowheadLength;
						}
						if (!shape.LineFormat.HasKey(3) && lineFormat.HasKey(3))
						{
							shape.LineFormat.BeginArrowheadStyle = lineFormat.BeginArrowheadStyle;
						}
						if (!shape.LineFormat.HasKey(4) && lineFormat.HasKey(4))
						{
							shape.LineFormat.BeginArrowheadWidth = lineFormat.BeginArrowheadWidth;
						}
						if (!shape.LineFormat.HasKey(5) && lineFormat.HasKey(5))
						{
							shape.LineFormat.DashStyle = lineFormat.DashStyle;
						}
						if (!shape.LineFormat.HasKey(6) && lineFormat.HasKey(6))
						{
							shape.LineFormat.EndArrowheadLength = lineFormat.EndArrowheadLength;
						}
						if (!shape.LineFormat.HasKey(7) && lineFormat.HasKey(7))
						{
							shape.LineFormat.EndArrowheadStyle = lineFormat.EndArrowheadStyle;
						}
						if (!shape.LineFormat.HasKey(8) && lineFormat.HasKey(8))
						{
							shape.LineFormat.EndArrowheadWidth = lineFormat.EndArrowheadWidth;
						}
						if (!shape.LineFormat.HasKey(9) && lineFormat.HasKey(9))
						{
							shape.LineFormat.InsetPen = lineFormat.InsetPen;
						}
						if (!shape.LineFormat.HasKey(10) && lineFormat.HasKey(10))
						{
							shape.LineFormat.Style = lineFormat.Style;
						}
						if (shape.LineFormat.LineFormatType == (LineFormatType)0 && lineFormat.LineFormatType == (LineFormatType)0)
						{
							shape.LineFormat.Line = false;
						}
						else if (shape.LineFormat.LineFormatType == (LineFormatType)0 && lineFormat.LineFormatType != 0)
						{
							shape.LineFormat.LineFormatType = lineFormat.LineFormatType;
						}
						if (!shape.LineFormat.HasKey(12) && lineFormat.HasKey(12))
						{
							if (lineFormat.LineFormatType == LineFormatType.Solid)
							{
								if (lineFormat.LineSchemeColorTransforms.Count > 0)
								{
									shape.LineFormat.Color = shape.StyleColorTransform(lineFormat.LineSchemeColorTransforms, color, ref opacity);
									opacity = uint.MaxValue;
								}
								else
								{
									shape.LineFormat.Color = (lineFormat.Color.IsEmpty ? color : lineFormat.Color);
								}
							}
							else if (lineFormat.LineFormatType == LineFormatType.Gradient)
							{
								for (int i = 0; i < lineFormat.GradientFill.GradientStops.Count; i++)
								{
									if (lineFormat.GradientFill.GradientStops[i].FillSchemeColorTransforms.Count > 0)
									{
										if (lineFormat.GradientFill.GradientStops[i].Color.IsEmpty)
										{
											lineFormat.GradientFill.GradientStops[i].Color = shape.StyleColorTransform(lineFormat.GradientFill.GradientStops[i].FillSchemeColorTransforms, color, ref opacity);
											opacity = uint.MaxValue;
										}
									}
									else
									{
										lineFormat.GradientFill.GradientStops[i].Color = color;
									}
								}
								shape.LineFormat.GradientFill = lineFormat.GradientFill;
							}
							else if (lineFormat.LineFormatType == LineFormatType.Patterned)
							{
								if (lineFormat.LineSchemeColorTransforms.Count > 0)
								{
									List<DictionaryEntry> list = new List<DictionaryEntry>();
									List<DictionaryEntry> list2 = new List<DictionaryEntry>();
									for (int j = 0; j < lineFormat.LineSchemeColorTransforms.Count; j++)
									{
										if (StartsWithExt(lineFormat.LineSchemeColorTransforms[j].Key.ToString(), "fgClr"))
										{
											list.Add(lineFormat.LineSchemeColorTransforms[j]);
										}
										if (StartsWithExt(lineFormat.LineSchemeColorTransforms[j].Key.ToString(), "bgClr"))
										{
											list2.Add(lineFormat.LineSchemeColorTransforms[j]);
										}
									}
									shape.LineFormat.ForeColor = shape.StyleColorTransform(list, color, ref opacity);
									opacity = uint.MaxValue;
									shape.LineFormat.Color = shape.StyleColorTransform(list2, color, ref opacity);
									opacity = uint.MaxValue;
								}
								else
								{
									shape.LineFormat.Color = (lineFormat.Color.IsEmpty ? color : lineFormat.Color);
									shape.LineFormat.ForeColor = (lineFormat.ForeColor.IsEmpty ? color : lineFormat.ForeColor);
								}
							}
							else
							{
								shape.LineFormat = lineFormat;
							}
						}
					}
					flag = false;
					break;
				}
				case "fillRef":
				{
					int num3 = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color3 = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num3;
					shapeStyleReference.StyleRefColor = color3;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (!shape.IsFillStyleInline && shape.FillFormat.Fill && m_doc.Themes.FmtScheme.FillFormats.Count > 0 && num3 != 0)
					{
						if (num3 > m_doc.Themes.FmtScheme.FillFormats.Count)
						{
							num3 = m_doc.Themes.FmtScheme.FillFormats.Count;
						}
						FillFormat fillFormat = m_doc.Themes.FmtScheme.FillFormats[num3 - 1];
						if (fillFormat.FillType == FillType.None)
						{
							shape.FillFormat.Fill = fillFormat.Fill;
						}
						if (fillFormat.FillType == FillType.FillSolid && fillFormat.Color == Color.Empty)
						{
							if (fillFormat.FillSchemeColorTransforms.Count > 0)
							{
								shape.FillFormat.Color = shape.StyleColorTransform(fillFormat.FillSchemeColorTransforms, color3, ref opacity);
								shape.FillFormat = fillFormat;
								opacity = uint.MaxValue;
							}
							shape.FillFormat.Color = (fillFormat.Color.IsEmpty ? color3 : fillFormat.Color);
						}
						else if (fillFormat.FillType == FillType.FillGradient)
						{
							for (int k = 0; k < fillFormat.GradientFill.GradientStops.Count; k++)
							{
								if (fillFormat.GradientFill.GradientStops[k].FillSchemeColorTransforms.Count > 0)
								{
									fillFormat.GradientFill.GradientStops[k].Color = shape.StyleColorTransform(fillFormat.GradientFill.GradientStops[k].FillSchemeColorTransforms, color3, ref opacity);
									opacity = uint.MaxValue;
								}
								else if (fillFormat.GradientFill.GradientStops[k].Color.IsEmpty)
								{
									fillFormat.GradientFill.GradientStops[k].Color = color3;
								}
							}
							shape.FillFormat.GradientFill = fillFormat.GradientFill;
						}
						else if (fillFormat.FillType == FillType.FillPatterned)
						{
							shape.FillFormat = fillFormat;
							List<DictionaryEntry> list3 = new List<DictionaryEntry>();
							List<DictionaryEntry> list4 = new List<DictionaryEntry>();
							if (fillFormat.FillSchemeColorTransforms.Count > 0)
							{
								for (int l = 0; l < fillFormat.FillSchemeColorTransforms.Count; l++)
								{
									if (StartsWithExt(fillFormat.FillSchemeColorTransforms[l].Key.ToString(), "fgClr"))
									{
										list3.Add(fillFormat.FillSchemeColorTransforms[l]);
									}
									if (StartsWithExt(fillFormat.FillSchemeColorTransforms[l].Key.ToString(), "bgClr"))
									{
										list4.Add(fillFormat.FillSchemeColorTransforms[l]);
									}
								}
								shape.FillFormat.ForeColor = shape.StyleColorTransform(list3, color3, ref opacity);
								opacity = uint.MaxValue;
								shape.FillFormat.Color = shape.StyleColorTransform(list4, color3, ref opacity);
								opacity = uint.MaxValue;
							}
							else
							{
								shape.FillFormat.Color = (fillFormat.Color.IsEmpty ? color3 : fillFormat.Color);
								shape.FillFormat.ForeColor = (fillFormat.ForeColor.IsEmpty ? color3 : fillFormat.ForeColor);
							}
						}
						else if (fillFormat.FillType == FillType.FillPicture || fillFormat.FillType == FillType.FillTextured || fillFormat.FillType == FillType.FillMixed)
						{
							shape.FillFormat = fillFormat;
						}
					}
					flag = false;
					break;
				}
				case "effectRef":
				{
					int num2 = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color2 = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num2;
					shapeStyleReference.StyleRefColor = color2;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (!shape.IsEffectStyleInline && num2 != 0)
					{
						if (num2 > m_doc.Themes.FmtScheme.EffectStyles.Count)
						{
							num2 = m_doc.Themes.FmtScheme.EffectStyles.Count;
						}
						shape.EffectList.Add(m_doc.Themes.FmtScheme.EffectStyles[num2 - 1]);
						foreach (EffectFormat effect in shape.EffectList)
						{
							if (effect.IsShadowEffect && effect.ShadowFormat.Color.IsEmpty)
							{
								effect.ShadowFormat.Color = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ShadowFormat.Transparency = opacity;
								}
							}
							if (!effect.IsShapeProperties)
							{
								continue;
							}
							if (effect.ThreeDFormat.HasContourColor && effect.ThreeDFormat.ContourColor.IsEmpty)
							{
								effect.ThreeDFormat.ContourColor = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ThreeDFormat.ContourOpacity = opacity;
								}
							}
							if (effect.ThreeDFormat.HasExtrusionColor && effect.ThreeDFormat.ExtrusionColor.IsEmpty)
							{
								effect.ThreeDFormat.ExtrusionColor = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ThreeDFormat.ExtrusionOpacity = opacity;
								}
							}
						}
					}
					flag = false;
					break;
				}
				case "fontRef":
				{
					string attribute = xmlReader.GetAttribute("idx");
					shape.FontRefColor = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = ((attribute == "minor") ? 1 : 2);
					shapeStyleReference.StyleRefColor = shape.FontRefColor;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					flag = false;
					break;
				}
				}
				if (!flag)
				{
					xmlReader.Read();
				}
			}
			else
			{
				xmlReader.Read();
			}
			SkipWhitespaces(xmlReader);
		}
	}

	private void ParseStyleItems(MemoryStream stream, ChildShape shape)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "style")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		ShapeStyleReference shapeStyleReference = new ShapeStyleReference();
		SkipWhitespaces(xmlReader);
		while (!(xmlReader.LocalName == "style") || xmlReader.NodeType != XmlNodeType.EndElement)
		{
			_ = string.Empty;
			_ = Color.Empty;
			uint opacity = uint.MaxValue;
			shapeStyleReference = new ShapeStyleReference();
			flag = true;
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "lnRef":
				{
					int num = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num;
					shapeStyleReference.StyleRefColor = color;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (num > m_doc.Themes.FmtScheme.LnStyleScheme.Count)
					{
						num = m_doc.Themes.FmtScheme.LnStyleScheme.Count;
					}
					if (num != 0)
					{
						LineFormat lineFormat = m_doc.Themes.FmtScheme.LnStyleScheme[num - 1];
						if (!shape.LineFormat.HasKey(14) && lineFormat.HasKey(14))
						{
							shape.LineFormat.Line = lineFormat.Line;
						}
						if (!shape.LineFormat.HasKey(11) && lineFormat.HasKey(11))
						{
							shape.LineFormat.Weight = lineFormat.Weight;
						}
						if (!shape.LineFormat.HasKey(0) && lineFormat.HasKey(0))
						{
							shape.LineFormat.LineJoin = lineFormat.LineJoin;
						}
						if (!shape.LineFormat.HasKey(1) && lineFormat.HasKey(1))
						{
							shape.LineFormat.LineCap = lineFormat.LineCap;
						}
						if (!shape.LineFormat.HasKey(2) && lineFormat.HasKey(2))
						{
							shape.LineFormat.BeginArrowheadLength = lineFormat.BeginArrowheadLength;
						}
						if (!shape.LineFormat.HasKey(3) && lineFormat.HasKey(3))
						{
							shape.LineFormat.BeginArrowheadStyle = lineFormat.BeginArrowheadStyle;
						}
						if (!shape.LineFormat.HasKey(4) && lineFormat.HasKey(4))
						{
							shape.LineFormat.BeginArrowheadWidth = lineFormat.BeginArrowheadWidth;
						}
						if (!shape.LineFormat.HasKey(5) && lineFormat.HasKey(5))
						{
							shape.LineFormat.DashStyle = lineFormat.DashStyle;
						}
						if (!shape.LineFormat.HasKey(6) && lineFormat.HasKey(6))
						{
							shape.LineFormat.EndArrowheadLength = lineFormat.EndArrowheadLength;
						}
						if (!shape.LineFormat.HasKey(7) && lineFormat.HasKey(7))
						{
							shape.LineFormat.EndArrowheadStyle = lineFormat.EndArrowheadStyle;
						}
						if (!shape.LineFormat.HasKey(8) && lineFormat.HasKey(8))
						{
							shape.LineFormat.EndArrowheadWidth = lineFormat.EndArrowheadWidth;
						}
						if (!shape.LineFormat.HasKey(9) && lineFormat.HasKey(9))
						{
							shape.LineFormat.InsetPen = lineFormat.InsetPen;
						}
						if (!shape.LineFormat.HasKey(10) && lineFormat.HasKey(10))
						{
							shape.LineFormat.Style = lineFormat.Style;
						}
						if (shape.LineFormat.LineFormatType == (LineFormatType)0 && lineFormat.LineFormatType == (LineFormatType)0)
						{
							shape.LineFormat.Line = false;
						}
						if (!shape.LineFormat.HasKey(12) && lineFormat.HasKey(12) && shape.LineFormat.Line)
						{
							if (lineFormat.LineFormatType == LineFormatType.Solid)
							{
								if (lineFormat.LineSchemeColorTransforms.Count > 0)
								{
									shape.LineFormat.Color = shape.StyleColorTransform(lineFormat.LineSchemeColorTransforms, color, ref opacity);
									opacity = uint.MaxValue;
								}
								else
								{
									shape.LineFormat.Color = (lineFormat.Color.IsEmpty ? color : lineFormat.Color);
								}
							}
							else if (lineFormat.LineFormatType == LineFormatType.Gradient)
							{
								for (int i = 0; i < lineFormat.GradientFill.GradientStops.Count; i++)
								{
									if (lineFormat.GradientFill.GradientStops[i].FillSchemeColorTransforms.Count > 0)
									{
										if (lineFormat.GradientFill.GradientStops[i].Color.IsEmpty)
										{
											lineFormat.GradientFill.GradientStops[i].Color = shape.StyleColorTransform(lineFormat.GradientFill.GradientStops[i].FillSchemeColorTransforms, color, ref opacity);
											opacity = uint.MaxValue;
										}
									}
									else
									{
										lineFormat.GradientFill.GradientStops[i].Color = color;
									}
								}
								shape.LineFormat.GradientFill = lineFormat.GradientFill;
							}
							else if (lineFormat.LineFormatType == LineFormatType.Patterned)
							{
								if (lineFormat.LineSchemeColorTransforms.Count > 0)
								{
									List<DictionaryEntry> list = new List<DictionaryEntry>();
									List<DictionaryEntry> list2 = new List<DictionaryEntry>();
									for (int j = 0; j < lineFormat.LineSchemeColorTransforms.Count; j++)
									{
										if (lineFormat.LineSchemeColorTransforms[j].Key.ToString().StartsWith("fgClr"))
										{
											list.Add(lineFormat.LineSchemeColorTransforms[j]);
										}
										if (lineFormat.LineSchemeColorTransforms[j].Key.ToString().StartsWith("bgClr"))
										{
											list2.Add(lineFormat.LineSchemeColorTransforms[j]);
										}
									}
									shape.LineFormat.ForeColor = shape.StyleColorTransform(list, color, ref opacity);
									opacity = uint.MaxValue;
									shape.LineFormat.Color = shape.StyleColorTransform(list2, color, ref opacity);
									opacity = uint.MaxValue;
								}
								else
								{
									shape.LineFormat.Color = (lineFormat.Color.IsEmpty ? color : lineFormat.Color);
									shape.LineFormat.ForeColor = (lineFormat.ForeColor.IsEmpty ? color : lineFormat.ForeColor);
								}
							}
							else
							{
								shape.LineFormat = lineFormat;
							}
						}
					}
					else if (shape.LineFormat.LineFormatType == (LineFormatType)0)
					{
						shape.LineFormat.Line = false;
					}
					flag = false;
					break;
				}
				case "fillRef":
				{
					int num3 = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color3 = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num3;
					shapeStyleReference.StyleRefColor = color3;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (!shape.IsFillStyleInline && shape.FillFormat.Fill && num3 != 0)
					{
						if (num3 > m_doc.Themes.FmtScheme.FillFormats.Count)
						{
							num3 = m_doc.Themes.FmtScheme.FillFormats.Count;
						}
						FillFormat fillFormat = m_doc.Themes.FmtScheme.FillFormats[num3 - 1];
						if (fillFormat.FillType == FillType.FillSolid && fillFormat.Color == Color.Empty)
						{
							if (fillFormat.FillSchemeColorTransforms.Count > 0)
							{
								shape.FillFormat.Color = shape.StyleColorTransform(fillFormat.FillSchemeColorTransforms, color3, ref opacity);
								shape.FillFormat = fillFormat;
								opacity = uint.MaxValue;
							}
							shape.FillFormat.Color = (fillFormat.Color.IsEmpty ? color3 : fillFormat.Color);
						}
						else if (fillFormat.FillType == FillType.FillGradient)
						{
							for (int k = 0; k < fillFormat.GradientFill.GradientStops.Count; k++)
							{
								if (fillFormat.GradientFill.GradientStops[k].FillSchemeColorTransforms.Count > 0)
								{
									fillFormat.GradientFill.GradientStops[k].Color = shape.StyleColorTransform(fillFormat.GradientFill.GradientStops[k].FillSchemeColorTransforms, color3, ref opacity);
									opacity = uint.MaxValue;
								}
								else if (fillFormat.GradientFill.GradientStops[k].Color.IsEmpty)
								{
									fillFormat.GradientFill.GradientStops[k].Color = color3;
								}
							}
							shape.FillFormat.GradientFill = fillFormat.GradientFill;
						}
						else if (fillFormat.FillType == FillType.FillPatterned)
						{
							shape.FillFormat = fillFormat;
							List<DictionaryEntry> list3 = new List<DictionaryEntry>();
							List<DictionaryEntry> list4 = new List<DictionaryEntry>();
							if (fillFormat.FillSchemeColorTransforms.Count > 0)
							{
								for (int l = 0; l < fillFormat.FillSchemeColorTransforms.Count; l++)
								{
									if (fillFormat.FillSchemeColorTransforms[l].Key.ToString().StartsWith("fgClr"))
									{
										list3.Add(fillFormat.FillSchemeColorTransforms[l]);
									}
									if (fillFormat.FillSchemeColorTransforms[l].Key.ToString().StartsWith("bgClr"))
									{
										list4.Add(fillFormat.FillSchemeColorTransforms[l]);
									}
								}
								shape.FillFormat.ForeColor = shape.StyleColorTransform(list3, color3, ref opacity);
								opacity = uint.MaxValue;
								shape.FillFormat.Color = shape.StyleColorTransform(list4, color3, ref opacity);
								opacity = uint.MaxValue;
							}
							else
							{
								shape.FillFormat.Color = (fillFormat.Color.IsEmpty ? color3 : fillFormat.Color);
								shape.FillFormat.ForeColor = (fillFormat.ForeColor.IsEmpty ? color3 : fillFormat.ForeColor);
							}
						}
						else if (fillFormat.FillType == FillType.FillPicture || fillFormat.FillType == FillType.FillTextured || fillFormat.FillType == FillType.FillMixed)
						{
							shape.FillFormat = fillFormat;
						}
					}
					flag = false;
					break;
				}
				case "effectRef":
				{
					int num2 = Convert.ToInt32(xmlReader.GetAttribute("idx"));
					Color color2 = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = num2;
					shapeStyleReference.StyleRefColor = color2;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					if (!shape.IsEffectStyleInline && num2 != 0)
					{
						if (num2 > m_doc.Themes.FmtScheme.EffectStyles.Count)
						{
							num2 = m_doc.Themes.FmtScheme.EffectStyles.Count;
						}
						shape.EffectList.Add(m_doc.Themes.FmtScheme.EffectStyles[num2 - 1]);
						foreach (EffectFormat effect in shape.EffectList)
						{
							if (effect.IsShadowEffect && effect.ShadowFormat.Color.IsEmpty)
							{
								effect.ShadowFormat.Color = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ShadowFormat.Transparency = opacity;
								}
							}
							if (!effect.IsShapeProperties)
							{
								continue;
							}
							if (effect.ThreeDFormat.HasContourColor && effect.ThreeDFormat.ContourColor.IsEmpty)
							{
								effect.ThreeDFormat.ContourColor = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ThreeDFormat.ContourOpacity = opacity;
								}
							}
							if (effect.ThreeDFormat.HasExtrusionColor && effect.ThreeDFormat.ExtrusionColor.IsEmpty)
							{
								effect.ThreeDFormat.ExtrusionColor = color2;
								if (opacity != uint.MaxValue)
								{
									effect.ThreeDFormat.ExtrusionOpacity = opacity;
								}
							}
						}
					}
					flag = false;
					break;
				}
				case "fontRef":
				{
					string attribute = xmlReader.GetAttribute("idx");
					shape.FontRefColor = ParseColor(xmlReader, xmlReader.LocalName, ref opacity, xmlReader.LocalName, isAlreadyChecked: false);
					shapeStyleReference.StyleRefIndex = ((attribute == "minor") ? 1 : 2);
					shapeStyleReference.StyleRefColor = shape.FontRefColor;
					if (opacity != uint.MaxValue)
					{
						shapeStyleReference.StyleRefOpacity = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					shape.ShapeStyleReferences.Add(shapeStyleReference);
					flag = false;
					break;
				}
				}
				if (!flag)
				{
					xmlReader.Read();
				}
			}
			else
			{
				xmlReader.Read();
			}
			SkipWhitespaces(xmlReader);
		}
	}

	private void ParseShapeAdjustValues(XmlReader reader, Shape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "avLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "avLst")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "gd")
				{
					string attribute = reader.GetAttribute("name");
					string attribute2 = reader.GetAttribute("fmla");
					if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
					{
						shape.ShapeGuide.Add(attribute, attribute2);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseShapeAdjustValues(XmlReader reader, ChildShape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "avLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "avLst")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "gd")
				{
					string attribute = reader.GetAttribute("name");
					string attribute2 = reader.GetAttribute("fmla");
					if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
					{
						shape.ShapeGuide.Add(attribute, attribute2);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseBlipFill(XmlReader reader, FillFormat fillFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("rotWithShape");
		if (!string.IsNullOrEmpty(attribute))
		{
			fillFormat.RotateWithObject = GetBoolValue(attribute);
		}
		else
		{
			fillFormat.RotateWithObject = true;
		}
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string empty = string.Empty;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == localName2))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "blip":
				{
					string attribute2 = reader.GetAttribute("cstate");
					if (!string.IsNullOrEmpty(attribute2) && attribute2.Length > 2)
					{
						fillFormat.BlipCompressionMode = (Enum.IsDefined(typeof(BlipCompressionType), char.ToUpper(attribute2[0]) + attribute2.Substring(1)) ? ((BlipCompressionType)Enum.Parse(typeof(BlipCompressionType), attribute2, ignoreCase: true)) : BlipCompressionType.None);
					}
					string attribute3 = reader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					reader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					if (!string.IsNullOrEmpty(attribute3))
					{
						bool isImageRelation = true;
						string imageName = GetImageName(attribute3, isHeaderFooter, isPicBullet: false, ref isImageRelation);
						if (isImageRelation)
						{
							if (ImageIds.ContainsKey(imageName))
							{
								fillFormat.ImageRecord = new ImageRecord(m_doc, m_doc.Images[ImageIds[imageName]]);
								fillFormat.ImageRecord.OccurenceCount++;
							}
							else
							{
								byte[] imageBytes = GetImageBytes(imageName);
								if (imageBytes != null && imageBytes.Length != 0)
								{
									fillFormat.ImageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
									ImageIds.Add(imageName, fillFormat.ImageRecord.ImageId);
								}
							}
						}
					}
					ParseBlipImage(reader, fillFormat.BlipFormat, null);
					break;
				}
				case "srcRect":
					empty = reader.GetAttribute("b");
					if (!string.IsNullOrEmpty(empty))
					{
						fillFormat.SourceRectangle.BottomOffset = GetPropertyValue(empty, "srcRect");
					}
					empty = reader.GetAttribute("l");
					if (!string.IsNullOrEmpty(empty))
					{
						fillFormat.SourceRectangle.LeftOffset = GetPropertyValue(empty, "srcRect");
					}
					empty = reader.GetAttribute("r");
					if (!string.IsNullOrEmpty(empty))
					{
						fillFormat.SourceRectangle.RightOffset = GetPropertyValue(empty, "srcRect");
					}
					empty = reader.GetAttribute("t");
					if (!string.IsNullOrEmpty(empty))
					{
						fillFormat.SourceRectangle.TopOffset = GetPropertyValue(empty, "srcRect");
					}
					break;
				case "stretch":
					fillFormat.FillRectangle.HasAttributes = ParseFillRectangle(reader, fillFormat);
					break;
				case "tile":
				{
					fillFormat.TextureTile = true;
					fillFormat.TextureAlignment = GetTextureAlignment(reader.GetAttribute("algn"));
					double result = 0.0;
					double result2 = 0.0;
					double result3 = 0.0;
					double result4 = 0.0;
					empty = reader.GetAttribute("tx");
					if (!string.IsNullOrEmpty(empty) && double.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
					{
						fillFormat.TextureOffsetX = result / 12700.0;
					}
					empty = reader.GetAttribute("ty");
					if (!string.IsNullOrEmpty(empty) && double.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
					{
						fillFormat.TextureOffsetY = result2 / 12700.0;
					}
					empty = reader.GetAttribute("sx");
					if (!string.IsNullOrEmpty(empty) && double.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result3))
					{
						fillFormat.TextureHorizontalScale = result3 / 1000.0;
					}
					empty = reader.GetAttribute("sy");
					if (!string.IsNullOrEmpty(empty) && double.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result4))
					{
						fillFormat.TextureVerticalScale = result4 / 1000.0;
					}
					fillFormat.FlipOrientation = GetFlipOrientation(reader.GetAttribute("flip"));
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseBlipImage(XmlReader reader, BlipFormat blipFormat, WPicture picture)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string empty = string.Empty;
		bool flag = false;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == localName2))
		{
			uint opacity = uint.MaxValue;
			if (reader.NodeType == XmlNodeType.Element)
			{
				flag = false;
				switch (reader.LocalName.ToLower())
				{
				case "alphabilevel":
					empty = reader.GetAttribute("thresh");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Threshold = GetBlipImageValue(empty);
					}
					break;
				case "alphaceiling":
					blipFormat.BlipTransparency = BlipTransparency.AlphaCeiling;
					break;
				case "alphafloor":
					blipFormat.BlipTransparency = BlipTransparency.AlphaFloor;
					break;
				case "grayscl":
					blipFormat.BlipTransparency = BlipTransparency.GrayScale;
					break;
				case "filloverlay":
					blipFormat.BlipTransparency = BlipTransparency.FillOverlay;
					break;
				case "alphamod":
					blipFormat.BlipTransparency = BlipTransparency.AlphaMod;
					break;
				case "alphainv":
					blipFormat.InverseColor = ParseColor(reader, "alphaInv", ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (opacity != uint.MaxValue)
					{
						float num2 = (float)Math.Round(1f - (float)opacity / 65536f, 2);
						blipFormat.InverseOpacity = 1f - num2;
					}
					break;
				case "alpharepl":
					empty = reader.GetAttribute("a");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.AlphaReplaceAmount = GetBlipImageValue(empty);
					}
					break;
				case "bilevel":
					empty = reader.GetAttribute("thresh");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.BilevelThreshold = GetBlipImageValue(empty);
					}
					break;
				case "blur":
					empty = reader.GetAttribute("grow");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Grow = GetBoolValue(empty);
					}
					empty = reader.GetAttribute("rad");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.BlurRadius = GetBlipImageValue(empty);
					}
					break;
				case "clrchange":
					empty = reader.GetAttribute("useA");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.HasAlpha = GetBoolValue(empty);
					}
					ParseColorChange(reader, blipFormat);
					break;
				case "hsl":
					empty = reader.GetAttribute("hue");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Hue = GetBlipImageValue(empty);
					}
					empty = reader.GetAttribute("lum");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Luminance = GetBlipImageValue(empty);
					}
					empty = reader.GetAttribute("sat");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Saturation = GetBlipImageValue(empty);
					}
					break;
				case "lum":
					empty = reader.GetAttribute("bright");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Brightness = GetBlipImageValue(empty);
					}
					empty = reader.GetAttribute("contrast");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.Contrast = GetBlipImageValue(empty);
					}
					break;
				case "tint":
					empty = reader.GetAttribute("amt");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.TintAmount = GetBlipImageValue(empty);
					}
					empty = reader.GetAttribute("hue");
					if (!string.IsNullOrEmpty(empty))
					{
						blipFormat.TintHue = GetBlipImageValue(empty);
					}
					break;
				case "duotone":
					opacity = uint.MaxValue;
					blipFormat.DuotoneColor = ParseDuotoneColor(reader, reader.LocalName, ref opacity, blipFormat);
					if (opacity != uint.MaxValue)
					{
						float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
						blipFormat.DuotoneOpacity = 1f - num;
					}
					break;
				case "extlst":
					ParseBlipExtensionList(reader, blipFormat, picture);
					break;
				case "alphamodfix":
					empty = reader.GetAttribute("amt");
					if (!string.IsNullOrEmpty(empty))
					{
						if (empty.EndsWith("%"))
						{
							float result = 0f;
							float.TryParse(empty.Replace("%", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							blipFormat.Transparency = result / 100f;
						}
						else
						{
							blipFormat.Transparency = GetBlipImageValue(empty);
						}
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private float GetBlipImageValue(string attrValue)
	{
		float result = 0f;
		float.TryParse(attrValue, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		return (float)Math.Round(100f - result / 1000f);
	}

	private Color ParseDuotoneColor(XmlReader reader, string parentElement, ref uint opacity, BlipFormat blipFormat)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != parentElement)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		Color themeColor = Color.Empty;
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				SkipWhitespaces(reader);
				while (reader.LocalName != parentElement)
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "srgbClr":
						{
							string attribute4 = reader.GetAttribute("val");
							themeColor = GetHexColor(attribute4);
							ParseColorTransform(reader, "srgbClr", ref themeColor, ref opacity);
							blipFormat.IsPresetColorAtFirst = true;
							break;
						}
						case "scrgbClr":
						{
							string attribute3 = reader.GetAttribute("r");
							double percentage = GetPercentage(attribute3);
							percentage = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage / 100.0));
							attribute3 = reader.GetAttribute("g");
							double percentage2 = GetPercentage(attribute3);
							percentage2 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage2 / 100.0));
							attribute3 = reader.GetAttribute("b");
							double percentage3 = GetPercentage(attribute3);
							percentage3 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage3 / 100.0));
							themeColor = Color.FromArgb(255, (byte)percentage, (byte)percentage2, (byte)percentage3);
							ParseColorTransform(reader, "scrgbClr", ref themeColor, ref opacity);
							blipFormat.IsPresetColorAtFirst = true;
							break;
						}
						case "prstClr":
						{
							Color themeColor2 = Color.Empty;
							string attribute2 = reader.GetAttribute("val");
							if (attribute2 != null)
							{
								themeColor2 = Color.FromName(attribute2);
							}
							ParseColorTransform(reader, "prstClr", ref themeColor2, ref opacity);
							if (themeColor2 != Color.Empty)
							{
								blipFormat.DuotonePresetColor = themeColor2;
								blipFormat.IsPresetColorAtFirst = false;
							}
							break;
						}
						case "hslClr":
						{
							double result = 0.0;
							double num = 0.0;
							double num2 = 0.0;
							string attribute = reader.GetAttribute("hue");
							double.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							result /= 60000.0;
							result /= 360.0;
							attribute = reader.GetAttribute("lum");
							num = GetPercentage(attribute) / 100.0;
							attribute = reader.GetAttribute("sat");
							num2 = GetPercentage(attribute) / 100.0;
							themeColor = WordColor.ConvertHSLToColor(result, num2, num);
							ParseColorTransform(reader, "hslClr", ref themeColor, ref opacity);
							blipFormat.IsPresetColorAtFirst = true;
							break;
						}
						case "sysClr":
							themeColor = GetSystemColor(reader);
							ParseColorTransform(reader, "sysClr", ref themeColor, ref opacity);
							blipFormat.IsPresetColorAtFirst = true;
							break;
						case "schemeClr":
							themeColor = GetSchemeColor(reader);
							ParseColorTransform(reader, "schemeClr", ref themeColor, ref opacity);
							blipFormat.IsPresetColorAtFirst = true;
							break;
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return themeColor;
			}
			return themeColor;
		}
		return themeColor;
	}

	private void ParseBlipExtensionList(XmlReader reader, BlipFormat blipFormat, WPicture picture)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "extLst")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "ext")
				{
					string attribute = reader.GetAttribute("uri");
					if (!string.IsNullOrEmpty(attribute))
					{
						blipFormat.ExtensionURI.Add(attribute.ToString());
					}
					ParseImageProperties(reader, blipFormat, picture);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseImageProperties(XmlReader reader, BlipFormat blipFormat, WPicture picture)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		bool flag = false;
		while (reader.LocalName != "ext")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "imgProps":
					blipFormat.ExtensionURI.Add(reader.LocalName);
					ParseImageLayer(reader, blipFormat);
					break;
				case "useLocalDpi":
				{
					blipFormat.ExtensionURI.Add(reader.LocalName);
					string attribute = reader.GetAttribute("val");
					blipFormat.HasCompression = GetBoolValue(attribute);
					break;
				}
				case "svgBlip":
					blipFormat.ExtensionURI.Add(reader.LocalName);
					ReadSvgData(reader, picture);
					break;
				default:
				{
					byte[] array = ReadSingleNodeIntoStream(reader).ToArray();
					string @string = Encoding.UTF8.GetString(array, 0, array.Length);
					blipFormat.ExtensionURI.Add(@string);
					flag = true;
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ReadSvgData(XmlReader reader, WPicture picture)
	{
		if (picture == null)
		{
			return;
		}
		string attribute = reader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		reader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
		bool isImageRelation = true;
		if (string.IsNullOrEmpty(attribute))
		{
			return;
		}
		string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (isImageRelation)
		{
			if (SvgDataDict.ContainsKey(imageName))
			{
				picture.SvgData = SvgDataDict[imageName];
				return;
			}
			picture.SvgData = GetImageBytes(imageName);
			SvgDataDict.Add(imageName, picture.SvgData);
		}
	}

	private void ParseImageLayer(XmlReader reader, BlipFormat blipFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "imgProps")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "imgLayer")
				{
					string attribute = reader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					if (!string.IsNullOrEmpty(attribute))
					{
						bool isImageRelation = true;
						string imageName = GetImageName(attribute, isHeaderFooter, isPicBullet: false, ref isImageRelation);
						if (isImageRelation)
						{
							if (ImageIds.ContainsKey(imageName))
							{
								blipFormat.ImageRecord = new ImageRecord(m_doc, m_doc.Images[ImageIds[imageName]]);
								blipFormat.ImageRecord.OccurenceCount++;
							}
							else
							{
								byte[] imageBytes = GetImageBytes(imageName);
								if (imageBytes != null && imageBytes.Length != 0)
								{
									blipFormat.ImageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
									ImageIds.Add(imageName, blipFormat.ImageRecord.ImageId);
								}
							}
						}
					}
					ParseImageEffect(reader, blipFormat);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseImageEffect(XmlReader reader, BlipFormat blipFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "imgLayer")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "imgEffect")
				{
					ParseImageEffectItem(reader, blipFormat.ImageEffect);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseImageEffectItem(XmlReader reader, ImageEffect imageEffect)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		string text = null;
		while (reader.LocalName != "imgEffect")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sharpenSoften":
					text = reader.GetAttribute("amount");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.SharpenAmount = GetImageEffectValue(text);
					}
					break;
				case "colorTemperature":
					text = reader.GetAttribute("colorTemp");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.ColorTemprature = GetImageEffectValue(text);
					}
					break;
				case "saturation":
					text = reader.GetAttribute("sat");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.Saturation = GetImageEffectValue(text);
					}
					break;
				case "brightnessContrast":
					text = reader.GetAttribute("bright");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.Brightness = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("contrast");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.Contrast = GetImageEffectValue(text);
					}
					break;
				case "artisticBlur":
					text = reader.GetAttribute("radius");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BlurRadius = GetImageEffectValue(text);
					}
					break;
				case "artisticCement":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CementTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("crackSpacing");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CementCracking = GetImageEffectValue(text);
					}
					break;
				case "artisticChalkSketch":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.ChalkSketchTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pressure");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.ChalkSketchPressure = GetImageEffectValue(text);
					}
					break;
				case "artisticCrisscrossEtching":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CrisscrossEtchingTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pressure");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CrisscrossEtchingPressure = GetImageEffectValue(text);
					}
					break;
				case "artisticCutout":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CutoutTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("numberOfShades");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.CutoutShades = GetImageEffectValue(text);
					}
					break;
				case "artisticFilmGrain":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GrainTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("grainSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GrainSize = GetImageEffectValue(text);
					}
					break;
				case "artisticGlass":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlassTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("scaling");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlassScaling = GetImageEffectValue(text);
					}
					break;
				case "artisticGlowDiffused":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlowDiffusedTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("intensity");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlowDiffusedIntensity = GetImageEffectValue(text);
					}
					break;
				case "artisticGlowEdges":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlowEdgesTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("smoothness");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.GlowEdgesSmoothness = GetImageEffectValue(text);
					}
					break;
				case "artisticLightScreen":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.LightScreenTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("gridSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.LightScreenGrid = GetImageEffectValue(text);
					}
					break;
				case "artisticLineDrawing":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.LineDrawingTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pencilSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.LineDrawingPensilSize = GetImageEffectValue(text);
					}
					break;
				case "artisticMarker":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.MarkerTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("size");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.MarkerSize = GetImageEffectValue(text);
					}
					break;
				case "artisticMosiaicBubbles":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.MosiaicBubbleTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pressure");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.MosiaicBubblePressure = GetImageEffectValue(text);
					}
					break;
				case "artisticPaintStrokes":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.StrokeTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("intensity");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.StrokeIntensity = GetImageEffectValue(text);
					}
					break;
				case "artisticPaintBrush":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BrushTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("brushSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BrushSize = GetImageEffectValue(text);
					}
					break;
				case "artisticPastelsSmooth":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PastelTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("brushSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PastelSize = GetImageEffectValue(text);
					}
					break;
				case "artisticPencilGrayscale":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PencilGrayScaleTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pencilSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PencilGraySize = GetImageEffectValue(text);
					}
					break;
				case "artisticPencilSketch":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PencilSketchTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("pencilSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PencilSketchSize = GetImageEffectValue(text);
					}
					break;
				case "artisticPhotocopy":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PhotocopyTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("detail");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PhotocopySize = GetImageEffectValue(text);
					}
					break;
				case "artisticPlasticWrap":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PlasticWrapTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("smoothness");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.PlasticWrapSmoothness = GetImageEffectValue(text);
					}
					break;
				case "artisticTexturizer":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.TexturizerTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("scaling");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.TexturizerSize = GetImageEffectValue(text);
					}
					break;
				case "artisticWatercolorSponge":
					text = reader.GetAttribute("trans");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.TexturizerTransparency = GetImageEffectValue(text);
					}
					text = reader.GetAttribute("brushSize");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.TexturizerSize = GetImageEffectValue(text);
					}
					break;
				case "backgroundRemoval":
					imageEffect.HasBackgroundRemovalEffect = true;
					text = reader.GetAttribute("t");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BackgroundRemovalRectangle.TopOffset = GetImageEffectValue(text) / 1000f;
					}
					text = reader.GetAttribute("b");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BackgroundRemovalRectangle.BottomOffset = GetImageEffectValue(text) / 1000f;
					}
					text = reader.GetAttribute("l");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BackgroundRemovalRectangle.LeftOffset = GetImageEffectValue(text) / 1000f;
					}
					text = reader.GetAttribute("r");
					if (!string.IsNullOrEmpty(text))
					{
						imageEffect.BackgroundRemovalRectangle.RightOffset = GetImageEffectValue(text) / 1000f;
					}
					ParseBackgroundRemoval(reader, imageEffect);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private float GetImageEffectValue(string value)
	{
		float result = 0f;
		if (value.EndsWith("%"))
		{
			float.TryParse(value.Replace("%", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			result *= 1000f;
		}
		else
		{
			float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		return result;
	}

	private void ParseBackgroundRemoval(XmlReader reader, ImageEffect imageEffect)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		string text = null;
		string text2 = null;
		string text3 = null;
		string text4 = null;
		while (reader.LocalName != "backgroundRemoval")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (localName2 == "foregroundMark" || localName2 == "backgroundMark")
				{
					text = reader.GetAttribute("x1");
					text2 = reader.GetAttribute("y1");
					text3 = reader.GetAttribute("x2");
					text4 = reader.GetAttribute("y2");
					float result = 0f;
					float result2 = 0f;
					float result3 = 0f;
					float result4 = 0f;
					if (!string.IsNullOrEmpty(text))
					{
						float.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					}
					if (!string.IsNullOrEmpty(text2))
					{
						float.TryParse(text2, NumberStyles.Number, CultureInfo.InvariantCulture, out result3);
					}
					if (!string.IsNullOrEmpty(text3))
					{
						float.TryParse(text3, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
					}
					if (!string.IsNullOrEmpty(text4))
					{
						float.TryParse(text4, NumberStyles.Number, CultureInfo.InvariantCulture, out result4);
					}
					if (reader.LocalName == "foregroundMark")
					{
						imageEffect.ForegroundVertices.Add(new PointF(result, result3));
						imageEffect.ForegroundVertices.Add(new PointF(result2, result4));
					}
					else
					{
						imageEffect.BackgroundVertices.Add(new PointF(result, result3));
						imageEffect.BackgroundVertices.Add(new PointF(result2, result4));
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseColorChange(XmlReader reader, BlipFormat blipFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		_ = string.Empty;
		while (!(reader.LocalName == localName))
		{
			uint opacity = uint.MaxValue;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "clrFrom"))
				{
					if (localName2 == "clrTo")
					{
						blipFormat.ColorTo = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
						if (opacity != uint.MaxValue)
						{
							float num = (float)Math.Round(1f - (float)opacity / 65536f, 2);
							blipFormat.ColorToOpacity = 1f - num;
						}
					}
				}
				else
				{
					blipFormat.ColorFrom = ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (opacity != uint.MaxValue)
					{
						float num2 = (float)Math.Round(1f - (float)opacity / 65536f, 2);
						blipFormat.ColorFromOpacity = 1f - num2;
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private bool ParseFillRectangle(XmlReader reader, FillFormat fillFormat)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				string text = localName;
				SkipWhitespaces(reader);
				if (!reader.HasAttributes)
				{
					return false;
				}
				string empty = string.Empty;
				bool result = false;
				while (!(reader.LocalName == text))
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						if (reader.LocalName == "fillRect")
						{
							int result2 = 0;
							empty = reader.GetAttribute("b");
							if (!string.IsNullOrEmpty(empty) && int.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
							{
								fillFormat.FillRectangle.BottomOffset = result2 / 1000;
								result = true;
							}
							empty = reader.GetAttribute("l");
							if (!string.IsNullOrEmpty(empty) && int.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
							{
								fillFormat.FillRectangle.LeftOffset = result2 / 1000;
								result = true;
							}
							empty = reader.GetAttribute("r");
							if (!string.IsNullOrEmpty(empty) && int.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
							{
								fillFormat.FillRectangle.RightOffset = result2 / 1000;
								result = true;
							}
							empty = reader.GetAttribute("t");
							if (!string.IsNullOrEmpty(empty) && int.TryParse(empty, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
							{
								fillFormat.FillRectangle.TopOffset = result2 / 1000;
								result = true;
							}
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
				return result;
			}
			return false;
		}
		return false;
	}

	private TextureAlignment GetTextureAlignment(string textureAlign)
	{
		return textureAlign switch
		{
			"b" => TextureAlignment.Bottom, 
			"bl" => TextureAlignment.BottomLeft, 
			"br" => TextureAlignment.BottomRight, 
			"ctr" => TextureAlignment.Center, 
			"l" => TextureAlignment.Left, 
			"r" => TextureAlignment.Right, 
			"t" => TextureAlignment.Top, 
			"tl" => TextureAlignment.TopLeft, 
			"tr" => TextureAlignment.TopRight, 
			_ => TextureAlignment.AlignmentMixed, 
		};
	}

	private PatternType GetPatternType(string value)
	{
		return value switch
		{
			"cross" => PatternType.Cross, 
			"dashDnDiag" => PatternType.DashedDownwardDiagonal, 
			"dashHorz" => PatternType.DashedHorizontal, 
			"dashUpDiag" => PatternType.DashedUpwardDiagonal, 
			"dashVert" => PatternType.DashedVertical, 
			"diagBrick" => PatternType.DiagonalBrick, 
			"diagCross" => PatternType.DiagonalCross, 
			"divot" => PatternType.Divot, 
			"dkDnDiag" => PatternType.DarkDownwardDiagonal, 
			"dkHorz" => PatternType.DarkHorizontal, 
			"dkUpDiag" => PatternType.DarkUpwardDiagonal, 
			"dkVert" => PatternType.DarkVertical, 
			"dnDiag" => PatternType.DownwardDiagonal, 
			"dotDmnd" => PatternType.DottedDiamond, 
			"dotGrid" => PatternType.DottedGrid, 
			"horz" => PatternType.Horizontal, 
			"horzBrick" => PatternType.HorizontalBrick, 
			"lgCheck" => PatternType.LargeCheckerBoard, 
			"lgConfetti" => PatternType.LargeConfetti, 
			"lgGrid" => PatternType.LargeGrid, 
			"ltDnDiag" => PatternType.LightDownwardDiagonal, 
			"ltHorz" => PatternType.LightHorizontal, 
			"ltUpDiag" => PatternType.LightUpwardDiagonal, 
			"ltVert" => PatternType.LightVertical, 
			"narHorz" => PatternType.NarrowHorizontal, 
			"narVert" => PatternType.NarrowVertical, 
			"openDmnd" => PatternType.OutlinedDiamond, 
			"pct10" => PatternType.Pattern10Percent, 
			"pct20" => PatternType.Pattern20Percent, 
			"pct25" => PatternType.Pattern25Percent, 
			"pct30" => PatternType.Pattern30Percent, 
			"pct40" => PatternType.Pattern40Percent, 
			"pct5" => PatternType.Pattern5Percent, 
			"pct50" => PatternType.Pattern50Percent, 
			"pct60" => PatternType.Pattern60Percent, 
			"pct70" => PatternType.Pattern70Percent, 
			"pct75" => PatternType.Pattern75Percent, 
			"pct80" => PatternType.Pattern80Percent, 
			"pct90" => PatternType.Pattern90Percent, 
			"Plaid" => PatternType.Plaid, 
			"shingle" => PatternType.Shingle, 
			"smCheck" => PatternType.SmallCheckerBoard, 
			"smConfetti" => PatternType.SmallConfetti, 
			"smGrid" => PatternType.SmallGrid, 
			"solidDmnd" => PatternType.SolidDiamond, 
			"sphere" => PatternType.Sphere, 
			"trellis" => PatternType.Trellis, 
			"upDiag" => PatternType.UpwardDiagonal, 
			"vert" => PatternType.Vertical, 
			"wave" => PatternType.Wave, 
			"wdDnDiag" => PatternType.WideDownwardDiagonal, 
			"wdUpDiag" => PatternType.WideUpwardDiagonal, 
			"weave" => PatternType.Weave, 
			"zigZag" => PatternType.ZigZag, 
			_ => PatternType.Pattern5Percent, 
		};
	}

	private TextDirection GetTextDirection(string value, bool isToApplyFarEast)
	{
		switch (value)
		{
		case "vert":
			return TextDirection.VerticalTopToBottom;
		case "vert270":
			return TextDirection.VerticalBottomToTop;
		case "mongolianVert":
			return TextDirection.Vertical;
		case "eaVert":
			return TextDirection.VerticalFarEast;
		default:
			if (isToApplyFarEast)
			{
				return TextDirection.HorizontalFarEast;
			}
			return TextDirection.Horizontal;
		}
	}

	private void ParseLineFormat(XmlReader reader, Shape shape)
	{
		string attribute = reader.GetAttribute("w");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Weight = GetPropertyValue(attribute, "w");
		}
		else
		{
			shape.LineFormat.IsInlineLineWeightNull = true;
		}
		attribute = reader.GetAttribute("cmpd");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Style = GetShapeOutLineStyle(attribute);
		}
		attribute = reader.GetAttribute("algn");
		if (attribute == "in")
		{
			shape.LineFormat.InsetPen = true;
		}
		attribute = reader.GetAttribute("cap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineCap = GetLineCapStyle(attribute);
		}
		ParseLineProps(reader, shape);
	}

	private void ParseLineFormat(XmlReader reader, ChildShape shape)
	{
		string attribute = reader.GetAttribute("w");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Weight = GetPropertyValue(attribute, "w");
		}
		attribute = reader.GetAttribute("cmpd");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.Style = GetShapeOutLineStyle(attribute);
		}
		attribute = reader.GetAttribute("algn");
		if (attribute == "in")
		{
			shape.LineFormat.InsetPen = true;
		}
		attribute = reader.GetAttribute("cap");
		if (!string.IsNullOrEmpty(attribute))
		{
			shape.LineFormat.LineCap = GetLineCapStyle(attribute);
		}
		ParseLineProps(reader, shape);
	}

	private LineStyle GetShapeOutLineStyle(string value)
	{
		switch (value)
		{
		case "dbl":
		case "thinThin":
			return LineStyle.ThinThin;
		case "thinThick":
			return LineStyle.ThinThick;
		case "thickThin":
			return LineStyle.ThickThin;
		case "thickBetweenThin":
		case "tri":
			return LineStyle.ThickBetweenThin;
		default:
			return LineStyle.Single;
		}
	}

	private bool ParseImageHyperlink(XmlReader reader, ParagraphItemCollection paraItems)
	{
		reader.ReadToFollowing("hlinkClick", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
		if (reader.LocalName == "hlinkClick" && !IsHyperLinkField)
		{
			return ParseHyperlink(reader, paraItems);
		}
		return false;
	}

	private XmlParagraphItem ParseXmlParaItem(Stream XmlParaItemStream)
	{
		XmlParagraphItem xmlParagraphItem = new XmlParagraphItem(XmlParaItemStream, m_doc);
		xmlParagraphItem.ApplyCharacterFormat(m_currentRunFormat);
		List<string> list = FindRelationshipIds(XmlParaItemStream);
		FindZIndex(XmlParaItemStream, xmlParagraphItem);
		if (list.Count > 0 && m_docRelations != null)
		{
			ParseShapeRelationId(xmlParagraphItem, list);
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				string text = list[i];
				if (ParseImageRelation(xmlParagraphItem, text))
				{
					continue;
				}
				DictionaryEntry value = default(DictionaryEntry);
				if (m_currentFile != null && m_currentFile != string.Empty)
				{
					Dictionary<string, DictionaryEntry> fileRelations = GetFileRelations(m_currentFile);
					if (fileRelations != null)
					{
						value = fileRelations[text];
					}
				}
				else if (m_docRelations != null && text != null && m_docRelations.ContainsKey(text))
				{
					value = m_docRelations[text];
				}
				if (text != null && !xmlParagraphItem.Relations.ContainsKey(text))
				{
					xmlParagraphItem.Relations.Add(text, value);
				}
				if (text == null || !xmlParagraphItem.Relations.ContainsKey(text))
				{
					continue;
				}
				string fileName = value.Value.ToString();
				string partName = GetPartName(ref fileName);
				Part part = FindPart(partName, fileName);
				if (part != null)
				{
					string currentFile = m_currentFile;
					m_currentFile = value.Value?.ToString() + ".rels";
					List<string> list2 = FindRelationshipIds(part.DataStream);
					for (int j = 0; j < list2.Count; j++)
					{
						string id = list2[j];
						int count2 = xmlParagraphItem.ImageRelations.Count;
						ParseImageRelation(xmlParagraphItem, id);
						xmlParagraphItem.HasNestedImageRelations = count2 != xmlParagraphItem.ImageRelations.Count || xmlParagraphItem.HasNestedImageRelations;
					}
					m_currentFile = currentFile;
				}
			}
		}
		return xmlParagraphItem;
	}

	private bool ParseImageRelation(GroupShape shape, string id)
	{
		ImageRecord imageRecord = null;
		bool isHeaderFooter = m_currentFile.StartsWith("header") || m_currentFile.StartsWith("footer");
		bool isImageRelation = true;
		string imageName = GetImageName(id, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (isImageRelation)
		{
			if (ImageIds.ContainsKey(imageName))
			{
				imageRecord = m_doc.Images[ImageIds[imageName]];
				imageRecord.OccurenceCount++;
			}
			else
			{
				byte[] imageBytes = GetImageBytes(imageName);
				if (imageBytes != null && imageBytes.Length != 0)
				{
					imageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
					ImageIds.Add(imageName, imageRecord.ImageId);
				}
			}
		}
		if (id != null && imageRecord != null && !shape.ImageRelations.ContainsKey(id))
		{
			shape.ImageRelations.Add(id, imageRecord);
		}
		return imageRecord != null;
	}

	private bool ParseImageRelation(ChildShape shape, string id)
	{
		ImageRecord imageRecord = null;
		bool isHeaderFooter = m_currentFile.StartsWith("header") || m_currentFile.StartsWith("footer");
		bool isImageRelation = true;
		string imageName = GetImageName(id, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (ImageIds.ContainsKey(imageName))
		{
			imageRecord = m_doc.Images[ImageIds[imageName]];
			imageRecord.OccurenceCount++;
		}
		else
		{
			byte[] imageBytes = GetImageBytes(imageName);
			if (imageBytes != null && imageBytes.Length != 0)
			{
				imageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
				ImageIds.Add(imageName, imageRecord.ImageId);
			}
		}
		if (id != null && imageRecord != null && !shape.ImageRelations.ContainsKey(id))
		{
			shape.ImageRelations.Add(id, imageRecord);
		}
		return imageRecord != null;
	}

	private bool ParseImageRelation(ParagraphItem paraItem, string id)
	{
		ImageRecord imageRecord = null;
		bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
		bool isImageRelation = true;
		string imageName = GetImageName(id, isHeaderFooter, isPicBullet: false, ref isImageRelation);
		if (isImageRelation)
		{
			if (ImageIds.ContainsKey(imageName))
			{
				imageRecord = m_doc.Images[ImageIds[imageName]];
				imageRecord.OccurenceCount++;
			}
			else
			{
				byte[] imageBytes = GetImageBytes(imageName);
				if (imageBytes != null && imageBytes.Length != 0)
				{
					imageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
					ImageIds.Add(imageName, imageRecord.ImageId);
				}
			}
			if (!string.IsNullOrEmpty(id) && imageRecord != null)
			{
				Shape shape = paraItem as Shape;
				XmlParagraphItem xmlParagraphItem = paraItem as XmlParagraphItem;
				if (shape != null)
				{
					if (!shape.ImageRelations.ContainsKey(id))
					{
						shape.ImageRelations.Add(id, imageRecord);
					}
				}
				else if (xmlParagraphItem != null && !xmlParagraphItem.ImageRelations.ContainsKey(id))
				{
					xmlParagraphItem.ImageRelations.Add(id, imageRecord);
				}
			}
		}
		return imageRecord != null;
	}

	private List<string> FindRelationshipIds(Stream XmlParaItemStream)
	{
		XmlParaItemStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(XmlParaItemStream);
		List<string> list = new List<string>();
		bool flag = false;
		do
		{
			flag = false;
			xmlReader.Read();
			string text = string.Empty;
			string text2 = string.Empty;
			switch (xmlReader.LocalName.ToLower())
			{
			case "fill":
			case "hyperlink":
			case "imagedata":
			case "oleobject":
			case "stroke":
			case "chart":
			case "control":
				text = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				text2 = xmlReader.GetAttribute("href", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				break;
			case "blip":
				text = xmlReader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				break;
			case "relids":
				text = xmlReader.GetAttribute("dm", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
				text = xmlReader.GetAttribute("lo", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
				text = xmlReader.GetAttribute("qs", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
				text = xmlReader.GetAttribute("cs", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
				flag = true;
				break;
			}
			if (!string.IsNullOrEmpty(text) && !flag)
			{
				list.Add(text);
			}
			if (!string.IsNullOrEmpty(text2))
			{
				list.Add(text2);
			}
		}
		while (!xmlReader.EOF);
		return list;
	}

	private void FindZIndex(Stream XmlParaItemStream, XmlParagraphItem xmlParaItem)
	{
		XmlParaItemStream.Position = 0L;
		XmlReader xmlReader = UtilityMethods.CreateReader(XmlParaItemStream);
		do
		{
			xmlReader.Read();
			if (xmlReader.NodeType != XmlNodeType.Element || !xmlReader.HasAttributes)
			{
				continue;
			}
			string attribute = xmlReader.GetAttribute("style");
			string attribute2 = xmlReader.GetAttribute("relativeHeight");
			if (!string.IsNullOrEmpty(attribute) && attribute.Contains("z-index"))
			{
				attribute = attribute.Trim();
				int num = attribute.IndexOf("z-index");
				if (num > -1 && num < attribute.Length)
				{
					attribute = attribute.Substring(num);
				}
				char[] separator = new char[1] { ';' };
				string[] array = attribute.Split(separator, StringSplitOptions.RemoveEmptyEntries);
				string[] propertyValues = GetPropertyValues(array[0]);
				if (propertyValues != null && propertyValues[0].Contains("z-index") && !string.IsNullOrEmpty(propertyValues[1]))
				{
					int result = 0;
					int.TryParse(propertyValues[1], NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					xmlParaItem.ZOrderIndex = result;
					break;
				}
			}
			if (!string.IsNullOrEmpty(attribute2))
			{
				int result2 = 0;
				int.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
				xmlParaItem.ZOrderIndex = result2;
				break;
			}
		}
		while (!xmlReader.EOF);
	}

	private void ParseShapeRelationId(XmlParagraphItem xmlItem, List<string> relationIds)
	{
		int i = 0;
		for (int count = relationIds.Count; i < count; i++)
		{
			string text = relationIds[i];
			if (IsExternalHyperlink.ContainsKey(text))
			{
				xmlItem.m_shapeHyperlink = text;
			}
		}
	}

	private ParagraphItem ParsePicture(XmlReader reader, WPicture picture)
	{
		if (m_currentRunFormat != null)
		{
			picture.CharacterFormat.ImportContainer(m_currentRunFormat);
			ApplyDirectionalOverride(picture.CharacterFormat);
		}
		m_currentRunFormat = null;
		ParsePictureProperties(reader, picture);
		return picture;
	}

	private void ParsePictureProperties(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "drawing")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "drawing")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "effectExtent":
					picture.DocxProps.Add(ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				case "extent":
				{
					string attribute = reader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute))
					{
						if (picture.Width == float.MinValue)
						{
							picture.Width = GetPropertyValue(attribute, "cx");
						}
						else
						{
							picture.SetWidthScaleValue(GetPropertyValue(attribute, "cx") * 100f / picture.Width);
						}
					}
					attribute = reader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute))
					{
						if (picture.Height == float.MinValue)
						{
							picture.Height = GetPropertyValue(attribute, "cy");
						}
						else
						{
							picture.SetHeightScaleValue(GetPropertyValue(attribute, "cy") * 100f / picture.Height);
						}
					}
					break;
				}
				case "positionH":
					ParsePictureHorizontalPosition(reader, picture);
					break;
				case "positionV":
					ParsePictureVerticalPosition(reader, picture);
					break;
				case "docPr":
				{
					picture.Title = reader.GetAttribute("title");
					picture.AlternativeText = reader.GetAttribute("descr");
					picture.Name = reader.GetAttribute("name");
					string attribute = reader.GetAttribute("hidden");
					if (!string.IsNullOrEmpty(attribute))
					{
						picture.Visible = !GetBoolValue(attribute);
					}
					break;
				}
				case "wrapSquare":
					picture.SetTextWrappingStyleValue(TextWrappingStyle.Square);
					ParseWrappingType(reader, picture);
					break;
				case "wrapTight":
					picture.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
					ParseWrappingType(reader, picture);
					ParseWrapPolygon(reader, picture);
					break;
				case "wrapThrough":
					picture.SetTextWrappingStyleValue(TextWrappingStyle.Through);
					ParseWrappingType(reader, picture);
					ParseWrapPolygon(reader, picture);
					break;
				case "wrapTopAndBottom":
					picture.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
					break;
				case "wrapNone":
					if (!flag2)
					{
						if (picture.IsBelowText)
						{
							picture.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
						}
						else
						{
							picture.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
						}
					}
					break;
				case "anchor":
					if (reader.AttributeCount != 0)
					{
						string attribute = reader.GetAttribute("behindDoc");
						picture.IsBelowText = ((attribute == "1" || attribute == "true") ? true : false);
						attribute = reader.GetAttribute("layoutInCell");
						picture.LayoutInCell = ((attribute == "1" || attribute == "true") ? true : false);
						attribute = reader.GetAttribute("relativeHeight");
						int result = 0;
						int.TryParse(attribute, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
						picture.OrderIndex = result;
						attribute = reader.GetAttribute("distT");
						if (!string.IsNullOrEmpty(attribute))
						{
							picture.DistanceFromTop = GetPointValue(attribute);
						}
						attribute = reader.GetAttribute("distB");
						if (!string.IsNullOrEmpty(attribute))
						{
							picture.DistanceFromBottom = GetPointValue(attribute);
						}
						attribute = reader.GetAttribute("distL");
						if (!string.IsNullOrEmpty(attribute))
						{
							picture.DistanceFromLeft = GetPointValue(attribute);
						}
						attribute = reader.GetAttribute("distR");
						if (!string.IsNullOrEmpty(attribute))
						{
							picture.DistanceFromRight = GetPointValue(attribute);
						}
						attribute = reader.GetAttribute("allowOverlap");
						if (!string.IsNullOrEmpty(attribute))
						{
							picture.AllowOverlap = ((attribute == "1" || attribute == "true") ? true : false);
						}
					}
					break;
				case "cNvGraphicFramePr":
					ParseLockAspectRatio(reader, picture);
					break;
				case "graphic":
					reader.Read();
					ParseGraphicData(reader, picture);
					break;
				case "inline":
					flag2 = true;
					break;
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseGraphicData(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "graphicData")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "graphicData")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "pic")
				{
					ParsePictureData(reader, picture);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseLockAspectRatio(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "cNvGraphicFramePr")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "cNvGraphicFramePr")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "graphicFrameLocks")
				{
					string attribute = reader.GetAttribute("noChangeAspect");
					picture.LockAspectRatio = GetBoolValue(attribute);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParsePictureData(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "pic")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "pic")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "spPr"))
				{
					if (localName2 == "blipFill")
					{
						picture.FillFormat.FillType = FillType.FillPicture;
						ParsePictureBlipFill(reader, picture);
					}
					else if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
				}
				else
				{
					ParseVisualShapeProps(reader, picture);
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseGroupShapePictureData(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "pic")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "pic")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "spPr"))
				{
					if (localName2 == "blipFill")
					{
						picture.FillFormat.FillType = FillType.FillPicture;
						ParsePictureBlipFill(reader, picture);
					}
					else if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
				}
				else
				{
					ParseGroupShapeVisualShapeProps(reader, picture);
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParsePictureBlipFill(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "blipFill")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "blipFill")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "blip"))
				{
					if (localName2 == "srcRect")
					{
						string attribute = reader.GetAttribute("b");
						float result = 0f;
						if (!string.IsNullOrEmpty(attribute) && float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							picture.FillRectangle.BottomOffset = result / 1000f;
						}
						attribute = reader.GetAttribute("l");
						if (!string.IsNullOrEmpty(attribute) && float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							picture.FillRectangle.LeftOffset = result / 1000f;
						}
						attribute = reader.GetAttribute("r");
						if (!string.IsNullOrEmpty(attribute) && float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							picture.FillRectangle.RightOffset = result / 1000f;
						}
						attribute = reader.GetAttribute("t");
						if (!string.IsNullOrEmpty(attribute) && float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
						{
							picture.FillRectangle.TopOffset = result / 1000f;
						}
					}
					else if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
				}
				else
				{
					string attribute2 = reader.GetAttribute("cstate");
					if (!string.IsNullOrEmpty(attribute2) && attribute2.Length > 2)
					{
						picture.FillFormat.BlipCompressionMode = (Enum.IsDefined(typeof(BlipCompressionType), char.ToUpper(attribute2[0]) + attribute2.Substring(1)) ? ((BlipCompressionType)Enum.Parse(typeof(BlipCompressionType), attribute2, ignoreCase: true)) : BlipCompressionType.None);
					}
					string attribute3 = reader.GetAttribute("embed", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					reader.GetAttribute("link", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					bool isHeaderFooter = StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer");
					if (!string.IsNullOrEmpty(attribute3))
					{
						bool isImageRelation = true;
						string imageName = GetImageName(attribute3, isHeaderFooter, isPicBullet: false, ref isImageRelation);
						if (isImageRelation)
						{
							if (ImageIds.ContainsKey(imageName))
							{
								picture.FillFormat.ImageRecord = new ImageRecord(m_doc, m_doc.Images[ImageIds[imageName]]);
								picture.FillFormat.ImageRecord.OccurenceCount++;
							}
							else
							{
								byte[] imageBytes = GetImageBytes(imageName);
								if (imageBytes != null && imageBytes.Length != 0)
								{
									picture.FillFormat.ImageRecord = m_doc.Images.LoadXmlItemImage(imageBytes);
									ImageIds.Add(imageName, picture.FillFormat.ImageRecord.ImageId);
								}
							}
						}
					}
					ParseBlipImage(reader, picture.FillFormat.BlipFormat, picture);
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseVisualShapeProps(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "spPr")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "spPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "xfrm":
				{
					string attribute = reader.GetAttribute("rot");
					if (!string.IsNullOrEmpty(attribute))
					{
						picture.Rotation = GetNumericValue(attribute) / 60000f;
					}
					string attribute2 = reader.GetAttribute("flipH");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.FlipHorizontal = ((attribute2 == "1" || attribute2 == "true") ? true : false);
					}
					attribute2 = reader.GetAttribute("flipV");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.FlipVertical = ((attribute2 == "1" || attribute2 == "true") ? true : false);
					}
					break;
				}
				case "ln":
				{
					picture.PictureShape.ShapeContainer = new MsofbtSpContainer(m_doc);
					picture.PictureShape.ShapeContainer.Children.Add(new MsofbtOPT(m_doc));
					picture.PictureShape.ShapeContainer.Children.Add(new MsofbtTertiaryFOPT(m_doc));
					picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511, 46u);
					picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
					picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
					string attribute2 = reader.GetAttribute("algn");
					if (attribute2 == "in")
					{
						picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = true;
					}
					attribute2 = reader.GetAttribute("cap");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(471, (uint)GetLineCapStyle(attribute2));
					}
					attribute2 = reader.GetAttribute("cmpd");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(461, (uint)GetLineStyle(attribute2));
					}
					attribute2 = reader.GetAttribute("w");
					if (!string.IsNullOrEmpty(attribute2))
					{
						uint value = (uint)GetPictureBorderWidth(attribute2, string.Empty);
						picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(459, value);
					}
					ParseLineProps(reader, picture.PictureShape);
					break;
				}
				case "sp3d":
				case "effectLst":
				case "scene3d":
				case "extLst":
					picture.DocxVisualShapeProps.Add(ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				case "blipFill":
					picture.PictureShape.FillFormat.Fill = true;
					picture.PictureShape.FillFormat.IsDefaultFill = false;
					picture.PictureShape.FillFormat.FillType = FillType.FillPicture;
					ParseBlipFill(reader, picture.PictureShape.FillFormat);
					break;
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseGroupShapeVisualShapeProps(XmlReader reader, WPicture picture)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "spPr")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "spPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "xfrm":
				{
					string attribute = reader.GetAttribute("rot");
					if (!string.IsNullOrEmpty(attribute))
					{
						picture.Rotation = GetNumericValue(attribute) / 60000f;
					}
					string attribute2 = reader.GetAttribute("flipH");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.FlipHorizontal = ((attribute2 == "1" || attribute2 == "true") ? true : false);
					}
					attribute2 = reader.GetAttribute("flipV");
					if (!string.IsNullOrEmpty(attribute2))
					{
						picture.FlipVertical = ((attribute2 == "1" || attribute2 == "true") ? true : false);
					}
					break;
				}
				case "off":
				{
					string attribute5 = reader.GetAttribute("x");
					if (!string.IsNullOrEmpty(attribute5))
					{
						picture.HorizontalPosition = GetPropertyValue(attribute5, "offX");
					}
					string attribute6 = reader.GetAttribute("y");
					if (!string.IsNullOrEmpty(attribute6))
					{
						picture.VerticalPosition = GetPropertyValue(attribute6, "offY");
					}
					break;
				}
				case "ext":
				{
					string attribute3 = reader.GetAttribute("cx");
					if (!string.IsNullOrEmpty(attribute3))
					{
						picture.Width = GetPropertyValue(attribute3, "cx");
					}
					string attribute4 = reader.GetAttribute("cy");
					if (!string.IsNullOrEmpty(attribute4))
					{
						picture.Height = GetPropertyValue(attribute4, "cy");
					}
					break;
				}
				case "sp3d":
				case "ln":
				case "effectLst":
				case "scene3d":
				case "extLst":
					picture.DocxVisualShapeProps.Add(ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private float GetPictureBorderWidth(string value, string pictureType)
	{
		float result = 0f;
		if (value.EndsWith("cm"))
		{
			return (float)(float.TryParse(value.Remove(value.IndexOf("cm"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((double)result * 28.35 * 8.0) : 0.75);
		}
		if (value.EndsWith("mm"))
		{
			return (float)(float.TryParse(value.Remove(value.IndexOf("mm"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((double)result * 2.835 * 8.0) : 0.75);
		}
		if (value.EndsWith("pt"))
		{
			return (float)(float.TryParse(value.Remove(value.IndexOf("pt"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((double)(result * 8f)) : 0.75);
		}
		if (value.EndsWith("pi"))
		{
			return (float)(float.TryParse(value.Remove(value.IndexOf("pi"), 2), NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((double)(result * 12f * 8f)) : 0.75);
		}
		if (pictureType == "inline")
		{
			return (float)(float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? Math.Round((double)result / 12700.0 * 8.0) : 0.75);
		}
		return (float)(float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? ((double)result) : 0.75);
	}

	private void ProcessEffectExtent(XmlReader picReader, ShapeBase shapeBase)
	{
		string attribute = picReader.GetAttribute("l");
		if (!string.IsNullOrEmpty(attribute))
		{
			shapeBase.LeftEdgeExtent = GetPropertyValue(attribute, "l");
		}
		attribute = picReader.GetAttribute("t");
		if (!string.IsNullOrEmpty(attribute))
		{
			shapeBase.TopEdgeExtent = GetPropertyValue(attribute, "t");
		}
		attribute = picReader.GetAttribute("r");
		if (!string.IsNullOrEmpty(attribute))
		{
			shapeBase.RightEdgeExtent = GetPropertyValue(attribute, "r");
		}
		attribute = picReader.GetAttribute("b");
		if (!string.IsNullOrEmpty(attribute))
		{
			shapeBase.BottomEdgeExtent = GetPropertyValue(attribute, "b");
		}
	}

	private DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineCap GetLineCapStyle(string lineCap)
	{
		switch (lineCap)
		{
		case "flat":
			return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineCap.Flat;
		case "rnd":
		case "round":
			return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineCap.Round;
		default:
			return DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineCap.Square;
		}
	}

	private void ParseLineProps(XmlReader reader, InlineShapeObject shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "ln")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "ln")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "bevel":
					if (reader.Prefix == "a")
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 0u);
					}
					break;
				case "gradFill":
					ParseGradientFill(reader, shape.LineGradient);
					break;
				case "headEnd":
				{
					string attribute3 = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(464, (uint)GetLineEnd(attribute3));
					}
					attribute3 = reader.GetAttribute("w");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(466, (uint)GetLineEndWidth(attribute3));
					}
					attribute3 = reader.GetAttribute("len");
					if (!string.IsNullOrEmpty(attribute3))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(467, (uint)GetLineEndLength(attribute3));
					}
					break;
				}
				case "miter":
					if (reader.Prefix == "a")
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 1u);
						string attribute = reader.GetAttribute("lim");
						if (!string.IsNullOrEmpty(attribute))
						{
							uint value = (uint)(GetPercentage(attribute) * 65536.0 / 100.0);
							shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, value);
						}
					}
					break;
				case "noFill":
					shape.ShapeContainer.ShapeOptions.LineProperties.Line = false;
					break;
				case "prstDash":
				{
					string attribute4 = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute4))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(462, (uint)GetDashStyle(attribute4));
					}
					break;
				}
				case "round":
					if (reader.Prefix == "a")
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 2u);
					}
					break;
				case "solidFill":
				{
					uint opacity = uint.MaxValue;
					Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (opacity != uint.MaxValue)
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, opacity);
					}
					shape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(color));
					break;
				}
				case "tailEnd":
				{
					string attribute2 = reader.GetAttribute("type");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(465, (uint)GetLineEnd(attribute2));
					}
					attribute2 = reader.GetAttribute("w");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(468, (uint)GetLineEndWidth(attribute2));
					}
					attribute2 = reader.GetAttribute("len");
					if (!string.IsNullOrEmpty(attribute2))
					{
						shape.ShapeContainer.ShapeOptions.SetPropertyValue(469, (uint)GetLineEndLength(attribute2));
					}
					break;
				}
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseLineProps(XmlReader reader, Shape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "ln")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		string empty = string.Empty;
		while (reader.LocalName != "ln")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "prstDash":
				{
					string attribute = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute))
					{
						shape.LineFormat.DashStyle = GetDashStyle(attribute);
					}
					break;
				}
				case "solidFill":
				{
					shape.LineFormat.LineFormatType = LineFormatType.Solid;
					uint opacity = uint.MaxValue;
					Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
					shape.LineFormat.Line = true;
					shape.LineFormat.Color = color;
					if (opacity != uint.MaxValue)
					{
						shape.LineFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
					}
					break;
				}
				case "noFill":
					shape.LineFormat.Line = false;
					shape.LineFormat.LineFormatType = LineFormatType.None;
					break;
				case "gradFill":
					shape.LineFormat.Line = true;
					shape.LineFormat.LineFormatType = LineFormatType.Gradient;
					ParseGradientFill(reader, shape.LineFormat.GradientFill);
					break;
				case "pattFill":
					shape.LineFormat.Line = true;
					shape.LineFormat.LineFormatType = LineFormatType.Patterned;
					empty = reader.GetAttribute("prst");
					if (!string.IsNullOrEmpty(empty))
					{
						shape.LineFormat.Pattern = GetPatternType(empty);
					}
					ParsePatternFill(reader, shape.LineFormat);
					break;
				case "bevel":
					if (reader.Prefix == "a")
					{
						shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Bevel;
					}
					break;
				case "miter":
					if (reader.Prefix == "a")
					{
						shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Miter;
						shape.LineFormat.MiterJoinLimit = reader.GetAttribute("lim");
					}
					break;
				case "round":
					if (reader.Prefix == "a")
					{
						shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Round;
					}
					break;
				case "headEnd":
					ParseHeadEnd(reader, shape.LineFormat);
					break;
				case "tailEnd":
					ParseTailEnd(reader, shape.LineFormat);
					break;
				case "custDash":
				case "extLst":
					shape.LineFormat.DocxProps.Add(reader.LocalName, ReadSingleNodeIntoStream(reader));
					flag = true;
					break;
				default:
					if (!IsWord2003ML)
					{
						ReadSingleNodeIntoStream(reader);
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseLineProps(XmlReader reader, ChildShape shape)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "ln")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				bool flag = false;
				SkipWhitespaces(reader);
				string empty = string.Empty;
				while (reader.LocalName != "ln")
				{
					flag = false;
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "prstDash":
						{
							string attribute = reader.GetAttribute("val");
							if (!string.IsNullOrEmpty(attribute))
							{
								shape.LineFormat.DashStyle = GetDashStyle(attribute);
							}
							break;
						}
						case "solidFill":
						{
							shape.LineFormat.LineFormatType = LineFormatType.Solid;
							uint opacity = uint.MaxValue;
							Color color = ParseColor(reader, "solidFill", ref opacity, reader.LocalName, isAlreadyChecked: false);
							shape.LineFormat.Line = true;
							shape.LineFormat.Color = color;
							if (opacity != uint.MaxValue)
							{
								shape.LineFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2);
							}
							break;
						}
						case "noFill":
							shape.LineFormat.Line = false;
							shape.LineFormat.LineFormatType = LineFormatType.None;
							break;
						case "gradFill":
							shape.LineFormat.Line = true;
							shape.LineFormat.LineFormatType = LineFormatType.Gradient;
							ParseGradientFill(reader, shape.LineFormat.GradientFill);
							break;
						case "pattFill":
							shape.LineFormat.Line = true;
							shape.LineFormat.LineFormatType = LineFormatType.Patterned;
							empty = reader.GetAttribute("prst");
							if (!string.IsNullOrEmpty(empty))
							{
								shape.LineFormat.Pattern = GetPatternType(empty);
							}
							ParsePatternFill(reader, shape.LineFormat);
							break;
						case "bevel":
							if (reader.Prefix == "a")
							{
								shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Bevel;
							}
							break;
						case "miter":
							if (reader.Prefix == "a")
							{
								shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Miter;
								shape.LineFormat.MiterJoinLimit = reader.GetAttribute("lim");
							}
							break;
						case "round":
							if (reader.Prefix == "a")
							{
								shape.LineFormat.LineJoin = DocGen.DocIO.ReaderWriter.DataStreamParser.Escher.LineJoin.Round;
							}
							break;
						case "headEnd":
							ParseHeadEnd(reader, shape.LineFormat);
							break;
						case "tailEnd":
							ParseTailEnd(reader, shape.LineFormat);
							break;
						case "custDash":
						case "extLst":
							shape.LineFormat.DocxProps.Add(reader.LocalName, ReadSingleNodeIntoStream(reader));
							flag = true;
							break;
						default:
							ReadSingleNodeIntoStream(reader);
							flag = true;
							break;
						}
						if (!flag)
						{
							reader.Read();
						}
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
			}
			else
			{
				shape.LineFormat.LineFormatType = LineFormatType.None;
			}
		}
		else
		{
			shape.LineFormat.LineFormatType = LineFormatType.None;
		}
	}

	private void ParseTailEnd(XmlReader reader, LineFormat lineFormat)
	{
		string attribute = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.EndArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("w");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.EndArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("len");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.EndArrowheadLength = GetLineEndLength(attribute);
		}
	}

	private void ParseHeadEnd(XmlReader reader, LineFormat lineFormat)
	{
		string attribute = reader.GetAttribute("type");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.BeginArrowheadStyle = GetLineEnd(attribute);
		}
		attribute = reader.GetAttribute("w");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.BeginArrowheadWidth = GetLineEndWidth(attribute);
		}
		attribute = reader.GetAttribute("len");
		if (!string.IsNullOrEmpty(attribute))
		{
			lineFormat.BeginArrowheadLength = GetLineEndLength(attribute);
		}
	}

	private void ParsePatternFill(XmlReader reader, LineFormat lineFormat)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		uint opacity = uint.MaxValue;
		SkipWhitespaces(reader);
		while (!(reader.LocalName == text))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "fgClr"))
				{
					if (localName2 == "bgClr")
					{
						lineFormat.Color = ParseColor(reader, "bgClr", ref opacity, reader.LocalName, isAlreadyChecked: false);
						if (opacity != uint.MaxValue)
						{
							lineFormat.Transparency = (float)Math.Round(1f - (float)opacity / 65536f, 2) * 100f;
						}
					}
				}
				else
				{
					lineFormat.ForeColor = ParseColor(reader, "fgClr", ref opacity, reader.LocalName, isAlreadyChecked: false);
					opacity = uint.MaxValue;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private ArrowheadStyle GetLineEnd(string lineEnd)
	{
		switch (lineEnd)
		{
		case "block":
		case "triangle":
			return ArrowheadStyle.ArrowheadTriangle;
		case "arrow":
		case "open":
			return ArrowheadStyle.ArrowheadOpen;
		case "oval":
			return ArrowheadStyle.ArrowheadOval;
		case "classic":
		case "stealth":
			return ArrowheadStyle.ArrowheadStealth;
		case "diamond":
			return ArrowheadStyle.ArrowheadDiamond;
		default:
			return ArrowheadStyle.ArrowheadNone;
		}
	}

	private LineEndWidth GetLineEndWidth(string lineEndWidth)
	{
		switch (lineEndWidth)
		{
		case "sm":
		case "narrow":
			return LineEndWidth.NarrowArrow;
		case "lg":
		case "wide":
			return LineEndWidth.WideArrow;
		default:
			return LineEndWidth.MediumWidthArrow;
		}
	}

	private LineEndLength GetLineEndLength(string lineEndLength)
	{
		switch (lineEndLength)
		{
		case "sm":
		case "short":
			return LineEndLength.ShortArrow;
		case "lg":
		case "long":
			return LineEndLength.LongArrow;
		default:
			return LineEndLength.MediumLenArrow;
		}
	}

	private short GetLanguageID(string value)
	{
		return value switch
		{
			"ar" => 1, 
			"bg" => 2, 
			"ca" => 3, 
			"zh" => 4, 
			"cs" => 5, 
			"da" => 6, 
			"de" => 7, 
			"el" => 8, 
			"en" => 9, 
			"es" => 10, 
			"fi" => 11, 
			"fr" => 12, 
			"he" => 13, 
			"hu" => 14, 
			"is" => 15, 
			"it" => 16, 
			"ja" => 17, 
			"ko" => 18, 
			"nl" => 19, 
			"nb" => 20, 
			"pl" => 21, 
			"pt" => 22, 
			"rm" => 23, 
			"ro" => 24, 
			"ru" => 25, 
			"hr" => 26, 
			"sk" => 27, 
			"sq" => 28, 
			"sv" => 29, 
			"th" => 30, 
			"tr" => 31, 
			"ur" => 32, 
			"id" => 33, 
			"uk" => 34, 
			"be" => 35, 
			"sl" => 36, 
			"et" => 37, 
			"lv" => 38, 
			"lt" => 39, 
			"tg" => 40, 
			"fa" => 41, 
			"vi" => 42, 
			"hy" => 43, 
			"az" => 44, 
			"eu" => 45, 
			"hsb" => 46, 
			"mk" => 47, 
			"tn" => 50, 
			"xh" => 52, 
			"zu" => 53, 
			"af" => 54, 
			"ka" => 55, 
			"fo" => 56, 
			"hi" => 57, 
			"mt" => 58, 
			"smn" => 59, 
			"ms" => 62, 
			"kk" => 63, 
			"ky" => 64, 
			"sw" => 65, 
			"tk" => 66, 
			"uz" => 67, 
			"tt" => 68, 
			"bn" => 69, 
			"pa" => 70, 
			"gu" => 71, 
			"or" => 72, 
			"ta" => 73, 
			"te" => 74, 
			"kn" => 75, 
			"ml" => 76, 
			"mr" => 78, 
			"sa" => 79, 
			"mn" => 80, 
			"bo" => 81, 
			"cy" => 82, 
			"lo" => 84, 
			"gl" => 86, 
			"kok" => 87, 
			"syr" => 90, 
			"si" => 91, 
			"chr" => 92, 
			"iu" => 93, 
			"am" => 94, 
			"ne" => 97, 
			"fy" => 98, 
			"ps" => 99, 
			"fil" => 100, 
			"dv" => 101, 
			"ff" => 103, 
			"ha" => 104, 
			"quz" => 107, 
			"nso" => 108, 
			"ba" => 109, 
			"lb" => 110, 
			"kl" => 111, 
			"ig" => 112, 
			"ti" => 115, 
			"haw" => 117, 
			"ii" => 120, 
			"arn" => 122, 
			"br" => 126, 
			"ug" => 128, 
			"mi" => 129, 
			"oc" => 130, 
			"co" => 131, 
			"gsw" => 132, 
			"sah" => 133, 
			"qut" => 134, 
			"rw" => 135, 
			"prs" => 140, 
			_ => 1033, 
		};
	}

	private FlipOrientation GetFlipOrientation(string flip)
	{
		return flip switch
		{
			"x" => FlipOrientation.Horizontal, 
			"y" => FlipOrientation.Vertical, 
			"xy" => FlipOrientation.Both, 
			_ => FlipOrientation.None, 
		};
	}

	private FlipOrientation GetChildShapeFlipOrientation(string flip)
	{
		switch (flip)
		{
		case "x":
			return FlipOrientation.Horizontal;
		case "y":
			return FlipOrientation.Vertical;
		case "x y":
		case "xy":
			return FlipOrientation.Both;
		default:
			return FlipOrientation.None;
		}
	}

	private GradientShadeType GetGradientShadeType(string shade)
	{
		if (!(shade == "circle"))
		{
			if (shade == "rect")
			{
				return GradientShadeType.Rectangle;
			}
			return GradientShadeType.Shape;
		}
		return GradientShadeType.Circle;
	}

	private void ParseGradientFill(XmlReader reader, GradientFill gradientFill)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "gradFill")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			string attribute = reader.GetAttribute("flip");
			attribute = reader.GetAttribute("rotWithShape");
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				if (!string.IsNullOrEmpty(attribute))
				{
					gradientFill.Flip = GetFlipOrientation(attribute);
				}
				if (!string.IsNullOrEmpty(attribute))
				{
					gradientFill.RotateWithShape = GetBoolValue(attribute);
				}
				SkipWhitespaces(reader);
				while (reader.LocalName != "gradFill")
				{
					if (reader.NodeType == XmlNodeType.Element)
					{
						switch (reader.LocalName)
						{
						case "gsLst":
							ParseGradientStop(reader, gradientFill);
							break;
						case "lin":
							ParseLinearGradient(reader, gradientFill);
							break;
						case "path":
							gradientFill.PathGradient = new PathGradient();
							attribute = reader.GetAttribute("path");
							gradientFill.PathGradient.PathShade = GetGradientShadeType(attribute);
							if (!reader.IsEmptyElement)
							{
								localName = reader.LocalName;
								reader.Read();
								if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
								{
									ParsePathGradient(reader, gradientFill.PathGradient, localName);
								}
							}
							break;
						case "tileRect":
							ParseTileRectangle(reader, gradientFill);
							break;
						}
						reader.Read();
					}
					else
					{
						reader.Read();
					}
					SkipWhitespaces(reader);
				}
			}
			else
			{
				gradientFill.IsEmptyElement = true;
			}
		}
		else
		{
			gradientFill.IsEmptyElement = true;
		}
	}

	private void ParseTileRectangle(XmlReader reader, GradientFill gradientFill)
	{
		string attribute = reader.GetAttribute("b");
		int result;
		if (!string.IsNullOrEmpty(attribute))
		{
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			gradientFill.TileRectangle.BottomOffset = result / 1000;
		}
		attribute = reader.GetAttribute("l");
		if (!string.IsNullOrEmpty(attribute))
		{
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			gradientFill.TileRectangle.LeftOffset = result / 1000;
		}
		attribute = reader.GetAttribute("r");
		if (!string.IsNullOrEmpty(attribute))
		{
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			gradientFill.TileRectangle.RightOffset = result / 1000;
		}
		attribute = reader.GetAttribute("t");
		if (!string.IsNullOrEmpty(attribute))
		{
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			gradientFill.TileRectangle.TopOffset = result / 1000;
		}
	}

	private void ParseLinearGradient(XmlReader reader, GradientFill gradientFill)
	{
		gradientFill.LinearGradient = new LinearGradient();
		string attribute = reader.GetAttribute("ang");
		if (!string.IsNullOrEmpty(attribute))
		{
			uint.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out var result);
			gradientFill.LinearGradient.Angle = (short)Math.Round((double)result / 60000.0);
		}
		attribute = reader.GetAttribute("scaled");
		if (!string.IsNullOrEmpty(attribute))
		{
			gradientFill.LinearGradient.Scaled = GetBoolValue(attribute);
		}
	}

	private void ParseGradientStop(XmlReader reader, GradientFill gradientFill)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "gsLst")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		for (; reader.LocalName != "gsLst"; SkipWhitespaces(reader))
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "gs")
				{
					string attribute = reader.GetAttribute("pos");
					GradientStop gradientStop = new GradientStop();
					if (!string.IsNullOrEmpty(attribute))
					{
						if (double.TryParse(attribute.EndsWith("%") ? attribute.Replace("%", "") : attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out var result))
						{
							gradientStop.Position = (attribute.EndsWith("%") ? ((byte)Math.Round(result)) : ((byte)Math.Round(result / 1000.0)));
						}
						else
						{
							if (gradientFill.GradientStops.Count != 0)
							{
								goto IL_0177;
							}
							gradientStop.Position = (byte)result;
						}
					}
					uint opacity = uint.MaxValue;
					gradientStop.Color = ParseColor(reader, "gs", ref opacity, reader.LocalName, isAlreadyChecked: false);
					if (opacity != uint.MaxValue)
					{
						gradientStop.Opacity = (byte)Math.Round((double)opacity / 65536.0 * 100.0);
					}
					gradientFill.GradientStops.Add(gradientStop);
				}
				goto IL_0177;
			}
			reader.Read();
			continue;
			IL_0177:
			reader.Read();
		}
	}

	private void ParsePathGradient(XmlReader reader, PathGradient pathGradient, string localName)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != "path")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "path")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "fillToRect")
				{
					string attribute = reader.GetAttribute("b");
					int result;
					if (!string.IsNullOrEmpty(attribute))
					{
						int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						pathGradient.BottomOffset = (short)(result / 1000);
					}
					attribute = reader.GetAttribute("l");
					if (!string.IsNullOrEmpty(attribute))
					{
						int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						pathGradient.LeftOffset = (short)(result / 1000);
					}
					attribute = reader.GetAttribute("r");
					if (!string.IsNullOrEmpty(attribute))
					{
						int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						pathGradient.RightOffset = (short)(result / 1000);
					}
					attribute = reader.GetAttribute("t");
					if (!string.IsNullOrEmpty(attribute))
					{
						int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						pathGradient.TopOffset = (short)(result / 1000);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private Color ParseColor(XmlReader reader, string parentElement, ref uint opacity, string localName, bool isAlreadyChecked)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != parentElement)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		Color color = Color.Empty;
		if (isAlreadyChecked)
		{
			color = ParseColorValues(reader, parentElement, ref opacity, localName, color);
		}
		else if (!reader.IsEmptyElement)
		{
			localName = reader.LocalName;
			reader.Read();
			if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				return color;
			}
			color = ParseColorValues(reader, parentElement, ref opacity, localName, color);
		}
		return color;
	}

	private Color ParseColorValues(XmlReader reader, string parentElement, ref uint opacity, string localName, Color color)
	{
		SkipWhitespaces(reader);
		while (reader.LocalName != parentElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "srgbClr":
				{
					string attribute3 = reader.GetAttribute("val");
					color = GetHexColor(attribute3);
					ParseColorTransform(reader, "srgbClr", ref color, ref opacity);
					break;
				}
				case "scrgbClr":
				{
					string attribute4 = reader.GetAttribute("r");
					double percentage = GetPercentage(attribute4);
					percentage = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage / 100.0));
					attribute4 = reader.GetAttribute("g");
					double percentage2 = GetPercentage(attribute4);
					percentage2 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage2 / 100.0));
					attribute4 = reader.GetAttribute("b");
					double percentage3 = GetPercentage(attribute4);
					percentage3 = Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage3 / 100.0));
					color = Color.FromArgb(255, (byte)percentage, (byte)percentage2, (byte)percentage3);
					ParseColorTransform(reader, "scrgbClr", ref color, ref opacity);
					break;
				}
				case "prstClr":
				{
					string attribute2 = reader.GetAttribute("val");
					if (attribute2 != null)
					{
						color = Color.FromName(attribute2);
					}
					ParseColorTransform(reader, "prstClr", ref color, ref opacity);
					break;
				}
				case "hslClr":
				{
					double result = 0.0;
					double num = 0.0;
					double num2 = 0.0;
					string attribute = reader.GetAttribute("hue");
					double.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					result /= 60000.0;
					result /= 360.0;
					attribute = reader.GetAttribute("lum");
					num = GetPercentage(attribute) / 100.0;
					attribute = reader.GetAttribute("sat");
					num2 = GetPercentage(attribute) / 100.0;
					color = WordColor.ConvertHSLToColor(result, num2, num);
					ParseColorTransform(reader, "hslClr", ref color, ref opacity);
					break;
				}
				case "sysClr":
					color = GetSystemColor(reader);
					ParseColorTransform(reader, "sysClr", ref color, ref opacity);
					break;
				case "schemeClr":
					color = GetSchemeColor(reader);
					ParseColorTransform(reader, "schemeClr", ref color, ref opacity);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		return color;
	}

	private Color GetSystemColor(XmlReader reader)
	{
		Color result = Color.Empty;
		string attribute = reader.GetAttribute("lastClr");
		if (!string.IsNullOrEmpty(attribute))
		{
			result = GetHexColor(attribute);
		}
		string attribute2 = reader.GetAttribute("val");
		if (!string.IsNullOrEmpty(attribute2))
		{
			KnownColor color = KnownColor.Black;
			switch (attribute2)
			{
			case "3dDkShadow":
				color = KnownColor.ControlDarkDark;
				break;
			case "3dLight":
				color = KnownColor.ControlLight;
				break;
			case "activeBorder":
				color = KnownColor.ActiveBorder;
				break;
			case "activeCaption":
				color = KnownColor.ActiveCaption;
				break;
			case "appWorkspace":
				color = KnownColor.AppWorkspace;
				break;
			case "background":
				color = KnownColor.Desktop;
				break;
			case "btnFace":
				color = KnownColor.ButtonFace;
				break;
			case "btnHighlight":
				color = KnownColor.ButtonHighlight;
				break;
			case "btnShadow":
				color = KnownColor.ButtonShadow;
				break;
			case "btnText":
				color = KnownColor.ControlText;
				break;
			case "captionText":
				color = KnownColor.ActiveCaptionText;
				break;
			case "gradientActiveCaption":
				color = KnownColor.GradientActiveCaption;
				break;
			case "gradientInactiveCaption":
				color = KnownColor.GradientInactiveCaption;
				break;
			case "grayText":
				color = KnownColor.GrayText;
				break;
			case "highlight":
				color = KnownColor.Highlight;
				break;
			case "highlightText":
				color = KnownColor.HighlightText;
				break;
			case "hotLight":
				color = KnownColor.HotTrack;
				break;
			case "inactiveBorder":
				color = KnownColor.InactiveBorder;
				break;
			case "inactiveCaption":
				color = KnownColor.InactiveCaption;
				break;
			case "inactiveCaptionText":
				color = KnownColor.InactiveCaptionText;
				break;
			case "infoBk":
				color = KnownColor.Info;
				break;
			case "infoText":
				color = KnownColor.InfoText;
				break;
			case "menu":
				color = KnownColor.Menu;
				break;
			case "menuBar":
				color = KnownColor.MenuBar;
				break;
			case "menuHighlight":
				color = KnownColor.MenuHighlight;
				break;
			case "menuText":
				color = KnownColor.MenuText;
				break;
			case "scrollBar":
				color = KnownColor.ScrollBar;
				break;
			case "window":
				color = KnownColor.Window;
				break;
			case "windowFrame":
				color = KnownColor.WindowFrame;
				break;
			case "windowText":
				color = KnownColor.WindowText;
				break;
			}
			result = Color.FromKnownColor(color);
		}
		return result;
	}

	private Color GetSchemeColor(XmlReader reader)
	{
		_ = Color.Empty;
		string attribute = reader.GetAttribute("val");
		return GetThemeFillColor(attribute);
	}

	private void ParseColorTransform(XmlReader reader, string parentElement, ref Color themeColor, ref uint opacity)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != parentElement)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		bool flag = false;
		while (reader.LocalName != parentElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "alpha":
				{
					flag = false;
					string attribute3 = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute3))
					{
						double percentage3 = GetPercentage(attribute3);
						opacity = (uint)(percentage3 * 65536.0 / 100.0);
						if (opacity > 65536)
						{
							opacity = 65536u;
						}
					}
					break;
				}
				case "alphaMod":
				{
					flag = false;
					string attribute = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute))
					{
						double percentage = GetPercentage(attribute);
						opacity = (uint)((double)((opacity == uint.MaxValue) ? 65536u : opacity) * (percentage / 100.0));
						if (opacity > 65536)
						{
							opacity = 65536u;
						}
					}
					break;
				}
				case "alphaOff":
				{
					if (flag)
					{
						break;
					}
					string attribute2 = reader.GetAttribute("val");
					if (!string.IsNullOrEmpty(attribute2))
					{
						double percentage2 = GetPercentage(attribute2);
						opacity = (uint)((double)((opacity != uint.MaxValue) ? opacity : 0u) + Math.Round(percentage2 * 65536.0 / 100.0));
						if (opacity > 65536)
						{
							opacity = 65536u;
						}
					}
					break;
				}
				default:
				{
					string value = reader.GetAttribute("val");
					if (string.IsNullOrEmpty(value) && (reader.LocalName == "comp" || reader.LocalName == "gamma" || reader.LocalName == "gray" || reader.LocalName == "invGamma" || reader.LocalName == "inv"))
					{
						value = string.Empty;
					}
					if (!string.IsNullOrEmpty(value))
					{
						flag = ParseColorTransform(reader.LocalName, value, ref themeColor);
					}
					if (flag)
					{
						opacity = uint.MaxValue;
					}
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private bool ParseColorTransform(string localName, string value, ref Color themeColor)
	{
		switch (localName)
		{
		case "blue":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage2 = GetPercentage(value);
				byte blue = (byte)Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage2 / 100.0));
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, themeColor.G, blue);
			}
			return true;
		case "blueMod":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage3 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, themeColor.G, WordColor.ConvertbyModulation(themeColor.B, percentage3));
			}
			return true;
		case "blueOff":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage13 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, themeColor.G, WordColor.ConvertbyOffset(themeColor.B, percentage13));
			}
			return true;
		case "green":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage10 = GetPercentage(value);
				byte green = (byte)Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage10 / 100.0));
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, green, themeColor.B);
			}
			return true;
		case "greenMod":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage6 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, WordColor.ConvertbyModulation(themeColor.G, percentage6), themeColor.B);
			}
			return true;
		case "greenOff":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage4 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, themeColor.R, WordColor.ConvertbyOffset(themeColor.G, percentage4), themeColor.B);
			}
			return true;
		case "red":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage11 = GetPercentage(value);
				byte red = (byte)Math.Round(255.0 * WordColor.ConvertsLinearRGBtoRGB(percentage11 / 100.0));
				themeColor = Color.FromArgb(themeColor.A, red, themeColor.G, themeColor.B);
			}
			return true;
		case "redMod":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage8 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, WordColor.ConvertbyModulation(themeColor.R, percentage8), themeColor.G, themeColor.B);
			}
			return true;
		case "redOff":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage15 = GetPercentage(value);
				themeColor = Color.FromArgb(themeColor.A, WordColor.ConvertbyOffset(themeColor.R, percentage15), themeColor.G, themeColor.B);
			}
			return true;
		case "hue":
			if (!string.IsNullOrEmpty(value))
			{
				double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result2);
				result2 /= 60000.0;
				WordColor.ConvertbyHue(ref themeColor, result2);
			}
			return true;
		case "hueMod":
			if (!string.IsNullOrEmpty(value))
			{
				double ratio = GetPercentage(value) / 100.0;
				WordColor.ConvertbyHueMod(ref themeColor, ratio);
			}
			return true;
		case "hueOff":
			if (!string.IsNullOrEmpty(value))
			{
				double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result);
				result /= 60000.0;
				WordColor.ConvertbyHueOffset(ref themeColor, result);
			}
			return true;
		case "sat":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage = GetPercentage(value);
				WordColor.ConvertbySat(ref themeColor, percentage);
			}
			return true;
		case "satMod":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage14 = GetPercentage(value);
				WordColor.ConvertbySatMod(ref themeColor, percentage14);
			}
			return true;
		case "satOff":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage12 = GetPercentage(value);
				WordColor.ConvertbySatOffset(ref themeColor, percentage12);
			}
			return true;
		case "lum":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage9 = GetPercentage(value);
				WordColor.ConvertbyLum(ref themeColor, percentage9);
			}
			return true;
		case "lumMod":
			if (!string.IsNullOrEmpty(value))
			{
				double percentage7 = GetPercentage(value);
				WordColor.ConvertbyLumMod(ref themeColor, percentage7);
			}
			return true;
		case "lumOff":
			if (value != null)
			{
				double percentage5 = GetPercentage(value);
				WordColor.ConvertbyLumOffset(ref themeColor, percentage5);
			}
			return true;
		case "comp":
			themeColor = WordColor.ComplementColor(themeColor);
			return true;
		case "gamma":
			themeColor = WordColor.GammaColor(themeColor);
			return true;
		case "gray":
			themeColor = WordColor.GrayColor(themeColor);
			return true;
		case "invGamma":
			themeColor = WordColor.InverseGammaColor(themeColor);
			return true;
		case "inv":
			themeColor = WordColor.InverseColor(themeColor);
			return true;
		case "tint":
			if (!string.IsNullOrEmpty(value))
			{
				double tint = GetPercentage(value) / 100.0;
				themeColor = WordColor.ConvertColorByTint(themeColor, tint);
			}
			return true;
		case "shade":
			if (!string.IsNullOrEmpty(value))
			{
				double shade = GetPercentage(value) / 100.0;
				themeColor = WordColor.ConvertColorByShade(themeColor, shade);
			}
			return true;
		default:
			return false;
		}
	}

	private double GetPercentage(string value)
	{
		double result;
		if (value.EndsWith("%"))
		{
			double.TryParse(value.Replace("%", ""), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return result;
		}
		double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		return result / 1000.0;
	}

	private void ParseWrappingType(XmlReader reader, WPicture picture)
	{
		string attribute = reader.GetAttribute("wrapText");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "bothSides":
				picture.TextWrappingType = TextWrappingType.Both;
				break;
			case "left":
				picture.TextWrappingType = TextWrappingType.Left;
				break;
			case "right":
				picture.TextWrappingType = TextWrappingType.Right;
				break;
			case "largest":
				picture.TextWrappingType = TextWrappingType.Largest;
				break;
			}
		}
	}

	private void ParsePictureHorizontalPosition(XmlReader reader, WPicture picture)
	{
		if (reader.LocalName != "positionH")
		{
			throw new XmlException("positionH");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("relativeFrom");
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		if (!string.IsNullOrEmpty(attribute))
		{
			picture.HorizontalOrigin = GetHorizOrigin(attribute);
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "positionH")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "align"))
				{
					if (localName2 == "posOffset")
					{
						float result = float.MaxValue;
						float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						flag = true;
						if (result != float.MaxValue)
						{
							picture.HorizontalPosition = (float)Math.Round(result / 12700f, 2);
						}
					}
				}
				else
				{
					string text = reader.ReadInnerXml();
					flag = true;
					if (!string.IsNullOrEmpty(text))
					{
						picture.HorizontalAlignment = GetHorizAlign(text);
					}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private ShapeHorizontalAlignment GetHorizAlign(string align)
	{
		return align switch
		{
			"center" => ShapeHorizontalAlignment.Center, 
			"left" => ShapeHorizontalAlignment.Left, 
			"right" => ShapeHorizontalAlignment.Right, 
			"inside" => ShapeHorizontalAlignment.Inside, 
			"outside" => ShapeHorizontalAlignment.Outside, 
			_ => ShapeHorizontalAlignment.None, 
		};
	}

	private HorizontalOrigin GetHorizOrigin(string origin)
	{
		switch (origin)
		{
		case "page":
			return HorizontalOrigin.Page;
		case "text":
		case "column":
			return HorizontalOrigin.Column;
		case "char":
		case "character":
			return HorizontalOrigin.Character;
		case "left-margin-area":
		case "leftMargin":
			return HorizontalOrigin.LeftMargin;
		case "right-margin-area":
		case "rightMargin":
			return HorizontalOrigin.RightMargin;
		case "inner-margin-area":
		case "insideMargin":
			return HorizontalOrigin.InsideMargin;
		case "outer-margin-area":
		case "outsideMargin":
			return HorizontalOrigin.OutsideMargin;
		default:
			return HorizontalOrigin.Margin;
		}
	}

	private void ParsePictureVerticalPosition(XmlReader reader, WPicture picture)
	{
		if (reader.LocalName != "positionV")
		{
			throw new XmlException("PositionV");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("relativeFrom");
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		picture.VerticalOrigin = GetVertOrigin(attribute);
		SkipWhitespaces(reader);
		while (reader.LocalName != "positionV")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "align"))
				{
					if (localName2 == "posOffset")
					{
						float result = float.MaxValue;
						float.TryParse(reader.ReadInnerXml(), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
						flag = true;
						if (result != float.MaxValue)
						{
							picture.VerticalPosition = (float)Math.Round(result / 12700f, 2);
						}
					}
				}
				else
				{
					string text = reader.ReadInnerXml();
					flag = true;
					if (!string.IsNullOrEmpty(text))
					{
						picture.VerticalAlignment = GetVertAlign(text);
					}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private ShapeVerticalAlignment GetVertAlign(string align)
	{
		return align switch
		{
			"top" => ShapeVerticalAlignment.Top, 
			"bottom" => ShapeVerticalAlignment.Bottom, 
			"center" => ShapeVerticalAlignment.Center, 
			"inside" => ShapeVerticalAlignment.Inside, 
			"inline" => ShapeVerticalAlignment.Inline, 
			"outside" => ShapeVerticalAlignment.Outside, 
			_ => ShapeVerticalAlignment.None, 
		};
	}

	private VerticalAlignment GetTextVertAlign(string align)
	{
		switch (align)
		{
		case "b":
		case "bottom":
			return VerticalAlignment.Bottom;
		case "ctr":
		case "middle":
			return VerticalAlignment.Middle;
		default:
			return VerticalAlignment.Top;
		}
	}

	private HeightOrigin GetHeightOrigin(string rel)
	{
		return rel switch
		{
			"page" => HeightOrigin.Page, 
			"top-margin-area" => HeightOrigin.TopMargin, 
			"inner-margin-area" => HeightOrigin.InsideMargin, 
			"outer-margin-area" => HeightOrigin.OutsideMargin, 
			"bottom-margin-area" => HeightOrigin.BottomMargin, 
			_ => HeightOrigin.Margin, 
		};
	}

	private WidthOrigin GetWidthOrigin(string rel)
	{
		return rel switch
		{
			"page" => WidthOrigin.Page, 
			"left-margin-area" => WidthOrigin.LeftMargin, 
			"inner-margin-area" => WidthOrigin.InsideMargin, 
			"outer-margin-area" => WidthOrigin.OutsideMargin, 
			"right-margin-area" => WidthOrigin.RightMargin, 
			_ => WidthOrigin.Margin, 
		};
	}

	private VerticalOrigin GetVertOrigin(string origin)
	{
		switch (origin.ToLower())
		{
		case "page":
			return VerticalOrigin.Page;
		case "text":
		case "paragraph":
			return VerticalOrigin.Paragraph;
		case "line":
			return VerticalOrigin.Line;
		case "topmargin":
		case "top-margin-area":
			return VerticalOrigin.TopMargin;
		case "bottommargin":
		case "bottom-margin-area":
			return VerticalOrigin.BottomMargin;
		case "insidemargin":
		case "innermargin":
		case "inner-margin-area":
			return VerticalOrigin.InsideMargin;
		case "outermargin":
		case "outer-margin-area":
		case "outsidemargin":
			return VerticalOrigin.OutsideMargin;
		default:
			return VerticalOrigin.Margin;
		}
	}

	private GraphicDataContentType CheckPicture(XmlReader reader)
	{
		reader.ReadToFollowing("graphicData", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
		if (reader.LocalName != "graphicData")
		{
			return GraphicDataContentType.None;
		}
		string attribute = reader.GetAttribute("uri");
		if (!string.IsNullOrEmpty(attribute) && attribute == "http://schemas.openxmlformats.org/drawingml/2006/diagram")
		{
			m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 28);
		}
		if (!string.IsNullOrEmpty(attribute) && attribute == "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas")
		{
			m_doc.SetTriggerElement(ref m_doc.m_notSupportedElementFlag, 10);
		}
		if (attribute == null)
		{
			return GraphicDataContentType.None;
		}
		if (attribute == (IsStrict ? "http://purl.oclc.org/ooxml/drawingml/picture" : "http://schemas.openxmlformats.org/drawingml/2006/picture"))
		{
			return GraphicDataContentType.Picture;
		}
		if (!(attribute == (IsStrict ? "http://purl.oclc.org/ooxml/drawingml/chart" : "http://schemas.openxmlformats.org/drawingml/2006/chart")))
		{
			switch (attribute)
			{
			case "http://schemas.microsoft.com/office/drawing/2014/chartex":
				break;
			case "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing":
			case "http://schemas.microsoft.com/office/word/2010/wordprocessingShape":
				return GraphicDataContentType.Shape;
			case "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup":
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 18);
				return GraphicDataContentType.Group;
			default:
				return GraphicDataContentType.None;
			}
		}
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 8);
		return GraphicDataContentType.Chart;
	}

	private bool IsValid2016Chart(Stream drawingStream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(drawingStream);
		xmlReader.ReadToFollowing("graphicData", IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
		if (xmlReader.GetAttribute("uri") == "http://schemas.microsoft.com/office/drawing/2014/chartex")
		{
			xmlReader.ReadToFollowing("chart", "http://schemas.microsoft.com/office/drawing/2014/chartex");
			string attribute = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
			string text = null;
			if ((m_currentFile != null && (StartsWithExt(m_currentFile, "header") || StartsWithExt(m_currentFile, "footer"))) || false || IsInFootnote || IsInEndnote || IsInComments)
			{
				Dictionary<string, DictionaryEntry> dictionary = null;
				if (IsInComments)
				{
					dictionary = GetFileRelations("comments.xml.rels");
				}
				else if (!string.IsNullOrEmpty(m_currentFile))
				{
					dictionary = GetFileRelations(m_currentFile);
				}
				if (dictionary != null && attribute != null && dictionary.ContainsKey(attribute))
				{
					DictionaryEntry dictionaryEntry = dictionary[attribute];
					text = ((dictionaryEntry.Value != null) ? ((string)dictionaryEntry.Value) : string.Empty);
				}
			}
			else if (m_docRelations != null && attribute != null)
			{
				text = m_docRelations[attribute].Value.ToString();
			}
			if (!string.IsNullOrEmpty(text))
			{
				int num = text.LastIndexOf('/');
				if (num > 0 && text.Substring(num + 1, text.Length - (num + 1)).Length > 0)
				{
					text = text.Replace(text.Substring(0, num + 1), null);
				}
				XmlReader xmlReader2 = UtilityMethods.CreateReader(m_doc.DocxPackage.FindPartContainer("word/charts/").XmlParts[text].DataStream);
				xmlReader2.ReadToDescendant("cx:series");
				xmlReader2.MoveToAttribute("layoutId");
				return xmlReader2.Value == "waterfall";
			}
		}
		return true;
	}

	private void ParseBreak(XmlReader reader, ParagraphItemCollection paraItems, IOfficeMathRunElement mathRunElement)
	{
		Break @break = null;
		if (reader.LocalName != "br" && reader.LocalName != "cr")
		{
			throw new XmlException("break item");
		}
		int bitPosition = ((reader.LocalName == "br") ? 6 : 7);
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, bitPosition);
		string attribute = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == "column")
		{
			@break = new Break(m_doc, BreakType.ColumnBreak);
		}
		else if (attribute == "page")
		{
			@break = new Break(m_doc, BreakType.PageBreak);
		}
		else
		{
			@break = new Break(m_doc, BreakType.LineBreak);
			WCharacterFormat wCharacterFormat = ((m_currentRunFormat != null) ? m_currentRunFormat : @break.CharacterFormat);
			ApplyDirectionalOverride(wCharacterFormat);
			string text = (IsWord2003ML ? "text-wrapping" : "textWrapping");
			if (attribute == text)
			{
				string attribute2 = reader.GetAttribute("clear", IsStrict ? m_strictNameSpace : m_nameSpace);
				if (!string.IsNullOrEmpty(attribute2))
				{
					switch (attribute2)
					{
					case "left":
						wCharacterFormat.BreakClear = BreakClearType.Left;
						break;
					case "right":
						wCharacterFormat.BreakClear = BreakClearType.Right;
						break;
					case "all":
						@break.m_breakType = BreakType.TextWrappingBreak;
						wCharacterFormat.BreakClear = BreakClearType.All;
						break;
					default:
						wCharacterFormat.BreakClear = BreakClearType.None;
						break;
					}
				}
			}
			if (reader.LocalName == "cr")
			{
				@break.TextRange.Text = ControlChar.CarriegeReturn;
			}
			else
			{
				@break.TextRange.Text = ControlChar.LineBreak;
			}
		}
		if (m_currentRunFormat != null)
		{
			@break.TextRange.ApplyCharacterFormat(m_currentRunFormat);
			ApplyDirectionalOverride(@break.CharacterFormat);
		}
		if (mathRunElement != null)
		{
			mathRunElement.Item = @break;
		}
		else
		{
			AddItem(@break, paraItems);
		}
		CheckTrackChange(@break);
	}

	private ParagraphItem ParseSymbol(XmlReader reader, ParagraphItemCollection paraItems)
	{
		if (reader.LocalName != "sym")
		{
			throw new XmlException("Excepting Symbol element");
		}
		if (reader.AttributeCount != 2)
		{
			return null;
		}
		string attribute = reader.GetAttribute("font", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		string attribute2 = reader.GetAttribute("char", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null || attribute2 == null)
		{
			return null;
		}
		int result = 0;
		int.TryParse(attribute2, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out result);
		if (StartsWithExt(attribute2, "F0"))
		{
			result -= 61440;
		}
		if (result <= 255)
		{
			WSymbol wSymbol = new WSymbol(m_doc);
			wSymbol.CharacterCode = (byte)result;
			wSymbol.FontName = attribute;
			if (StartsWithExt(attribute2, "F0"))
			{
				wSymbol.CharCodeExt = 240;
			}
			if (m_currentRunFormat != null)
			{
				wSymbol.CharacterFormat.ImportContainer(m_currentRunFormat);
				ApplyDirectionalOverride(wSymbol.CharacterFormat);
			}
			return wSymbol;
		}
		WTextRange wTextRange = new WTextRange(m_doc);
		if (m_currentRunFormat != null)
		{
			wTextRange.CharacterFormat.ImportContainer(m_currentRunFormat);
			ApplyDirectionalOverride(wTextRange.CharacterFormat);
		}
		wTextRange.CharacterFormat.FontName = attribute;
		wTextRange.Text = Convert.ToString((char)result, CultureInfo.InvariantCulture);
		return wTextRange;
	}

	private void UpdateTextRange(WTextRange textRange, string text, WCharacterFormat runFormat)
	{
		textRange.ApplyCharacterFormat(runFormat);
		textRange.Text = text;
		ApplyDirectionalOverride(textRange.CharacterFormat);
	}

	private WTextRange ParseText(XmlReader reader, ParagraphItemCollection paraItems, bool isNestedInRunProperties, bool isMathRunText)
	{
		WTextRange wTextRange = new WTextRange(m_doc);
		if (m_currentRunFormat != null)
		{
			wTextRange.ApplyCharacterFormat(m_currentRunFormat);
			wTextRange.CharacterFormat.CharStyleId = m_currentRunFormat.CharStyleId;
		}
		ApplyDirectionalOverride(wTextRange.CharacterFormat);
		if (reader.LocalName == "instrText" || reader.LocalName == "delInstrText")
		{
			string text = ModifyText(reader.ReadInnerXml());
			if (text != null)
			{
				wTextRange.Text = text;
				int bitPosition = ((reader.LocalName == "delInstrText") ? 11 : 19);
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, bitPosition);
			}
		}
		else
		{
			if (reader.LocalName == "t")
			{
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 12);
			}
			if (reader.LocalName == "delText")
			{
				m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 13);
			}
			bool flag = false;
			if (reader.HasAttributes && reader.MoveToAttribute("xml:space"))
			{
				flag = reader.GetAttribute("xml:space") == "preserve";
			}
			reader.MoveToElement();
			bool hasAnotherBodyInText = false;
			string m_localName = null;
			wTextRange.Text = GetNestedText(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, isAlreadyCheck: false, ref m_localName, flag, isMathRunText);
			if (reader.LocalName == "r" && reader.NodeType == XmlNodeType.EndElement && wTextRange.Text == string.Empty)
			{
				return null;
			}
			if (!flag && !PreserveSpace && !isMathRunText)
			{
				wTextRange.Text = wTextRange.Text.Trim(' ');
			}
			if (hasAnotherBodyInText && !isNestedInRunProperties)
			{
				if (m_localName == "tbl")
				{
					m_currentRunFormat = null;
					WTable wTable = ParseNestedTable(reader, (paraItems.Owner as WParagraph).Owner, m_localName, isAlreadyCheck: true);
					if (wTable != null && wTable.Rows.Count > 0)
					{
						MoveParaItemsToNestedTable(wTable, paraItems, wTextRange);
					}
					else
					{
						AddToParagraph(wTextRange, paraItems);
					}
				}
				else
				{
					AddToParagraph(wTextRange, paraItems);
					ParseNestedBody(reader, isFirstNestedBody: true);
				}
				return null;
			}
		}
		return wTextRange;
	}

	private WTable ParseNestedTable(XmlReader reader, Entity ownerTextBody, string localName, bool isAlreadyCheck)
	{
		IWTable iWTable = AddTable(ownerTextBody);
		iWTable.TableFormat.IsAutoResized = true;
		short gridCount = m_gridCount;
		ParseTable(reader, iWTable as WTable, isAlreadyCheck, localName);
		m_gridCount = gridCount;
		if (iWTable.Rows.Count == 0)
		{
			(iWTable.Owner as WTextBody).ChildEntities.RemoveAt((iWTable as WTable).Index);
		}
		return iWTable as WTable;
	}

	private void MoveParaItemsToNestedTable(WTable table, ParagraphItemCollection paraItems, WTextRange txtRange)
	{
		WParagraph wParagraph = ((table.Rows[0].Cells.Count > 0 && table.Rows[0].Cells[0].ChildEntities.Count > 0 && table.Rows[0].Cells[0].ChildEntities[0] is WParagraph) ? (table.Rows[0].Cells[0].ChildEntities[0] as WParagraph) : new WParagraph(m_doc));
		if (wParagraph.Owner == null)
		{
			table.Rows[0].Cells[0].ChildEntities.Insert(0, wParagraph);
		}
		int num = 0;
		wParagraph.ChildEntities.Insert(num, txtRange);
		while (paraItems.Count > 0)
		{
			wParagraph.ChildEntities.Insert(num, paraItems[0]);
			num++;
		}
		(table.Owner as WTextBody).ChildEntities.RemoveAt(table.Index - 1);
	}

	private void ParseNestedBody(XmlReader reader, bool isFirstNestedBody)
	{
		while (reader.NodeType == XmlNodeType.Element && reader.LocalName.Equals("body"))
		{
			ParseBody(reader, null, isFirstNestedBody, isFromDocument: false, isMappedPictureContentControl: false);
			if (reader.NodeType == XmlNodeType.EndElement)
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
			isFirstNestedBody = false;
		}
	}

	private string GetNestedText(XmlReader reader, ref bool hasAnotherBodyInText, ParagraphItemCollection paraItems, bool isNestedInRunProperties, bool isAlreadyCheck, ref string m_localName, bool preservespace, bool isMathRunText)
	{
		string result = string.Empty;
		if (isAlreadyCheck)
		{
			result = GetNestedTextValue(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, ref m_localName, preservespace, isMathRunText);
		}
		else if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				return result;
			}
			result = GetNestedTextValue(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, ref m_localName, preservespace, isMathRunText);
		}
		return result;
	}

	private string GetNestedTextValue(XmlReader reader, ref bool hasAnotherBodyInText, ParagraphItemCollection paraItems, bool isNestedInRunProperties, ref string m_localName, bool preservespace, bool isMathRunText)
	{
		string text = string.Empty;
		int num = 0;
		_ = reader.Value;
		if (reader.XmlSpace != 0 || !PreserveSpace)
		{
			SkipWhitespaces(reader);
		}
		while (num > 0 || reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Text || reader.NodeType == XmlNodeType.SignificantWhitespace || reader.NodeType == XmlNodeType.CDATA || (reader.NodeType == XmlNodeType.Whitespace && reader.XmlSpace == XmlSpace.None && PreserveSpace))
			{
				string value = reader.Value;
				text = ((preservespace || PreserveSpace || isMathRunText || !value.Contains("\t")) ? (text + value) : (text + value.Replace("\t", " ")));
				if (text.Contains(ControlChar.LineFeed))
				{
					text = text.Trim(ControlChar.LineFeedChar);
					text = text.Replace(ControlChar.LineFeedChar, ' ');
				}
			}
			else if (!isNestedInRunProperties && reader.NodeType == XmlNodeType.Element)
			{
				if (!reader.IsEmptyElement)
				{
					string localName = reader.LocalName;
					XmlNodeType nodeType = reader.NodeType;
					reader.Read();
					if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
					{
						if (nodeType == XmlNodeType.Element && localName == "r")
						{
							ParseRun(reader, paraItems, null, isAlreadyChecked: true, nodeType, isMappedPictureContentControl: false);
						}
						else if (nodeType == XmlNodeType.Element)
						{
							if (localName == "body" || localName == "tbl")
							{
								m_localName = localName;
								hasAnotherBodyInText = true;
								break;
							}
							num++;
							string nestedText = GetNestedText(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties: false, isAlreadyCheck: true, ref m_localName, preservespace, isMathRunText);
							nestedText = nestedText.Replace(ControlChar.CrLf, " ");
							nestedText = nestedText.Replace(ControlChar.ParagraphBreak, " ");
							nestedText = nestedText.Replace(ControlChar.LineFeedChar, ' ');
							text += nestedText;
						}
					}
					else if (nodeType == XmlNodeType.Element && localName == "br")
					{
						text += "\v";
						num++;
					}
				}
				else if (reader.LocalName == "br")
				{
					text += "\v";
				}
			}
			else if (!isNestedInRunProperties && reader.NodeType == XmlNodeType.Element && reader.LocalName == "br")
			{
				text += "\v";
			}
			else if (isNestedInRunProperties && reader.NodeType == XmlNodeType.Element)
			{
				SkipCurrentElement(reader, reader.LocalName);
			}
			if (reader.NodeType == XmlNodeType.EndElement)
			{
				if (num == 0)
				{
					break;
				}
				num--;
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
		return text;
	}

	private void SkipCurrentElement(XmlReader reader, string element)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			while (reader.NodeType != XmlNodeType.EndElement || !(reader.LocalName == element))
			{
				reader.Read();
			}
		}
	}

	private string RotateText(string text)
	{
		char[] array = text.ToCharArray();
		string text2 = string.Empty;
		for (int num = array.Length - 1; num >= 0; num--)
		{
			text2 += array[num];
		}
		return text2;
	}

	private string ModifyText(string text)
	{
		text = text.Replace("&amp;", "&");
		text = text.Replace("&lt;", "<");
		text = text.Replace("&gt;", ">");
		return text;
	}

	private void ParseDocumentBackground(XmlReader reader)
	{
		if (reader.LocalName != "background")
		{
			throw new XmlException("background");
		}
		XmlReader xmlReader = UtilityMethods.CreateReader(ReadSingleNodeIntoStream(reader));
		Color colorValue = GetColorValue(xmlReader.GetAttribute("color", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
		m_doc.Background.SetBackgroundColor(colorValue);
		m_doc.Background.Type = BackgroundType.Color;
		while (xmlReader.Read())
		{
			if (xmlReader.NodeType != XmlNodeType.Element)
			{
				continue;
			}
			string localName = xmlReader.LocalName;
			if (!(localName == "background"))
			{
				if (localName == "fill")
				{
					string attribute = xmlReader.GetAttribute("type");
					if (StartsWithExt(attribute, "gradient"))
					{
						ParseGradientFill(xmlReader, m_doc.Background);
					}
					else if (attribute == "frame" || attribute == "tile")
					{
						ParseBackgroundPicture(xmlReader, m_doc.Background);
					}
				}
			}
			else
			{
				string attribute2 = xmlReader.GetAttribute("fillcolor");
				Color backgroundColor = Color.White;
				if (attribute2 != null)
				{
					backgroundColor = GetColorValue(attribute2);
				}
				if (!backgroundColor.Equals(Color.White))
				{
					m_doc.Background.SetBackgroundColor(backgroundColor);
				}
			}
		}
	}

	private void ParseBackgroundPicture(XmlReader reader, Background background)
	{
		string attribute = reader.GetAttribute("type");
		string attribute2 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		if (attribute == null || attribute2 == null)
		{
			return;
		}
		background.Type = ((attribute == "tile") ? BackgroundType.Texture : BackgroundType.Picture);
		bool isImageRelation = true;
		string imageName = GetImageName(attribute2, isHeaderFooter: false, isPicBullet: false, ref isImageRelation);
		if (!isImageRelation)
		{
			return;
		}
		if (ImageIds.ContainsKey(imageName))
		{
			background.ImageRecord = m_doc.Images[ImageIds[imageName]];
			return;
		}
		byte[] imageBytes = GetImageBytes(imageName);
		if (imageBytes != null)
		{
			background.ImageBytes = imageBytes;
			ImageIds.Add(imageName, background.ImageRecord.ImageId);
		}
		else
		{
			background.Type = BackgroundType.NoBackground;
		}
	}

	private AlternateChunk AddAlternateChunk(IEntity entity)
	{
		AlternateChunk alternateChunk = null;
		if (entity != null)
		{
			switch (entity.EntityType)
			{
			case EntityType.HeaderFooter:
				alternateChunk = (entity as HeaderFooter).AddAlternateChunk();
				break;
			case EntityType.Footnote:
				alternateChunk = (entity as WFootnote).TextBody.AddAlternateChunk();
				(entity as WFootnote).TextBody.AlternateChunkCollection.Add(alternateChunk);
				break;
			case EntityType.Comment:
				alternateChunk = (entity as WComment).TextBody.AddAlternateChunk();
				break;
			case EntityType.BlockContentControl:
				alternateChunk = (entity as BlockContentControl).TextBody.AddAlternateChunk();
				break;
			case EntityType.TableCell:
			{
				alternateChunk = (entity as WTableCell).AddAlternateChunk();
				Entity ownerTextBody = alternateChunk.GetOwnerTextBody((Entity)entity);
				if (ownerTextBody is WFootnote)
				{
					(ownerTextBody as WFootnote).TextBody.AlternateChunkCollection.Add(alternateChunk);
				}
				break;
			}
			case EntityType.TextBox:
				alternateChunk = (entity as WTextBox).TextBoxBody.AddAlternateChunk();
				break;
			case EntityType.Shape:
			case EntityType.AutoShape:
				alternateChunk = (entity as Shape).TextBody.AddAlternateChunk();
				break;
			default:
				alternateChunk = m_doc.LastSection.AddAlternateChunk();
				break;
			}
		}
		else
		{
			alternateChunk = m_doc.LastSection.AddAlternateChunk();
		}
		if (m_doc.LastSection != null)
		{
			m_doc.LastSection.Body.AlternateChunkCollection.Add(alternateChunk);
		}
		return alternateChunk;
	}

	private void ParseAlternateChunk(XmlReader reader, AlternateChunk altChunk)
	{
		string id = (altChunk.TargetId = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships"));
		string fileName = (string)GetRelation(id).Value;
		string text = GetPartName(ref fileName);
		if (!string.IsNullOrEmpty(text))
		{
			text = text.Replace("word/", null);
		}
		altChunk.ContentPath = text + fileName;
		altChunk.ContentType = GetExtensionContentType(altChunk.ContentExtension);
		string localName = reader.LocalName;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "matchSrc" && GetBooleanValue(reader))
				{
					altChunk.ImportOption = ImportOptions.KeepSourceFormatting;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private IBlockContentControl AddStructureDocumentTagBlock(IEntity entity)
	{
		IBlockContentControl blockContentControl = null;
		if (entity is HeaderFooter)
		{
			return (entity as HeaderFooter).AddStructureDocumentTag();
		}
		if (entity is WFootnote)
		{
			return (entity as WFootnote).TextBody.AddStructureDocumentTag();
		}
		if (entity is WComment)
		{
			return (entity as WComment).TextBody.AddStructureDocumentTag();
		}
		if (entity is BlockContentControl)
		{
			return (entity as BlockContentControl).TextBody.AddStructureDocumentTag();
		}
		if (entity is WTableCell)
		{
			return (entity as WTableCell).AddStructureDocumentTag();
		}
		return m_doc.LastSection.AddStructureDocumentTag();
	}

	private void ParseStructureDocumentTagInline(XmlReader reader, InlineContentControl sdTagInline)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sdtPr":
					ParseSDTProperties(reader, sdTagInline.ContentControlProperties);
					break;
				case "sdtContent":
					ParseSDTContentInline(reader, sdTagInline);
					if (sdTagInline.ContentControlProperties.XmlMapping != null)
					{
						InlineContentControls.Add(sdTagInline);
					}
					break;
				case "sdtEndPr":
					ParseSDTEndCharacterFormat(reader, sdTagInline.BreakCharacterFormat);
					break;
				case "p":
					if (!sdTagInline.IsFirstNestedParaParsed)
					{
						ParseParagraphItems(reader, sdTagInline.ParagraphItems, null, null, isMappedPictureContentControl: false);
						WParagraph ownerParagraphValue = sdTagInline.GetOwnerParagraphValue();
						m_doc.UpdateLastItemRevision(ownerParagraphValue, ownerParagraphValue.Items);
					}
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTContentInline(XmlReader reader, InlineContentControl sdtInlineContent)
	{
		ParseParagraphItems(reader, sdtInlineContent.ParagraphItems, null, null, sdtInlineContent.ContentControlProperties.XmlMapping.IsMapped);
		if (sdtInlineContent.ParagraphItems.Count == 0 && emptyContentRevision != null)
		{
			m_trackChangeType = emptyContentRevision.RevisionType;
			CheckTrackChange(sdtInlineContent);
			m_trackChangeType = RevisionType.None;
		}
		emptyContentRevision = null;
		contentRevision = null;
	}

	private void ParseStructureDocumentTagBlock(XmlReader reader, BlockContentControl sdTagBlock)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 2);
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != localName || (reader.LocalName == "sdt" && reader.NodeType == XmlNodeType.Element))
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sdtPr":
					ParseSDTProperties(reader, sdTagBlock.ContentControlProperties);
					break;
				case "sdtContent":
					ParseSDTContent(reader, sdTagBlock);
					flag = true;
					PostProcessBlockContentControl(sdTagBlock);
					break;
				case "sdtEndPr":
					ParseSDTEndCharacterFormat(reader, sdTagBlock.BreakCharacterFormat);
					break;
				case "p":
				{
					IWParagraph iWParagraph = AddParagraph(sdTagBlock);
					(iWParagraph as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
					AddPostParaItems(iWParagraph);
					ParseParagraphItems(reader, iWParagraph.Items, null, null, isMappedPictureContentControl: false);
					m_doc.UpdateLastItemRevision(iWParagraph, iWParagraph.Items);
					if (!string.IsNullOrEmpty(iWParagraph.StyleName))
					{
						(iWParagraph as WParagraph).ApplyStyle(iWParagraph.StyleName, isDomChanges: false);
					}
					break;
				}
				case "tbl":
				{
					if (IsNeedToApplyParaFormat && m_doc.LastSection.ChildEntities.Count == 0)
					{
						m_doc.LastSection.RemoveSelf();
					}
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 11);
					IWTable iWTable = AddTable(sdTagBlock);
					iWTable.TableFormat.IsAutoResized = true;
					short gridCount = m_gridCount;
					ParseTable(reader, iWTable as WTable, isAlreadyCheck: false, reader.LocalName);
					m_gridCount = gridCount;
					if (iWTable.Rows.Count == 0)
					{
						(iWTable.Owner as WTextBody).ChildEntities.RemoveAt((iWTable as WTable).Index);
					}
					if (IsNeedToMergeTables(iWTable as WTable))
					{
						(iWTable.PreviousSibling as WTable).MergeTables(iWTable as WTable);
					}
					break;
				}
				case "sdt":
					ParseBlockContentControl(reader, sdTagBlock);
					PostProcessBlockContentControl(sdTagBlock);
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void MapPictureContentControl(BlockContentControl sdTagBlock)
	{
		List<BlockContentControl> list = new List<BlockContentControl>();
		list.Add(sdTagBlock);
		Dictionary<string, List<BlockContentControl>> dictionary = new Dictionary<string, List<BlockContentControl>>();
		PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("customXml/");
		if (!(partContainer.Name == "customXml/"))
		{
			return;
		}
		_ = string.Empty;
		foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
		{
			string key = xmlPart.Key;
			if (!key.Contains("Props") || partContainer.XmlParts[xmlPart.Key].DataStream.Length <= 0)
			{
				continue;
			}
			List<BlockContentControl> list2 = new List<BlockContentControl>();
			Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPart.Key].DataStream);
			System.Xml.Linq.XDocument xDocument = new System.Xml.Linq.XDocument();
			using (XmlReader reader = XmlReader.Create(input))
			{
				xDocument = System.Xml.Linq.XDocument.Load(reader, LoadOptions.None);
			}
			XElement root = xDocument.Root;
			if (root != null)
			{
				foreach (System.Xml.Linq.XAttribute item in root.Attributes())
				{
					if (!item.Name.ToString().Contains("itemID"))
					{
						continue;
					}
					foreach (BlockContentControl item2 in list)
					{
						if (item.Value.Equals(item2.ContentControlProperties.XmlMapping.StoreItemID))
						{
							list2.Add(item2);
						}
					}
				}
			}
			if (list2.Count > 0)
			{
				dictionary.Add(key, list2);
			}
			list2.Clear();
		}
		List<BlockContentControl> idMisMatchedContentControl = GetIdMisMatchedContentControl(dictionary, list);
		if (idMisMatchedContentControl.Count > 0)
		{
			dictionary.Add("", idMisMatchedContentControl);
		}
		if (dictionary.Count > 0)
		{
			ResetBlockControlWithMappedItem(partContainer, dictionary);
		}
		idMisMatchedContentControl.Clear();
		dictionary.Clear();
	}

	private void ParseSDTEndCharacterFormat(XmlReader reader, WCharacterFormat charFormat)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "rPr")
				{
					ParseCharacterFormat(reader, charFormat, null);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTContent(XmlReader reader, BlockContentControl sdTagBlock)
	{
		ParseBody(reader, sdTagBlock, isRunElementTextBody: false, isFromDocument: false, sdTagBlock.ContentControlProperties.Type == ContentControlType.Picture && sdTagBlock.ContentControlProperties.XmlMapping != null && sdTagBlock.ContentControlProperties.XmlMapping.IsMapped);
	}

	private void ParseSDTProperties(XmlReader reader, ContentControlProperties properties)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "rPr":
					ParseCharacterFormat(reader, properties.CharacterFormat, null);
					break;
				case "id":
					properties.ID = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "showingPlcHdr":
					properties.HasPlaceHolderText = true;
					break;
				case "alias":
					properties.Title = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "bibliography":
					properties.Bibliograph = true;
					break;
				case "citation":
					properties.Citation = true;
					break;
				case "temporary":
					properties.IsTemporary = true;
					break;
				case "appearance":
				{
					string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2012/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						properties.Appearance = GetAppearance(attribute);
					}
					break;
				}
				case "color":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute3))
					{
						properties.Color = GetColorValue(attribute3);
					}
					break;
				}
				case "picture":
					properties.Type = ContentControlType.Picture;
					break;
				case "text":
				{
					properties.Type = ContentControlType.Text;
					string attribute2 = reader.GetAttribute("multiLine", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute2))
					{
						properties.Multiline = GetBoolValue(attribute2);
					}
					break;
				}
				case "richText":
					properties.Type = ContentControlType.RichText;
					break;
				case "comboBox":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_2, 14);
					properties.Type = ContentControlType.ComboBox;
					properties.ContentControlListItems.LastValue = reader.GetAttribute("lastValue", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					ParseSDTComboBox(reader, properties.ContentControlListItems);
					break;
				case "dropDownList":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 15);
					properties.Type = ContentControlType.DropDownList;
					properties.ContentControlListItems.LastValue = reader.GetAttribute("lastValue", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					ParseSDTDropDownList(reader, properties.ContentControlListItems);
					break;
				case "group":
					properties.Type = ContentControlType.Group;
					break;
				case "repeatingSection":
					properties.Type = ContentControlType.RepeatingSection;
					break;
				case "placeholder":
					ParseSDTPlaceHolder(reader, properties);
					break;
				case "lock":
					switch (reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
					{
					case "sdtLocked":
						properties.LockContentControl = true;
						break;
					case "sdtContentLocked":
						properties.LockContentControl = true;
						properties.LockContents = true;
						break;
					case "contentLocked":
						properties.LockContents = true;
						break;
					case "unlocked":
						properties.Unlocked = true;
						break;
					}
					break;
				case "date":
				{
					properties.Type = ContentControlType.Date;
					string attribute4 = reader.GetAttribute("fullDate", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (attribute4 != string.Empty)
					{
						properties.FullDate = attribute4;
					}
					ParseSDTDate(reader, properties);
					break;
				}
				case "dataBinding":
					properties.XmlMapping = new XmlMapping(properties.Owner);
					properties.XmlMapping.XPath = reader.GetAttribute("xpath", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					properties.XmlMapping.StoreItemID = reader.GetAttribute("storeItemID", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					properties.XmlMapping.PrefixMapping = reader.GetAttribute("prefixMappings", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					properties.XmlMapping.IsMapped = true;
					if (reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2010/wordml" || reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2012/wordml")
					{
						properties.XmlMapping.IsSupportWordML = true;
					}
					break;
				case "checkbox":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 9);
					properties.Type = ContentControlType.CheckBox;
					parseSDTCheckBox(reader, properties);
					break;
				case "docPartObj":
					properties.DocPartObj = new DocPartObj();
					ParseDocPartObj(reader, properties.DocPartObj, properties);
					break;
				case "docPartList":
					properties.DocPartList = new DocPartList();
					ParseDocPartList(reader, properties.DocPartList, properties);
					break;
				case "repeatingSectionItem":
					properties.ContentRepeatingType = ContentRepeatingType.RepeatingSectionItem;
					break;
				case "tag":
					properties.Tag = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTPlaceHolder(XmlReader reader, ContentControlProperties properties)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "docPart")
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (attribute != string.Empty)
					{
						properties.PlaceHolderDocPartId = attribute;
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private ContentControlAppearance GetAppearance(string appearance)
	{
		if (!(appearance == "hidden"))
		{
			if (appearance == "tags")
			{
				return ContentControlAppearance.Tags;
			}
			return ContentControlAppearance.BoundingBox;
		}
		return ContentControlAppearance.Hidden;
	}

	private void ParseDocPartList(XmlReader reader, DocPartList docPartList, ContentControlProperties controlProperties)
	{
		ParseDocPartItem(reader, docPartList, controlProperties);
	}

	private void ParseDocPartItem(XmlReader reader, DocPartItem docPartItem, ContentControlProperties controlProperties)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "docPartUnique":
					docPartItem.IsDocPartUnique = true;
					break;
				case "docPartGallery":
					controlProperties.Type = ContentControlType.BuildingBlockGallery;
					docPartItem.DocPartGallery = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (docPartItem.DocPartGallery.Equals("Cover Pages"))
					{
						m_doc.HasCoverPage = true;
					}
					break;
				case "docPartCategory":
					controlProperties.Type = ContentControlType.BuildingBlockGallery;
					docPartItem.DocPartCategory = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseDocPartObj(XmlReader reader, DocPartObj docPartobj, ContentControlProperties controlProperties)
	{
		ParseDocPartItem(reader, docPartobj, controlProperties);
	}

	private void parseSDTCheckBox(XmlReader reader, ContentControlProperties properties)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "checked":
					properties.IsChecked = GetBooleanValue(reader, "http://schemas.microsoft.com/office/word/2010/wordml");
					break;
				case "checkedState":
				{
					int.TryParse(reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var result2);
					properties.CheckedState.Value = ((char)result2).ToString();
					properties.CheckedState.Font = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2010/wordml");
					break;
				}
				case "uncheckedState":
				{
					int.TryParse(reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var result);
					properties.UncheckedState.Font = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2010/wordml");
					properties.UncheckedState.Value = ((char)result).ToString();
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTDropDownList(XmlReader reader, ContentControlListItems dropDownList)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "listItem")
				{
					ContentControlListItem contentControlListItem = new ContentControlListItem();
					contentControlListItem.DisplayText = reader.GetAttribute("displayText", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					contentControlListItem.Value = reader.GetAttribute("value", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					dropDownList.Add(contentControlListItem);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTComboBox(XmlReader reader, ContentControlListItems comboBox)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "listItem")
				{
					ContentControlListItem contentControlListItem = new ContentControlListItem();
					contentControlListItem.DisplayText = reader.GetAttribute("displayText", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					contentControlListItem.Value = reader.GetAttribute("value", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					comboBox.Add(contentControlListItem);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseSDTDate(XmlReader reader, ContentControlProperties controlProperties)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName2)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "dateFormat":
					controlProperties.DateDisplayFormat = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "lid":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (controlProperties.DateDisplayLocale != 0)
					{
						controlProperties.DateDisplayLocale = (LocaleIDs)0;
					}
					if (controlProperties.XmlProps.ContainsKey("localeId"))
					{
						controlProperties.XmlProps.Remove("localeId");
					}
					if (!string.IsNullOrEmpty(attribute) && Enum.IsDefined(typeof(LocaleIDs), attribute.Replace('-', '_')))
					{
						controlProperties.DateDisplayLocale = (LocaleIDs)Enum.Parse(typeof(LocaleIDs), attribute.Replace('-', '_'), ignoreCase: true);
					}
					else
					{
						controlProperties.XmlProps.Add("localeId", ReadSingleNodeIntoStream(reader));
					}
					break;
				}
				case "storeMappedDataAs":
					if (!string.IsNullOrEmpty(reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")))
					{
						controlProperties.DateStorageFormat = GetDateStorageType(reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
					}
					break;
				case "calendar":
					if (!string.IsNullOrEmpty(reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")))
					{
						CalendarType calendarType = GetCalendarType(reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
						controlProperties.DateCalendarType = calendarType;
					}
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private CalendarType GetCalendarType(string type)
	{
		return type switch
		{
			"gregorian" => CalendarType.Gregorian, 
			"gregorianArabic" => CalendarType.GregorianArabic, 
			"gregorianMeFrench" => CalendarType.GregorianMiddleEastFrench, 
			"gregorianUs" => CalendarType.GregorianEnglish, 
			"gregorianXlitEnglish" => CalendarType.GregorianTransliteratedEnglish, 
			"gregorianXlitFrench" => CalendarType.GregorianTransliteratedFrench, 
			"hebrew" => CalendarType.Hebrew, 
			"hijri" => CalendarType.Hijri, 
			"japan" => CalendarType.Japan, 
			"korea" => CalendarType.Korean, 
			"saka" => CalendarType.Saka, 
			"taiwan" => CalendarType.Taiwan, 
			"thai" => CalendarType.Thai, 
			_ => CalendarType.Gregorian, 
		};
	}

	private ContentControlDateStorageFormat GetDateStorageType(string type)
	{
		if (!(type == "date"))
		{
			if (type == "text")
			{
				return ContentControlDateStorageFormat.DateStorageText;
			}
			return ContentControlDateStorageFormat.DateStorageDateTime;
		}
		return ContentControlDateStorageFormat.DateStorageDate;
	}

	private void ParseMathMlElement(XmlReader reader, ParagraphItemCollection paraItems)
	{
		MathMLParser mathMLParser = new MathMLParser();
		XmlParagraphItem xmlParagraphItem = new XmlParagraphItem(ReadSingleNodeIntoStream(reader), m_doc);
		WMath wMath = new WMath(m_doc);
		paraItems.Add(wMath);
		XmlReader xmlReader = UtilityMethods.CreateReader(xmlParagraphItem.DataNode);
		if (xmlReader.LocalName == "oMathPara")
		{
			mathMLParser.ParseMathPara(xmlReader, wMath.MathParagraph, this);
			return;
		}
		OfficeMath officeMath = wMath.MathParagraph.Maths.Add(wMath.MathParagraph.Maths.Count) as OfficeMath;
		mathMLParser.ParseMath(xmlReader, officeMath, this);
	}

	internal override IOfficeRunFormat ParseMathControlFormat(XmlReader reader, IOfficeMathFunctionBase mathFunction)
	{
		WParagraph wParagraph = null;
		if (mathFunction != null)
		{
			wParagraph = GetMathOwnerParagraph(mathFunction);
		}
		WCharacterFormat wCharacterFormat = new WCharacterFormat(m_doc);
		ApplyDirectionalOverride(wCharacterFormat);
		if (wParagraph != null && wParagraph.ParaStyle != null)
		{
			wCharacterFormat.ApplyBase(wParagraph.ParaStyle.CharacterFormat);
		}
		ParseCharacterFormat(reader, wCharacterFormat, null);
		return wCharacterFormat;
	}

	internal override void ParseMathRun(XmlReader reader, IOfficeMathRunElement mathParaItem)
	{
		ParseRun(reader, null, mathParaItem, isAlreadyChecked: false, reader.NodeType, isMappedPictureContentControl: false);
	}

	private void ParseDocumentRelations(Stream stream)
	{
		XmlReader relReader = UtilityMethods.CreateReader(stream);
		ParseRelations(relReader, DocumentRelations);
	}

	private void ParseFontTableRelations(Stream stream)
	{
		XmlReader relReader = UtilityMethods.CreateReader(stream);
		ParseRelations(relReader, FontTableRelations);
	}

	private void ParseRelations(XmlReader relReader, Dictionary<string, DictionaryEntry> relations)
	{
		relReader.MoveToContent();
		if (relReader.LocalName != "Relationships")
		{
			relReader.ReadInnerXml();
		}
		else
		{
			if (relReader.IsEmptyElement)
			{
				return;
			}
			string localName = relReader.LocalName;
			bool flag = false;
			relReader.Read();
			flag = true;
			if (localName == relReader.LocalName && relReader.NodeType == XmlNodeType.EndElement)
			{
				return;
			}
			string text = null;
			string text2 = null;
			string text3 = null;
			do
			{
				if (!flag)
				{
					relReader.Read();
				}
				text = relReader.GetAttribute("Id");
				text2 = relReader.GetAttribute("Target");
				text3 = relReader.GetAttribute("Type");
				if (text != null && text2 != null && text3 != null)
				{
					DictionaryEntry value = new DictionaryEntry(text3, text2);
					relations.Add(text, value);
					if (relReader.GetAttribute("TargetMode") == "External" && !IsExternalHyperlink.ContainsKey(text))
					{
						IsExternalHyperlink.Add(text, value: true);
					}
				}
				flag = false;
			}
			while (relReader.LocalName != "Relationships");
		}
	}

	private void ParseCustomProperties(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "Properties")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		CustomDocumentProperties customDocumentProperties = m_doc.CustomDocumentProperties;
		SkipWhitespaces(reader);
		while (!reader.EOF)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "property")
				{
					ParseCustomProperty(reader, customDocumentProperties);
				}
			}
			else
			{
				reader.Skip();
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private void ParseCustomProperty(XmlReader reader, CustomDocumentProperties customProperties)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (customProperties == null)
		{
			throw new ArgumentNullException("customProperties");
		}
		if (reader.LocalName != "property")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		reader.GetAttribute("name");
		reader.MoveToElement();
		DocumentProperty documentProperty = null;
		string text = null;
		int result = 0;
		if (!(reader.LocalName == "property"))
		{
			return;
		}
		do
		{
			if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "property")
			{
				if (reader.MoveToAttribute("name"))
				{
					text = reader.Value;
				}
				if (reader.MoveToAttribute("pid"))
				{
					int.TryParse(reader.Value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
				}
			}
			else if (reader.NodeType == XmlNodeType.Element && text != null)
			{
				string localName = reader.LocalName;
				reader.Read();
				if (!localName.Equals("lpstr") && !localName.Equals("lpwstr"))
				{
					SkipWhitespaces(reader);
				}
				switch (localName)
				{
				case "i4":
				{
					float result4 = 0f;
					string value4 = reader.Value;
					if (!string.IsNullOrEmpty(value4))
					{
						float.TryParse(value4, NumberStyles.Number, CultureInfo.InvariantCulture, out result4);
						documentProperty = new DocumentProperty(text, (int)Math.Round(result4));
						m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
					}
					break;
				}
				case "r8":
				{
					double result2 = 0.0;
					string value2 = reader.Value;
					if (!string.IsNullOrEmpty(value2))
					{
						double.TryParse(value2, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
						documentProperty = new DocumentProperty(text, result2);
						m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
					}
					break;
				}
				case "lpstr":
				case "lpwstr":
				{
					string value5 = reader.Value;
					documentProperty = new DocumentProperty(text, UpdateText(value5));
					m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
					break;
				}
				case "filetime":
				{
					string value3 = reader.Value;
					if (!string.IsNullOrEmpty(value3))
					{
						DateTime result3 = default(DateTime);
						CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
						if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
						{
							cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
						}
						DateTime.TryParse(value3, cultureInfo, DateTimeStyles.AdjustToUniversal, out result3);
						documentProperty = new DocumentProperty(text, result3);
						m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
					}
					break;
				}
				case "bool":
				{
					string value = reader.Value;
					if (!string.IsNullOrEmpty(value))
					{
						documentProperty = new DocumentProperty(text, GetBoolValue(value));
						m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
					}
					break;
				}
				}
			}
			reader.Read();
		}
		while (!reader.EOF && reader.LocalName != "property");
	}

	private string UpdateText(string text)
	{
		text = XmlConvert.DecodeName(text);
		return text;
	}

	private void ParseCoreProperties(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "coreProperties")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		BuiltinDocumentProperties builtinDocumentProperties = m_doc.BuiltinDocumentProperties;
		CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
		if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
		{
			cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
		}
		while (reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "category":
					builtinDocumentProperties.Category = GetReaderElementValue(reader);
					break;
				case "created":
				{
					DateTime result3 = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result3);
					builtinDocumentProperties.CreateDate = result3;
					break;
				}
				case "creator":
					builtinDocumentProperties.Author = GetReaderElementValue(reader);
					break;
				case "description":
					builtinDocumentProperties.Comments = GetReaderElementValue(reader);
					break;
				case "keywords":
					builtinDocumentProperties.Keywords = GetReaderElementValue(reader);
					break;
				case "lastModifiedBy":
					builtinDocumentProperties.LastAuthor = GetReaderElementValue(reader);
					break;
				case "lastPrinted":
				{
					DateTime result2 = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result2);
					builtinDocumentProperties.LastPrinted = result2;
					break;
				}
				case "modified":
				{
					DateTime result = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
					builtinDocumentProperties.LastSaveDate = result;
					break;
				}
				case "subject":
					builtinDocumentProperties.Subject = GetReaderElementValue(reader);
					break;
				case "title":
					builtinDocumentProperties.Title = GetReaderElementValue(reader);
					break;
				case "revision":
					builtinDocumentProperties.RevisionNumber = GetReaderElementValue(reader);
					break;
				case "contentStatus":
					builtinDocumentProperties.ContentStatus = GetReaderElementValue(reader);
					break;
				default:
					reader.Skip();
					break;
				}
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private void ParseAppProperties(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "Properties")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		BuiltinDocumentProperties builtinDocumentProperties = m_doc.BuiltinDocumentProperties;
		while (reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string text = null;
				switch (reader.LocalName)
				{
				case "Template":
					builtinDocumentProperties.Template = GetReaderElementValue(reader);
					break;
				case "TotalTime":
				{
					text = GetReaderElementValue(reader);
					double result = 0.0;
					double.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
					builtinDocumentProperties.TotalEditingTime = TimeSpan.FromMinutes(Math.Round(result));
					break;
				}
				case "Pages":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Pagecount, GetAppProperty(text));
					break;
				case "Words":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Wordcount, GetAppProperty(text));
					break;
				case "Characters":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Charcount, GetAppProperty(text));
					break;
				case "Application":
					builtinDocumentProperties.ApplicationName = GetReaderElementValue(reader);
					break;
				case "DocSecurity":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.DocSecurity = GetAppProperty(text);
					break;
				case "Lines":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(BuiltInProperty.LineCount, GetAppProperty(text));
					break;
				case "Paragraphs":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(BuiltInProperty.ParagraphCount, GetAppProperty(text));
					break;
				case "Company":
					builtinDocumentProperties.Company = GetReaderElementValue(reader);
					break;
				case "Manager":
					builtinDocumentProperties.Manager = GetReaderElementValue(reader);
					break;
				case "AppVersion":
					AppVersion = GetReaderElementValue(reader);
					break;
				default:
					reader.Skip();
					break;
				}
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private int GetAppProperty(string attrValue)
	{
		float result = 0f;
		float.TryParse(attrValue, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
		return (int)result;
	}

	private void ParseWord2003DocumentProperties(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "DocumentProperties")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		BuiltinDocumentProperties builtinDocumentProperties = m_doc.BuiltinDocumentProperties;
		CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
		if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
		{
			cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
		}
		while (reader.NodeType != XmlNodeType.EndElement)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string text = null;
				switch (reader.LocalName)
				{
				case "Title":
					builtinDocumentProperties.Title = GetReaderElementValue(reader);
					break;
				case "Subject":
					builtinDocumentProperties.Subject = GetReaderElementValue(reader);
					break;
				case "Author":
					builtinDocumentProperties.Author = GetReaderElementValue(reader);
					break;
				case "Keywords":
					builtinDocumentProperties.Keywords = GetReaderElementValue(reader);
					break;
				case "Description":
					builtinDocumentProperties.Comments = GetReaderElementValue(reader);
					break;
				case "LastAuthor":
					builtinDocumentProperties.LastAuthor = GetReaderElementValue(reader);
					break;
				case "Revision":
					builtinDocumentProperties.RevisionNumber = GetReaderElementValue(reader);
					break;
				case "AppName":
					builtinDocumentProperties.ApplicationName = GetReaderElementValue(reader);
					break;
				case "TotalTime":
				{
					text = GetReaderElementValue(reader);
					double result4 = 0.0;
					double.TryParse(text, NumberStyles.Number, CultureInfo.InvariantCulture, out result4);
					builtinDocumentProperties.TotalEditingTime = TimeSpan.FromMinutes(Math.Round(result4));
					break;
				}
				case "LastPrinted":
				{
					DateTime result3 = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result3);
					builtinDocumentProperties.LastPrinted = result3;
					break;
				}
				case "Created":
				{
					DateTime result2 = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result2);
					builtinDocumentProperties.CreateDate = result2;
					break;
				}
				case "LastSaved":
				{
					DateTime result = default(DateTime);
					DateTime.TryParse(GetReaderElementValue(reader), cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
					builtinDocumentProperties.LastSaveDate = result;
					break;
				}
				case "Pages":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Pagecount, GetAppProperty(text));
					break;
				case "Words":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Wordcount, GetAppProperty(text));
					break;
				case "Characters":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(PIDSI.Charcount, GetAppProperty(text));
					break;
				case "Category":
					builtinDocumentProperties.Category = GetReaderElementValue(reader);
					break;
				case "Manager":
					builtinDocumentProperties.Manager = GetReaderElementValue(reader);
					break;
				case "Company":
					builtinDocumentProperties.Company = GetReaderElementValue(reader);
					break;
				case "Lines":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(BuiltInProperty.LineCount, GetAppProperty(text));
					break;
				case "Paragraphs":
					text = GetReaderElementValue(reader);
					builtinDocumentProperties.SetPropertyValue(BuiltInProperty.ParagraphCount, GetAppProperty(text));
					break;
				case "Version":
					AppVersion = GetReaderElementValue(reader);
					break;
				default:
					reader.Skip();
					break;
				}
			}
			else
			{
				reader.Skip();
			}
		}
	}

	private void ParseWord2003CustomDocumentproperties(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "CustomDocumentProperties")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		if (m_doc.CustomDocumentProperties == null)
		{
			throw new ArgumentNullException("customProperties");
		}
		DocumentProperty documentProperty = null;
		SkipWhitespaces(reader);
		while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != "CustomDocumentProperties")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				string attribute = reader.GetAttribute("dt", "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882");
				reader.Read();
				SkipWhitespaces(reader);
				string value = reader.Value;
				if (localName2 != null)
				{
					switch (attribute)
					{
					case "float":
						if (!string.IsNullOrEmpty(value))
						{
							float result = 0f;
							float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							documentProperty = new DocumentProperty(localName2, (int)Math.Round(result));
							m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
						}
						break;
					case "double":
						if (!string.IsNullOrEmpty(value))
						{
							double result3 = 0.0;
							double.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result3);
							documentProperty = new DocumentProperty(localName2, result3);
							m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
						}
						break;
					case "string":
						if (!string.IsNullOrEmpty(value))
						{
							documentProperty = new DocumentProperty(localName2, UpdateText(value));
							m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
						}
						break;
					case "dateTime.tz":
						if (!string.IsNullOrEmpty(value))
						{
							DateTime result2 = default(DateTime);
							CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
							if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
							{
								cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
							}
							DateTime.TryParse(value, cultureInfo, DateTimeStyles.AdjustToUniversal, out result2);
							documentProperty = new DocumentProperty(localName2, result2);
							m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
						}
						break;
					case "boolean":
						if (!string.IsNullOrEmpty(value))
						{
							documentProperty = new DocumentProperty(localName2, GetBoolValue(value));
							m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
						}
						break;
					}
				}
				reader.Read();
			}
			else
			{
				reader.Skip();
			}
			reader.Read();
		}
	}

	private void ParseList(XmlReader reader, FormatBase format)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		WParagraphFormat wParagraphFormat = format as WParagraphFormat;
		if (wParagraphFormat.OwnerBase == null)
		{
			return;
		}
		bool flag = false;
		WListFormat wListFormat = null;
		if (wParagraphFormat.OwnerBase is WParagraph)
		{
			wListFormat = (wParagraphFormat.OwnerBase as WParagraph).ListFormat;
			wListFormat.IsFormattingChange = wParagraphFormat.IsFormattingChange;
		}
		else if (wParagraphFormat.OwnerBase is WParagraphStyle)
		{
			wListFormat = (wParagraphFormat.OwnerBase as WParagraphStyle).ListFormat;
			wListFormat.IsFormattingChange = wParagraphFormat.IsFormattingChange;
			flag = true;
		}
		else if (wParagraphFormat.OwnerBase is WTableStyle)
		{
			wListFormat = (wParagraphFormat.OwnerBase as WTableStyle).ListFormat;
		}
		else
		{
			if (!(wParagraphFormat.OwnerBase is WNumberingStyle))
			{
				return;
			}
			wListFormat = (wParagraphFormat.OwnerBase as WNumberingStyle).ListFormat;
		}
		ParseListFormat(reader, wListFormat, localName);
		if (!flag)
		{
			return;
		}
		string text = null;
		if (wListFormat.CurrentListLevel != null)
		{
			foreach (KeyValuePair<string, string> item in StyleNameId)
			{
				if (item.Value == (wParagraphFormat.OwnerBase as WParagraphStyle).Name)
				{
					text = item.Key;
					break;
				}
			}
			if (wListFormat.CurrentListLevel.ParaStyleName == null)
			{
				if (text != null && StyleNameId.ContainsKey(text))
				{
					text = StyleNameId[text];
				}
				wListFormat.CurrentListLevel.ParaStyleName = text;
			}
		}
		else if (wParagraphFormat.OwnerBase is WParagraphStyle && wListFormat.ListLevelNumber > 0)
		{
			ListStyle listStyle = FindListStyle(wParagraphFormat.OwnerBase as WParagraphStyle);
			if (listStyle != null && listStyle.Levels.Count > wListFormat.ListLevelNumber)
			{
				text = (wParagraphFormat.OwnerBase as WParagraphStyle).Name;
				listStyle.Levels[wListFormat.ListLevelNumber].ParaStyleName = text;
			}
		}
	}

	private ListStyle FindListStyle(WParagraphStyle style)
	{
		WParagraphStyle baseStyle = style.BaseStyle;
		if (baseStyle == null)
		{
			return null;
		}
		while (baseStyle != null)
		{
			if (baseStyle.ListFormat.CurrentListStyle != null)
			{
				return baseStyle.ListFormat.CurrentListStyle;
			}
			baseStyle = baseStyle.BaseStyle;
		}
		return null;
	}

	private void ParseListFormat(XmlReader reader, WListFormat listFormat, string localName)
	{
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "ilvl":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						int result = 0;
						int.TryParse(attribute2, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
						if (result > 8)
						{
							result = 8;
						}
						listFormat.ListLevelNumber = result;
					}
					break;
				}
				case "numId":
				case "ilfo":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (attribute == "0" || string.IsNullOrEmpty(attribute))
					{
						listFormat.IsEmptyList = true;
					}
					else if (m_doc.ListStyleNames.ContainsKey(attribute))
					{
						string text = m_doc.ListStyleNames[attribute];
						ListStyle listStyle = m_doc.ListStyles.FindByName(text);
						if (text != null)
						{
							listFormat.ApplyStyle(text);
							if (listStyle != null)
							{
								WListLevel wListLevel = listStyle.Levels[listFormat.ListLevelNumber];
								ListType listTypeKey = ((wListLevel.PatternType == ListPatternType.Bullet || wListLevel.PatternType == ListPatternType.None) ? ListType.Bulleted : ListType.Numbered);
								listFormat.SetListTypeKey(listTypeKey);
							}
						}
						if (OverrideListStyleNames.ContainsKey(attribute))
						{
							listFormat.LFOStyleName = OverrideListStyleNames[attribute];
						}
					}
					else
					{
						UpdateListStyleForInvalidNumId(attribute, listFormat);
					}
					break;
				}
				}
			}
			reader.Read();
		}
	}

	private void UpdateListStyleForInvalidNumId(string id, WListFormat listFormat)
	{
		if (!IsFirstInvalidNumID)
		{
			ListStyle listStyle = new ListStyle(m_doc);
			listStyle.CreateDefListLevels(ListType.Numbered);
			foreach (WListLevel level in listStyle.Levels)
			{
				level.PatternType = ListPatternType.Arabic;
				level.NumberAlignment = ListNumberAlignment.Left;
				level.ParagraphFormat.SetPropertyValue(5, -36f);
			}
			UpdateListType(listStyle);
			UpdateStyleName(listStyle);
			if (!AbstractListStyleNames.ContainsKey(id))
			{
				AbstractListStyleNames.Add(id, listStyle.Name);
			}
			m_doc.ListStyleNames.Add(id, listStyle.Name);
			m_doc.ListStyles.Add(listStyle);
			IsFirstInvalidNumID = true;
			m_firstInvalidNumId = id;
		}
		else
		{
			m_doc.ListStyleNames.Add(id, AbstractListStyleNames[m_firstInvalidNumId]);
			if (!OverrideListStyleNames.ContainsKey(id))
			{
				ListOverrideStyle listOverrideStyle = new ListOverrideStyle(m_doc);
				listOverrideStyle.Name = "LfoStyle_" + Guid.NewGuid();
				listOverrideStyle.listStyleName = m_doc.ListStyleNames[id];
				OverrideListStyleNames.Add(id, listOverrideStyle.Name);
				m_doc.ListOverrides.Add(listOverrideStyle);
				for (int i = 0; i < 9; i++)
				{
					OverrideLevelFormat overrideLevelFormat = new OverrideLevelFormat(m_doc);
					listOverrideStyle.OverrideLevels.Add(i, overrideLevelFormat);
					overrideLevelFormat.StartAt = 1;
					overrideLevelFormat.OverrideStartAtValue = true;
				}
			}
		}
		listFormat.ApplyStyle(m_doc.ListStyleNames[id]);
		if (OverrideListStyleNames.ContainsKey(id))
		{
			listFormat.LFOStyleName = OverrideListStyleNames[id];
		}
	}

	private void GetListFormatBaseStyleName(ListStyle listStyle, ref string styleName)
	{
		if (listStyle == null || listStyle.BaseListStyleName == null || !(listStyle.BaseListStyleName != string.Empty))
		{
			return;
		}
		if (m_doc.ListStyleNames.ContainsKey(listStyle.BaseListStyleName))
		{
			string key = m_doc.ListStyleNames[listStyle.BaseListStyleName];
			if (m_doc.ListStyleNames.ContainsKey(key))
			{
				styleName = m_doc.ListStyleNames[key];
			}
		}
		else if (StyleNameId.ContainsKey(listStyle.BaseListStyleName))
		{
			IStyle style = m_doc.Styles.FindByName(StyleNameId[listStyle.BaseListStyleName]);
			if (style != null && style.StyleType == StyleType.NumberingStyle && (style as WNumberingStyle).ListFormat != null && (style as WNumberingStyle).ListFormat.CurrentListStyle != null)
			{
				styleName = (style as WNumberingStyle).ListFormat.CurrentListStyle.Name;
			}
		}
	}

	private void ParseNumberings(XmlReader reader)
	{
		if (reader.NamespaceURI == m_strictNameSpace)
		{
			IsStrict = true;
		}
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (reader.NodeType != XmlNodeType.Element && (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement))
		{
			reader.Read();
		}
		string text = (IsWord2003ML ? "lists" : "numbering");
		if (localName != text)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		SkipWhitespaces(reader);
		Dictionary<long, string> dictionary = new Dictionary<long, string>();
		Dictionary<string, long> dictionary2 = new Dictionary<string, long>();
		while (reader.LocalName != localName)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (IsWord2003ML)
				{
					ParseWord2003MLNumberings(reader, dictionary, dictionary2);
				}
				else
				{
					ParseDocxNumberings(reader, dictionary, dictionary2);
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		dictionary.Clear();
		dictionary2.Clear();
		UpdateLinkedListStyles();
		UpdateListStyleNames();
	}

	private void UpdateListStyleNames()
	{
		foreach (string item in new List<string>(m_doc.ListStyleNames.Keys))
		{
			string key = m_doc.ListStyleNames[item];
			m_doc.ListStyleNames[item] = AbstractListStyleNames[key];
			if (OverrideListStyleNames.ContainsKey(item))
			{
				ListOverrideStyle listOverrideStyle = m_doc.ListOverrides.FindByName(OverrideListStyleNames[item]);
				listOverrideStyle.listStyleName = m_doc.ListStyleNames[item];
				ListStyle listStyle = m_doc.ListStyles.FindByName(listOverrideStyle.listStyleName);
				if (listStyle != null)
				{
					listOverrideStyle.ListID = listStyle.ListID;
				}
			}
		}
	}

	private void UpdateLinkedListStyles()
	{
		for (int i = 0; i < m_doc.ListStyles.Count; i++)
		{
			ListStyle listStyle = m_doc.ListStyles[i];
			if (!string.IsNullOrEmpty(listStyle.BaseListStyleName))
			{
				ListStyle listStyle2 = FindByStyleLink(listStyle.BaseListStyleName);
				if (listStyle2 != null)
				{
					listStyle2 = listStyle2.Clone() as ListStyle;
					listStyle2.SetNewName(m_doc);
					UpdateAbstractStyleName(listStyle.Name, listStyle2.Name);
					m_doc.ListStyles.InnerList.Insert(i, listStyle2);
					m_doc.ListStyles.InnerList.Remove(listStyle);
				}
				else
				{
					listStyle.BaseListStyleName = string.Empty;
				}
			}
		}
	}

	private void UpdateAbstractStyleName(string oldName, string newName)
	{
		new List<string>();
		foreach (KeyValuePair<string, string> abstractListStyleName in AbstractListStyleNames)
		{
			if (abstractListStyleName.Value == oldName)
			{
				AbstractListStyleNames[abstractListStyleName.Key] = newName;
				break;
			}
		}
	}

	private ListStyle FindByStyleLink(string styleLinkName)
	{
		foreach (ListStyle listStyle in m_doc.ListStyles)
		{
			if (listStyle.StyleLink == styleLinkName)
			{
				return listStyle;
			}
		}
		return null;
	}

	private void ParseWord2003MLNumberings(XmlReader reader, Dictionary<long, string> nsidCollection, Dictionary<string, long> abstractNumCollection)
	{
		switch (reader.LocalName)
		{
		case "listPicBullet":
			ParsePictureBullet(reader);
			break;
		case "listDef":
			ParseAbstractNum(reader, nsidCollection, abstractNumCollection);
			break;
		case "list":
			ParseListNum(reader, nsidCollection, abstractNumCollection);
			break;
		}
	}

	private void ParseDocxNumberings(XmlReader reader, Dictionary<long, string> nsidCollection, Dictionary<string, long> abstractNumCollection)
	{
		switch (reader.LocalName)
		{
		case "numPicBullet":
			ParsePictureBullet(reader);
			break;
		case "abstractNum":
			ParseAbstractNum(reader, nsidCollection, abstractNumCollection);
			break;
		case "num":
			ParseListNum(reader, nsidCollection, abstractNumCollection);
			break;
		}
	}

	private void ParseListNum(XmlReader reader, Dictionary<long, string> nsidCollection, Dictionary<string, long> abstractNumCollection)
	{
		if (reader == null)
		{
			throw new ArgumentException("reader");
		}
		string text = (IsWord2003ML ? "list" : "num");
		string name = (IsWord2003ML ? "ilfo" : "numId");
		if (reader.LocalName != text)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "abstractNumId":
				case "ilst":
					if (abstractNumCollection != null && nsidCollection != null && m_doc != null && (IsWord2003ML ? (reader.LocalName == "ilst") : (reader.LocalName == "abstractNumId")))
					{
						string abstractNumID = GetAbstractNumID(nsidCollection, abstractNumCollection, reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace));
						if (AbstractListStyleNames.ContainsKey(abstractNumID) && attribute != null && !string.IsNullOrEmpty(abstractNumID) && !m_doc.ListStyleNames.ContainsKey(attribute))
						{
							m_doc.ListStyleNames.Add(attribute, abstractNumID);
						}
					}
					break;
				case "lvlOverride":
					ParseLevelOverride(reader, attribute);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
		}
	}

	private string GetAbstractNumID(Dictionary<long, string> nsidCollection, Dictionary<string, long> abstractNumCollection, string abstractNumId)
	{
		if (abstractNumCollection.ContainsKey(abstractNumId))
		{
			long key = abstractNumCollection[abstractNumId];
			if (nsidCollection.ContainsKey(key))
			{
				return nsidCollection[key];
			}
		}
		return abstractNumId;
	}

	private void ParseLevelOverride(XmlReader reader, string numId)
	{
		if (reader == null)
		{
			throw new ArgumentException("reader");
		}
		if (reader.LocalName != "lvlOverride")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		string localName = reader.LocalName;
		string attribute = reader.GetAttribute("ilvl", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!reader.IsEmptyElement)
		{
			reader.Read();
		}
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		ListOverrideStyle listOverrideStyle = null;
		if (!OverrideListStyleNames.ContainsKey(numId))
		{
			listOverrideStyle = new ListOverrideStyle(m_doc);
			listOverrideStyle.Name = "LfoStyle_" + Guid.NewGuid();
			OverrideListStyleNames.Add(numId, listOverrideStyle.Name);
			m_doc.ListOverrides.Add(listOverrideStyle);
		}
		else
		{
			listOverrideStyle = m_doc.ListOverrides.FindByName(OverrideListStyleNames[numId]);
		}
		OverrideLevelFormat overrideLevelFormat = new OverrideLevelFormat(m_doc);
		if (!string.IsNullOrEmpty(attribute))
		{
			int levelNumber = ParseIntegerValue(attribute);
			listOverrideStyle.OverrideLevels.Add(levelNumber, overrideLevelFormat);
			if (localName == "lvlOverride")
			{
				ParseLevelOverride(reader, overrideLevelFormat);
			}
		}
	}

	private void ParseLevelOverride(XmlReader reader, OverrideLevelFormat levelFormat)
	{
		SkipWhitespaces(reader);
		while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != "lvlOverride")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!(localName == "startOverride"))
				{
					if (localName == "lvl")
					{
						levelFormat.OverrideFormatting = true;
						ParseListLevel(reader, levelFormat.OverrideListLevel);
					}
				}
				else
				{
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute))
					{
						float result = 0f;
						levelFormat.StartAt = (float.TryParse(attribute, NumberStyles.Float, CultureInfo.InvariantCulture, out result) ? ((int)result) : 0);
					}
					levelFormat.OverrideStartAtValue = true;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseAbstractNum(XmlReader reader, Dictionary<long, string> nsidCollection, Dictionary<string, long> abstractNumCollection)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		string text = (IsWord2003ML ? "listDef" : "abstractNum");
		string name = (IsWord2003ML ? "listDefId" : "abstractNumId");
		if (reader.LocalName != text)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == null || AbstractListStyleNames.ContainsKey(attribute))
		{
			reader.Skip();
			return;
		}
		ListStyle listStyle = new ListStyle(m_doc);
		ParseListStyle(reader, listStyle);
		abstractNumCollection.Add(attribute, listStyle.ListID);
		long num = 1720085641L;
		if (listStyle.ListID == num || !nsidCollection.ContainsKey(listStyle.ListID))
		{
			if (listStyle.ListID != num)
			{
				nsidCollection.Add(listStyle.ListID, attribute);
			}
			m_doc.ListStyles.Add(listStyle);
			UpdateListType(listStyle);
			UpdateStyleName(listStyle);
			listStyle.IsSimple = listStyle.Levels.Count == 1;
			AbstractListStyleNames.Add(attribute, listStyle.Name);
		}
	}

	private void ParseListStyle(XmlReader reader, ListStyle listStyle)
	{
		if (listStyle == null)
		{
			throw new ArgumentException("list style");
		}
		string text = (IsWord2003ML ? "listDef" : "abstractNum");
		if (reader.LocalName != text)
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		listStyle.CreateEmptyListLevels(isOneLevelList: false);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "lsid":
				case "nsid":
					if (IsWord2003ML ? (reader.LocalName == "lsid") : (reader.LocalName == "nsid"))
					{
						string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute2))
						{
							long result2 = 0L;
							long.TryParse(attribute2, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out result2);
							listStyle.ListID = result2;
							flag = true;
						}
					}
					break;
				case "plt":
				case "multiLevelType":
					if ((IsWord2003ML ? (reader.LocalName == "plt") : (reader.LocalName == "multiLevelType")) && reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace).ToLower() == "hybridmultilevel")
					{
						listStyle.IsHybrid = true;
					}
					break;
				case "numStyleLink":
				case "listStyleLink":
					if (IsWord2003ML ? (reader.LocalName == "listStyleLink") : (reader.LocalName == "numStyleLink"))
					{
						listStyle.BaseListStyleName = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					}
					break;
				case "styleLink":
					if (reader.LocalName == "styleLink")
					{
						listStyle.StyleLink = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					}
					break;
				case "lvl":
				{
					string attribute = reader.GetAttribute("ilvl", IsStrict ? m_strictNameSpace : m_nameSpace);
					WListLevel level = listStyle.Levels[0];
					if (!string.IsNullOrEmpty(attribute))
					{
						int result = 0;
						int.TryParse(attribute, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
						level = listStyle.Levels[result];
					}
					ParseListLevel(reader, level);
					break;
				}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		if (!flag)
		{
			listStyle.SetNewListID(m_doc);
		}
	}

	private void ParseListLevel(XmlReader reader, WListLevel level)
	{
		if (level == null)
		{
			throw new ArgumentException("list level");
		}
		if (reader.LocalName != "lvl")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "lvl")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "start":
				{
					string attribute5 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute5))
					{
						float result = 0f;
						level.StartAt = ((!float.TryParse(attribute5, NumberStyles.Float, CultureInfo.InvariantCulture, out result)) ? 1 : ((int)result));
					}
					break;
				}
				case "pPr":
					ParseParagraphFormat(reader, level.ParagraphFormat);
					break;
				case "rPr":
					ParseCharacterFormat(reader, level.CharacterFormat, null);
					break;
				case "isLgl":
					level.IsLegalStyleNumbering = GetBooleanValue(reader);
					break;
				case "lvlRestart":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					level.restartLevel = ParseIntegerValue(attribute3);
					if (attribute3 == "0")
					{
						level.NoRestartByHigher = true;
					}
					break;
				}
				case "pStyle":
				{
					string attribute8 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute8) && StyleNameId.ContainsKey(attribute8))
					{
						level.ParaStyleName = StyleNameId[attribute8];
					}
					break;
				}
				case "lvlPicBulletId":
				{
					string attribute6 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute6) && PictureBullet.ContainsKey(attribute6))
					{
						level.PicBullet = PictureBullet[attribute6];
					}
					if (level.PicBullet != null && level.PicBullet.ImageRecord == null && level.PicBullet.OPictureHRef == null)
					{
						level.IsEmptyPicture = true;
					}
					break;
				}
				case "nfc":
				case "numFmt":
					if (IsWord2003ML ? (reader.LocalName == "nfc") : (reader.LocalName == "numFmt"))
					{
						string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
						level.PatternType = GetLevelNumberFormat(attribute2);
					}
					break;
				case "lvlText":
				{
					string attribute7 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute7))
					{
						ParseLevelText(level, attribute7);
					}
					break;
				}
				case "lvlJc":
				{
					string attribute4 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					level.NumberAlignment = ParseLevelJc(attribute4);
					break;
				}
				case "suff":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					level.FollowCharacter = GetFollowChar(attribute.ToLower());
					break;
				}
				case "legacy":
					ParseLegacyProperties(reader, level);
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseLegacyProperties(XmlReader reader, WListLevel level)
	{
		switch (reader.GetAttribute("legacy", IsStrict ? m_strictNameSpace : m_nameSpace))
		{
		case "0":
		case "false":
		case "off":
			level.Word6Legacy = false;
			break;
		default:
			level.Word6Legacy = true;
			break;
		}
		string attribute = reader.GetAttribute("legacySpace", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			float result = 0f;
			if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				level.LegacySpace = (int)result;
			}
		}
		attribute = reader.GetAttribute("legacyIndent", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			float result2 = 0f;
			if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result2))
			{
				level.LegacyIndent = (int)result2;
			}
		}
	}

	private FollowCharacterType GetFollowChar(string levelFollow)
	{
		if (!(levelFollow == "tab"))
		{
			if (levelFollow == "space")
			{
				return FollowCharacterType.Space;
			}
			return FollowCharacterType.Nothing;
		}
		return FollowCharacterType.Tab;
	}

	private ListNumberAlignment ParseLevelJc(string justification)
	{
		switch (justification)
		{
		case "center":
			return ListNumberAlignment.Center;
		case "end":
		case "right":
			return ListNumberAlignment.Right;
		default:
			return ListNumberAlignment.Left;
		}
	}

	private void ParseLevelText(WListLevel level, string levelText)
	{
		string value = "%" + (level.LevelNumber + 1);
		int num = levelText.IndexOf(value);
		if (num == -1 && levelText.Length > 1 && levelText.IndexOf('%') == 0 && levelText.IndexOf('.') == 2 && level.LevelNumber == int.Parse(levelText[1].ToString()))
		{
			int num2 = int.Parse(levelText[1].ToString());
			level.LevelText = levelText;
			value = "%" + num2;
			num = levelText.IndexOf(value);
		}
		string text = null;
		string text2 = null;
		if (num != -1)
		{
			text = levelText.Substring(0, num);
			if (level.PatternType != ListPatternType.Bullet)
			{
				text = level.CheckNumberPrefOrSuf(text);
			}
			int num3 = num + 2;
			text2 = levelText.Substring(num3, levelText.Length - num3);
		}
		if (level.PatternType == ListPatternType.Bullet)
		{
			if (num != -1)
			{
				level.BulletCharacter = text;
				level.BulletCharacter += text2;
			}
			else
			{
				level.BulletCharacter = levelText;
			}
			return;
		}
		level.NumberPrefix = text;
		level.NumberSuffix = text2;
		if (level.PatternType == ListPatternType.None)
		{
			if (num != -1)
			{
				level.BulletCharacter = text;
				level.BulletCharacter += text2;
			}
			else
			{
				level.BulletCharacter = levelText;
			}
		}
		if (text == null && text2 == null)
		{
			level.LevelText = levelText;
		}
	}

	private ListPatternType GetLevelNumberFormat(string pattern)
	{
		if (IsWord2003ML)
		{
			switch (pattern)
			{
			case "47":
				return ListPatternType.None;
			case "0":
				return ListPatternType.Arabic;
			case "1":
				return ListPatternType.UpRoman;
			case "2":
				return ListPatternType.LowRoman;
			case "3":
				return ListPatternType.UpLetter;
			case "4":
				return ListPatternType.LowLetter;
			case "5":
				return ListPatternType.Ordinal;
			case "7":
				return ListPatternType.OrdinalText;
			case "22":
				return ListPatternType.LeadingZero;
			case "6":
				return ListPatternType.Number;
			case "20":
				return ListPatternType.FarEast;
			case "45":
				return ListPatternType.Special;
			}
		}
		else
		{
			switch (pattern)
			{
			case "none":
				return ListPatternType.None;
			case "decimal":
				return ListPatternType.Arabic;
			case "upperRoman":
				return ListPatternType.UpRoman;
			case "lowerRoman":
				return ListPatternType.LowRoman;
			case "upperLetter":
				return ListPatternType.UpLetter;
			case "lowerLetter":
				return ListPatternType.LowLetter;
			case "ordinal":
				return ListPatternType.Ordinal;
			case "ordinalText":
				return ListPatternType.OrdinalText;
			case "decimalZero":
				return ListPatternType.LeadingZero;
			case "cardinalText":
				return ListPatternType.Number;
			case "aiueoFullWidth":
				return ListPatternType.FarEast;
			case "russianLower":
				return ListPatternType.Special;
			case "chineseCountingThousand":
				return ListPatternType.ChineseCountingThousand;
			case "japaneseCounting":
				return ListPatternType.KanjiDigit;
			}
		}
		return ListPatternType.Bullet;
	}

	private void UpdateListType(ListStyle listStyle)
	{
		listStyle.ListType = ListType.Bulleted;
		foreach (WListLevel level in listStyle.Levels)
		{
			if (level.PatternType != ListPatternType.Bullet)
			{
				listStyle.ListType = ListType.Numbered;
				break;
			}
		}
	}

	private void UpdateStyleName(ListStyle listStyle)
	{
		if (listStyle.ListType == ListType.Numbered)
		{
			listStyle.Name = "Numbered_" + Guid.NewGuid();
		}
		else
		{
			listStyle.Name = "Bulleted_" + Guid.NewGuid();
		}
	}

	private void ParsePictureBullet(XmlReader reader)
	{
		string name = (IsWord2003ML ? "listPicBulletId" : "numPicBulletId");
		string text = (IsWord2003ML ? "listPicBullet" : "numPicBullet");
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		byte[] array = null;
		while (reader.LocalName != "shape")
		{
			reader.Read();
			if (reader.LocalName == "binData" && IsWord2003ML)
			{
				string attribute2 = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
				if (!string.IsNullOrEmpty(attribute2) && !attribute2.ToLower().Contains(".wmz") && !attribute2.ToLower().Contains(".emz"))
				{
					try
					{
						array = Convert.FromBase64String(Read2003ImageBase64String(reader, null));
					}
					catch
					{
						return;
					}
				}
			}
			if (reader.LocalName == text)
			{
				return;
			}
		}
		string size = ParsePictureBulletStyle(reader);
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			string text2 = null;
			if (localName == "imagedata")
			{
				text2 = ParsePictureId(reader);
			}
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				if (localName != "imagedata" && (!(localName == "shape") || reader.NodeType != XmlNodeType.EndElement))
				{
					localName = reader.LocalName;
				}
				while (localName != "imagedata" && (!(localName == "shape") || reader.NodeType != XmlNodeType.EndElement))
				{
					reader.Read();
					localName = reader.LocalName;
				}
				if (localName == "imagedata")
				{
					if (text2 == null)
					{
						text2 = ParsePictureId(reader);
					}
					if ((text2 == null || text2.Length == 0) && !IsWord2003ML)
					{
						return;
					}
					if (m_doc != null)
					{
						WPicture wPicture = new WPicture(m_doc);
						if (IsWord2003ML && array != null)
						{
							wPicture.LoadImage(array);
						}
						else
						{
							LoadImage(wPicture, text2, isHeaderFooter: false, isPicBullet: true);
						}
						ProcessPictureStyle(wPicture, size);
						if (attribute == string.Empty || wPicture.ImageRecord == null)
						{
							return;
						}
						if (attribute != null)
						{
							PictureBullet.Add(attribute, wPicture);
						}
					}
				}
			}
			else
			{
				while (reader.LocalName != text)
				{
					reader.Read();
				}
			}
		}
		else if (reader.LocalName == "shape")
		{
			WPicture wPicture2 = new WPicture(m_doc);
			ProcessPictureStyle(wPicture2, size);
			if (attribute == string.Empty)
			{
				return;
			}
			if (attribute != null)
			{
				PictureBullet.Add(attribute, wPicture2);
			}
		}
		while (reader.LocalName != text)
		{
			reader.Read();
		}
	}

	private void ProcessPictureStyle(WPicture picture, string size)
	{
		string[] array = size.Split(new char[1] { ';' });
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			string text = array[i];
			if (StartsWithExt(text, "width:"))
			{
				text = text.Replace("width:", string.Empty);
				picture.Width = GetPointValue(text);
			}
			else if (StartsWithExt(text, "height:"))
			{
				text = text.Replace("height:", string.Empty);
				picture.Height = GetPointValue(text);
			}
		}
	}

	private float ParseSize(string partString)
	{
		if (partString.EndsWith("in"))
		{
			int result = 0;
			int.TryParse(partString.Replace("in", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)UnitsConvertor.Instance.ConvertUnits(result, PrintUnits.Inch, PrintUnits.Point);
		}
		partString = partString.Replace("pt", string.Empty);
		return ParseFloatVal(partString);
	}

	private string ParsePictureId(XmlReader reader)
	{
		if (reader.LocalName != "imagedata")
		{
			throw new XmlException("imagedata - relationship id of shape");
		}
		return reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
	}

	private string ParsePictureBulletStyle(XmlReader reader)
	{
		if (reader.LocalName != "shape")
		{
			throw new XmlException("shape - Picture bullet");
		}
		return reader.GetAttribute("style");
	}

	private void ParseStyles(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "styles")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		Dictionary<int, string> dictionary = new Dictionary<int, string>();
		List<int> paraLinkStyleIndex = new List<int>();
		while (reader.LocalName != "styles")
		{
			bool flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "docDefaults":
					if (!IsWord2003ML)
					{
						ParseDocDefaults(reader);
					}
					break;
				case "latentStyles":
					if (IsWord2003ML)
					{
						reader.Read();
					}
					else
					{
						ParseLatentStyles(reader);
					}
					flag = true;
					break;
				case "style":
					flag = ParseStyle(reader, dictionary, paraLinkStyleIndex);
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Skip();
			}
			SkipWhitespaces(reader);
		}
		UpdateBaseStyles();
		UpdateLinkName(dictionary, paraLinkStyleIndex);
		dictionary.Clear();
		UpdateListInStyles();
	}

	private void Parse2003XmlStyles(XmlReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "styles")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		Dictionary<int, string> dictionary = new Dictionary<int, string>();
		List<int> paraLinkStyleIndex = new List<int>();
		while (reader.LocalName != "styles")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "docDefaults":
					ParseDocDefaults(reader);
					break;
				case "latentStyles":
					ParseLatentStyles(reader);
					flag = true;
					break;
				case "style":
					flag = ParseStyle(reader, dictionary, paraLinkStyleIndex);
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Skip();
			}
			SkipWhitespaces(reader);
		}
		UpdateBaseStyles();
		UpdateLinkName(dictionary, paraLinkStyleIndex);
		dictionary.Clear();
		UpdateListInStyles();
	}

	private void UpdateBaseStyles()
	{
		if (m_baseStyleNames == null)
		{
			return;
		}
		foreach (string key in m_baseStyleNames.Keys)
		{
			Style style = m_doc.Styles.FindByName(StyleNameId[key]) as Style;
			if (StyleNameId.ContainsKey(m_baseStyleNames[key]))
			{
				Style style2 = m_doc.Styles.FindByName(StyleNameId[m_baseStyleNames[key]]) as Style;
				if (style != null && style2 != null && (style2.BaseStyle == null || (style2.BaseStyle != null && style2.BaseStyle.Name != style.Name)))
				{
					style.ApplyBaseStyle(StyleNameId[m_baseStyleNames[key]]);
				}
			}
		}
	}

	private void UpdateListInStyles()
	{
		foreach (IStyle style in m_doc.Styles)
		{
			if (style is WParagraphStyle)
			{
				string styleName = null;
				ListStyle currentListStyle = (style as WParagraphStyle).ListFormat.CurrentListStyle;
				GetListFormatBaseStyleName(currentListStyle, ref styleName);
				if (styleName != null)
				{
					(style as WParagraphStyle).ListFormat.ApplyStyle(styleName);
				}
			}
		}
	}

	private void UpdateLinkName(Dictionary<int, string> linkStyleNamesReferByCharacterStyle, List<int> paraLinkStyleIndex)
	{
		if (m_linkStyleNames != null)
		{
			List<string> list = new List<string>();
			list.AddRange(m_linkStyleNames.Values);
			Dictionary<string, int> dictionary = CountOccurrencesOfValue(list);
			list.Clear();
			int num = 0;
			foreach (string key2 in m_linkStyleNames.Keys)
			{
				if (dictionary[m_linkStyleNames[key2]] == 1)
				{
					Style style = m_doc.Styles[paraLinkStyleIndex[num]] as Style;
					string key = m_linkStyleNames[key2];
					if (StyleNameId.ContainsKey(key))
					{
						style.LinkedStyleName = StyleNameId[key];
					}
				}
				else
				{
					if (linkStyleNamesReferByCharacterStyle.ContainsValue(key2))
					{
						foreach (int key3 in linkStyleNamesReferByCharacterStyle.Keys)
						{
							if (linkStyleNamesReferByCharacterStyle[key3] == key2)
							{
								(m_doc.Styles[key3] as Style).LinkedStyleName = null;
							}
						}
					}
					linkStyleNamesReferByCharacterStyle.Clear();
					(m_doc.Styles[paraLinkStyleIndex[num]] as Style).LinkedStyleName = null;
					dictionary[m_linkStyleNames[key2]]--;
				}
				num++;
			}
		}
		if (linkStyleNamesReferByCharacterStyle != null)
		{
			List<string> list2 = new List<string>();
			list2.AddRange(linkStyleNamesReferByCharacterStyle.Values);
			Dictionary<string, int> dictionary2 = CountOccurrencesOfValue(list2);
			list2.Clear();
			foreach (int key4 in linkStyleNamesReferByCharacterStyle.Keys)
			{
				if (dictionary2[linkStyleNamesReferByCharacterStyle[key4]] > 1)
				{
					(m_doc.Styles[key4] as Style).LinkedStyleName = null;
					dictionary2[linkStyleNamesReferByCharacterStyle[key4]]--;
				}
			}
		}
		linkStyleNamesReferByCharacterStyle.Clear();
	}

	private Dictionary<string, int> CountOccurrencesOfValue(List<string> list)
	{
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		foreach (string item in list)
		{
			if (dictionary.ContainsKey(item))
			{
				dictionary[item]++;
			}
			else
			{
				dictionary[item] = 1;
			}
		}
		return dictionary;
	}

	private bool ParseStyle(XmlReader reader, Dictionary<int, string> linkStyleNamesReferByCharacterStyle, List<int> paraLinkStyleIndex)
	{
		string styleNameId = string.Empty;
		if (reader.NamespaceURI == m_strictNameSpace)
		{
			IsStrict = true;
		}
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "style")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (!reader.IsEmptyElement)
		{
			string text = "paragraph";
			string text2 = string.Empty;
			string text3 = null;
			if (reader.HasAttributes)
			{
				string text4 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace).ToLower();
				text = (string.IsNullOrEmpty(text4) ? text : text4);
				text4 = reader.GetAttribute("styleId", IsStrict ? m_strictNameSpace : m_nameSpace);
				text2 = (string.IsNullOrEmpty(text4) ? text2 : text4);
				text4 = reader.GetAttribute("customStyle", IsStrict ? m_strictNameSpace : m_nameSpace);
				text3 = (string.IsNullOrEmpty(text4) ? text3 : text4);
			}
			string localName = reader.LocalName;
			reader.Read();
			if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
			{
				return false;
			}
			switch (text)
			{
			case "list":
				if (!IsWord2003ML)
				{
					break;
				}
				goto case "character";
			case "character":
			case "paragraph":
			case "table":
			case "numbering":
			{
				Style style = CreateStyle(text);
				if (!string.IsNullOrEmpty(text2))
				{
					string text6 = (style.Name = text2);
					styleNameId = text6;
				}
				if (!string.IsNullOrEmpty(text3) && !IsWord2003ML)
				{
					style.IsCustom = XmlConvert.ToBoolean(text3);
				}
				if (reader.NodeType != XmlNodeType.Element)
				{
					reader.MoveToElement();
				}
				ParseStyleProperties(reader, style, linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex, ref styleNameId, localName);
				if (!string.IsNullOrEmpty(style.StyleIDName))
				{
					m_doc.Styles.Add(style);
				}
				break;
			}
			}
		}
		return false;
	}

	private void ParseStyleProperties(XmlReader reader, Style style, Dictionary<int, string> linkStyleNamesReferByCharacterStyle, List<int> paraLinkStyleIndex, ref string styleNameId, string localName)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (style == null)
		{
			throw new ArgumentException("style");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (localName != "style")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		bool flag = false;
		bool flag2 = false;
		string text = style.Name;
		bool flag3 = true;
		SkipWhitespaces(reader);
		bool flag4 = false;
		while (reader.LocalName != "style")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "rPr":
				{
					WCharacterFormat characterFormat = GetCharacterFormat(style);
					ParseCharacterFormat(reader, characterFormat, null);
					break;
				}
				case "pPr":
				{
					if (style.StyleType == StyleType.CharacterStyle)
					{
						SkipCurrentElement(reader, reader.LocalName);
						break;
					}
					WParagraphFormat paragraphFormat = GetParagraphFormat(style);
					ParseParagraphFormat(reader, paragraphFormat);
					break;
				}
				case "tblPr":
					if (style.StyleType != StyleType.TableStyle)
					{
						SkipCurrentElement(reader, reader.LocalName);
					}
					else
					{
						ParseTableStyleTableProperties(reader, (style as WTableStyle).TableProperties);
					}
					break;
				case "trPr":
					if (style.StyleType != StyleType.TableStyle)
					{
						SkipCurrentElement(reader, reader.LocalName);
					}
					else
					{
						ParseTableStyleRowProperties(reader, (style as WTableStyle).RowProperties);
					}
					break;
				case "tcPr":
					if (style.StyleType != StyleType.TableStyle)
					{
						SkipCurrentElement(reader, reader.LocalName);
					}
					else
					{
						ParseTableStyleCellProperties(reader, (style as WTableStyle).CellProperties);
					}
					break;
				case "tblStylePr":
					ParseConditionalFormattingStyleProperties(reader, style);
					break;
				case "semiHidden":
					style.IsSemiHidden = GetBooleanValue(reader);
					break;
				case "unhideWhenUsed":
					if (!IsWord2003ML)
					{
						style.UnhideWhenUsed = GetBooleanValue(reader);
					}
					break;
				case "qFormat":
					if (!IsWord2003ML)
					{
						style.IsPrimaryStyle = GetBooleanValue(reader);
					}
					break;
				case "link":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (StyleNameId.ContainsKey(attribute2))
					{
						style.LinkedStyleName = StyleNameId[attribute2];
						if (!linkStyleNamesReferByCharacterStyle.ContainsKey(StyleNameId.Count - 1))
						{
							linkStyleNamesReferByCharacterStyle.Add(StyleNameId.Count - 1, StyleNameId[attribute2]);
						}
						break;
					}
					int num = 0;
					bool flag5 = false;
					foreach (KeyValuePair<string, string> linkStyleName in LinkStyleNames)
					{
						if (linkStyleName.Key == style.Name)
						{
							LinkStyleNames[style.Name] = attribute2;
							paraLinkStyleIndex.RemoveAt(num);
							paraLinkStyleIndex.Insert(num, StyleNameId.Count - 1);
							flag5 = true;
							break;
						}
						num++;
					}
					if (!flag5)
					{
						LinkStyleNames.Add(style.Name, attribute2);
						flag4 = true;
					}
					break;
				}
				case "next":
				{
					string attribute4 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					style.NextStyle = attribute4;
					break;
				}
				case "name":
					flag3 = false;
					while (reader.LocalName == "name" && reader.NodeType != XmlNodeType.EndElement)
					{
						text = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
						reader.Read();
						SkipWhitespaces(reader);
					}
					if (string.IsNullOrEmpty(styleNameId))
					{
						styleNameId = text;
						if (string.IsNullOrEmpty(text))
						{
							return;
						}
						style.SetStyleName(text);
					}
					AddStyleNameID(style, text);
					flag = true;
					break;
				case "basedOn":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					flag2 = true;
					if (!StyleNameId.ContainsKey(attribute3))
					{
						if (!BaseStyleNames.ContainsKey(styleNameId))
						{
							BaseStyleNames.Add(styleNameId, attribute3);
						}
					}
					else if (m_doc.Styles.FindByName(StyleNameId[attribute3]) == null)
					{
						BaseStyleNames.Add(styleNameId, attribute3);
					}
					else
					{
						style.ApplyBaseStyle(StyleNameId[attribute3]);
					}
					break;
				}
				case "numPr":
					if (!IsWord2003ML)
					{
						WParagraphFormat format = null;
						if (style is WParagraphStyle)
						{
							format = (style as WParagraphStyle).ParagraphFormat;
						}
						else if (style is WTableStyle)
						{
							format = (style as WTableStyle).ParagraphFormat;
						}
						else if (style is WNumberingStyle)
						{
							format = (style as WNumberingStyle).ParagraphFormat;
						}
						ParseList(reader, format);
					}
					break;
				case "uiPriority":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					style.UIPriority = Convert.ToInt32(attribute);
					break;
				}
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		if (flag3)
		{
			AddStyleNameID(style, text);
		}
		if (flag4)
		{
			paraLinkStyleIndex.Add(StyleNameId.Count - 1);
			flag4 = false;
		}
		if (!flag2 && style.BaseStyle != null && style is WParagraphStyle)
		{
			style.RemoveBaseStyle();
		}
	}

	private void AddStyleNameID(Style style, string styleName)
	{
		if (!style.IsCustom)
		{
			Dictionary<string, string> builtinStyles = style.GetBuiltinStyles();
			if (builtinStyles.ContainsKey(styleName.ToLower()))
			{
				styleName = builtinStyles[styleName.ToLower()];
			}
		}
		if (string.IsNullOrEmpty(style.Name.Trim()) && !string.IsNullOrEmpty(styleName.Trim()))
		{
			style.Name = styleName;
		}
		if (!string.IsNullOrEmpty(style.Name) && !StyleNameId.ContainsKey(style.Name))
		{
			StyleNameId.Add(style.Name, styleName);
			style.StyleIDName = style.Name;
		}
		else if (!string.IsNullOrEmpty(style.Name) && StyleNameId.ContainsKey(style.Name))
		{
			IStyle style2 = m_doc.Styles.FindByName(style.Name);
			if (style2 != null)
			{
				(m_doc.Styles as StyleCollection).InnerList.Remove(style2);
				(style2 as Style).RemoveBaseStyle();
				style2 = null;
			}
			StyleNameId[style.Name] = styleName;
		}
		style.StyleIDName = style.Name;
		style.Name = styleName;
	}

	private Style CreateStyle(string styleType)
	{
		Style result = null;
		switch (styleType)
		{
		case "character":
			result = new WCharacterStyle(m_doc);
			break;
		case "paragraph":
			result = new WParagraphStyle(m_doc);
			break;
		case "table":
			result = new WTableStyle(m_doc);
			break;
		case "numbering":
			result = new WNumberingStyle(m_doc);
			break;
		default:
			if (IsWord2003ML && styleType == "list")
			{
				result = new WNumberingStyle(m_doc);
			}
			break;
		}
		return result;
	}

	private void ParseLatentStyles(XmlReader reader)
	{
		m_doc.LatentStyles2010 = ReadSingleNodeIntoStream(reader);
	}

	private void ParseDocDefaults(XmlReader reader)
	{
		if (reader.LocalName != "docDefaults")
		{
			throw new XmlException("docDefaults");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "docDefaults")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				string localName2 = reader.LocalName;
				if (!(localName2 == "rPrDefault"))
				{
					if (localName2 == "pPrDefault")
					{
						m_doc.m_defParaFormat = new WParagraphFormat(m_doc);
						if (!reader.IsEmptyElement)
						{
							string localName3 = reader.LocalName;
							reader.Read();
							if (!(localName3 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
							{
								SkipWhitespaces(reader);
								if (reader.LocalName == "pPrDefault" && reader.NodeType == XmlNodeType.EndElement)
								{
									break;
								}
								if (reader.LocalName == "pPr")
								{
									ParseParagraphFormat(reader, m_doc.m_defParaFormat);
									reader.Read();
								}
								else
								{
									while (!(reader.LocalName == "pPrDefault") || reader.NodeType != XmlNodeType.EndElement)
									{
										reader.Read();
									}
								}
							}
						}
					}
				}
				else if (!reader.IsEmptyElement)
				{
					string localName4 = reader.LocalName;
					reader.Read();
					if (!(localName4 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
					{
						SkipWhitespaces(reader);
						if (reader.LocalName == "rPrDefault" && reader.NodeType == XmlNodeType.EndElement)
						{
							break;
						}
						m_doc.DefCharFormat = new WCharacterFormat(m_doc);
						ParseCharacterFormat(reader, m_doc.DefCharFormat, null);
						reader.Read();
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private WCharacterFormat GetCharacterFormat(Style style)
	{
		if (style.StyleType != StyleType.TableStyle)
		{
			if (style.StyleType != StyleType.CharacterStyle)
			{
				if (style.StyleType != StyleType.NumberingStyle)
				{
					return (style as WParagraphStyle).CharacterFormat;
				}
				return (style as WNumberingStyle).CharacterFormat;
			}
			return (style as WCharacterStyle).CharacterFormat;
		}
		return (style as WTableStyle).CharacterFormat;
	}

	private WParagraphFormat GetParagraphFormat(Style style)
	{
		if (style.StyleType != StyleType.TableStyle)
		{
			if (style.StyleType != StyleType.NumberingStyle)
			{
				return (style as WParagraphStyle).ParagraphFormat;
			}
			return (style as WNumberingStyle).ParagraphFormat;
		}
		return (style as WTableStyle).ParagraphFormat;
	}

	private void ParseConditionalFormattingStyleProperties(XmlReader reader, Style style)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		if (style == null)
		{
			throw new ArgumentException("style");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string attribute = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == "wholeTable")
		{
			SkipCurrentElement(reader, reader.LocalName);
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		ConditionalFormattingType conditionalFormattingCode = GetConditionalFormattingCode(attribute);
		ConditionalFormattingStyle conditionalFormattingStyle = (style as WTableStyle).ConditionalFormat(conditionalFormattingCode);
		SkipWhitespaces(reader);
		while (reader.LocalName != "tblStylePr")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "rPr":
					ParseCharacterFormat(reader, conditionalFormattingStyle.CharacterFormat, null);
					break;
				case "pPr":
					ParseParagraphFormat(reader, conditionalFormattingStyle.ParagraphFormat);
					break;
				case "tblPr":
					ParseTableStyleTableProperties(reader, conditionalFormattingStyle.TableProperties);
					break;
				case "trPr":
					ParseTableStyleRowProperties(reader, conditionalFormattingStyle.RowProperties);
					break;
				case "tcPr":
					ParseTableStyleCellProperties(reader, conditionalFormattingStyle.CellProperties);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private ConditionalFormattingType GetConditionalFormattingCode(string styleType)
	{
		ConditionalFormattingType result = ConditionalFormattingType.FirstRow;
		switch (styleType)
		{
		case "firstRow":
			result = ConditionalFormattingType.FirstRow;
			break;
		case "lastRow":
			result = ConditionalFormattingType.LastRow;
			break;
		case "band1Horz":
			result = ConditionalFormattingType.OddRowBanding;
			break;
		case "band2Horz":
			result = ConditionalFormattingType.EvenRowBanding;
			break;
		case "firstCol":
			result = ConditionalFormattingType.FirstColumn;
			break;
		case "lastCol":
			result = ConditionalFormattingType.LastColumn;
			break;
		case "band1Vert":
			result = ConditionalFormattingType.OddColumnBanding;
			break;
		case "band2Vert":
			result = ConditionalFormattingType.EvenColumnBanding;
			break;
		case "neCell":
			result = ConditionalFormattingType.FirstRowLastCell;
			break;
		case "nwCell":
			result = ConditionalFormattingType.FirstRowFirstCell;
			break;
		case "seCell":
			result = ConditionalFormattingType.LastRowLastCell;
			break;
		case "swCell":
			result = ConditionalFormattingType.LastRowFirstCell;
			break;
		}
		return result;
	}

	private void ParseTableStyleTableProperties(XmlReader reader, TableStyleTableProperties props)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "tblStyleRowBandSize":
				{
					string attribute4 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute4))
					{
						double result = 0.0;
						props.RowStripe = (double.TryParse(attribute4, NumberStyles.Float, CultureInfo.InvariantCulture, out result) ? ((long)result) : 1);
					}
					break;
				}
				case "tblStyleColBandSize":
				{
					string attribute5 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute5))
					{
						double result2 = 0.0;
						props.ColumnStripe = (double.TryParse(attribute5, NumberStyles.Float, CultureInfo.InvariantCulture, out result2) ? ((long)result2) : 1);
					}
					break;
				}
				case "tblCellSpacing":
				{
					float num = 0f;
					string attribute2 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						num = GetFloatValue(attribute2, reader.LocalName);
					}
					string attribute3 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (num != float.MaxValue && (string.IsNullOrEmpty(attribute3) || !(attribute3 == "nil")))
					{
						props.CellSpacing = num;
					}
					break;
				}
				case "tblInd":
				{
					string attribute = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute))
					{
						float floatValue = GetFloatValue(attribute, reader.LocalName);
						if (floatValue < -1080f || floatValue > 1080f || float.IsNaN(floatValue))
						{
							props.LeftIndent = 0f;
						}
						else
						{
							props.LeftIndent = floatValue;
						}
					}
					break;
				}
				case "jc":
					props.HorizontalAlignment = ParseTableJustification(reader);
					break;
				case "tblCellMar":
					ParseTableMargins(reader, props.Paddings);
					break;
				case "tblBorders":
					ParseBorder(reader, props.Borders);
					break;
				case "shd":
					ParseShading(reader, props);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseTableStyleRowProperties(XmlReader reader, TableStyleRowProperties props)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "hidden":
					props.IsHidden = GetBooleanValue(reader);
					break;
				case "tblHeader":
					props.IsHeader = GetBooleanValue(reader);
					break;
				case "cantSplit":
					props.IsBreakAcrossPages = GetBooleanValue(reader);
					break;
				case "tblCellSpacing":
				{
					float num = 0f;
					string attribute = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute))
					{
						num = GetFloatValue(attribute, reader.LocalName);
					}
					string attribute2 = reader.GetAttribute("type", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (num != float.MaxValue && (string.IsNullOrEmpty(attribute2) || !(attribute2 == "nil")))
					{
						props.CellSpacing = num;
					}
					break;
				}
				case "jc":
					props.HorizontalAlignment = ParseTableJustification(reader);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseTableStyleCellProperties(XmlReader reader, TableStyleCellProperties props)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "noWrap":
					props.TextWrap = !GetBooleanValue(reader);
					break;
				case "vAlign":
					props.VerticalAlignment = ParseCellVerticalAlignment(reader);
					break;
				case "tcMar":
					ParseTableMargins(reader, props.Paddings);
					break;
				case "tcBorders":
					ParseBorder(reader, props.Borders);
					break;
				case "shd":
					ParseShading(reader, props);
					break;
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseShading(XmlReader reader, TableStyleTableProperties props)
	{
		string attribute = reader.GetAttribute("fill", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				props.BackColor = Color.Empty;
			}
			else
			{
				props.BackColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("color", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				props.ForeColor = Color.Empty;
			}
			else
			{
				props.ForeColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			props.TextureStyle = ParseTexture(attribute);
		}
	}

	private void ParseShading(XmlReader reader, TableStyleCellProperties props)
	{
		string attribute = reader.GetAttribute("fill", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				props.BackColor = Color.Empty;
			}
			else
			{
				props.BackColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("color", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				props.ForeColor = Color.Empty;
			}
			else
			{
				props.ForeColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			props.TextureStyle = ParseTexture(attribute);
		}
	}

	private void ParseCharacterFormat(XmlReader reader, WCharacterFormat charFormat, ParagraphItemCollection paraItems)
	{
		bool flag = false;
		int num = 0;
		if (reader.LocalName != "rPr")
		{
			throw new XmlException("Run properties");
		}
		if (charFormat == null)
		{
			throw new ArgumentException("Character Format");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		float num2 = float.MaxValue;
		while (!(reader.LocalName == "rPr") || reader.NodeType != XmlNodeType.EndElement)
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "rFonts":
					ParseFonts(reader, charFormat);
					break;
				case "cs":
					if (reader.NodeType == XmlNodeType.Element)
					{
						charFormat.ComplexScript = GetBooleanValue(reader);
					}
					break;
				case "sz":
				{
					string attribute8 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute8))
					{
						charFormat.SetPropertyValue(3, GetFloatValue(attribute8, reader.LocalName));
					}
					break;
				}
				case "szCs":
				case "sz-cs":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						charFormat.SetPropertyValue(62, GetFloatValue(attribute2, reader.LocalName));
					}
					break;
				}
				case "lang":
					ParseLanguage(reader, charFormat);
					break;
				case "u":
					if (IsWord2003ML)
					{
						Parse2003Underline(reader, charFormat);
					}
					else
					{
						ParseUnderline(reader, charFormat);
					}
					break;
				case "em":
					ParseEmphasis(reader, charFormat);
					break;
				case "effect":
					ParseTextEffect(reader, charFormat);
					break;
				case "snapToGrid":
					if (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace) == "off")
					{
						charFormat.SnapToGrid = false;
					}
					break;
				case "webHidden":
					charFormat.WebHidden = GetBooleanValue(reader);
					break;
				case "vertAlign":
					ParseVertAlign(reader, charFormat);
					break;
				case "color":
				{
					string attribute9 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (attribute9 == "auto")
					{
						charFormat.TextColor = Color.Empty;
					}
					else if (!string.IsNullOrEmpty(attribute9))
					{
						charFormat.TextColor = GetColorValue(attribute9);
					}
					break;
				}
				case "highlight":
					ParseHighlight(reader, charFormat);
					break;
				case "outline":
					charFormat.OutLine = GetBooleanValue(reader);
					break;
				case "position":
				{
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute))
					{
						charFormat.SetPositionValue(GetFloatValue(attribute, reader.LocalName));
					}
					break;
				}
				case "spacing":
				{
					string attribute10 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute10))
					{
						charFormat.SetCharacterSpacingValue(GetFloatValue(attribute10, reader.LocalName));
					}
					break;
				}
				case "rStyle":
				{
					string attribute4 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute4) && StyleNameId.ContainsKey(attribute4))
					{
						charFormat.CharStyleName = StyleNameId[attribute4];
					}
					List<string> list = new List<string>();
					list.AddRange(StyleNameId.Values);
					Dictionary<string, int> dictionary = CountOccurrencesOfValue(list);
					if (charFormat.CharStyleName != null && dictionary[charFormat.CharStyleName] > 1)
					{
						charFormat.CharStyleId = attribute4;
					}
					break;
				}
				case "shd":
					ParseRunShading(reader, charFormat);
					break;
				case "bdr":
					ParseBorder(reader, charFormat.Border);
					break;
				case "rPrChange":
					if (reader.AttributeCount > 0)
					{
						string attribute7 = reader.GetAttribute("author", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute7))
						{
							charFormat.FormatChangeAuthorName = attribute7;
						}
						attribute7 = reader.GetAttribute("date", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute7))
						{
							DateTime result3 = default(DateTime);
							CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
							if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
							{
								cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
							}
							DateTime.TryParse(attribute7, cultureInfo, DateTimeStyles.AdjustToUniversal, out result3);
							charFormat.FormatChangeDateTime = result3;
						}
					}
					ParseChangeCharacterFormat(reader, charFormat);
					m_doc.CharFormatChangeRevision(charFormat, null);
					break;
				case "b":
					charFormat.Bold = GetBooleanValue(reader);
					break;
				case "b-cs":
				case "bCs":
					charFormat.BoldBidi = GetBooleanValue(reader);
					break;
				case "caps":
					charFormat.AllCaps = GetBooleanValue(reader);
					break;
				case "dstrike":
					charFormat.DoubleStrike = GetBooleanValue(reader);
					break;
				case "vanish":
					charFormat.Hidden = GetBooleanValue(reader);
					break;
				case "specVanish":
					charFormat.SpecVanish = GetBooleanValue(reader);
					break;
				case "smallCaps":
					charFormat.SmallCaps = GetBooleanValue(reader);
					break;
				case "imprint":
					charFormat.Engrave = GetBooleanValue(reader);
					break;
				case "emboss":
					charFormat.Emboss = GetBooleanValue(reader);
					break;
				case "i":
					charFormat.Italic = GetBooleanValue(reader);
					break;
				case "i-cs":
				case "iCs":
					charFormat.ItalicBidi = GetBooleanValue(reader);
					break;
				case "strike":
					charFormat.Strikeout = GetBooleanValue(reader);
					break;
				case "shadow":
					if (reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2010/wordml" && !IsWord2003ML)
					{
						charFormat.XmlProps.Add(ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					else
					{
						charFormat.Shadow = GetBooleanValue(reader);
					}
					break;
				case "noProof":
					charFormat.NoProof = GetBooleanValue(reader);
					break;
				case "rtl":
					charFormat.Bidi = GetBooleanValue(reader);
					break;
				case "del":
					if (charFormat.IsFormattingChange || (reader.IsEmptyElement && num > 0))
					{
						break;
					}
					if (!reader.IsEmptyElement && num > 0)
					{
						num++;
						break;
					}
					if (!reader.IsEmptyElement)
					{
						num++;
					}
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 12);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					charFormat.IsDeleteRevision = true;
					UpdateRevAuthorInformation(reader, charFormat);
					m_doc.BreakCharacterFormatRevision(RevisionType.Deletions, charFormat, null, null);
					break;
				case "moveFrom":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 26);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					charFormat.IsDeleteRevision = true;
					UpdateRevAuthorInformation(reader, charFormat);
					m_doc.BreakCharacterFormatRevision(RevisionType.MoveFrom, charFormat, moveRevision, null);
					break;
				case "ins":
					if (charFormat.IsFormattingChange || (reader.IsEmptyElement && num > 0))
					{
						break;
					}
					if (!reader.IsEmptyElement && num > 0)
					{
						num++;
						break;
					}
					if (!reader.IsEmptyElement)
					{
						num++;
					}
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 24);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					charFormat.IsInsertRevision = true;
					UpdateRevAuthorInformation(reader, charFormat);
					m_doc.BreakCharacterFormatRevision(RevisionType.Insertions, charFormat, null, null);
					break;
				case "moveTo":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 27);
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 30);
					charFormat.IsInsertRevision = true;
					UpdateRevAuthorInformation(reader, charFormat);
					m_doc.BreakCharacterFormatRevision(RevisionType.MoveTo, charFormat, moveRevision, null);
					break;
				case "cntxtAlts":
					charFormat.UseContextualAlternates = GetBooleanValue(reader, "http://schemas.microsoft.com/office/word/2010/wordml");
					break;
				case "ligatures":
					ParseLigatures(reader, charFormat);
					break;
				case "numForm":
					ParseNumberForm(reader, charFormat);
					break;
				case "numSpacing":
					ParseNumberSpacing(reader, charFormat);
					break;
				case "stylisticSets":
					ParseStylisticSet(reader, charFormat);
					break;
				case "kern":
				{
					string attribute6 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute6))
					{
						num2 = GetFloatValue(attribute6, reader.LocalName);
					}
					break;
				}
				case "w":
				{
					string attribute5 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute5))
					{
						charFormat.SetScalingValue(GetFloatValue(attribute5, reader.LocalName));
					}
					break;
				}
				case "eastAsianLayout":
					if (reader.AttributeCount > 0)
					{
						CFELayout cFELayout = ParseCFELayout(reader);
						charFormat.CFELayout = cFELayout;
					}
					break;
				case "fitText":
					if (reader.AttributeCount > 0)
					{
						string attribute3 = reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute3))
						{
							int result = 0;
							int.TryParse(attribute3, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
							charFormat.FitTextID = result;
						}
						attribute3 = string.Empty;
						attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute3))
						{
							int result2 = 0;
							int.TryParse(attribute3, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
							charFormat.FitTextWidth = result2 / 20;
						}
					}
					break;
				case "t":
				case "instrText":
				case "delText":
				case "delInstrText":
					if (paraItems != null)
					{
						ParagraphItem paragraphItem = ParseText(reader, paraItems, isNestedInRunProperties: true, isMathRunText: false);
						if (paragraphItem != null)
						{
							AddToParagraph(paragraphItem, paraItems);
							CheckTrackChange(paragraphItem);
						}
					}
					break;
				case "pPr":
					if (charFormat.OwnerBase != null && charFormat.OwnerBase is WParagraphStyle)
					{
						ParseParagraphFormat(reader, (charFormat.OwnerBase as WParagraphStyle).ParagraphFormat);
					}
					break;
				default:
					if (!IsWord2003ML && reader.LocalName != string.Empty && reader.LocalName != "rPr")
					{
						charFormat.XmlProps.Add(ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "rPr":
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				if (num > 0 && (reader.LocalName == "ins" || reader.LocalName == "del") && reader.NodeType == XmlNodeType.EndElement)
				{
					num--;
				}
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
		if (num2 != float.MaxValue)
		{
			charFormat.SetKernSize(num2);
		}
	}

	private void UpdateRevAuthorInformation(XmlReader reader, WCharacterFormat charFormat)
	{
		if (charFormat == null)
		{
			m_revAuthorName = string.Empty;
			m_revDateTime = DateTime.MinValue;
			m_name = string.Empty;
		}
		if (reader.AttributeCount <= 0)
		{
			return;
		}
		string attribute = reader.GetAttribute("author", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (charFormat != null)
			{
				charFormat.AuthorName = attribute;
			}
			else
			{
				m_revAuthorName = attribute;
			}
		}
		attribute = reader.GetAttribute("date", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			DateTime result = default(DateTime);
			CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
			if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
			{
				cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
			}
			DateTime.TryParse(attribute, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
			if (charFormat != null)
			{
				charFormat.RevDateTime = result;
			}
			else
			{
				m_revDateTime = result;
			}
		}
		attribute = reader.GetAttribute("name", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (charFormat != null)
			{
				charFormat.RevisionName = attribute;
			}
			else
			{
				m_name = attribute;
			}
		}
	}

	private void UpdateRevAuthorInformation(RowFormat rowFormat, XmlReader reader, RevisionType revisionType)
	{
		if (reader.AttributeCount <= 0)
		{
			return;
		}
		string attribute = reader.GetAttribute("author", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (revisionType == RevisionType.Formatting)
			{
				rowFormat.FormatChangeAuthorName = attribute;
			}
			else
			{
				rowFormat.OwnerRow.CharacterFormat.AuthorName = attribute;
			}
		}
		attribute = reader.GetAttribute("date", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			DateTime result = default(DateTime);
			CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
			if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
			{
				cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
			}
			DateTime.TryParse(attribute, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
			if (revisionType == RevisionType.Formatting)
			{
				rowFormat.FormatChangeDateTime = result;
			}
			else
			{
				rowFormat.OwnerRow.CharacterFormat.RevDateTime = result;
			}
		}
	}

	private float GetFloatValue(string value, string elementName)
	{
		float result = 0f;
		if (value.Contains(ControlChar.SpaceChar.ToString()))
		{
			return result;
		}
		if (value.EndsWith("cm"))
		{
			return (float)((double)GetNumericValue(value.Remove(value.IndexOf("cm"), 2)) * 28.35);
		}
		if (value.EndsWith("mm"))
		{
			return (float)((double)GetNumericValue(value.Remove(value.IndexOf("mm"), 2)) * 2.835);
		}
		if (value.EndsWith("pt"))
		{
			return GetNumericValue(value.Remove(value.IndexOf("pt"), 2));
		}
		if (value.EndsWith("pi"))
		{
			return GetNumericValue(value.Remove(value.IndexOf("pi"), 2)) * 12f;
		}
		if (value.EndsWith("in"))
		{
			return GetNumericValue(value.Remove(value.IndexOf("in"), 2)) * 72f;
		}
		if (elementName != null)
		{
			switch (elementName.Length)
			{
			case 4:
			{
				char c = elementName[2];
				if ((uint)c <= 83u)
				{
					if (c == 'C')
					{
						if (!(elementName == "szCs"))
						{
							break;
						}
						goto IL_067d;
					}
					if (c != 'S' || !(elementName == "pgSz"))
					{
						break;
					}
				}
				else if (c != 'f')
				{
					if (c != 'n')
					{
						if (c != 'r' || !(elementName == "kern"))
						{
							break;
						}
						goto IL_067d;
					}
					if (!(elementName == "line"))
					{
						break;
					}
				}
				else if (!(elementName == "left"))
				{
					break;
				}
				goto IL_069b;
			}
			case 8:
			{
				char c = elementName[0];
				if (c != 'd')
				{
					if (c != 'p' || !(elementName == "position"))
					{
						break;
					}
					goto IL_067d;
				}
				if (!(elementName == "distance"))
				{
					break;
				}
				goto IL_069b;
			}
			case 5:
			{
				char c = elementName[1];
				if ((uint)c <= 103u)
				{
					if (c != 'b')
					{
						if (c != 'g' || !(elementName == "pgMar"))
						{
							break;
						}
					}
					else if (!(elementName == "tblpX") && !(elementName == "tblpY"))
					{
						break;
					}
				}
				else if (c != 'i')
				{
					if (c != 't')
					{
						if (c != 'z' || !(elementName == "sz-cs"))
						{
							break;
						}
						goto IL_067d;
					}
					if (!(elementName == "start"))
					{
						break;
					}
				}
				else if (!(elementName == "right"))
				{
					break;
				}
				goto IL_069b;
			}
			case 1:
				switch (elementName[0])
				{
				case 'w':
					return GetNumericValue(value);
				case 'x':
				case 'y':
					break;
				default:
					goto end_IL_010f;
				}
				goto IL_069b;
			case 11:
			{
				char c = elementName[0];
				if ((uint)c <= 98u)
				{
					if (c != 'a')
					{
						if (c != 'b' || !(elementName == "beforeLines"))
						{
							break;
						}
					}
					else if (!(elementName == "after-lines"))
					{
						break;
					}
					goto IL_06bf;
				}
				if (c != 'f')
				{
					if (c != 'p')
					{
						if (c != 't' || !(elementName == "topFromText"))
						{
							break;
						}
					}
					else if (!(elementName == "paraSpacing"))
					{
						break;
					}
				}
				else if (!(elementName == "frameHeight"))
				{
					break;
				}
				goto IL_069b;
			}
			case 3:
			{
				char c = elementName[0];
				if ((uint)c <= 101u)
				{
					if (c != 'c')
					{
						if (c != 'e' || !(elementName == "end"))
						{
							break;
						}
					}
					else if (!(elementName == "col"))
					{
						break;
					}
				}
				else if (c != 'i')
				{
					if (c != 'p')
					{
						if (c != 't' || !(elementName == "top"))
						{
							break;
						}
					}
					else if (!(elementName == "pos"))
					{
						break;
					}
				}
				else if (!(elementName == "ind"))
				{
					break;
				}
				goto IL_069b;
			}
			case 10:
			{
				char c = elementName[0];
				if (c != 'a')
				{
					if (c != 'f' || !(elementName == "frameWidth"))
					{
						break;
					}
					goto IL_069b;
				}
				if (!(elementName == "afterLines"))
				{
					break;
				}
				goto IL_06bf;
			}
			case 6:
				switch (elementName[2])
				{
				case 'p':
					break;
				case 't':
					goto IL_05b1;
				case 'l':
					goto IL_05c6;
				case 'r':
					if (!(elementName == "border"))
					{
						goto end_IL_010f;
					}
					return GetNumericValue(value) / 8f;
				default:
					goto end_IL_010f;
				}
				switch (elementName)
				{
				case "vSpace":
				case "vspace":
				case "hSpace":
				case "hspace":
					break;
				default:
					goto end_IL_010f;
				}
				goto IL_069b;
			case 14:
			{
				char c = elementName[0];
				if (c != 'b')
				{
					if (c != 'd')
					{
						if (c != 't' || !(elementName == "tblCellSpacing"))
						{
							break;
						}
					}
					else if (!(elementName == "defaultTabStop"))
					{
						break;
					}
				}
				else if (!(elementName == "bottomFromText"))
				{
					break;
				}
				goto IL_069b;
			}
			case 9:
			{
				char c = elementName[0];
				if (c != 'l')
				{
					if (c != 'r' || !(elementName == "rowHeight"))
					{
						break;
					}
				}
				else if (!(elementName == "linePitch"))
				{
					break;
				}
				goto IL_069b;
			}
			case 12:
			{
				char c = elementName[0];
				if (c != 'b')
				{
					if (c != 'l' || !(elementName == "leftFromText"))
					{
						break;
					}
					goto IL_069b;
				}
				if (!(elementName == "before-lines"))
				{
					break;
				}
				goto IL_06bf;
			}
			case 2:
				if (!(elementName == "sz"))
				{
					break;
				}
				goto IL_067d;
			case 7:
				if (!(elementName == "spacing"))
				{
					break;
				}
				goto IL_069b;
			case 13:
				{
					if (!(elementName == "rightFromText"))
					{
						break;
					}
					goto IL_069b;
				}
				IL_05b1:
				if (!(elementName == "bottom"))
				{
					break;
				}
				goto IL_069b;
				IL_069b:
				return (float)Math.Round(GetNumericValue(value) / 20f, 2);
				IL_06bf:
				return (float)Math.Round(GetNumericValue(value) / 100f, 2);
				IL_067d:
				return (float)Math.Round(GetNumericValue(value) / 2f, 2);
				IL_05c6:
				if (!(elementName == "tblInd"))
				{
					break;
				}
				goto IL_069b;
				end_IL_010f:
				break;
			}
		}
		return 0f;
	}

	private float GetNumericValue(string value)
	{
		float result = 0f;
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		if (!string.IsNullOrEmpty(value) && (double)result == 0.0 && m_isFloatValue.IsMatch(value) && m_hasAlphabet.IsMatch(value))
		{
			string[] array = value.Split(new char[1] { '.' }, StringSplitOptions.RemoveEmptyEntries);
			float.TryParse(StartsWithExt(value, ".") ? ("0." + array[0]) : ((array.Length > 1) ? (array[0] + "." + array[1]) : array[0]), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		return result;
	}

	private void ParseLigatures(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml");
		if (attribute == null)
		{
			return;
		}
		switch (attribute.Length)
		{
		case 10:
			switch (attribute[0])
			{
			case 'c':
				if (attribute == "contextual")
				{
					charFormat.Ligatures = LigatureType.Contextual;
				}
				break;
			case 'h':
				if (attribute == "historical")
				{
					charFormat.Ligatures = LigatureType.Historical;
				}
				break;
			}
			break;
		case 18:
			switch (attribute[8])
			{
			case 'C':
				if (attribute == "standardContextual")
				{
					charFormat.Ligatures = LigatureType.StandardContextual;
				}
				break;
			case 'H':
				if (attribute == "standardHistorical")
				{
					charFormat.Ligatures = LigatureType.StandardHistorical;
				}
				break;
			}
			break;
		case 20:
			switch (attribute[0])
			{
			case 'c':
				if (attribute == "contextualHistorical")
				{
					charFormat.Ligatures = LigatureType.ContextualHistorical;
				}
				break;
			case 's':
				if (attribute == "standardDiscretional")
				{
					charFormat.Ligatures = LigatureType.StandardDiscretional;
				}
				break;
			}
			break;
		case 22:
			switch (attribute[0])
			{
			case 'c':
				if (attribute == "contextualDiscretional")
				{
					charFormat.Ligatures = LigatureType.ContextualDiscretional;
				}
				break;
			case 'h':
				if (attribute == "historicalDiscretional")
				{
					charFormat.Ligatures = LigatureType.HistoricalDiscretional;
				}
				break;
			}
			break;
		case 30:
			switch (attribute[8])
			{
			case 'C':
				if (attribute == "standardContextualDiscretional")
				{
					charFormat.Ligatures = LigatureType.StandardContextualDiscretional;
				}
				break;
			case 'H':
				if (attribute == "standardHistoricalDiscretional")
				{
					charFormat.Ligatures = LigatureType.StandardHistoricalDiscretional;
				}
				break;
			}
			break;
		case 4:
			if (attribute == "none")
			{
				charFormat.Ligatures = LigatureType.None;
			}
			break;
		case 8:
			if (attribute == "standard")
			{
				charFormat.Ligatures = LigatureType.Standard;
			}
			break;
		case 28:
			if (attribute == "standardContextualHistorical")
			{
				charFormat.Ligatures = LigatureType.StandardContextualHistorical;
			}
			break;
		case 12:
			if (attribute == "discretional")
			{
				charFormat.Ligatures = LigatureType.Discretional;
			}
			break;
		case 32:
			if (attribute == "contextualHistoricalDiscretional")
			{
				charFormat.Ligatures = LigatureType.ContextualHistoricalDiscretional;
			}
			break;
		case 3:
			if (attribute == "all")
			{
				charFormat.Ligatures = LigatureType.All;
			}
			break;
		}
	}

	private void ParseNumberForm(XmlReader reader, WCharacterFormat charFormat)
	{
		switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"))
		{
		case "default":
			charFormat.NumberForm = NumberFormType.Default;
			break;
		case "lining":
			charFormat.NumberForm = NumberFormType.Lining;
			break;
		case "oldStyle":
			charFormat.NumberForm = NumberFormType.OldStyle;
			break;
		}
	}

	private void ParseNumberSpacing(XmlReader reader, WCharacterFormat charFormat)
	{
		switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"))
		{
		case "default":
			charFormat.NumberSpacing = NumberSpacingType.Default;
			break;
		case "proportional":
			charFormat.NumberSpacing = NumberSpacingType.Proportional;
			break;
		case "tabular":
			charFormat.NumberSpacing = NumberSpacingType.Tabular;
			break;
		}
	}

	private void ParseStylisticSet(XmlReader reader, WCharacterFormat charFormat)
	{
		if (reader == null)
		{
			throw new Exception("reader is null");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "stylisticSets")
		{
			throw new XmlException("Expected xml tag \"stylisticSets\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "stylisticSets")
		{
			if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "styleSet")
			{
				string attribute = reader.GetAttribute("id", "http://schemas.microsoft.com/office/word/2010/wordml");
				charFormat.StylisticSet = GetStylisticSet(attribute);
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private CFELayout ParseCFELayout(XmlReader reader)
	{
		CFELayout cFELayout = new CFELayout();
		string attribute = reader.GetAttribute("id", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			int result = 0;
			int.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			cFELayout.ID = result;
		}
		attribute = string.Empty;
		attribute = reader.GetAttribute("combine", IsStrict ? m_strictNameSpace : m_nameSpace);
		cFELayout.Combine = GetBoolValue(attribute);
		attribute = string.Empty;
		attribute = reader.GetAttribute("vert", IsStrict ? m_strictNameSpace : m_nameSpace);
		cFELayout.Vertical = GetBoolValue(attribute);
		attribute = string.Empty;
		attribute = reader.GetAttribute("vertCompress", IsStrict ? m_strictNameSpace : m_nameSpace);
		cFELayout.VerticalCompress = GetBoolValue(attribute);
		attribute = string.Empty;
		attribute = reader.GetAttribute("combineBrackets", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "angle":
				cFELayout.CombineBracketsType = CombineBracketsType.Angle;
				break;
			case "curly":
				cFELayout.CombineBracketsType = CombineBracketsType.Curly;
				break;
			case "none":
				cFELayout.CombineBracketsType = CombineBracketsType.None;
				break;
			case "round":
				cFELayout.CombineBracketsType = CombineBracketsType.Round;
				break;
			case "square":
				cFELayout.CombineBracketsType = CombineBracketsType.Square;
				break;
			}
		}
		return cFELayout;
	}

	private StylisticSetType GetStylisticSet(string value)
	{
		StylisticSetType result = StylisticSetType.StylisticSetDefault;
		switch (value)
		{
		case "0":
			result = StylisticSetType.StylisticSetDefault;
			break;
		case "1":
			result = StylisticSetType.StylisticSet01;
			break;
		case "2":
			result = StylisticSetType.StylisticSet02;
			break;
		case "3":
			result = StylisticSetType.StylisticSet03;
			break;
		case "4":
			result = StylisticSetType.StylisticSet04;
			break;
		case "5":
			result = StylisticSetType.StylisticSet05;
			break;
		case "6":
			result = StylisticSetType.StylisticSet06;
			break;
		case "7":
			result = StylisticSetType.StylisticSet07;
			break;
		case "8":
			result = StylisticSetType.StylisticSet08;
			break;
		case "9":
			result = StylisticSetType.StylisticSet09;
			break;
		case "10":
			result = StylisticSetType.StylisticSet10;
			break;
		case "11":
			result = StylisticSetType.StylisticSet11;
			break;
		case "12":
			result = StylisticSetType.StylisticSet12;
			break;
		case "13":
			result = StylisticSetType.StylisticSet13;
			break;
		case "14":
			result = StylisticSetType.StylisticSet14;
			break;
		case "15":
			result = StylisticSetType.StylisticSet15;
			break;
		case "16":
			result = StylisticSetType.StylisticSet16;
			break;
		case "17":
			result = StylisticSetType.StylisticSet17;
			break;
		case "18":
			result = StylisticSetType.StylisticSet18;
			break;
		case "19":
			result = StylisticSetType.StylisticSet19;
			break;
		case "20":
			result = StylisticSetType.StylisticSet20;
			break;
		}
		return result;
	}

	private void ParseChangeCharacterFormat(XmlReader reader, WCharacterFormat charFormat)
	{
		charFormat.IsChangedFormat = true;
		charFormat.IsFormattingChange = true;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			SkipWhitespaces(reader);
			if (!(reader.LocalName == "rPrChange") || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseCharacterFormat(reader, charFormat, null);
				charFormat.SetPropertyValue(105, true);
				charFormat.IsFormattingChange = false;
			}
		}
	}

	private void ParseBorder(XmlReader reader, Border border)
	{
		border.IsRead = true;
		border.BorderType = GetBorderStyle(reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace), border);
		string attribute = reader.GetAttribute("sz", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			border.LineWidth = (float)(int)(byte)GetNumericValue(attribute) / 8f;
		}
		float result = float.MaxValue;
		attribute = reader.GetAttribute("space", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		if (result != float.MaxValue)
		{
			border.Space = result;
		}
		string attribute2 = reader.GetAttribute("color", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			border.Color = GetColorValue(attribute2);
		}
		attribute = reader.GetAttribute("shadow", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "on":
			case "1":
			case "true":
				border.Shadow = true;
				break;
			}
		}
		if (border.BorderType == BorderStyle.None && !border.HasNoneStyle && border.LineWidth == 0f && border.Color == Color.Black)
		{
			border.BorderType = BorderStyle.Single;
			border.LineWidth = 0.5f;
		}
		border.IsRead = false;
	}

	private BorderStyle GetBorderStyle(string boderStyle, Border border)
	{
		BorderStyle result = BorderStyle.None;
		switch (boderStyle)
		{
		case "twistedLines1":
		case "twisted-lines-1":
			result = BorderStyle.TwistedLines1;
			break;
		case "triple":
			result = BorderStyle.Triple;
			break;
		case "dashSmallGap":
		case "dash-small-gap":
			result = BorderStyle.DashSmallGap;
			break;
		case "single":
			result = BorderStyle.Single;
			break;
		case "dotted":
			result = BorderStyle.Dot;
			break;
		case "dotDash":
		case "dot-dash":
			result = BorderStyle.DotDash;
			break;
		case "dotDotDash":
		case "dot-Dot-Dash":
			result = BorderStyle.DotDotDash;
			break;
		case "dashed":
			result = BorderStyle.DashLargeGap;
			break;
		case "double":
			result = BorderStyle.Double;
			break;
		case "thickThinSmallGap":
		case "thick-thin-small-gap":
			result = BorderStyle.ThinThinSmallGap;
			break;
		case "thinThickSmallGap":
		case "thin-thick-small-gap":
			result = BorderStyle.ThinThickSmallGap;
			break;
		case "thinThickThinSmallGap":
		case "thin-thick-thin-small-gap":
			result = BorderStyle.ThinThickThinSmallGap;
			break;
		case "thinThickThinMediumGap":
		case "thin-thick-thin-medium-gap":
			result = BorderStyle.ThickThickThinMediumGap;
			break;
		case "thickThinMediumGap":
		case "thick-thin-medium-gap":
			result = BorderStyle.ThickThinMediumGap;
			break;
		case "thinThickMediumGap":
		case "thin-thick-medium-gap":
			result = BorderStyle.ThinThickMediumGap;
			break;
		case "thickThinLargeGap":
		case "thick-thin-large-gap":
			result = BorderStyle.ThickThinLargeGap;
			break;
		case "thinThickLargeGap":
		case "thin-thick-large-gap":
			result = BorderStyle.ThinThickLargeGap;
			break;
		case "thinThickThinLargeGap":
		case "thin-thick-thin-large-gap":
			result = BorderStyle.ThinThickThinLargeGap;
			break;
		case "thick":
			result = BorderStyle.Thick;
			break;
		case "wave":
			result = BorderStyle.Wave;
			break;
		case "doubleWave":
		case "double-wave":
			result = BorderStyle.DoubleWave;
			break;
		case "dashDotStroked":
		case "dash-dot-stroked":
			result = BorderStyle.DashDotStroker;
			break;
		case "threeDEngrave":
		case "three-d-engrave":
			result = BorderStyle.Engrave3D;
			break;
		case "threeDEmboss":
		case "three-d-emboss":
			result = BorderStyle.Emboss3D;
			break;
		case "outset":
			result = BorderStyle.Outset;
			break;
		case "inset":
			result = BorderStyle.Inset;
			break;
		case "nil":
			result = BorderStyle.Cleared;
			break;
		case "apples":
			result = BorderStyle.Single;
			break;
		case "archedScallops":
			result = (BorderStyle)97;
			break;
		case "babyPacifier":
			result = (BorderStyle)70;
			break;
		case "babyRattle":
			result = (BorderStyle)71;
			break;
		case "balloons3Colors":
			result = BorderStyle.ThinThickSmallGap;
			break;
		case "balloonsHotAir":
			result = BorderStyle.ThinThinSmallGap;
			break;
		case "basicBlackDashes":
			result = (BorderStyle)155;
			break;
		case "basicBlackDots":
			result = (BorderStyle)156;
			break;
		case "basicBlackSquares":
			result = (BorderStyle)154;
			break;
		case "basicThinLines":
			result = (BorderStyle)151;
			break;
		case "basicWhiteDashes":
			result = (BorderStyle)152;
			break;
		case "basicWhiteDots":
			result = (BorderStyle)147;
			break;
		case "basicWhiteSquares":
			result = (BorderStyle)153;
			break;
		case "basicWideInline":
			result = (BorderStyle)150;
			break;
		case "basicWideMidline":
			result = (BorderStyle)148;
			break;
		case "basicWideOutline":
			result = (BorderStyle)149;
			break;
		case "bats":
			result = (BorderStyle)37;
			break;
		case "birds":
			result = (BorderStyle)102;
			break;
		case "birdsFlight":
			result = (BorderStyle)35;
			break;
		case "cabins":
			result = (BorderStyle)72;
			break;
		case "cakeSlice":
			result = BorderStyle.Double;
			break;
		case "candyCorn":
			result = (BorderStyle)4;
			break;
		case "celticKnotwork":
			result = (BorderStyle)99;
			break;
		case "certificateBanner":
			result = (BorderStyle)158;
			break;
		case "chainLink":
			result = (BorderStyle)128;
			break;
		case "champagneBottle":
			result = BorderStyle.Dot;
			break;
		case "checkedBarBlack":
			result = (BorderStyle)145;
			break;
		case "checkedBarColor":
			result = (BorderStyle)61;
			break;
		case "checkered":
			result = (BorderStyle)144;
			break;
		case "christmasTree":
			result = BorderStyle.DotDash;
			break;
		case "circlesLines":
			result = (BorderStyle)91;
			break;
		case "circlesRectangles":
			result = (BorderStyle)140;
			break;
		case "classicalWave":
			result = (BorderStyle)56;
			break;
		case "clocks":
			result = BorderStyle.Inset;
			break;
		case "compass":
			result = (BorderStyle)54;
			break;
		case "confetti":
			result = (BorderStyle)31;
			break;
		case "confettiGrays":
			result = (BorderStyle)115;
			break;
		case "confettiOutline":
			result = (BorderStyle)116;
			break;
		case "confettiStreamers":
			result = BorderStyle.ThinThickMediumGap;
			break;
		case "confettiWhite":
			result = (BorderStyle)117;
			break;
		case "cornerTriangles":
			result = (BorderStyle)141;
			break;
		case "couponCutoutDashes":
			result = (BorderStyle)163;
			break;
		case "couponCutoutDots":
			result = (BorderStyle)164;
			break;
		case "crazyMaze":
			result = (BorderStyle)100;
			break;
		case "creaturesButterfly":
			result = (BorderStyle)32;
			break;
		case "creaturesFish":
			result = (BorderStyle)34;
			break;
		case "creaturesInsects":
			result = (BorderStyle)142;
			break;
		case "creaturesLadyBug":
			result = (BorderStyle)33;
			break;
		case "crossStitch":
			result = (BorderStyle)138;
			break;
		case "cup":
			result = (BorderStyle)67;
			break;
		case "decoArch":
			result = (BorderStyle)89;
			break;
		case "decoArchColor":
			result = (BorderStyle)50;
			break;
		case "decoBlocks":
			result = (BorderStyle)90;
			break;
		case "diamondsGray":
			result = (BorderStyle)88;
			break;
		case "doubleD":
			result = (BorderStyle)55;
			break;
		case "doubleDiamonds":
			result = (BorderStyle)127;
			break;
		case "earth1":
			result = BorderStyle.DashSmallGap;
			break;
		case "earth2":
			result = BorderStyle.DoubleWave;
			break;
		case "eclipsingSquares1":
			result = (BorderStyle)101;
			break;
		case "eclipsingSquares2":
			result = (BorderStyle)86;
			break;
		case "eggsBlack":
			result = (BorderStyle)66;
			break;
		case "fans":
			result = (BorderStyle)51;
			break;
		case "film":
			result = (BorderStyle)52;
			break;
		case "firecrackers":
			result = (BorderStyle)28;
			break;
		case "flowersBlockPrint":
			result = (BorderStyle)49;
			break;
		case "flowersDaisies":
			result = (BorderStyle)48;
			break;
		case "flowersModern1":
			result = (BorderStyle)45;
			break;
		case "flowersModern2":
			result = (BorderStyle)44;
			break;
		case "flowersPansy":
			result = (BorderStyle)43;
			break;
		case "flowersRedRose":
			result = (BorderStyle)39;
			break;
		case "flowersRoses":
			result = (BorderStyle)38;
			break;
		case "flowersTeacup":
			result = (BorderStyle)103;
			break;
		case "flowersTiny":
			result = (BorderStyle)42;
			break;
		case "gems":
			result = (BorderStyle)139;
			break;
		case "gingerbreadMan":
			result = (BorderStyle)69;
			break;
		case "gradient":
			result = (BorderStyle)122;
			break;
		case "handmade1":
			result = (BorderStyle)159;
			break;
		case "handmade2":
			result = (BorderStyle)160;
			break;
		case "heartBalloon":
			result = BorderStyle.ThickThickThinMediumGap;
			break;
		case "heartGray":
			result = (BorderStyle)68;
			break;
		case "hearts":
			result = BorderStyle.ThickThinMediumGap;
			break;
		case "heebieJeebies":
			result = (BorderStyle)120;
			break;
		case "holly":
			result = (BorderStyle)41;
			break;
		case "houseFunky":
			result = (BorderStyle)73;
			break;
		case "hypnotic":
			result = (BorderStyle)87;
			break;
		case "iceCreamCones":
			result = BorderStyle.Hairline;
			break;
		case "lightBulb":
			result = (BorderStyle)121;
			break;
		case "lightning1":
			result = (BorderStyle)53;
			break;
		case "lightning2":
			result = (BorderStyle)119;
			break;
		case "mapleLeaf":
			result = (BorderStyle)81;
			break;
		case "mapleMuffins":
			result = BorderStyle.Thick;
			break;
		case "mapPins":
			result = (BorderStyle)30;
			break;
		case "marquee":
			result = (BorderStyle)146;
			break;
		case "marqueeToothed":
			result = (BorderStyle)131;
			break;
		case "moons":
			result = (BorderStyle)125;
			break;
		case "mosaic":
			result = (BorderStyle)118;
			break;
		case "musicNotes":
			result = (BorderStyle)79;
			break;
		case "northwest":
			result = (BorderStyle)104;
			break;
		case "ovals":
			result = (BorderStyle)126;
			break;
		case "packages":
			result = BorderStyle.Outset;
			break;
		case "palmsBlack":
			result = (BorderStyle)80;
			break;
		case "palmsColor":
			result = BorderStyle.Triple;
			break;
		case "paperClips":
			result = (BorderStyle)82;
			break;
		case "papyrus":
			result = (BorderStyle)92;
			break;
		case "partyFavor":
			result = BorderStyle.ThinThickThinSmallGap;
			break;
		case "partyGlass":
			result = BorderStyle.DashLargeGap;
			break;
		case "pencils":
			result = BorderStyle.Engrave3D;
			break;
		case "people":
			result = (BorderStyle)84;
			break;
		case "peopleHats":
			result = BorderStyle.DashDotStroker;
			break;
		case "peopleWaving":
			result = (BorderStyle)85;
			break;
		case "poinsettias":
			result = (BorderStyle)40;
			break;
		case "postageStamp":
			result = (BorderStyle)135;
			break;
		case "pumpkin1":
			result = (BorderStyle)65;
			break;
		case "pushPinNote1":
			result = (BorderStyle)63;
			break;
		case "pushPinNote2":
			result = (BorderStyle)64;
			break;
		case "pyramids":
			result = (BorderStyle)113;
			break;
		case "pyramidsAbove":
			result = (BorderStyle)114;
			break;
		case "quadrants":
			result = (BorderStyle)60;
			break;
		case "rings":
			result = (BorderStyle)29;
			break;
		case "safari":
			result = (BorderStyle)98;
			break;
		case "sawtooth":
			result = (BorderStyle)133;
			break;
		case "sawtoothGray":
			result = (BorderStyle)134;
			break;
		case "scaredCat":
			result = (BorderStyle)36;
			break;
		case "seattle":
			result = (BorderStyle)78;
			break;
		case "shadowedSquares":
			result = (BorderStyle)57;
			break;
		case "sharksTeeth":
			result = (BorderStyle)132;
			break;
		case "shorebirdTracks":
			result = (BorderStyle)83;
			break;
		case "skyrocket":
			result = (BorderStyle)77;
			break;
		case "snowflakeFancy":
			result = (BorderStyle)76;
			break;
		case "snowflakes":
			result = (BorderStyle)75;
			break;
		case "sombrero":
			result = BorderStyle.Emboss3D;
			break;
		case "southwest":
			result = (BorderStyle)105;
			break;
		case "stars":
			result = BorderStyle.ThinThickThinLargeGap;
			break;
		case "stars3D":
			result = BorderStyle.ThinThickLargeGap;
			break;
		case "starsBlack":
			result = (BorderStyle)74;
			break;
		case "starsShadowed":
			result = BorderStyle.ThickThinLargeGap;
			break;
		case "starsTop":
			result = (BorderStyle)157;
			break;
		case "sun":
			result = BorderStyle.Wave;
			break;
		case "swirligig":
			result = (BorderStyle)62;
			break;
		case "tornPaper":
			result = (BorderStyle)161;
			break;
		case "tornPaperBlack":
			result = (BorderStyle)162;
			break;
		case "trees":
			result = BorderStyle.DotDotDash;
			break;
		case "triangleParty":
			result = (BorderStyle)123;
			break;
		case "triangles":
			result = (BorderStyle)129;
			break;
		case "tribal1":
			result = (BorderStyle)130;
			break;
		case "tribal2":
			result = (BorderStyle)109;
			break;
		case "tribal3":
			result = (BorderStyle)108;
			break;
		case "tribal4":
			result = (BorderStyle)107;
			break;
		case "tribal5":
			result = (BorderStyle)110;
			break;
		case "tribal6":
			result = (BorderStyle)106;
			break;
		case "twistedLines2":
			result = (BorderStyle)124;
			break;
		case "vine":
			result = (BorderStyle)47;
			break;
		case "waveline":
			result = (BorderStyle)59;
			break;
		case "weavingAngles":
			result = (BorderStyle)96;
			break;
		case "weavingBraid":
			result = (BorderStyle)94;
			break;
		case "weavingRibbon":
			result = (BorderStyle)95;
			break;
		case "weavingStrips":
			result = (BorderStyle)136;
			break;
		case "whiteFlowers":
			result = (BorderStyle)46;
			break;
		case "woodwork":
			result = (BorderStyle)93;
			break;
		case "xIllusions":
			result = (BorderStyle)111;
			break;
		case "zanyTriangles":
			result = (BorderStyle)112;
			break;
		case "zigZag":
			result = (BorderStyle)137;
			break;
		case "zigZagStitch":
			result = (BorderStyle)143;
			break;
		case "none":
			result = BorderStyle.None;
			border.HasNoneStyle = true;
			break;
		}
		return result;
	}

	private int GetBorderMultiplier(Border border)
	{
		FormatBase parentFormat = border.ParentFormat;
		if (parentFormat is WCharacterFormat)
		{
			return 20;
		}
		if (parentFormat is Borders)
		{
			parentFormat = parentFormat.ParentFormat;
		}
		if (parentFormat == null || parentFormat is WParagraphFormat)
		{
			return 20;
		}
		return 8;
	}

	private void ParseRunShading(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("fill", IsStrict ? m_strictNameSpace : m_nameSpace);
		string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		string attribute3 = reader.GetAttribute("color", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			charFormat.TextureStyle = ParseTexture(attribute2);
		}
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				charFormat.TextBackgroundColor = Color.Empty;
			}
			else
			{
				charFormat.TextBackgroundColor = GetColorValue(attribute);
			}
		}
		if (!string.IsNullOrEmpty(attribute3))
		{
			if (attribute3 == "auto")
			{
				charFormat.ForeColor = Color.Empty;
			}
			else
			{
				charFormat.ForeColor = GetColorValue(attribute3);
			}
		}
	}

	private TextureStyle ParseTexture(string textureStyle)
	{
		return textureStyle switch
		{
			"pct5" => TextureStyle.Texture5Percent, 
			"pct10" => TextureStyle.Texture10Percent, 
			"pct12" => TextureStyle.Texture12Pt5Percent, 
			"pct15" => TextureStyle.Texture15Percent, 
			"pct20" => TextureStyle.Texture20Percent, 
			"pct25" => TextureStyle.Texture25Percent, 
			"pct30" => TextureStyle.Texture30Percent, 
			"pct35" => TextureStyle.Texture35Percent, 
			"pct37" => TextureStyle.Texture37Pt5Percent, 
			"pct40" => TextureStyle.Texture40Percent, 
			"pct45" => TextureStyle.Texture45Percent, 
			"pct50" => TextureStyle.Texture50Percent, 
			"pct55" => TextureStyle.Texture55Percent, 
			"pct60" => TextureStyle.Texture60Percent, 
			"pct62" => TextureStyle.Texture62Pt5Percent, 
			"pct65" => TextureStyle.Texture65Percent, 
			"pct70" => TextureStyle.Texture70Percent, 
			"pct75" => TextureStyle.Texture75Percent, 
			"pct80" => TextureStyle.Texture80Percent, 
			"pct85" => TextureStyle.Texture85Percent, 
			"pct87" => TextureStyle.Texture87Pt5Percent, 
			"pct90" => TextureStyle.Texture90Percent, 
			"pct95" => TextureStyle.Texture95Percent, 
			"thinHorzCross" => TextureStyle.TextureCross, 
			"horzCross" => TextureStyle.TextureDarkCross, 
			"diagCross" => TextureStyle.TextureDarkDiagonalCross, 
			"reverseDiagStripe" => TextureStyle.TextureDarkDiagonalDown, 
			"diagStripe" => TextureStyle.TextureDarkDiagonalUp, 
			"horzStripe" => TextureStyle.TextureDarkHorizontal, 
			"vertStripe" => TextureStyle.TextureDarkVertical, 
			"thinDiagCross" => TextureStyle.TextureDiagonalCross, 
			"thinReverseDiagStripe" => TextureStyle.TextureDiagonalDown, 
			"thinDiagStripe" => TextureStyle.TextureDiagonalUp, 
			"thinHorzStripe" => TextureStyle.TextureHorizontal, 
			"solid" => TextureStyle.TextureSolid, 
			"thinVertStripe" => TextureStyle.TextureVertical, 
			"nil" => TextureStyle.TextureNil, 
			_ => TextureStyle.TextureNone, 
		};
	}

	private TextureStyle Parse2003Texture(string textureStyle)
	{
		return textureStyle switch
		{
			"pct-5" => TextureStyle.Texture5Percent, 
			"pct-10" => TextureStyle.Texture10Percent, 
			"pct-12" => TextureStyle.Texture12Pt5Percent, 
			"pct-15" => TextureStyle.Texture15Percent, 
			"pct-20" => TextureStyle.Texture20Percent, 
			"pct-25" => TextureStyle.Texture25Percent, 
			"pct-30" => TextureStyle.Texture30Percent, 
			"pct-35" => TextureStyle.Texture35Percent, 
			"pct-37" => TextureStyle.Texture37Pt5Percent, 
			"pct-40" => TextureStyle.Texture40Percent, 
			"pct-45" => TextureStyle.Texture45Percent, 
			"pct-50" => TextureStyle.Texture50Percent, 
			"pct-55" => TextureStyle.Texture55Percent, 
			"pct-60" => TextureStyle.Texture60Percent, 
			"pct-62" => TextureStyle.Texture62Pt5Percent, 
			"pct-65" => TextureStyle.Texture65Percent, 
			"pct-70" => TextureStyle.Texture70Percent, 
			"pct-75" => TextureStyle.Texture75Percent, 
			"pct-80" => TextureStyle.Texture80Percent, 
			"pct-85" => TextureStyle.Texture85Percent, 
			"pct-87" => TextureStyle.Texture87Pt5Percent, 
			"pct-90" => TextureStyle.Texture90Percent, 
			"pct-95" => TextureStyle.Texture95Percent, 
			"thin-horz-cross" => TextureStyle.TextureCross, 
			"horz-cross" => TextureStyle.TextureDarkCross, 
			"diag-cross" => TextureStyle.TextureDarkDiagonalCross, 
			"reverse-diag-stripe" => TextureStyle.TextureDarkDiagonalDown, 
			"diag-stripe" => TextureStyle.TextureDarkDiagonalUp, 
			"horz-stripe" => TextureStyle.TextureDarkHorizontal, 
			"vert-stripe" => TextureStyle.TextureDarkVertical, 
			"thin-diag-cross" => TextureStyle.TextureDiagonalCross, 
			"thin-reverse-diag-stripe" => TextureStyle.TextureDiagonalDown, 
			"thin-diag-stripe" => TextureStyle.TextureDiagonalUp, 
			"thin-horz-stripe" => TextureStyle.TextureHorizontal, 
			"solid" => TextureStyle.TextureSolid, 
			"thin-vert-stripe" => TextureStyle.TextureVertical, 
			"nil" => TextureStyle.TextureNil, 
			_ => TextureStyle.TextureNone, 
		};
	}

	private void ParseVertAlign(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "subscript":
				charFormat.SubSuperScript = SubSuperScript.SubScript;
				break;
			case "superscript":
				charFormat.SubSuperScript = SubSuperScript.SuperScript;
				break;
			case "baseline":
				charFormat.SubSuperScript = SubSuperScript.None;
				break;
			}
		}
	}

	private void ParseEmphasis(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "circle":
				charFormat.EmphasisType = EmphasisType.Circle;
				break;
			case "comma":
				charFormat.EmphasisType = EmphasisType.Comma;
				break;
			case "dot":
				charFormat.EmphasisType = EmphasisType.Dot;
				break;
			case "underDot":
				charFormat.EmphasisType = EmphasisType.UnderDot;
				break;
			default:
				charFormat.EmphasisType = EmphasisType.NoEmphasis;
				break;
			}
		}
	}

	private void ParseTextEffect(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "antsBlack":
				charFormat.TextEffect = TextEffect.MarchingBlackAnts;
				break;
			case "antsRed":
				charFormat.TextEffect = TextEffect.MarchingRedAnts;
				break;
			case "blinkBackground":
				charFormat.TextEffect = TextEffect.BlinkingBackground;
				break;
			case "lights":
				charFormat.TextEffect = TextEffect.LasVegasLights;
				break;
			case "shimmer":
				charFormat.TextEffect = TextEffect.Shimmer;
				break;
			case "sparkle":
				charFormat.TextEffect = TextEffect.SparkleText;
				break;
			default:
				charFormat.TextEffect = TextEffect.None;
				break;
			}
		}
	}

	private void ParseUnderline(XmlReader reader, WCharacterFormat charFormat)
	{
		switch (reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
		{
		case "single":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Single;
			break;
		case "words":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Words;
			break;
		case "double":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Double;
			break;
		case "dotted":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Dotted;
			break;
		case "thick":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Thick;
			break;
		case "dash":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Dash;
			break;
		case "dotDash":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDash;
			break;
		case "dotDotDash":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDotDash;
			break;
		case "wave":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Wavy;
			break;
		case "dashLong":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashLong;
			break;
		case "dottedHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DottedHeavy;
			break;
		case "dashedHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashHeavy;
			break;
		case "dashLongHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashLongHeavy;
			break;
		case "dashDotHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDashHeavy;
			break;
		case "dashDotDotHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDotDashHeavy;
			break;
		case "wavyHeavy":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.WavyHeavy;
			break;
		case "wavyDouble":
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.WavyDouble;
			break;
		default:
			charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.None;
			break;
		case null:
			break;
		}
		string attribute = reader.GetAttribute("color", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute != null)
		{
			charFormat.UnderlineColor = GetColorValue(attribute);
		}
	}

	private void Parse2003Underline(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "single":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Single;
				break;
			case "words":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Words;
				break;
			case "double":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Double;
				break;
			case "dotted":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Dotted;
				break;
			case "thick":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Thick;
				break;
			case "dash":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Dash;
				break;
			case "dot-dash":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDash;
				break;
			case "dot-dot-dash":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDotDash;
				break;
			case "wave":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.Wavy;
				break;
			case "dash-long":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashLong;
				break;
			case "dotted-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DottedHeavy;
				break;
			case "dashed-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashHeavy;
				break;
			case "dash-long-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DashLongHeavy;
				break;
			case "dash-dot-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDashHeavy;
				break;
			case "dash-dot-dot-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.DotDotDashHeavy;
				break;
			case "wavy-heavy":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.WavyHeavy;
				break;
			case "wavy-double":
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.WavyDouble;
				break;
			default:
				charFormat.UnderlineStyle = DocGen.Drawing.UnderlineStyle.None;
				break;
			}
		}
	}

	private void ParseFonts(XmlReader reader, WCharacterFormat charFormat)
	{
		int i = 0;
		for (int attributeCount = reader.AttributeCount; i < attributeCount; i++)
		{
			reader.MoveToAttribute(i);
			switch (reader.LocalName)
			{
			case "ascii":
			{
				string attribute4 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute4))
				{
					charFormat.FontNameAscii = attribute4;
					charFormat.FontName = attribute4;
				}
				break;
			}
			case "hAnsi":
			case "h-ansi":
			{
				string attribute9 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute9))
				{
					charFormat.FontNameNonFarEast = attribute9;
				}
				break;
			}
			case "fareast":
			case "eastAsia":
			{
				string attribute6 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute6))
				{
					charFormat.FontNameFarEast = attribute6;
				}
				break;
			}
			case "hint":
			{
				string attribute8 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute8))
				{
					switch (attribute8.ToLower())
					{
					case "cs":
						charFormat.IdctHint = FontHintType.CS;
						break;
					case "eastasia":
					case "fareast":
						charFormat.IdctHint = FontHintType.EastAsia;
						break;
					default:
						charFormat.IdctHint = FontHintType.Default;
						break;
					}
				}
				break;
			}
			case "cs":
			{
				string attribute2 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute2))
				{
					charFormat.FontNameBidi = attribute2;
				}
				break;
			}
			case "asciiTheme":
			{
				string attribute7 = reader.GetAttribute(i);
				if (string.IsNullOrEmpty(attribute7))
				{
					break;
				}
				charFormat.FontNameAscii = attribute7;
				if (attribute7 == "minorHAnsi")
				{
					if (m_minorFontName == null)
					{
						charFormat.FontName = "Calibri";
					}
					else
					{
						charFormat.FontName = m_minorFontName;
					}
				}
				else if (attribute7 == "majorHAnsi")
				{
					if (m_majorFontName == null)
					{
						charFormat.FontName = "Cambria";
					}
					else
					{
						charFormat.FontName = m_majorFontName;
					}
				}
				break;
			}
			case "eastAsiaTheme":
			{
				string attribute5 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute5))
				{
					charFormat.FontNameFarEast = attribute5;
				}
				break;
			}
			case "hAnsiTheme":
			{
				string attribute3 = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute3))
				{
					charFormat.FontNameNonFarEast = attribute3;
				}
				break;
			}
			case "cstheme":
			{
				string attribute = reader.GetAttribute(i);
				if (!string.IsNullOrEmpty(attribute))
				{
					charFormat.FontNameBidi = attribute;
				}
				break;
			}
			}
		}
	}

	private static bool IsEnumDefined(ref string value, string formattedValue)
	{
		if (Enum.IsDefined(typeof(LocaleIDs), formattedValue))
		{
			value = formattedValue;
			return true;
		}
		return false;
	}

	internal static bool IsEnumDefined(ref string value)
	{
		value = value.Replace('-', '_');
		if (Enum.IsDefined(typeof(LocaleIDs), value))
		{
			return true;
		}
		string[] array = value.Split('_');
		if (array.Length == 2)
		{
			string formattedValue = array[0].ToLower() + "_" + array[1].ToUpper();
			if (IsEnumDefined(ref value, formattedValue))
			{
				return true;
			}
			formattedValue = array[0].ToLower() + "_" + FirstLetterToUpper(array[1]);
			if (IsEnumDefined(ref value, formattedValue))
			{
				return true;
			}
		}
		else if (array.Length == 3)
		{
			string formattedValue2 = array[0].ToLower() + "_" + FirstLetterToUpper(array[1]) + "_" + array[2].ToUpper();
			if (IsEnumDefined(ref value, formattedValue2))
			{
				return true;
			}
			formattedValue2 = array[0].ToLower() + "_" + array[1].ToLower() + "_" + array[2].ToUpper();
			if (IsEnumDefined(ref value, formattedValue2))
			{
				return true;
			}
			formattedValue2 = array[0].ToLower() + "_" + array[1].ToUpper() + "_" + array[2].ToLower();
			if (IsEnumDefined(ref value, formattedValue2))
			{
				return true;
			}
		}
		return false;
	}

	private static string FirstLetterToUpper(string str)
	{
		if (str.Length > 1)
		{
			return char.ToUpper(str[0]) + str.Substring(1);
		}
		return str;
	}

	private void ParseLanguage(XmlReader reader, WCharacterFormat charFormat)
	{
		string value = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(value))
		{
			if (IsWord2003ML)
			{
				value = value.ToLower();
			}
			if (IsEnumDefined(ref value))
			{
				charFormat.LocaleIdASCII = (short)(LocaleIDs)Enum.Parse(typeof(LocaleIDs), value.Replace('-', '_'), ignoreCase: true);
			}
			else
			{
				short languageID = GetLanguageID(value);
				if (languageID != 1033)
				{
					charFormat.LocaleIdASCII = languageID;
				}
			}
		}
		string name = (IsWord2003ML ? "fareast" : "eastAsia");
		value = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(value))
		{
			if (IsWord2003ML)
			{
				value = value.ToLower();
			}
			if (Enum.IsDefined(typeof(LocaleIDs), value.Replace('-', '_')))
			{
				charFormat.LocaleIdFarEast = (short)(LocaleIDs)Enum.Parse(typeof(LocaleIDs), value.Replace('-', '_'), ignoreCase: true);
			}
			else
			{
				short languageID2 = GetLanguageID(value);
				if (languageID2 != 1033)
				{
					charFormat.LocaleIdFarEast = languageID2;
				}
			}
		}
		value = reader.GetAttribute("bidi", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (string.IsNullOrEmpty(value))
		{
			return;
		}
		if (IsWord2003ML)
		{
			value = value.ToLower();
		}
		if (Enum.IsDefined(typeof(LocaleIDs), value.Replace('-', '_')))
		{
			charFormat.LocaleIdBidi = (short)(LocaleIDs)Enum.Parse(typeof(LocaleIDs), value.Replace('-', '_'), ignoreCase: true);
			return;
		}
		short languageID3 = GetLanguageID(value);
		if (languageID3 != 1033)
		{
			charFormat.LocaleIdBidi = languageID3;
		}
	}

	private void ParseHighlight(XmlReader reader, WCharacterFormat charFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute != null)
		{
			if (attribute.ToLower() == "darkyellow")
			{
				charFormat.HighlightColor = Color.Gold;
			}
			else
			{
				charFormat.HighlightColor = GetColorValue(attribute);
			}
		}
	}

	private void ParseParagraphFormat(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		if (reader.LocalName != "pPr" && reader.LocalName != "pPrChange")
		{
			throw new XmlException("Paragraph properties");
		}
		if (paragraphFormat == null)
		{
			throw new ArgumentException("Paragraph format should not be null");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "pPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "sectPr":
					if (paragraphFormat.OwnerBase is WParagraph && (paragraphFormat.OwnerBase as WParagraph).OwnerTextBody.Owner is BlockContentControl)
					{
						paragraphFormat.XmlProps.Add("sectPr", ReadSingleNodeIntoStream(reader));
						IsSDTHasSectionBreak = true;
						flag = true;
					}
					else
					{
						ParseSectionProperties(reader, m_doc.LastSection);
						m_doc.AddSection();
					}
					break;
				case "pStyle":
				{
					string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (string.IsNullOrEmpty(attribute2))
					{
						break;
					}
					attribute2 = attribute2.Trim();
					if (paragraphFormat.OwnerBase is WParagraph && StyleNameId.ContainsKey(attribute2) && m_doc.Styles.FindByName(StyleNameId[attribute2], StyleType.ParagraphStyle) is IWParagraphStyle style)
					{
						if (!paragraphFormat.IsFormattingChange)
						{
							(paragraphFormat.OwnerBase as WParagraph).ApplyStyle(style, isDomChanges: false);
						}
						else
						{
							paragraphFormat.ParagraphStyleName = attribute2;
						}
					}
					break;
				}
				case "framePr":
					ParseFrameProperties(reader, paragraphFormat);
					break;
				case "rPr":
					if (paragraphFormat.OwnerBase is WParagraph)
					{
						WCharacterFormat breakCharacterFormat = (paragraphFormat.OwnerBase as WParagraph).BreakCharacterFormat;
						ParseCharacterFormat(reader, breakCharacterFormat, null);
					}
					else if (paragraphFormat.OwnerBase is WListLevel)
					{
						ParseCharacterFormat(reader, (paragraphFormat.OwnerBase as WListLevel).CharacterFormat, null);
					}
					break;
				case "tabs":
					ParseTabs(reader, paragraphFormat);
					break;
				case "pageBreakBefore":
					paragraphFormat.PageBreakBefore = GetBooleanValue(reader);
					break;
				case "keepLines":
					paragraphFormat.Keep = GetBooleanValue(reader);
					break;
				case "outlineLvl":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute3))
					{
						float result2 = 0f;
						if (float.TryParse(attribute3, NumberStyles.Float, CultureInfo.InvariantCulture, out result2) && result2 > -1f)
						{
							paragraphFormat.OutlineLevel = (((int)result2 >= 0 && (int)result2 <= 9) ? ((OutlineLevel)Enum.ToObject(typeof(OutlineLevel), (int)result2)) : OutlineLevel.BodyText);
						}
					}
					break;
				}
				case "keepNext":
					paragraphFormat.KeepFollow = GetBooleanValue(reader);
					break;
				case "jc":
					if (IsWord2003ML)
					{
						ParseParagraph2003Justification(reader, paragraphFormat);
					}
					else
					{
						ParseParagraphJustification(reader, paragraphFormat);
					}
					break;
				case "ind":
					ParseIndentation(reader, paragraphFormat);
					break;
				case "spacing":
					ParseSpacing(reader, paragraphFormat);
					break;
				case "shd":
					ParseShading(reader, paragraphFormat);
					break;
				case "bidi":
					paragraphFormat.Bidi = GetBooleanValue(reader);
					break;
				case "widowControl":
					paragraphFormat.WidowControl = GetBooleanValue(reader);
					break;
				case "wordWrap":
					paragraphFormat.WordWrap = GetBooleanValue(reader);
					break;
				case "autoSpaceDE":
					paragraphFormat.AutoSpaceDE = GetBooleanValue(reader);
					break;
				case "autoSpaceDN":
					paragraphFormat.AutoSpaceDN = GetBooleanValue(reader);
					break;
				case "adjustRightInd":
					paragraphFormat.AdjustRightIndent = GetBooleanValue(reader);
					break;
				case "pBdr":
					ParseBorders(reader, paragraphFormat.OwnerBase as IEntity, paragraphFormat.Borders);
					break;
				case "listPr":
				case "numPr":
					ParseList(reader, paragraphFormat);
					break;
				case "contextualSpacing":
					paragraphFormat.ContextualSpacing = GetBooleanValue(reader);
					break;
				case "pPrChange":
					if (reader.AttributeCount > 0)
					{
						string attribute = reader.GetAttribute("author", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute))
						{
							paragraphFormat.FormatChangeAuthorName = attribute;
						}
						attribute = reader.GetAttribute("date", IsStrict ? m_strictNameSpace : m_nameSpace);
						if (!string.IsNullOrEmpty(attribute))
						{
							DateTime result = default(DateTime);
							CultureInfo cultureInfo = (CultureInfo)CultureInfo.InvariantCulture.Clone();
							if (cultureInfo.Calendar is GregorianCalendar || cultureInfo.Calendar is EastAsianLunisolarCalendar || cultureInfo.Calendar is JulianCalendar || cultureInfo.Calendar is ChineseLunisolarCalendar)
							{
								cultureInfo.DateTimeFormat.Calendar.TwoDigitYearMax = 2029;
							}
							DateTime.TryParse(attribute, cultureInfo, DateTimeStyles.AdjustToUniversal, out result);
							paragraphFormat.FormatChangeDateTime = result;
						}
					}
					ParseChangeParagraphFormat(reader, paragraphFormat);
					m_doc.ParaFormatChangeRevision(paragraphFormat);
					break;
				case "mirrorIndents":
					paragraphFormat.MirrorIndents = GetBooleanValue(reader);
					break;
				case "suppressAutoHyphens":
					paragraphFormat.SuppressAutoHyphens = GetBooleanValue(reader);
					break;
				case "textAlignment":
					ParseParagraphTextAlignment(reader, paragraphFormat);
					break;
				case "snapToGrid":
					paragraphFormat.SnapToGrid = GetBooleanValue(reader);
					break;
				case "suppressOverlap":
					paragraphFormat.SuppressOverlap = GetBooleanValue(reader);
					break;
				case "textboxTightWrap":
					ParseParagraphTextboxTightWrap(reader, paragraphFormat);
					break;
				case "suppressLineNumbers":
					paragraphFormat.SuppressLineNumbers = GetBooleanValue(reader);
					break;
				case "kinsoku":
					paragraphFormat.Kinsoku = GetBooleanValue(reader);
					break;
				case "overflowPunct":
					paragraphFormat.OverflowPunctuation = GetBooleanValue(reader);
					break;
				case "topLinePunct":
					paragraphFormat.TopLinePunctuation = GetBooleanValue(reader);
					break;
				case "bottom":
				case "between":
				case "top":
				case "bar":
				case "left":
				case "right":
				{
					WParagraphFormat paragraphFormat2 = (paragraphFormat.OwnerBase as WParagraph).ParagraphFormat;
					Borders borders = null;
					if (paragraphFormat2.IsFormattingChange)
					{
						borders = new Borders();
						paragraphFormat2.SetPropertyValue(20, borders);
						borders = (Borders)paragraphFormat2.OldPropertiesHash[20];
					}
					else
					{
						borders = paragraphFormat2.Borders;
					}
					if (borders != null)
					{
						ParseBorderValue(reader, borders);
					}
					break;
				}
				case "rFonts":
					if (paragraphFormat.OwnerBase is WParagraph)
					{
						WCharacterFormat breakCharacterFormat2 = (paragraphFormat.OwnerBase as WParagraph).BreakCharacterFormat;
						ParseFonts(reader, breakCharacterFormat2);
					}
					else if (paragraphFormat.OwnerBase is WListLevel)
					{
						ParseFonts(reader, (paragraphFormat.OwnerBase as WListLevel).CharacterFormat);
					}
					break;
				default:
					if (!IsWord2003ML && reader.LocalName != "pPr")
					{
						paragraphFormat.XmlProps.Add(reader.LocalName, ReadSingleNodeIntoStream(reader));
						flag = true;
					}
					break;
				case "cnfStyle":
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseFrameProperties(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		ParseFramePos(reader, paragraphFormat);
		ParseFrameAnchor(reader, paragraphFormat);
		ParseFrameSize(reader, paragraphFormat);
	}

	private void ParseFrameSize(XmlReader reader, WParagraphFormat paraFormat)
	{
		string name = (IsWord2003ML ? "h-rule" : "hRule");
		string attribute = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			paraFormat.SetFrameWidthValue(GetFloatValue(attribute, "frameWidth"));
		}
		string attribute2 = reader.GetAttribute("h", IsStrict ? m_strictNameSpace : m_nameSpace);
		float result = 0f;
		if (!string.IsNullOrEmpty(attribute2))
		{
			float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		string attribute3 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute3 != null && attribute3 == "exact")
		{
			paraFormat.FrameHeight = result / 20f;
		}
		else if (result != 0f)
		{
			paraFormat.FrameHeight = (float)((short)result | 0x8000) / 20f;
		}
		else if (attribute3 == "auto" || ((attribute2 == "0" || attribute2 == string.Empty) && string.IsNullOrEmpty(attribute3)))
		{
			paraFormat.FrameHeight = 0f;
		}
		string attribute4 = reader.GetAttribute("dropCap", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute4))
		{
			if (!(attribute4 == "margin"))
			{
				if (attribute4 == "drop")
				{
					paraFormat.DropCap = DropCapType.DropCap;
				}
				else
				{
					paraFormat.DropCap = DropCapType.None;
				}
			}
			else
			{
				paraFormat.DropCap = DropCapType.Margin;
			}
		}
		string attribute5 = reader.GetAttribute("lines", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute5))
		{
			int num = Convert.ToInt32(attribute5);
			if (num > 0 && num < 11)
			{
				paraFormat.DropCapLines = num;
			}
			else
			{
				paraFormat.DropCapLines = 1;
			}
		}
	}

	private void ParseFrameAnchor(XmlReader reader, WParagraphFormat paraFormat)
	{
		string name = (IsWord2003ML ? "hanchor" : "hAnchor");
		string name2 = (IsWord2003ML ? "vanchor" : "vAnchor");
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "margin":
				paraFormat.FrameHorizontalPos = 1;
				break;
			case "page":
			case "column":
				paraFormat.FrameHorizontalPos = 2;
				break;
			case "text":
				paraFormat.FrameHorizontalPos = 0;
				break;
			}
		}
		string attribute2 = reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			switch (attribute2)
			{
			case "margin":
				paraFormat.FrameVerticalPos = 0;
				break;
			case "page":
				paraFormat.FrameVerticalPos = 1;
				break;
			case "text":
				paraFormat.FrameVerticalPos = 2;
				break;
			case "none":
				paraFormat.FrameVerticalPos = 3;
				break;
			}
		}
		string attribute3 = reader.GetAttribute("anchorLock", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute3))
		{
			paraFormat.LockFrameAnchor = GetBoolValue(attribute3);
		}
	}

	private void ParseFramePos(XmlReader reader, WParagraphFormat paraFormat)
	{
		string name = (IsWord2003ML ? "x-align" : "xAlign");
		string name2 = (IsWord2003ML ? "y-align" : "yAlign");
		string text = (IsWord2003ML ? "vspace" : "vSpace");
		string text2 = (IsWord2003ML ? "hspace" : "hSpace");
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "right":
				paraFormat.FrameX = -8f;
				break;
			case "center":
				paraFormat.FrameX = -4f;
				break;
			case "inside":
				paraFormat.FrameX = -12f;
				break;
			case "outside":
				paraFormat.FrameX = -16f;
				break;
			case "left":
				paraFormat.FrameX = 0f;
				break;
			}
		}
		string attribute2 = reader.GetAttribute("x", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			SetFramePositions(attribute2, isXValue: true, paraFormat);
		}
		string attribute3 = reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute3))
		{
			switch (attribute3)
			{
			case "top":
				paraFormat.FrameY = -4f;
				break;
			case "bottom":
				paraFormat.FrameY = -12f;
				break;
			case "center":
				paraFormat.FrameY = -8f;
				break;
			case "inside":
				paraFormat.FrameY = -16f;
				break;
			case "outside":
				paraFormat.FrameY = -20f;
				break;
			case "inline":
				paraFormat.FrameY = 0f;
				break;
			}
		}
		string attribute4 = reader.GetAttribute("y", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute4))
		{
			SetFramePositions(attribute4, isXValue: false, paraFormat);
		}
		string attribute5 = reader.GetAttribute("wrap", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute5))
		{
			switch (attribute5)
			{
			case "notBeside":
				paraFormat.WrapFrameAround = FrameWrapMode.NotBeside;
				break;
			case "around":
				paraFormat.WrapFrameAround = FrameWrapMode.Around;
				break;
			case "none":
				paraFormat.WrapFrameAround = FrameWrapMode.None;
				break;
			case "tight":
				paraFormat.WrapFrameAround = FrameWrapMode.Tight;
				break;
			case "through":
				paraFormat.WrapFrameAround = FrameWrapMode.Through;
				break;
			default:
				if (IsWord2003ML && attribute5 == "not-beside")
				{
					paraFormat.WrapFrameAround = FrameWrapMode.NotBeside;
				}
				paraFormat.WrapFrameAround = FrameWrapMode.Auto;
				break;
			}
		}
		string attribute6 = reader.GetAttribute(text2, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute6))
		{
			paraFormat.SetFrameHorizontalDistanceFromTextValue(GetFloatValue(attribute6, text2));
		}
		string attribute7 = reader.GetAttribute(text, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute7))
		{
			paraFormat.SetFrameVerticalDistanceFromTextValue(GetFloatValue(attribute7, text));
		}
	}

	private void SetFramePositions(string position, bool isXValue, WParagraphFormat paraFormat)
	{
		short result = 0;
		bool flag = false;
		if (short.TryParse(position, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
		{
			flag = (isXValue ? paraFormat.IsFrameXAlign(result) : paraFormat.IsFrameYAlign(result));
		}
		if (flag)
		{
			if (isXValue)
			{
				paraFormat.FrameX = result;
			}
			else
			{
				paraFormat.FrameY = result;
			}
			return;
		}
		float num = GetFloatValue(position, "x");
		if (isXValue ? paraFormat.IsFrameXAlign(num) : paraFormat.IsFrameYAlign(num))
		{
			num -= 0.05f;
		}
		if (isXValue)
		{
			paraFormat.SetFrameXValue(num);
		}
		else
		{
			paraFormat.SetFrameYValue(num);
		}
	}

	private void ParseTabs(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		if (reader.LocalName != "tabs")
		{
			throw new XmlException("Tab collection");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "tabs")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "tab")
				{
					Tab tab = paragraphFormat.Tabs.AddTab();
					string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute) && attribute != "clear")
					{
						tab.Justification = GetTabAlign(attribute);
					}
					string attribute2 = reader.GetAttribute("pos", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						float num = GetFloatValue(attribute2, "pos");
						if ((double)num < -1584.05 || (double)num > 1584.05)
						{
							num = 0f;
						}
						if (attribute == "clear")
						{
							tab.DeletePosition = num * 20f;
						}
						else
						{
							tab.Position = num;
						}
					}
					string attribute3 = reader.GetAttribute("leader", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute3))
					{
						tab.TabLeader = GetTabLeader(attribute3);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private TabJustification GetTabAlign(string align)
	{
		switch (align.ToLower())
		{
		case "center":
			return TabJustification.Centered;
		case "end":
		case "right":
			return TabJustification.Right;
		case "decimal":
			return TabJustification.Decimal;
		case "bar":
			return TabJustification.Bar;
		case "num":
			return TabJustification.List;
		default:
			return TabJustification.Left;
		}
	}

	private TabLeader GetTabLeader(string leader)
	{
		return leader switch
		{
			"dot" => TabLeader.Dotted, 
			"hyphen" => TabLeader.Hyphenated, 
			"underscore" => TabLeader.Single, 
			"heavy" => TabLeader.Heavy, 
			_ => TabLeader.NoLeader, 
		};
	}

	private void ParseChangeParagraphFormat(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		paragraphFormat.IsChangedFormat = true;
		paragraphFormat.IsFormattingChange = true;
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		if (!(reader.LocalName == "pPrChange") || reader.NodeType != XmlNodeType.EndElement)
		{
			ParseParagraphFormat(reader, paragraphFormat);
			paragraphFormat.IsFormattingChange = false;
			if (paragraphFormat.OwnerBase is WParagraph)
			{
				(paragraphFormat.OwnerBase as WParagraph).ListFormat.IsFormattingChange = paragraphFormat.IsFormattingChange;
			}
			else if (paragraphFormat.OwnerBase is WParagraphStyle)
			{
				(paragraphFormat.OwnerBase as WParagraphStyle).ListFormat.IsFormattingChange = paragraphFormat.IsFormattingChange;
			}
		}
	}

	private void CheckTrackChange(ParagraphItem item)
	{
		if (item.GetCharFormat() != null && item.GetCharFormat().HasKey(105))
		{
			m_doc.CharFormatChangeRevision(item.GetCharFormat(), item);
		}
		if (m_trackChangeType == RevisionType.None)
		{
			if (moveRevision != null)
			{
				moveRevision.Range.Items.Add(item);
			}
			return;
		}
		if (moveRevision != null && m_trackchangeRevisionDetails.Count == 0 && (m_trackChangeType == RevisionType.Insertions || m_trackChangeType == RevisionType.Deletions))
		{
			moveRevision.Range.Items.Add(item);
		}
		if (m_trackChangeType == RevisionType.Deletions)
		{
			item.SetDeleteRev(value: true, m_revAuthorName, m_revDateTime);
			m_doc.ParagraphItemRevision(item, RevisionType.Deletions, m_revAuthorName, m_revDateTime, m_name, isNestedRevision: false, moveRevision, contentRevision, m_trackchangeRevisionDetails);
		}
		else if (m_trackChangeType == RevisionType.Insertions)
		{
			item.SetInsertRev(value: true, m_revAuthorName, m_revDateTime);
			m_doc.ParagraphItemRevision(item, RevisionType.Insertions, m_revAuthorName, m_revDateTime, m_name, isNestedRevision: false, moveRevision, contentRevision, m_trackchangeRevisionDetails);
		}
		else if (m_trackChangeType == RevisionType.MoveFrom)
		{
			item.SetDeleteRev(value: true, m_revAuthorName, m_revDateTime);
			m_doc.ParagraphItemRevision(item, RevisionType.MoveFrom, m_revAuthorName, m_revDateTime, m_name, isNestedRevision: false, moveRevision, contentRevision, m_trackchangeRevisionDetails);
		}
		else if (m_trackChangeType == RevisionType.MoveTo)
		{
			item.SetInsertRev(value: true, m_revAuthorName, m_revDateTime);
			m_doc.ParagraphItemRevision(item, RevisionType.MoveTo, m_revAuthorName, m_revDateTime, m_name, isNestedRevision: false, moveRevision, contentRevision, m_trackchangeRevisionDetails);
		}
	}

	private void CreateMoveRangeRevision(WParagraph para, RevisionType revisionType)
	{
		if (para != null && para.BreakCharacterFormat.Revisions.Count > 0)
		{
			foreach (Revision revision in para.BreakCharacterFormat.Revisions)
			{
				if (revision.RevisionType == revisionType && revision.Author == m_revAuthorName && m_doc.Revisions.InnerList.Contains(revision))
				{
					moveRevision = revision;
					revision.Name = m_name;
				}
				else
				{
					moveRevision = m_doc.CreateNewRevision(revisionType, m_revAuthorName, m_revDateTime, m_name);
				}
			}
			return;
		}
		moveRevision = m_doc.CreateNewRevision(revisionType, m_revAuthorName, m_revDateTime, m_name);
	}

	private void UpdateInsDelRevision(XmlReader reader, ParagraphItemCollection paraItems, RevisionType revisionType, IOfficeMathRunElement mathParaItem, bool isParsingRun)
	{
		if (m_trackChangeType == revisionType)
		{
			m_trackChangeType = RevisionType.None;
			if (m_trackchangeStack.Count > 0)
			{
				m_trackchangeStack.Pop();
			}
		}
		if (m_trackChangeType == RevisionType.Deletions)
		{
			m_trackchangeRevisionDetails.Push(m_doc.CreateNewChildRevision(RevisionType.Deletions, m_revAuthorName, m_revDateTime, m_name));
		}
		else if (m_trackChangeType == RevisionType.Insertions)
		{
			m_trackchangeRevisionDetails.Push(m_doc.CreateNewChildRevision(RevisionType.Insertions, m_revAuthorName, m_revDateTime, m_name));
		}
		else if (m_trackChangeType == RevisionType.MoveTo)
		{
			m_trackchangeRevisionDetails.Push(m_doc.CreateNewChildRevision(RevisionType.MoveTo, m_revAuthorName, m_revDateTime, m_name));
		}
		else if (m_trackChangeType == RevisionType.MoveFrom)
		{
			m_trackchangeRevisionDetails.Push(m_doc.CreateNewChildRevision(RevisionType.MoveFrom, m_revAuthorName, m_revDateTime, m_name));
		}
		UpdateRevAuthorInformation(reader, null);
		m_trackChangeType = revisionType;
		m_trackchangeStack.Push(m_trackChangeType);
		if (isParsingRun)
		{
			ParseRun(reader, paraItems, mathParaItem, isAlreadyChecked: false, reader.NodeType, isMappedPictureContentControl: false);
		}
		else
		{
			ParseParagraphItems(reader, paraItems, null, mathParaItem, isMappedPictureContentControl: false);
		}
		m_trackChangeType = RevisionType.None;
		if (m_trackchangeStack.Count > 0)
		{
			m_trackchangeStack.Pop();
		}
		if (m_trackchangeRevisionDetails.Count > 0)
		{
			m_revAuthorName = m_trackchangeRevisionDetails.Peek().Author;
			m_revDateTime = m_trackchangeRevisionDetails.Peek().Date;
			m_trackchangeRevisionDetails.Pop();
		}
		if (m_trackchangeStack.Count > 0)
		{
			m_trackChangeType = m_trackchangeStack.Peek();
		}
	}

	private void ParseBorders(XmlReader reader, IEntity ent, Borders borders)
	{
		if (ent is WTable)
		{
			if (IsTableChangeFormat)
			{
				borders = new Borders();
				(ent as WTable).DocxTableFormat.Format.SetPropertyValue(1, borders);
				borders = (Borders)(ent as WTable).DocxTableFormat.Format.OldPropertiesHash[1];
			}
			else
			{
				borders = (ent as WTable).DocxTableFormat.Format.Borders;
			}
		}
		else if (ent is WTableRow)
		{
			if (IsRowChangeFormat)
			{
				borders = new Borders();
				(ent as WTableRow).RowFormat.SetPropertyValue(1, borders);
				borders = (Borders)(ent as WTableRow).RowFormat.OldPropertiesHash[1];
			}
			else
			{
				borders = (ent as WTableRow).RowFormat.Borders;
			}
		}
		else if (ent is WTableCell)
		{
			if (IsCellChangeFormat)
			{
				borders = new Borders();
				(ent as WTableCell).CellFormat.SetPropertyValue(1, borders);
				borders = (Borders)(ent as WTableCell).CellFormat.OldPropertiesHash[1];
			}
			else
			{
				borders = (ent as WTableCell).CellFormat.Borders;
			}
		}
		else if (ent is WSection)
		{
			WPageSetup pageSetup = (ent as WSection).PageSetup;
			if ((ent as WSection).SectionFormat.IsFormattingChange)
			{
				pageSetup.Borders.IsFormattingChange = true;
			}
			if (pageSetup.IsFormattingChange)
			{
				borders = new Borders();
				pageSetup.SetPropertyValue(34, borders);
				borders = (Borders)pageSetup.OldPropertiesHash[34];
			}
			else
			{
				borders = (ent as WSection).PageSetup.Borders;
			}
		}
		else if (ent is WParagraph)
		{
			WParagraphFormat paragraphFormat = (ent as WParagraph).ParagraphFormat;
			if (paragraphFormat.IsFormattingChange)
			{
				borders = new Borders();
				paragraphFormat.SetPropertyValue(20, borders);
				borders = (Borders)paragraphFormat.OldPropertiesHash[20];
			}
			else
			{
				borders = paragraphFormat.Borders;
			}
		}
		if (borders != null)
		{
			ParseBorder(reader, borders);
		}
	}

	private void ParseBorder(XmlReader reader, Borders borders)
	{
		if (borders == null)
		{
			throw new ArgumentException("Borders should not be null");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				ParseBorderValue(reader, borders);
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseBorderValue(XmlReader reader, Borders borders)
	{
		string localName = reader.LocalName;
		if (localName == null)
		{
			return;
		}
		switch (localName.Length)
		{
		default:
			return;
		case 3:
		{
			char c = localName[0];
			if (c != 'b')
			{
				switch (c)
				{
				default:
					return;
				case 't':
					if (localName == "top")
					{
						ParseBorder(reader, borders.Top);
					}
					return;
				case 'e':
					break;
				}
				if (!(localName == "end"))
				{
					return;
				}
				goto IL_017a;
			}
			if (!(localName == "bar"))
			{
				return;
			}
			break;
		}
		case 5:
		{
			char c = localName[1];
			if ((uint)c <= 108u)
			{
				switch (c)
				{
				default:
					return;
				case 'i':
					break;
				case 'l':
					if (localName == "tl2br")
					{
						ParseBorder(reader, borders.DiagonalDown);
					}
					return;
				}
				if (!(localName == "right"))
				{
					return;
				}
				goto IL_017a;
			}
			switch (c)
			{
			default:
				return;
			case 't':
				break;
			case 'r':
				if (localName == "tr2bl")
				{
					ParseBorder(reader, borders.DiagonalUp);
				}
				return;
			}
			if (!(localName == "start"))
			{
				return;
			}
			goto IL_015e;
		}
		case 7:
		{
			char c = localName[6];
			if (c != 'H')
			{
				if (c == 'V')
				{
					if (!(localName == "insideV"))
					{
						return;
					}
					break;
				}
				if (c != 'n' || !(localName == "between"))
				{
					return;
				}
			}
			else if (!(localName == "insideH"))
			{
				return;
			}
			ParseBorder(reader, borders.Horizontal);
			return;
		}
		case 4:
			if (!(localName == "left"))
			{
				return;
			}
			goto IL_015e;
		case 6:
			{
				if (localName == "bottom")
				{
					ParseBorder(reader, borders.Bottom);
				}
				return;
			}
			IL_017a:
			ParseBorder(reader, borders.Right);
			return;
			IL_015e:
			ParseBorder(reader, borders.Left);
			return;
		}
		ParseBorder(reader, borders.Vertical);
	}

	private void ParseSpacing(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		if (reader.AttributeCount != 0)
		{
			string text = (IsWord2003ML ? "before-lines" : "beforeLines");
			string text2 = (IsWord2003ML ? "after-lines" : "afterLines");
			string name = (IsWord2003ML ? "before-autospacing" : "beforeAutospacing");
			string name2 = (IsWord2003ML ? "after-autospacing" : "afterAutospacing");
			string attribute = reader.GetAttribute("before", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(8, GetFloatValue(attribute, "paraSpacing"));
			}
			attribute = reader.GetAttribute(text, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.BeforeLines = GetFloatValue(attribute, text);
			}
			attribute = reader.GetAttribute(text2, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.AfterLines = GetFloatValue(attribute, text2);
			}
			attribute = reader.GetAttribute("after", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(9, GetFloatValue(attribute, "paraSpacing"));
			}
			string attribute2 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute2))
			{
				paragraphFormat.SpaceBeforeAuto = GetBoolValue(attribute2);
			}
			attribute2 = reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute2))
			{
				paragraphFormat.SpaceAfterAuto = GetBoolValue(attribute2);
			}
			ParseLineSpacing(reader, paragraphFormat);
		}
	}

	private void ParseLineSpacing(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string name = (IsWord2003ML ? "line-rule" : "lineRule");
		string attribute = reader.GetAttribute("line", IsStrict ? m_strictNameSpace : m_nameSpace);
		float num = 0f;
		if (!string.IsNullOrEmpty(attribute))
		{
			num = GetFloatValue(attribute, "line");
		}
		if (num != 0f)
		{
			paragraphFormat.SetPropertyValue(52, 0f);
			paragraphFormat.SetPropertyValue(52, Math.Abs(num));
			string attribute2 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
			switch (attribute2)
			{
			case "atLeast":
				paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
				return;
			case "exact":
				paragraphFormat.LineSpacingRule = LineSpacingRule.Exactly;
				return;
			}
			if (IsWord2003ML && attribute2 == "at-least")
			{
				paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
			}
			paragraphFormat.LineSpacingRule = ((!(num > 0f)) ? LineSpacingRule.Exactly : LineSpacingRule.Multiple);
		}
		else if (!string.IsNullOrEmpty(attribute))
		{
			string attribute3 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (attribute3 == "auto")
			{
				paragraphFormat.SetPropertyValue(52, 0f);
				paragraphFormat.LineSpacingRule = LineSpacingRule.Multiple;
			}
			else if (attribute3 == "atLeast")
			{
				paragraphFormat.SetPropertyValue(52, 0f);
				paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
			}
		}
	}

	private void ParseIndentation(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		if (reader.AttributeCount != 0)
		{
			string name = (IsWord2003ML ? "first-line" : "firstLine");
			string name2 = (IsWord2003ML ? "left-chars" : "leftChars");
			string name3 = (IsWord2003ML ? "right-chars" : "rightChars");
			string name4 = (IsWord2003ML ? "first-line-chars" : "firstLineChars");
			string name5 = (IsWord2003ML ? "hanging-chars" : "hangingChars");
			string attribute = reader.GetAttribute("left", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(2, GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute("right", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(3, GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute("start", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(2, GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute("end", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(3, GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(5, GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute("hanging", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.SetPropertyValue(5, 0f - GetFloatValue(attribute, reader.LocalName));
			}
			attribute = reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.LeftIndentChars = GetFloatValue(attribute, reader.LocalName) * 20f / 100f;
			}
			attribute = reader.GetAttribute(name3, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.RightIndentChars = GetFloatValue(attribute, reader.LocalName) * 20f / 100f;
			}
			attribute = reader.GetAttribute(name4, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.FirstLineIndentChars = GetFloatValue(attribute, reader.LocalName) * 20f / 100f;
			}
			attribute = reader.GetAttribute(name5, IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute))
			{
				paragraphFormat.FirstLineIndentChars = 0f - GetFloatValue(attribute, reader.LocalName) * 20f / 100f;
			}
		}
	}

	private void ParseParagraph2003Justification(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "center":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Center;
				break;
			case "right":
			case "end":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Right;
				break;
			case "both":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Justify;
				break;
			case "distribute":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Distribute;
				break;
			case "medium-kashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyMedium;
				break;
			case "high-kashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyHigh;
				break;
			case "low-kashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyLow;
				break;
			case "thai-distribute":
				paragraphFormat.LogicalJustification = HorizontalAlignment.ThaiJustify;
				break;
			case "list-tab":
				paragraphFormat.LogicalJustification = (HorizontalAlignment)6;
				break;
			default:
				paragraphFormat.LogicalJustification = HorizontalAlignment.Left;
				break;
			}
		}
	}

	private void ParseParagraphJustification(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "center":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Center;
				break;
			case "right":
			case "end":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Right;
				break;
			case "both":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Justify;
				break;
			case "distribute":
				paragraphFormat.LogicalJustification = HorizontalAlignment.Distribute;
				break;
			case "mediumKashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyMedium;
				break;
			case "numTab":
				paragraphFormat.LogicalJustification = (HorizontalAlignment)6;
				break;
			case "highKashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyHigh;
				break;
			case "lowKashida":
				paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyLow;
				break;
			case "thaiDistribute":
				paragraphFormat.LogicalJustification = HorizontalAlignment.ThaiJustify;
				break;
			default:
				paragraphFormat.LogicalJustification = HorizontalAlignment.Left;
				break;
			}
		}
	}

	private void ParseParagraphTextAlignment(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "baseline":
				paragraphFormat.BaseLineAlignment = BaseLineAlignment.Baseline;
				break;
			case "bottom":
				paragraphFormat.BaseLineAlignment = BaseLineAlignment.Bottom;
				break;
			case "center":
				paragraphFormat.BaseLineAlignment = BaseLineAlignment.Center;
				break;
			case "top":
				paragraphFormat.BaseLineAlignment = BaseLineAlignment.Top;
				break;
			default:
				paragraphFormat.BaseLineAlignment = BaseLineAlignment.Auto;
				break;
			}
		}
	}

	private void ParseParagraphTextboxTightWrap(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "allLines":
				paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.AllLines;
				break;
			case "firstAndLastLine":
				paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.FirstAndLastLine;
				break;
			case "firstLineOnly":
				paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.FirstLineOnly;
				break;
			case "lastLineOnly":
				paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.LastLineOnly;
				break;
			default:
				paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.None;
				break;
			}
		}
	}

	private void ParseShading(XmlReader reader, WParagraphFormat paragraphFormat)
	{
		string attribute = reader.GetAttribute("fill", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				paragraphFormat.BackColor = Color.Empty;
			}
			else
			{
				paragraphFormat.BackColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("themeFill", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				paragraphFormat.BackGroundColor = Color.Empty;
			}
			else
			{
				paragraphFormat.BackGroundColor = GetThemeFillColor(attribute);
			}
		}
		attribute = reader.GetAttribute("color", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (attribute == "auto")
			{
				paragraphFormat.ForeColor = Color.Empty;
			}
			else
			{
				paragraphFormat.ForeColor = GetColorValue(attribute);
			}
		}
		attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			paragraphFormat.TextureStyle = ParseTexture(attribute);
		}
	}

	private Color GetThemeFillColor(string value)
	{
		Color result = Color.Empty;
		if (!string.IsNullOrEmpty(value))
		{
			if (!m_doc.Themes.SchemeColor.ContainsKey(value))
			{
				switch (value)
				{
				case "tx1":
					value = "dk1";
					break;
				case "tx2":
					value = "dk2";
					break;
				case "bg1":
					value = "lt1";
					break;
				case "bg2":
					value = "lt2";
					break;
				}
			}
			if (m_doc.Themes.SchemeColor.ContainsKey(value))
			{
				return m_doc.Themes.SchemeColor[value];
			}
			switch (value)
			{
			case "accent1":
				result = Color.FromArgb(255, 79, 129, 189);
				break;
			case "accent2":
				result = Color.FromArgb(255, 192, 80, 77);
				break;
			case "accent3":
				result = Color.FromArgb(255, 155, 187, 89);
				break;
			case "accent4":
				result = Color.FromArgb(255, 128, 100, 162);
				break;
			case "accent5":
				result = Color.FromArgb(255, 75, 172, 198);
				break;
			case "accent6":
				result = Color.FromArgb(255, 247, 150, 70);
				break;
			case "tx1":
			case "dk1":
			case "phClr":
				result = Color.FromArgb(255, 0, 0, 0);
				break;
			case "tx2":
			case "dk2":
				result = Color.FromArgb(255, 31, 73, 125);
				break;
			case "folHlink":
				result = Color.FromArgb(255, 128, 0, 128);
				break;
			case "hlink":
				result = Color.FromArgb(255, 0, 0, 255);
				break;
			case "lt1":
			case "bg1":
				result = Color.FromArgb(255, 255, 255, 255);
				break;
			case "lt2":
			case "bg2":
				result = Color.FromArgb(255, 238, 236, 225);
				break;
			}
		}
		return result;
	}

	private void ParseSectionProperties(XmlReader reader, IEntity entity)
	{
		if (reader.LocalName != "sectPr")
		{
			throw new XmlException("Section properties");
		}
		if (entity == null)
		{
			throw new ArgumentException("Section should not be null");
		}
		(entity as WSection).PageSetup.InitializeDocxPageSetup();
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		SkipWhitespaces(reader);
		while (reader.LocalName != "sectPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "footerReference":
				case "headerReference":
					ParseHeaderFooter(reader);
					break;
				case "type":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (IsWord2003ML)
					{
						Parse2003SectionBreakType(entity as WSection, attribute3);
					}
					else
					{
						ParseSectionBreakType(entity as WSection, attribute3);
					}
					break;
				}
				case "pgSz":
					ParsePageSize(reader, entity as WSection);
					break;
				case "pgMar":
					ParsePageMargins(reader, entity as WSection);
					break;
				case "cols":
					ParseColumns(reader, entity as WSection);
					if (reader.LocalName != "cols")
					{
						flag = true;
					}
					break;
				case "titlePg":
					(entity as WSection).PageSetup.DifferentFirstPage = GetBooleanValue(reader);
					break;
				case "pgBorders":
					ParsePageBorders(reader, entity as WSection);
					break;
				case "docGrid":
					ParseGrid(reader, entity as WSection);
					break;
				case "vAlign":
					ParseVertAlign(reader, entity as WSection);
					break;
				case "lnNumType":
					m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, 18);
					ParseLineNumbering(reader, entity as WSection);
					if ((double)(entity as WSection).PageSetup.LineNumberingDistanceFromText == 0.0)
					{
						(entity as WSection).PageSetup.LineNumberingDistanceFromText = 18f;
					}
					break;
				case "footnotePr":
					ParseFootnoteProp(reader, isFootnote: true, entity as WSection);
					break;
				case "endnotePr":
					ParseFootnoteProp(reader, isFootnote: false, entity as WSection);
					break;
				case "textDirection":
					ParseTextDirection(reader, entity as WSection);
					break;
				case "rtlGutter":
					if (GetBooleanValue(reader))
					{
						(entity as WSection).PageSetup.Margins.Right += m_gutter;
					}
					break;
				case "pgNumType":
					ParsePageNumberType(reader, entity as WSection);
					break;
				case "bidi":
					(entity as WSection).PageSetup.Bidi = GetBooleanValue(reader);
					break;
				case "formProt":
					(entity as WSection).ProtectForm = GetBooleanValue(reader);
					break;
				case "paperSrc":
				{
					string attribute2 = reader.GetAttribute("first", IsStrict ? m_strictNameSpace : m_nameSpace);
					float result = float.MaxValue;
					if (!string.IsNullOrEmpty(attribute2))
					{
						(entity as WSection).PageSetup.FirstPageTray = (PrinterPaperTray)Math.Floor(float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? result : 0f);
					}
					attribute2 = reader.GetAttribute("other", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						(entity as WSection).PageSetup.OtherPagesTray = (PrinterPaperTray)Math.Floor(float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result) ? result : 0f);
					}
					break;
				}
				case "sectPrChange":
					UpdateRevAuthorInformation(reader, null);
					ParseChangeSectionProperties(reader, entity as WSection);
					m_doc.SectionFormatChangeRevision(entity as WSection);
					break;
				default:
					if (IsWord2003ML)
					{
						switch (reader.LocalName)
						{
						case "hdr":
						case "ftr":
						{
							bool isHeader = reader.LocalName == "hdr";
							string attribute = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
							ParseHeaderFooter(m_doc.LastSection.HeadersFooters, reader, attribute, isHeader);
							break;
						}
						case "textFlow":
							Parse2003TextDirection(reader, entity as WSection);
							break;
						}
					}
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParseChangeSectionProperties(XmlReader reader, WSection section)
	{
		section.SectionFormat.IsFormattingChange = true;
		section.PageSetup.IsFormattingChange = true;
		section.PageSetup.PageNumbers.IsFormattingChange = true;
		section.PageSetup.Margins.IsFormattingChange = true;
		section.PageSetup.Borders.IsFormattingChange = true;
		section.Document.SetDefaultSectionFormatting(section);
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
		{
			SkipWhitespaces(reader);
			if (!(reader.LocalName == "sectPrChange") || reader.NodeType != XmlNodeType.EndElement)
			{
				ParseSectionProperties(reader, section);
				section.SectionFormat.FormatChangeAuthorName = m_revAuthorName;
				section.SectionFormat.FormatChangeDateTime = m_revDateTime;
				section.SectionFormat.IsFormattingChange = false;
				section.PageSetup.IsFormattingChange = false;
				section.PageSetup.PageNumbers.IsFormattingChange = false;
				section.PageSetup.Margins.IsFormattingChange = false;
				section.PageSetup.Borders.IsFormattingChange = false;
				section.SectionFormat.IsChangedFormat = true;
			}
		}
	}

	private void ParseHeaderFooter(XmlReader reader)
	{
		string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
		DictionaryEntry dictionaryEntry = ((m_docRelations == null || string.IsNullOrEmpty(attribute) || !m_docRelations.ContainsKey(attribute)) ? default(DictionaryEntry) : m_docRelations[attribute]);
		string text = reader.GetAttribute("type", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		bool flag = dictionaryEntry.Key != null && (string)dictionaryEntry.Key == (IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships/header" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header");
		string fileName = ((dictionaryEntry.Value != null) ? dictionaryEntry.Value.ToString() : string.Empty);
		string partName = GetPartName(ref fileName);
		Part part = FindPart(partName, fileName);
		m_currentFile = ((dictionaryEntry.Value != null) ? (dictionaryEntry.Value?.ToString() + ".rels") : string.Empty);
		if (string.IsNullOrEmpty(text) && (flag ? (m_doc.LastSection.HeadersFooters.OddHeader.Items.Count == 0) : (m_doc.LastSection.HeadersFooters.OddFooter.Items.Count == 0)))
		{
			text = "default";
		}
		ParseHeaderFooter(m_doc.LastSection.HeadersFooters, part, text, flag);
		m_currentFile = "";
	}

	private void ParseHeaderFooter(WHeadersFooters headerfooter, XmlReader reader, string type, bool isHeader)
	{
		IEntity entity = null;
		switch (type)
		{
		case "odd":
			entity = ((!isHeader) ? headerfooter.OddFooter : headerfooter.OddHeader);
			break;
		case "first":
			entity = ((!isHeader) ? headerfooter.FirstPageFooter : headerfooter.FirstPageHeader);
			break;
		case "even":
			entity = ((!isHeader) ? headerfooter.EvenFooter : headerfooter.EvenHeader);
			break;
		}
		if (entity != null)
		{
			reader.MoveToContent();
			ParseBody(reader, entity, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
		}
	}

	private void ParseHeaderFooter(WHeadersFooters headerfooter, Part part, string type, bool isHeader)
	{
		IEntity entity = null;
		XmlReader xmlReader = UtilityMethods.CreateReader(part.DataStream);
		int bitPosition = (isHeader ? 22 : 20);
		m_doc.SetTriggerElement(ref m_doc.m_supportedElementFlag_1, bitPosition);
		switch (type)
		{
		case "default":
			entity = ((!isHeader) ? headerfooter.OddFooter : headerfooter.OddHeader);
			break;
		case "first":
			entity = ((!isHeader) ? headerfooter.FirstPageFooter : headerfooter.FirstPageHeader);
			break;
		case "even":
			entity = ((!isHeader) ? headerfooter.EvenFooter : headerfooter.EvenHeader);
			break;
		}
		if (entity != null)
		{
			xmlReader.MoveToContent();
			ParseBody(xmlReader, entity, isRunElementTextBody: false, isFromDocument: false, isMappedPictureContentControl: false);
		}
	}

	private void ParseFootnoteProp(XmlReader reader, bool isFootnote, WSection section)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		string localName2 = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != localName2)
		{
			switch (reader.LocalName)
			{
			case "pos":
			{
				string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
				if (!string.IsNullOrEmpty(attribute) && (IsWord2003ML ? (attribute == "beneath-text") : (attribute == "beneathText")))
				{
					section.PageSetup.FootnotePosition = FootnotePosition.PrintImmediatelyBeneathText;
				}
				break;
			}
			case "numFmt":
				if (IsWord2003ML)
				{
					Parse2003FootnoteNumFormat(reader, isFootnote, section);
				}
				else
				{
					ParseFootnoteNumFormat(reader, isFootnote, section);
				}
				break;
			case "numRestart":
				ParseFootnoteNumRestart(reader, isFootnote, section);
				break;
			case "numStart":
				ParseFootnoteNumberStart(reader, isFootnote, section);
				break;
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private void ParseFootnoteNumberStart(XmlReader reader, bool isFootnote, WSection section)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == null)
		{
			return;
		}
		float result = 0f;
		if (isFootnote)
		{
			if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				section.PageSetup.InitialFootnoteNumber = (int)result;
			}
		}
		else if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
		{
			section.PageSetup.InitialEndnoteNumber = (int)result;
		}
	}

	private void Parse2003FootnoteNumFormat(XmlReader reader, bool isFootnote, WSection section)
	{
		string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
		if (attribute == null)
		{
			return;
		}
		switch (attribute)
		{
		case "decimal":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			break;
		case "lower-letter":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			break;
		case "upper-letter":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			break;
		case "lower-roman":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			break;
		case "upper-roman":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			break;
		}
	}

	private void ParseFootnoteNumFormat(XmlReader reader, bool isFootnote, WSection section)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null)
		{
			return;
		}
		switch (attribute)
		{
		case "decimal":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			break;
		case "lowerLetter":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			break;
		case "upperLetter":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			break;
		case "lowerRoman":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			break;
		case "upperRoman":
			if (isFootnote)
			{
				section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			else
			{
				section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			break;
		}
	}

	private void ParseFootnoteNumRestart(XmlReader reader, bool isFootnote, WSection section)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute == null)
		{
			return;
		}
		if (IsWord2003ML ? (attribute == "each-page") : (attribute == "eachPage"))
		{
			section.PageSetup.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachPage;
		}
		else if (IsWord2003ML ? (attribute == "each-sect") : (attribute == "eachSect"))
		{
			if (isFootnote)
			{
				section.PageSetup.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachSection;
			}
			else
			{
				section.PageSetup.RestartIndexForEndnote = EndnoteRestartIndex.RestartForEachSection;
			}
		}
	}

	private void ParseFootnoteProp(XmlReader reader, bool isFootnote)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		string text = localName;
		SkipWhitespaces(reader);
		while (reader.LocalName != text)
		{
			switch (reader.LocalName)
			{
			case "pos":
			{
				string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
				if (!string.IsNullOrEmpty(attribute) && (IsWord2003ML ? (attribute == "beneath-text") : (attribute == "beneathText")))
				{
					m_doc.FootnotePosition = FootnotePosition.PrintImmediatelyBeneathText;
				}
				else if (!isFootnote && !string.IsNullOrEmpty(attribute) && (IsWord2003ML ? (attribute == "sect-end") : (attribute == "sectEnd")))
				{
					m_doc.EndnotePosition = EndnotePosition.DisplayEndOfSection;
				}
				break;
			}
			case "numFmt":
				if (IsWord2003ML)
				{
					Parse2003FootnoteNumFormat(reader, isFootnote);
				}
				else
				{
					ParseFootnoteNumFormat(reader, isFootnote);
				}
				break;
			case "numRestart":
				ParseFootnoteNumRestart(reader, isFootnote);
				break;
			case "numStart":
				ParseFootnoteNumberStart(reader, isFootnote);
				break;
			}
			reader.Read();
			SkipWhitespaces(reader);
		}
	}

	private void ParseFootnoteNumberStart(XmlReader reader, bool isFootnote)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null)
		{
			return;
		}
		float result = 0f;
		if (isFootnote)
		{
			if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
			{
				m_doc.InitialFootnoteNumber = (int)result;
			}
		}
		else if (float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result))
		{
			m_doc.InitialEndnoteNumber = (int)result;
		}
	}

	private void Parse2003FootnoteNumFormat(XmlReader reader, bool isFootnote)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null)
		{
			return;
		}
		switch (attribute)
		{
		case "decimal":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			break;
		case "lower-letter":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			break;
		case "upper-letter":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			break;
		case "lower-roman":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			break;
		case "upper-roman":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			break;
		}
	}

	private void ParseFootnoteNumFormat(XmlReader reader, bool isFootnote)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null)
		{
			return;
		}
		switch (attribute)
		{
		case "decimal":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
			}
			break;
		case "lowerLetter":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
			}
			break;
		case "upperLetter":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
			}
			break;
		case "lowerRoman":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
			}
			break;
		case "upperRoman":
			if (isFootnote)
			{
				m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			else
			{
				m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
			}
			break;
		}
	}

	private void ParseFootnoteNumRestart(XmlReader reader, bool isFootnote)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null)
		{
			return;
		}
		if (attribute == "eachPage")
		{
			m_doc.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachPage;
		}
		else if (attribute == "eachSect")
		{
			if (isFootnote)
			{
				m_doc.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachSection;
			}
			else
			{
				m_doc.RestartIndexForEndnote = EndnoteRestartIndex.RestartForEachSection;
			}
		}
	}

	private void Parse2003PageNumberStyle(WSection section, string numberType)
	{
		switch (numberType)
		{
		case "lower-roman":
			section.PageSetup.PageNumberStyle = PageNumberStyle.RomanLower;
			break;
		case "upper-roman":
			section.PageSetup.PageNumberStyle = PageNumberStyle.RomanUpper;
			break;
		case "upper-letter":
			section.PageSetup.PageNumberStyle = PageNumberStyle.LetterUpper;
			break;
		case "lower-letter":
			section.PageSetup.PageNumberStyle = PageNumberStyle.LetterLower;
			break;
		case "decimal":
			section.PageSetup.PageNumberStyle = PageNumberStyle.Arabic;
			break;
		}
	}

	private void Parse2003ChapterNumberSeparator(WSection section, string chapterNumberSeprator)
	{
		switch (chapterNumberSeprator)
		{
		case "colon":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Colon;
			break;
		case "hyphen":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Hyphen;
			break;
		case "period":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Period;
			break;
		case "em-dash":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EmDash;
			break;
		case "en-dash":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EnDash;
			break;
		}
	}

	private void ParseChapterNumberSeparator(WSection section, string chapterNumberSeprator)
	{
		if (section.SectionFormat.IsFormattingChange)
		{
			section.PageSetup.PageNumbers.IsFormattingChange = true;
		}
		switch (chapterNumberSeprator)
		{
		case "colon":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Colon;
			break;
		case "hyphen":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Hyphen;
			break;
		case "period":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Period;
			break;
		case "emDash":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EmDash;
			break;
		case "enDash":
			section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EnDash;
			break;
		}
	}

	private void ParsePageNumberStyle(WSection section, string numberType)
	{
		if (section.SectionFormat.IsFormattingChange)
		{
			section.PageSetup.PageNumbers.IsFormattingChange = true;
		}
		switch (numberType)
		{
		case "decimal":
			section.PageSetup.PageNumberStyle = PageNumberStyle.Arabic;
			break;
		case "lowerRoman":
			section.PageSetup.PageNumberStyle = PageNumberStyle.RomanLower;
			break;
		case "upperRoman":
			section.PageSetup.PageNumberStyle = PageNumberStyle.RomanUpper;
			break;
		case "lowerLetter":
			section.PageSetup.PageNumberStyle = PageNumberStyle.LetterLower;
			break;
		case "upperLetter":
			section.PageSetup.PageNumberStyle = PageNumberStyle.LetterUpper;
			break;
		}
	}

	private void ParsePageNumberType(XmlReader reader, WSection section)
	{
		string attribute = reader.GetAttribute("fmt", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (IsWord2003ML)
			{
				Parse2003PageNumberStyle(section, attribute);
			}
			else
			{
				ParsePageNumberStyle(section, attribute);
			}
		}
		string attribute2 = reader.GetAttribute("start", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			section.PageSetup.RestartPageNumbering = true;
			section.PageSetup.PageStartingNumber = ParseIntegerValue(attribute2);
		}
		string name = (IsWord2003ML ? "chap-style" : "chapStyle");
		string attribute3 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute3))
		{
			section.PageSetup.PageNumbers.HeadingLevelForChapter = (HeadingLevel)ParseIntegerValue(attribute3);
		}
		string name2 = (IsWord2003ML ? "chap-sep" : "chapSep");
		string attribute4 = reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute4))
		{
			if (IsWord2003ML)
			{
				Parse2003ChapterNumberSeparator(section, attribute4);
			}
			else
			{
				ParseChapterNumberSeparator(section, attribute4);
			}
		}
	}

	private void Parse2003TextDirection(XmlReader reader, IEntity ent)
	{
		string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
		if (attribute != null)
		{
			switch (attribute)
			{
			case "lr-tb":
				(ent as WSection).TextDirection = DocTextDirection.LeftToRight;
				break;
			case "tb-rl":
				(ent as WSection).TextDirection = DocTextDirection.TopToBottom;
				break;
			case "bt-lr":
				(ent as WSection).TextDirection = DocTextDirection.LeftToRightRotated;
				break;
			case "lr-tb-v":
				(ent as WSection).TextDirection = DocTextDirection.RightToLeft;
				break;
			case "tb-rl-v":
				(ent as WSection).TextDirection = DocTextDirection.RightToLeftRotated;
				break;
			}
		}
	}

	private void ParseTextDirection(XmlReader reader, IEntity ent)
	{
		if (IsWord2003ML)
		{
			return;
		}
		string attribute = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (attribute == null || attribute == null)
		{
			return;
		}
		switch (attribute.Length)
		{
		default:
			return;
		case 2:
		{
			char c = attribute[0];
			if (c != 'l')
			{
				if (c != 'r')
				{
					if (c != 't' || !(attribute == "tb"))
					{
						return;
					}
					goto IL_0135;
				}
				if (!(attribute == "rl"))
				{
					return;
				}
				goto IL_0142;
			}
			if (!(attribute == "lr"))
			{
				return;
			}
			goto IL_014f;
		}
		case 4:
		{
			char c = attribute[0];
			if (c != 'b')
			{
				if (c != 'l')
				{
					if (c != 't' || !(attribute == "tbRl"))
					{
						return;
					}
					goto IL_0142;
				}
				if (!(attribute == "lrTb"))
				{
					return;
				}
				goto IL_0135;
			}
			if (!(attribute == "btLr"))
			{
				return;
			}
			goto IL_014f;
		}
		case 3:
		{
			char c = attribute[0];
			if (c != 'r')
			{
				if (c != 't' || !(attribute == "tbV"))
				{
					return;
				}
				goto IL_015c;
			}
			if (!(attribute == "rlV"))
			{
				return;
			}
			break;
		}
		case 5:
			{
				char c = attribute[0];
				if (c != 'l')
				{
					if (c != 't' || !(attribute == "tbRlV"))
					{
						return;
					}
					break;
				}
				if (!(attribute == "lrTbV"))
				{
					return;
				}
				goto IL_015c;
			}
			IL_014f:
			(ent as WSection).TextDirection = DocTextDirection.LeftToRightRotated;
			return;
			IL_0135:
			(ent as WSection).TextDirection = DocTextDirection.LeftToRight;
			return;
			IL_0142:
			(ent as WSection).TextDirection = DocTextDirection.TopToBottom;
			return;
			IL_015c:
			(ent as WSection).TextDirection = DocTextDirection.RightToLeft;
			return;
		}
		(ent as WSection).TextDirection = DocTextDirection.RightToLeftRotated;
	}

	private void ParseLineNumbering(XmlReader reader, WSection section)
	{
		string name = (IsWord2003ML ? "count-by" : "countBy");
		WPageSetup pageSetup = section.PageSetup;
		string attribute = reader.GetAttribute("distance", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (reader.AttributeCount == 1 && !string.IsNullOrEmpty(attribute))
		{
			return;
		}
		if (reader.HasAttributes && pageSetup.LineNumberingMode == LineNumberingMode.None)
		{
			pageSetup.LineNumberingMode = LineNumberingMode.RestartPage;
		}
		float result = 0f;
		string attribute2 = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			pageSetup.SetPageSetupProperty("LineNumberingStep", (int)(float.TryParse(attribute2, NumberStyles.Integer, CultureInfo.InvariantCulture, out result) ? result : 0f));
		}
		attribute2 = reader.GetAttribute("start", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2) && new Regex("^.*\\d+(\\.*\\d+)*$").IsMatch(attribute2))
		{
			int num = (int)GetNumericValue(attribute2);
			pageSetup.SetPageSetupProperty("LineNumberingStartValue", (num != -1) ? (num + 1) : num);
		}
		string attribute3 = reader.GetAttribute("distance", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute3))
		{
			pageSetup.SetPageSetupProperty("LineNumberingDistanceFromText", GetFloatValue(attribute3, "distance"));
		}
		attribute2 = reader.GetAttribute("restart", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (string.IsNullOrEmpty(attribute2))
		{
			return;
		}
		if (IsWord2003ML)
		{
			switch (attribute2)
			{
			case "new-page":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.RestartPage);
				break;
			case "new-section":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.RestartSection);
				break;
			case "continuous":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.Continuous);
				break;
			}
		}
		else
		{
			switch (attribute2)
			{
			case "newPage":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.RestartPage);
				break;
			case "newSection":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.RestartSection);
				break;
			case "continuous":
				pageSetup.SetPageSetupProperty("LineNumberingMode", LineNumberingMode.Continuous);
				break;
			}
		}
	}

	private void ParseVertAlign(XmlReader reader, WSection section)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			switch (attribute)
			{
			case "top":
				section.PageSetup.VerticalAlignment = PageAlignment.Top;
				break;
			case "center":
				section.PageSetup.VerticalAlignment = PageAlignment.Middle;
				break;
			case "both":
				section.PageSetup.VerticalAlignment = PageAlignment.Justified;
				break;
			case "bottom":
				section.PageSetup.VerticalAlignment = PageAlignment.Bottom;
				break;
			}
		}
	}

	private void ParseGrid(XmlReader reader, WSection section)
	{
		string text = (IsWord2003ML ? "line-pitch" : "linePitch");
		string attribute = reader.GetAttribute(text, IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (string.IsNullOrEmpty(attribute))
		{
			return;
		}
		section.PageSetup.LinePitch = GetFloatValue(attribute, text);
		string attribute2 = reader.GetAttribute("type", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
		if (string.IsNullOrEmpty(attribute2))
		{
			return;
		}
		if (IsWord2003ML)
		{
			switch (attribute2)
			{
			case "lines-and-chars":
				section.PageSetup.PitchType = GridPitchType.CharsAndLine;
				break;
			case "snap-to-chars":
				section.PageSetup.PitchType = GridPitchType.SnapToChars;
				break;
			case "lines":
				section.PageSetup.PitchType = GridPitchType.LinesOnly;
				break;
			}
		}
		else
		{
			switch (attribute2)
			{
			case "lines":
				section.PageSetup.PitchType = GridPitchType.LinesOnly;
				break;
			case "linesAndChars":
				section.PageSetup.PitchType = GridPitchType.CharsAndLine;
				break;
			case "snapToChars":
				section.PageSetup.PitchType = GridPitchType.SnapToChars;
				break;
			}
		}
	}

	private void ParsePageBorders(XmlReader reader, WSection section)
	{
		string name = (IsWord2003ML ? "offset-from" : "offsetFrom");
		string name2 = (IsWord2003ML ? "z-order" : "zOrder");
		string attribute = reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			section.PageSetup.PageBorderOffsetFrom = ((attribute == "page") ? PageBorderOffsetFrom.PageEdge : PageBorderOffsetFrom.Text);
		}
		if (reader.GetAttribute(name2, IsStrict ? m_strictNameSpace : m_nameSpace) == "back")
		{
			section.PageSetup.IsFrontPageBorder = false;
		}
		string attribute2 = reader.GetAttribute("display", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			if (IsWord2003ML ? (attribute2 == "first-page") : (attribute2 == "firstPage"))
			{
				section.PageSetup.PageBordersApplyType = PageBordersApplyType.FirstPage;
			}
			else if (IsWord2003ML ? (attribute2 == "not-first-page") : (attribute2 == "notFirstPage"))
			{
				section.PageSetup.PageBordersApplyType = PageBordersApplyType.AllExceptFirstPage;
			}
		}
		ParseBorders(reader, section, null);
	}

	private void ParseColumns(XmlReader reader, WSection section)
	{
		string attribute = reader.GetAttribute("sep", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute) && attribute == "1")
		{
			section.PageSetup.DrawLinesBetweenCols = true;
		}
		int result = 1;
		string attribute2 = reader.GetAttribute("num", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			int.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		}
		section.PageSetup.NumberOfColumns = result;
		attribute2 = reader.GetAttribute("space", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2))
		{
			float result2 = 0f;
			float.TryParse(attribute2, NumberStyles.Number, CultureInfo.InvariantCulture, out result2);
			section.PageSetup.ColumnSpace = result2;
		}
		ColumnCollection columnCollection = new ColumnCollection(section);
		if (section.SectionFormat.IsFormattingChange)
		{
			for (int i = 0; i < section.Columns.Count; i++)
			{
				columnCollection.Add(section.Columns[i]);
			}
		}
		if (section.Columns.Count > 0)
		{
			section.Columns.InnerList.Clear();
		}
		if (!GetBooleanValue(reader))
		{
			section.Columns.OwnerSection.PageSetup.EqualColumnWidth = false;
			ParseColumn(reader, section, result);
		}
		else
		{
			section.Columns.OwnerSection.PageSetup.EqualColumnWidth = true;
			ParseEqualColumns(reader, section, result);
		}
		if (columnCollection.Count > 0)
		{
			section.SectionFormat.SectFormattingColumnCollection = new ColumnCollection(section);
			for (int j = 0; j < section.Columns.Count; j++)
			{
				section.SectionFormat.SectFormattingColumnCollection.Add(section.Columns[j]);
			}
			if (section.Columns.Count > 0)
			{
				section.Columns.InnerList.Clear();
			}
			for (int k = 0; k < columnCollection.Count; k++)
			{
				section.Columns.Add(columnCollection[k]);
			}
			columnCollection.Close();
		}
	}

	private void ParseEqualColumns(XmlReader reader, WSection section, int num)
	{
		float num2 = section.PageSetup.PageSize.Width * 20f;
		float num3 = section.PageSetup.Margins.Left * 20f;
		float num4 = section.PageSetup.Margins.Right * 20f;
		float result = (IsStrict ? 36 : 720);
		float num5 = 0f;
		string attribute = reader.GetAttribute("space", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute))
		{
			if (IsStrict)
			{
				result = ParseFloatValue(attribute);
			}
			else
			{
				float.TryParse(attribute, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			}
		}
		num5 = (num2 - num3 - num4 - (IsStrict ? (result * 20f) : (result * (float)(num - 1)))) / (float)num;
		for (int i = 0; i < num; i++)
		{
			Column column = new Column(m_doc);
			if (section.SectionFormat.IsFormattingChange)
			{
				column.IsFormattingChange = true;
			}
			column.Space = (IsStrict ? result : (result / 20f));
			column.Width = num5 / 20f;
			section.Columns.Add(column, isOpening: true);
		}
	}

	private void ParseColumn(XmlReader reader, WSection section, int num)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		SkipWhitespaces(reader);
		while (reader.LocalName != "cols")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (reader.LocalName == "col")
				{
					Column column = new Column(m_doc);
					if (section.SectionFormat.IsFormattingChange)
					{
						column.IsFormattingChange = true;
					}
					string attribute = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
					string attribute2 = reader.GetAttribute("space", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (!string.IsNullOrEmpty(attribute2))
					{
						float floatValue = GetFloatValue(attribute2, reader.LocalName);
						column.Space = ((floatValue < 0f || floatValue > 1584f) ? 0f : floatValue);
					}
					if (!string.IsNullOrEmpty(attribute))
					{
						float floatValue2 = GetFloatValue(attribute, reader.LocalName);
						column.Width = ((floatValue2 < 0f || floatValue2 > 1584f) ? 0f : floatValue2);
					}
					if (section.Columns.Count < num)
					{
						section.Columns.Add(column, isOpening: true);
					}
				}
				reader.Read();
			}
			else
			{
				reader.Read();
			}
			SkipWhitespaces(reader);
		}
	}

	private void ParsePageMargins(XmlReader reader, WSection section)
	{
		float marginValue = GetMarginValue(reader, "top");
		float marginValue2 = GetMarginValue(reader, "right");
		float marginValue3 = GetMarginValue(reader, "bottom");
		float marginValue4 = GetMarginValue(reader, "left");
		float marginValue5 = GetMarginValue(reader, "footer");
		float marginValue6 = GetMarginValue(reader, "header");
		float marginValue7 = GetMarginValue(reader, "gutter");
		if (section.SectionFormat.IsFormattingChange)
		{
			section.PageSetup.Margins = new MarginsF();
			section.PageSetup.Margins.SetOldPropertyHashMarginValues(marginValue4, marginValue, marginValue2, marginValue3, marginValue7);
		}
		else
		{
			section.PageSetup.Margins = new MarginsF(marginValue4, marginValue, marginValue2, marginValue3);
			section.PageSetup.Margins.Gutter = marginValue7;
		}
		if (marginValue5 != -1f)
		{
			section.PageSetup.SetPageSetupProperty("FooterDistance", marginValue5);
		}
		if (marginValue6 != -1f)
		{
			section.PageSetup.SetPageSetupProperty("HeaderDistance", marginValue6);
		}
		m_gutter = marginValue7;
	}

	private float GetMarginValue(XmlReader reader, string attributeName)
	{
		int num;
		switch (attributeName)
		{
		default:
			num = 72;
			break;
		case "gutter":
			num = 0;
			break;
		case "footer":
		case "header":
			num = 36;
			break;
		}
		float result = num;
		string attribute = reader.GetAttribute(attributeName, IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute != null)
		{
			result = ((attribute.Trim(ControlChar.SpaceChar) == string.Empty) ? 0f : GetFloatValue(attribute, "pgMar"));
		}
		return result;
	}

	private void ParsePageSize(XmlReader reader, WSection section)
	{
		float height = 792f;
		float width = 612f;
		string attribute = reader.GetAttribute("h", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute != null)
		{
			height = ((attribute.Trim(ControlChar.SpaceChar) == string.Empty) ? 0f : GetFloatValue(attribute, "pgSz"));
		}
		string attribute2 = reader.GetAttribute("w", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (attribute2 != null)
		{
			width = ((attribute2.Trim(ControlChar.SpaceChar) == string.Empty) ? 0f : GetFloatValue(attribute2, "pgSz"));
		}
		section.PageSetup.PageSize = new SizeF(width, height);
		string attribute3 = reader.GetAttribute("orient", IsStrict ? m_strictNameSpace : m_nameSpace);
		section.PageSetup.Orientation = ((attribute3 == "landscape") ? PageOrientation.Landscape : PageOrientation.Portrait);
	}

	private float GetPageSize(string value)
	{
		if (value.EndsWith("cm"))
		{
			return (float)((double)GetNumericValue(value.Remove(value.IndexOf("cm"), 2)) * 0.39);
		}
		if (value.EndsWith("mm"))
		{
			return (float)((double)GetNumericValue(value.Remove(value.IndexOf("mm"), 2)) * 0.039);
		}
		if (value.EndsWith("pt"))
		{
			return (float)((double)GetNumericValue(value.Remove(value.IndexOf("pt"), 2)) * 0.0139);
		}
		return (float)Math.Floor(GetNumericValue(value) / 2f);
	}

	private void ParseSectionBreakType(WSection section, string sectionBreakType)
	{
		switch (sectionBreakType)
		{
		case "nextColumn":
			section.BreakCode = SectionBreakCode.NewColumn;
			break;
		case "nextPage":
			section.BreakCode = SectionBreakCode.NewPage;
			break;
		case "evenPage":
			section.BreakCode = SectionBreakCode.EvenPage;
			break;
		case "oddPage":
			section.BreakCode = SectionBreakCode.Oddpage;
			break;
		default:
			section.BreakCode = SectionBreakCode.NoBreak;
			break;
		}
	}

	private void Parse2003SectionBreakType(WSection section, string sectionBreakType)
	{
		switch (sectionBreakType)
		{
		case "next-column":
			section.BreakCode = SectionBreakCode.NewColumn;
			break;
		case "next-page":
			section.BreakCode = SectionBreakCode.NewPage;
			break;
		case "even-page":
			section.BreakCode = SectionBreakCode.EvenPage;
			break;
		case "odd-page":
			section.BreakCode = SectionBreakCode.Oddpage;
			break;
		default:
			section.BreakCode = SectionBreakCode.NoBreak;
			break;
		}
	}

	private void ParseSettingsRelations(Stream stream)
	{
		stream.Position = 0L;
		XmlReader relReader = UtilityMethods.CreateReader(stream);
		ParseRelations(relReader, SettingsRelations);
	}

	private void InitializeCompactSettings()
	{
		if (AppVersion == "Word2010" || AppVersion == "Word2013" || AppVersion == "WordLatest")
		{
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.overrideTableStyleFontSizeAndJustification] = false;
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.enableOpenTypeFeatures] = false;
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.doNotFlipMirrorIndents] = false;
		}
		if (AppVersion == "Word2010" || AppVersion == "Word2013" || AppVersion == "WordLatest")
		{
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.differentiateMultirowTableHeader] = false;
		}
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseIndentAsNumberingTabStop] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseNormalStyleForList] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.FELineBreak11] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.AllowSpaceOfSameStyleInTable] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW11IndentRules] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAutofitConstrainedTables] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.AutofitLikeWW11] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.HangulWidthLikeWW11] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignCellWithSp] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakConstrainedForcedTables] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignInTxbx] = false;
		m_doc.Settings.CompatibilityOptions[CompatibilityOption.Word11KerningPairs] = false;
	}

	private void ParseSettings(Stream stream)
	{
		InitializeCompactSettings();
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "settings")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (xmlReader.LocalName != "settings")
		{
			flag = false;
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				switch (xmlReader.LocalName)
				{
				case "zoom":
				{
					string attribute5 = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute5))
					{
						switch (attribute5)
						{
						case "fullPage":
							m_doc.ViewSetup.ZoomType = ZoomType.FullPage;
							break;
						case "bestFit":
							m_doc.ViewSetup.ZoomType = ZoomType.PageWidth;
							break;
						case "textFit":
							m_doc.ViewSetup.ZoomType = ZoomType.TextFit;
							break;
						default:
							m_doc.ViewSetup.ZoomType = ZoomType.None;
							break;
						}
					}
					string attribute6 = xmlReader.GetAttribute("percent", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute6))
					{
						int result3 = 0;
						int.TryParse(attribute6, NumberStyles.Integer, CultureInfo.InvariantCulture, out result3);
						m_doc.ViewSetup.SetZoomPercentValue(result3);
					}
					break;
				}
				case "gutterAtTop":
					m_doc.DOP.GutterAtTop = true;
					break;
				case "bordersDoNotSurroundHeader":
					m_doc.BordersSurroundHeader = false;
					break;
				case "bordersDoNotSurroundFooter":
					m_doc.BordersSurroundFooter = false;
					break;
				case "defaultTabStop":
				{
					string text = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (text.Trim() == "NaN")
					{
						text = "720";
					}
					if (!string.IsNullOrEmpty(text))
					{
						m_doc.DefaultTabWidth = GetFloatValue(text, xmlReader.LocalName);
					}
					break;
				}
				case "mirrorMargins":
					m_doc.MultiplePage = MultiplePage.MirrorMargins;
					break;
				case "bookFoldPrinting":
					m_doc.MultiplePage = MultiplePage.BookFold;
					break;
				case "bookFoldRevPrinting":
					m_doc.MultiplePage = MultiplePage.ReverseBookFold;
					break;
				case "printTwoOnOne":
					m_doc.MultiplePage = MultiplePage.TwoPagesPerSheet;
					break;
				case "bookFoldPrintingSheets":
				{
					string attribute2 = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute2))
					{
						int result = 0;
						int.TryParse(attribute2, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
						m_doc.SheetsPerBooklet = result;
					}
					break;
				}
				case "proofState":
					if (xmlReader.GetAttribute("spelling", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main") == "clean")
					{
						m_doc.DOP.SpellAllDone = true;
					}
					if (xmlReader.GetAttribute("grammar", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main") == "clean")
					{
						m_doc.DOP.Dop97.GramAllDone = true;
					}
					break;
				case "displayBackgroundShape":
					m_doc.Settings.DisplayBackgrounds = true;
					break;
				case "doNotDisplayPageBoundaries":
					m_doc.DOP.Dop2000.NoMargPgvwSaved = GetBooleanValue(xmlReader);
					break;
				case "trackRevisions":
					m_doc.TrackChanges = true;
					break;
				case "uiCompat97To2003":
					m_doc.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2003);
					break;
				case "shapeDefaults":
				case "hdrShapeDefaults":
				case "rsids":
					xmlReader.Skip();
					flag = true;
					break;
				case "themeFontLang":
					m_doc.Settings.ThemeFontLanguages = new WCharacterFormat(m_doc);
					ParseLanguage(xmlReader, m_doc.Settings.ThemeFontLanguages);
					break;
				case "footnotePr":
					ParseFootnoteProp(xmlReader, isFootnote: true);
					break;
				case "endnotePr":
					ParseFootnoteProp(xmlReader, isFootnote: false);
					break;
				case "evenAndOddHeaders":
					m_doc.DifferentOddAndEvenPages = GetBoolValue(xmlReader, IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "docVars":
					ParseVariables(xmlReader);
					break;
				case "view":
					ParseViewType(xmlReader);
					break;
				case "documentProtection":
					ParseProtectType(xmlReader);
					break;
				case "compat":
					ParseCompatNode(xmlReader);
					break;
				case "compatSetting":
					ParseCompatSettingNode(xmlReader);
					break;
				case "autoHyphenation":
					m_doc.DOP.AutoHyphen = GetBooleanValue(xmlReader);
					break;
				case "consecutiveHyphenLimit":
				{
					string attribute7 = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute7))
					{
						int result4 = 0;
						int.TryParse(attribute7, NumberStyles.Integer, CultureInfo.InvariantCulture, out result4);
						m_doc.DOP.ConsecHypLim = result4;
					}
					break;
				}
				case "hyphenationZone":
				{
					string attribute4 = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute4))
					{
						int result2 = 0;
						int.TryParse(attribute4, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
						m_doc.DOP.DxaHotZ = result2;
					}
					break;
				}
				case "doNotHyphenateCaps":
					m_doc.DOP.HyphCapitals = !GetBooleanValue(xmlReader);
					break;
				case "attachedTemplate":
				{
					string attribute3 = xmlReader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (!string.IsNullOrEmpty(attribute3) && SettingsRelations.ContainsKey(attribute3))
					{
						m_doc.AssociatedStrings.AttachedTemplate = SettingsRelations[attribute3].Value.ToString().Replace("file:///", string.Empty);
					}
					break;
				}
				case "doNotShadeFormData":
					m_doc.DOP.FormFieldShading = !GetBooleanValue(xmlReader);
					break;
				case "linkStyles":
					m_doc.DOP.LinkStyles = GetBooleanValue(xmlReader);
					break;
				case "mailMerge":
					ParseMailMergeSettings(xmlReader);
					break;
				case "mathPr":
				{
					MathMLParser mathMLParser = new MathMLParser();
					m_doc.Settings.MathProperties = new OfficeMathProperties();
					mathMLParser.ParseMathProperties(xmlReader, m_doc.Settings.MathProperties);
					break;
				}
				case "forceUpgrade":
					m_doc.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2013);
					break;
				case "clrSchemeMapping":
					m_doc.DocxProps.Add(ReadSingleNodeIntoStream(xmlReader));
					flag = true;
					break;
				case "characterSpacingControl":
				{
					string attribute = xmlReader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!(attribute == "compressPunctuation"))
					{
						if (attribute == "compressPunctuationAndJapaneseKana")
						{
							m_doc.CharacterSpacingControl = CharacterSpacingControl.CompressPunctuationAndJapaneseKana;
						}
						else
						{
							m_doc.CharacterSpacingControl = CharacterSpacingControl.DoNotCompress;
						}
					}
					else
					{
						m_doc.CharacterSpacingControl = CharacterSpacingControl.CompressPunctuation;
					}
					break;
				}
				default:
					flag = ParseCompatibiltyOption(xmlReader);
					break;
				}
				if (!flag)
				{
					xmlReader.Read();
				}
			}
			else
			{
				xmlReader.Read();
			}
		}
	}

	private void ParseMailMergeSettings(XmlReader reader)
	{
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (reader.LocalName != "mailMerge")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "mainDocumentType":
					ParseMailMergeSettingsMainDocumentType(reader);
					break;
				case "activeRecord":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					if (attribute3 != null)
					{
						m_doc.MailMerge.Settings.ActiveRecord = ParseIntegerValue(attribute3);
					}
					break;
				}
				case "addressFieldName":
					m_doc.MailMerge.Settings.AddressFieldName = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					break;
				case "checkErrors":
					ParseMailMergeSettingsCheckErrors(reader);
					break;
				case "connectString":
					m_doc.MailMerge.Settings.ConnectString = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					break;
				case "dataSource":
				{
					string attribute = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (attribute != null)
					{
						DictionaryEntry dictionaryEntry = SettingsRelations[attribute];
						m_doc.MailMerge.Settings.DataSource = dictionaryEntry.Value.ToString();
					}
					break;
				}
				case "dataType":
					ParseMailMergeSettingsDataType(reader);
					break;
				case "destination":
					ParseMailMergeSettingsDestination(reader);
					break;
				case "doNotSuppressBlankLines":
					m_doc.MailMerge.Settings.DoNotSupressBlankLines = GetBooleanValue(reader);
					break;
				case "headerSource":
				{
					string attribute2 = reader.GetAttribute("id", IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
					if (attribute2 != null)
					{
						DictionaryEntry dictionaryEntry2 = SettingsRelations[attribute2];
						m_doc.MailMerge.Settings.HeaderSource = dictionaryEntry2.Value.ToString();
					}
					break;
				}
				case "linkToQuery":
					m_doc.MailMerge.Settings.LinkToQuery = GetBooleanValue(reader);
					break;
				case "mailAsAttachment":
					m_doc.MailMerge.Settings.MailAsAttachment = GetBooleanValue(reader);
					break;
				case "mailSubject":
					m_doc.MailMerge.Settings.MailSubject = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					break;
				case "query":
					m_doc.MailMerge.Settings.Query = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
					break;
				case "viewMergedData":
					m_doc.MailMerge.Settings.ViewMergedData = GetBooleanValue(reader);
					break;
				case "odso":
					m_doc.MailMerge.Settings.ODSOSettings = ReadSingleNodeIntoStream(reader);
					flag = true;
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
		if (m_doc.MailMerge.Settings.ViewMergedData && !m_doc.MailMerge.Settings.HasKey(0))
		{
			m_doc.MailMerge.Settings.ActiveRecord = 1;
		}
	}

	private void ParseMailMergeSettingsCheckErrors(XmlReader reader)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!(attribute == "1"))
		{
			if (attribute == "3")
			{
				m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.CollectErrors;
			}
			else
			{
				m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.PauseOnError;
			}
		}
		else
		{
			m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.Simulate;
		}
	}

	private void ParseMailMergeSettingsDestination(XmlReader reader)
	{
		switch (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace))
		{
		case "printer":
			m_doc.MailMerge.Settings.Destination = MailMergeDestination.Printer;
			break;
		case "email":
			m_doc.MailMerge.Settings.Destination = MailMergeDestination.EMail;
			break;
		case "fax":
			m_doc.MailMerge.Settings.Destination = MailMergeDestination.Fax;
			break;
		default:
			m_doc.MailMerge.Settings.Destination = MailMergeDestination.NewDocument;
			break;
		}
	}

	private void ParseMailMergeSettingsDataType(XmlReader reader)
	{
		switch (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace))
		{
		case "textFile":
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.TextFile;
			break;
		case "database":
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.Database;
			break;
		case "spreadsheet":
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.Spreadsheet;
			break;
		case "query":
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.Query;
			break;
		case "odbc":
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.ODBC;
			break;
		default:
			m_doc.MailMerge.Settings.DataType = MailMergeDataType.Native;
			break;
		}
	}

	private void ParseMailMergeSettingsMainDocumentType(XmlReader reader)
	{
		switch (reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace))
		{
		case "catalog":
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Catalog;
			break;
		case "envelopes":
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Envelopes;
			break;
		case "mailingLabels":
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.MailingLabels;
			break;
		case "email":
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.EMail;
			break;
		case "fax":
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Fax;
			break;
		default:
			m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.FormLetters;
			break;
		}
	}

	private void ParseWebSettings(Stream stream)
	{
		XmlReader xmlReader = UtilityMethods.CreateReader(stream);
		if (xmlReader == null)
		{
			throw new Exception("reader");
		}
		while (xmlReader.NodeType != XmlNodeType.Element)
		{
			xmlReader.Read();
		}
		if (xmlReader.LocalName != "webSettings")
		{
			throw new XmlException("Unexpected xml tag " + xmlReader.LocalName);
		}
		if (xmlReader.IsEmptyElement)
		{
			return;
		}
		string localName = xmlReader.LocalName;
		xmlReader.Read();
		if (localName == xmlReader.LocalName && xmlReader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (xmlReader.LocalName != "webSettings")
		{
			if (xmlReader.NodeType == XmlNodeType.Element)
			{
				if (xmlReader.LocalName == "optimizeForBrowser")
				{
					m_doc.Settings.IsOptimizedForBrowser = GetBooleanValue(xmlReader);
				}
				xmlReader.Read();
			}
			else
			{
				xmlReader.Read();
			}
		}
	}

	private void ParseWord2003DocPr(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "docPr")
		{
			throw new XmlException("Unexpected xml tag " + reader.LocalName);
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		bool flag = false;
		while (reader.LocalName != "docPr")
		{
			flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "view":
					ParseViewType(reader);
					break;
				case "zoom":
				{
					string attribute4 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute4))
					{
						switch (attribute4)
						{
						case "full-page":
							m_doc.ViewSetup.ZoomType = ZoomType.FullPage;
							break;
						case "best-fit":
							m_doc.ViewSetup.ZoomType = ZoomType.PageWidth;
							break;
						case "text-fit":
							m_doc.ViewSetup.ZoomType = ZoomType.TextFit;
							break;
						default:
							m_doc.ViewSetup.ZoomType = ZoomType.None;
							break;
						}
					}
					string attribute5 = reader.GetAttribute("percent", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute5))
					{
						int result4 = 0;
						int.TryParse(attribute5, NumberStyles.Integer, CultureInfo.InvariantCulture, out result4);
						m_doc.ViewSetup.SetZoomPercentValue(result4);
					}
					break;
				}
				case "dontDisplayPageBoundaries":
					m_doc.DOP.Dop2000.NoMargPgvwSaved = true;
					break;
				case "displayBackgroundShape":
					m_doc.Settings.DisplayBackgrounds = true;
					break;
				case "mirrorMargins":
					m_doc.MultiplePage = MultiplePage.MirrorMargins;
					break;
				case "bookFoldPrinting":
					m_doc.MultiplePage = MultiplePage.BookFold;
					break;
				case "bookFoldRevPrinting":
					m_doc.MultiplePage = MultiplePage.ReverseBookFold;
					break;
				case "printTwoOnOne":
					m_doc.MultiplePage = MultiplePage.TwoPagesPerSheet;
					break;
				case "bookFoldPrintingSheets":
				{
					string attribute3 = reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					if (!string.IsNullOrEmpty(attribute3))
					{
						int result3 = 0;
						int.TryParse(attribute3, NumberStyles.Integer, CultureInfo.InvariantCulture, out result3);
						m_doc.SheetsPerBooklet = result3;
					}
					break;
				}
				case "bordersDontSurroundHeader":
					m_doc.BordersSurroundHeader = false;
					break;
				case "bordersDontSurroundFooter":
					m_doc.BordersSurroundFooter = false;
					break;
				case "gutterAtTop":
					m_doc.DOP.GutterAtTop = true;
					break;
				case "proofState":
					if (reader.GetAttribute("spelling", "http://schemas.microsoft.com/office/word/2003/wordml") == "clean")
					{
						m_doc.DOP.SpellAllDone = true;
					}
					if (reader.GetAttribute("grammar", "http://schemas.microsoft.com/office/word/2003/wordml") == "clean")
					{
						m_doc.DOP.Dop97.GramAllDone = true;
					}
					break;
				case "attachedTemplate":
				{
					string attribute6 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute6) && SettingsRelations.ContainsKey(attribute6))
					{
						m_doc.AssociatedStrings.AttachedTemplate = SettingsRelations[attribute6].Value.ToString().Replace("file:///", string.Empty);
					}
					break;
				}
				case "linkStyles":
					m_doc.DOP.LinkStyles = GetBooleanValue(reader);
					break;
				case "trackRevisions":
					m_doc.TrackChanges = true;
					break;
				case "documentProtection":
					ParseProtectType(reader);
					break;
				case "defaultTabStop":
				{
					string text = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (text.Trim() == "NaN")
					{
						text = "720";
					}
					if (!string.IsNullOrEmpty(text))
					{
						m_doc.DefaultTabWidth = GetFloatValue(text, reader.LocalName);
					}
					break;
				}
				case "autoHyphenation":
					m_doc.DOP.AutoHyphen = GetBooleanValue(reader);
					break;
				case "consecutiveHyphenLimit":
				{
					string attribute2 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute2))
					{
						int result2 = 0;
						int.TryParse(attribute2, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2);
						m_doc.DOP.ConsecHypLim = result2;
					}
					break;
				}
				case "hyphenationZone":
				{
					string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
					if (!string.IsNullOrEmpty(attribute))
					{
						int result = 0;
						int.TryParse(attribute, NumberStyles.Integer, CultureInfo.InvariantCulture, out result);
						m_doc.DOP.DxaHotZ = result;
					}
					break;
				}
				case "doNotHyphenateCaps":
					m_doc.DOP.HyphCapitals = !GetBooleanValue(reader);
					break;
				case "evenAndOddHeaders":
					m_doc.DifferentOddAndEvenPages = GetBoolValue(reader, IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
					break;
				case "hdrShapeDefaults":
					reader.Skip();
					flag = true;
					break;
				case "compat":
					ParseWord2003CompatNode(reader);
					break;
				case "docVars":
					ParseVariables(reader);
					break;
				default:
					reader.Skip();
					flag = true;
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private bool ParseCompatibiltyOption(XmlReader reader)
	{
		switch (reader.LocalName)
		{
		case "useSingleBorderforContiguousCells":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.OrigWordTableRules] = GetBooleanValue(reader);
			break;
		case "wpJustification":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPJust] = GetBooleanValue(reader);
			break;
		case "noTabHangInd":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoTabForInd] = GetBooleanValue(reader);
			break;
		case "noLeading":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoExtLeading] = GetBooleanValue(reader);
			break;
		case "spaceForUL":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontMakeSpaceForUL] = !GetBooleanValue(reader);
			break;
		case "noColumnBalance":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoColumnBalance] = GetBooleanValue(reader);
			break;
		case "balanceSingleByteDoubleByteWidth":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntBlnSbDbWid] = !GetBooleanValue(reader);
			break;
		case "noExtraLineSpacing":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExactOnTop] = GetBooleanValue(reader);
			break;
		case "doNotLeaveBackslashAlone":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.LeaveBackslashAlone] = !GetBooleanValue(reader);
			break;
		case "ulTrailSpace":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntULTrlSpc] = !GetBooleanValue(reader);
			break;
		case "doNotExpandShiftReturn":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExpShRtn] = !GetBooleanValue(reader);
			break;
		case "spacingInWholePoints":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncDxaExpand] = GetBooleanValue(reader);
			break;
		case "lineWrapLikeWord6":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.LineWrapLikeWord6] = GetBooleanValue(reader);
			break;
		case "printBodyTextBeforeHeader":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintBodyBeforeHdr] = GetBooleanValue(reader);
			break;
		case "printColBlack":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.MapPrintTextColor] = GetBooleanValue(reader);
			break;
		case "wpSpaceWidth":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPSpace] = GetBooleanValue(reader);
			break;
		case "showBreaksInFrames":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ShowBreaksInFrames] = GetBooleanValue(reader);
			break;
		case "subFontBySize":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SubOnSize] = GetBooleanValue(reader);
			break;
		case "suppressBottomSpacing":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExtraAfter] = GetBooleanValue(reader);
			break;
		case "suppressTopSpacing":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacing] = GetBooleanValue(reader);
			break;
		case "suppressSpacingAtTopOfPage":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacingMac5] = GetBooleanValue(reader);
			break;
		case "suppressTopSpacingWP":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.F2ptExtLeadingOnly] = GetBooleanValue(reader);
			break;
		case "suppressSpBfAfterPgBrk":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressSpBfAfterPgBrk] = GetBooleanValue(reader);
			break;
		case "swapBordersFacingPages":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SwapBordersFacingPgs] = GetBooleanValue(reader);
			break;
		case "convMailMergeEsc":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ConvMailMergeEsc] = GetBooleanValue(reader);
			break;
		case "truncateFontHeightsLikeWP6":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncFontHeight] = GetBooleanValue(reader);
			break;
		case "mwSmallCaps":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.MWSmallCaps] = GetBooleanValue(reader);
			break;
		case "usePrinterMetrics":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintMet] = GetBooleanValue(reader);
			break;
		case "doNotSuppressParagraphBorders":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW6BorderRules] = GetBooleanValue(reader);
			break;
		case "wrapTrailSpaces":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.WrapTrailSpaces] = GetBooleanValue(reader);
			break;
		case "footnoteLayoutLikeWW8":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.FtnLayoutLikeWW8] = GetBooleanValue(reader);
			break;
		case "shapeLayoutLikeWW8":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SpLayoutLikeWW8] = GetBooleanValue(reader);
			break;
		case "alignTablesRowByRow":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.AlignTablesRowByRow] = GetBooleanValue(reader);
			break;
		case "forgetLastTabAlignment":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ForgetLastTabAlign] = GetBooleanValue(reader);
			break;
		case "adjustLineHeightInTable":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAdjustLineHeightInTable] = !GetBooleanValue(reader);
			break;
		case "autoSpaceLikeWord95":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseAutospaceForFullWidthAlpha] = GetBooleanValue(reader);
			break;
		case "noSpaceRaiseLower":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoSpaceRaiseLower] = GetBooleanValue(reader);
			break;
		case "doNotUseHTMLParagraphAutoSpacing":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseHTMLParagraphAutoSpacing] = GetBooleanValue(reader);
			break;
		case "layoutRawTableWidth":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutRawTableWidth] = GetBooleanValue(reader);
			break;
		case "layoutTableRowsApart":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutTableRowsApart] = GetBooleanValue(reader);
			break;
		case "useWord97LineBreakRules":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord97LineBreakingRules] = GetBooleanValue(reader);
			break;
		case "doNotBreakWrappedTables":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakWrappedTables] = GetBooleanValue(reader);
			break;
		case "doNotSnapToGridInCell":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontSnapToGridInCell] = GetBooleanValue(reader);
			break;
		case "selectFldWithFirstOrLastChar":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAllowFieldEndSelect] = GetBooleanValue(reader);
			break;
		case "applyBreakingRules":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.ApplyBreakingRules] = GetBooleanValue(reader);
			break;
		case "doNotWrapTextWithPunct":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontWrapTextWithPunct] = GetBooleanValue(reader);
			break;
		case "doNotUseEastAsianBreakRules":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseAsianBreakRules] = GetBooleanValue(reader);
			break;
		case "useWord2002TableStyleRules":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord2002TableStyleRules] = GetBooleanValue(reader);
			break;
		case "growAutofit":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.GrowAutoFit] = GetBooleanValue(reader);
			break;
		case "useNormalStyleForList":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseNormalStyleForList] = GetBooleanValue(reader);
			break;
		case "doNotUseIndentAsNumberingTabStop":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseIndentAsNumberingTabStop] = GetBooleanValue(reader);
			break;
		case "useAltKinsokuLineBreakRules":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.FELineBreak11] = GetBooleanValue(reader);
			break;
		case "allowSpaceOfSameStyleInTable":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.AllowSpaceOfSameStyleInTable] = GetBooleanValue(reader);
			break;
		case "doNotSuppressIndentation":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW11IndentRules] = GetBooleanValue(reader);
			break;
		case "doNotAutofitConstrainedTables":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAutofitConstrainedTables] = GetBooleanValue(reader);
			break;
		case "autofitToFirstFixedWidthCell":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.AutofitLikeWW11] = GetBooleanValue(reader);
			break;
		case "underlineTabInNumList":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.UnderlineTabInNumList] = GetBooleanValue(reader);
			break;
		case "displayHangulFixedWidth":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.HangulWidthLikeWW11] = GetBooleanValue(reader);
			break;
		case "splitPgBreakAndParaMark":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.SplitPgBreakAndParaMark] = GetBooleanValue(reader);
			break;
		case "doNotVertAlignCellWithSp":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignCellWithSp] = GetBooleanValue(reader);
			break;
		case "doNotBreakConstrainedForcedTable":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakConstrainedForcedTables] = GetBooleanValue(reader);
			break;
		case "doNotVertAlignInTxbx":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignInTxbx] = GetBooleanValue(reader);
			break;
		case "useAnsiKerningPairs":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.Word11KerningPairs] = GetBooleanValue(reader);
			break;
		case "cachedColBalance":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.CachedColBalance] = GetBooleanValue(reader);
			break;
		case "compatSetting":
			ParseCompatSettingNode(reader);
			break;
		default:
			m_doc.DocxProps.Add(ReadSingleNodeIntoStream(reader));
			return true;
		}
		return false;
	}

	private void ParseCompatNode(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "compat")
		{
			throw new XmlException("Expected xml tag \"compat\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (reader.LocalName != "compat")
		{
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (!ParseCompatibiltyOption(reader))
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseWord2003CompatNode(XmlReader reader)
	{
		if (reader == null)
		{
			throw new Exception("reader");
		}
		while (reader.NodeType != XmlNodeType.Element)
		{
			reader.Read();
		}
		if (reader.LocalName != "compat")
		{
			throw new XmlException("Expected xml tag \"compat\"");
		}
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (reader.LocalName != "compat")
		{
			bool flag = false;
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
				case "origWordTableRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.OrigWordTableRules] = GetBooleanValue(reader);
					break;
				case "wpJustification":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPJust] = GetBooleanValue(reader);
					break;
				case "noTabHangInd":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoTabForInd] = GetBooleanValue(reader);
					break;
				case "noLeading":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoExtLeading] = GetBooleanValue(reader);
					break;
				case "spaceForUL":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontMakeSpaceForUL] = !GetBooleanValue(reader);
					break;
				case "noColumnBalance":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoColumnBalance] = GetBooleanValue(reader);
					break;
				case "balanceSingleByteDoubleByteWidth":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntBlnSbDbWid] = !GetBooleanValue(reader);
					break;
				case "noExtraLineSpacing":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExactOnTop] = GetBooleanValue(reader);
					break;
				case "doNotLeaveBackslashAlone":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.LeaveBackslashAlone] = !GetBooleanValue(reader);
					break;
				case "ulTrailSpace":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntULTrlSpc] = !GetBooleanValue(reader);
					break;
				case "doNotExpandShiftReturn":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExpShRtn] = !GetBooleanValue(reader);
					break;
				case "spacingInWholePoints":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncDxaExpand] = GetBooleanValue(reader);
					break;
				case "lineWrapLikeWord6":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.LineWrapLikeWord6] = GetBooleanValue(reader);
					break;
				case "printBodyTextBeforeHeader":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintBodyBeforeHdr] = GetBooleanValue(reader);
					break;
				case "printColBlack":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.MapPrintTextColor] = GetBooleanValue(reader);
					break;
				case "wpSpaceWidth":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPSpace] = GetBooleanValue(reader);
					break;
				case "showBreaksInFrames":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ShowBreaksInFrames] = GetBooleanValue(reader);
					break;
				case "subFontBySize":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SubOnSize] = GetBooleanValue(reader);
					break;
				case "suppressBottomSpacing":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExtraAfter] = GetBooleanValue(reader);
					break;
				case "suppressTopSpacing":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacing] = GetBooleanValue(reader);
					break;
				case "suppressTopSpacingMac5":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacingMac5] = GetBooleanValue(reader);
					break;
				case "suppressTopSpacingWP":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.F2ptExtLeadingOnly] = GetBooleanValue(reader);
					break;
				case "suppressSpBfAfterPgBrk":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressSpBfAfterPgBrk] = GetBooleanValue(reader);
					break;
				case "swapBordersFacingPages":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SwapBordersFacingPgs] = GetBooleanValue(reader);
					break;
				case "convMailMergeEsc":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ConvMailMergeEsc] = GetBooleanValue(reader);
					break;
				case "truncateFontHeight":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncFontHeight] = GetBooleanValue(reader);
					break;
				case "mwSmallCaps":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.MWSmallCaps] = GetBooleanValue(reader);
					break;
				case "usePrinterMetrics":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintMet] = GetBooleanValue(reader);
					break;
				case "ww6BorderRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW6BorderRules] = GetBooleanValue(reader);
					break;
				case "wrapTrailSpaces":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.WrapTrailSpaces] = GetBooleanValue(reader);
					break;
				case "footnoteLayoutLikeWW8":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.FtnLayoutLikeWW8] = GetBooleanValue(reader);
					break;
				case "shapeLayoutLikeWW8":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.SpLayoutLikeWW8] = GetBooleanValue(reader);
					break;
				case "alignTablesRowByRow":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.AlignTablesRowByRow] = GetBooleanValue(reader);
					break;
				case "forgetLastTabAlignment":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ForgetLastTabAlign] = GetBooleanValue(reader);
					break;
				case "adjustLineHeightInTable":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAdjustLineHeightInTable] = !GetBooleanValue(reader);
					break;
				case "autoSpaceLikeWord95":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseAutospaceForFullWidthAlpha] = GetBooleanValue(reader);
					break;
				case "noSpaceRaiseLower":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoSpaceRaiseLower] = GetBooleanValue(reader);
					break;
				case "doNotUseHTMLParagraphAutoSpacing":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseHTMLParagraphAutoSpacing] = GetBooleanValue(reader);
					break;
				case "layoutRawTableWidth":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutRawTableWidth] = GetBooleanValue(reader);
					break;
				case "layoutTableRowsApart":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutTableRowsApart] = GetBooleanValue(reader);
					break;
				case "useWord97LineBreakRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord97LineBreakingRules] = GetBooleanValue(reader);
					break;
				case "breakWrappedTables":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakWrappedTables] = !GetBooleanValue(reader);
					break;
				case "snapToGridInCell":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontSnapToGridInCell] = !GetBooleanValue(reader);
					break;
				case "dontAllowFieldEndSelect":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAllowFieldEndSelect] = GetBooleanValue(reader);
					break;
				case "applyBreakingRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.ApplyBreakingRules] = GetBooleanValue(reader);
					break;
				case "wrapTextWithPunct":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontWrapTextWithPunct] = !GetBooleanValue(reader);
					break;
				case "useAsianBreakRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseAsianBreakRules] = !GetBooleanValue(reader);
					break;
				case "useWord2002TableStyleRules":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord2002TableStyleRules] = GetBooleanValue(reader);
					break;
				case "dontGrowAutofit":
					m_doc.Settings.CompatibilityOptions[CompatibilityOption.GrowAutoFit] = !GetBooleanValue(reader);
					break;
				default:
					reader.Skip();
					flag = true;
					break;
				}
				if (!flag)
				{
					reader.Read();
				}
			}
			else
			{
				reader.Read();
			}
		}
	}

	private void ParseCompatSettingNode(XmlReader reader)
	{
		switch (reader.GetAttribute("name", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
		{
		case "compatibilityMode":
			m_doc.Settings.SetCompatibilityModeValue(GetCompatibilityMode(reader));
			if (m_doc.Settings.CompatibilityMode == CompatibilityMode.Word2013)
			{
				m_doc.Settings.CompatibilityOptions[CompatibilityOption.overrideTableStyleFontSizeAndJustification] = true;
			}
			break;
		case "overrideTableStyleFontSizeAndJustification":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.overrideTableStyleFontSizeAndJustification] = GetBooleanValue(reader);
			break;
		case "enableOpenTypeFeatures":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.enableOpenTypeFeatures] = GetBooleanValue(reader);
			break;
		case "doNotFlipMirrorIndents":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.doNotFlipMirrorIndents] = GetBooleanValue(reader);
			break;
		case "differentiateMultirowTableHeader":
			m_doc.Settings.CompatibilityOptions[CompatibilityOption.differentiateMultirowTableHeader] = GetBooleanValue(reader);
			break;
		}
	}

	private void ParseVariables(XmlReader reader)
	{
		if (reader.IsEmptyElement)
		{
			return;
		}
		string localName = reader.LocalName;
		reader.Read();
		if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
		{
			return;
		}
		while (reader.LocalName != "docVars")
		{
			string attribute = reader.GetAttribute("name", IsStrict ? m_strictNameSpace : m_nameSpace);
			string attribute2 = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
			if (!string.IsNullOrEmpty(attribute) && !string.IsNullOrEmpty(attribute2))
			{
				m_doc.Variables.Items.Add(attribute, ParseString(attribute2));
			}
			reader.Read();
		}
	}

	private string ParseString(string text)
	{
		StringBuilder stringBuilder = new StringBuilder(text);
		int num = 0;
		while (num < text.Length)
		{
			int num2 = text.IndexOf("_x", num);
			if (num2 == -1)
			{
				break;
			}
			num2 += 2;
			int num3 = text.IndexOf("_", num2);
			if (num3 == -1)
			{
				break;
			}
			if (num3 - num2 == 4)
			{
				string text2 = text.Substring(num2, 4);
				if (int.TryParse(text2, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var result))
				{
					stringBuilder.Replace("_x" + text2 + "_", Convert.ToString((char)result));
				}
			}
			num = num3;
		}
		return stringBuilder.ToString();
	}

	private void ParseProtectType(XmlReader reader)
	{
		string attribute = reader.GetAttribute("formatting", IsStrict ? m_strictNameSpace : m_nameSpace);
		m_doc.RestrictFormatting = GetBoolValue(attribute);
		switch (reader.GetAttribute("edit", IsStrict ? m_strictNameSpace : m_nameSpace))
		{
		case "comments":
			m_doc.ProtectionType = ProtectionType.AllowOnlyComments;
			break;
		case "forms":
			m_doc.ProtectionType = ProtectionType.AllowOnlyFormFields;
			break;
		case "trackedChanges":
		case "tracked-changes":
			m_doc.ProtectionType = ProtectionType.AllowOnlyRevisions;
			break;
		case "readOnly":
		case "read-only":
			m_doc.ProtectionType = ProtectionType.AllowOnlyReading;
			break;
		}
		string attribute2 = reader.GetAttribute("enforcement", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute2) && !(m_doc.Enforcement = GetBoolValue(attribute2)))
		{
			switch (m_doc.ProtectionType)
			{
			case ProtectionType.AllowOnlyComments:
				m_doc.DOP.LockAtn = false;
				break;
			case ProtectionType.AllowOnlyFormFields:
				m_doc.DOP.ProtEnabled = false;
				break;
			case ProtectionType.AllowOnlyRevisions:
				m_doc.DOP.LockRev = false;
				break;
			case ProtectionType.AllowOnlyReading:
				m_doc.DOP.LockAtn = false;
				m_doc.DOP.Dop2003.TreatLockAtnAsReadOnly = false;
				break;
			}
		}
		string attribute3 = reader.GetAttribute("hash", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute3))
		{
			m_doc.Settings.HashValue = attribute3;
		}
		string attribute4 = reader.GetAttribute("salt", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute4))
		{
			m_doc.Settings.SaltValue = attribute4;
		}
		string attribute5 = reader.GetAttribute("cryptProviderType", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute5))
		{
			m_doc.Settings.CryptProviderTypeValue = attribute5;
		}
		string attribute6 = reader.GetAttribute("cryptAlgorithmClass", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute6))
		{
			m_doc.Settings.CryptAlgorithmClassValue = attribute6;
		}
		string attribute7 = reader.GetAttribute("cryptAlgorithmType", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute7))
		{
			m_doc.Settings.CryptAlgorithmTypeValue = attribute7;
		}
		string attribute8 = reader.GetAttribute("cryptAlgorithmSid", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute8))
		{
			m_doc.Settings.CryptAlgorithmSidValue = attribute8;
		}
		string attribute9 = reader.GetAttribute("cryptSpinCount", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (!string.IsNullOrEmpty(attribute9))
		{
			m_doc.Settings.CryptSpinCountValue = attribute9;
		}
	}

	private void ParseViewType(XmlReader reader)
	{
		string attribute = reader.GetAttribute("val", IsStrict ? m_strictNameSpace : m_nameSpace);
		if (string.IsNullOrEmpty(attribute))
		{
			return;
		}
		if (!(attribute == "web"))
		{
			if (attribute == "outline")
			{
				m_doc.ViewSetup.DocumentViewType = DocumentViewType.OutlineLayout;
			}
		}
		else
		{
			m_doc.ViewSetup.DocumentViewType = DocumentViewType.WebLayout;
		}
	}

	private void AddItem(ParagraphItem item, ParagraphItemCollection paragraphItems)
	{
		paragraphItems.Add(item);
	}

	private void AddToParagraph(ParagraphItem item, ParagraphItemCollection paragraphItems)
	{
		AddItem(item, paragraphItems);
		UpdateCommentItems(item);
		if (item is WOleObject)
		{
			AddOleObject(item as WOleObject, paragraphItems);
		}
	}

	private void AddOleObject(WOleObject oleObject, ParagraphItemCollection paragraphItems)
	{
		oleObject.AddFieldCodeText();
		WField field = oleObject.Field;
		WFieldMark wFieldMark = new WFieldMark(m_doc)
		{
			Type = FieldMarkType.FieldSeparator
		};
		AddToParagraph(wFieldMark, paragraphItems);
		field.FieldSeparator = wFieldMark;
		WPicture olePicture = oleObject.OlePicture;
		AddToParagraph(olePicture, paragraphItems);
		WFieldMark wFieldMark2 = new WFieldMark(m_doc)
		{
			Type = FieldMarkType.FieldEnd
		};
		AddToParagraph(wFieldMark2, paragraphItems);
		field.FieldEnd = wFieldMark2;
	}

	private string GetImageName(string imageId, bool isHeaderFooter, bool isPicBullet, ref bool isImageRelation)
	{
		Dictionary<string, DictionaryEntry> dictionary;
		if (isHeaderFooter)
		{
			dictionary = GetFileRelations(m_currentFile);
		}
		else if (isPicBullet)
		{
			dictionary = GetFileRelations("numbering.xml.rels");
		}
		else if (StartsWithExt(m_currentFile, "comments"))
		{
			dictionary = GetFileRelations("comments.xml.rels");
		}
		else if (!StartsWithExt(m_currentFile, "diagrams"))
		{
			dictionary = (string.IsNullOrEmpty(m_currentFile) ? m_docRelations : GetFileRelations(m_currentFile));
		}
		else
		{
			dictionary = GetDiagramFileRelations(m_currentFile);
			if (dictionary == null)
			{
				dictionary = m_docRelations;
			}
		}
		DictionaryEntry dictionaryEntry = default(DictionaryEntry);
		if (dictionary != null && dictionary.ContainsKey(imageId))
		{
			dictionaryEntry = dictionary[imageId];
		}
		if (dictionaryEntry.Key != null && dictionaryEntry.Key.ToString() != (IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships/image" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"))
		{
			isImageRelation = false;
		}
		if (dictionaryEntry.Value == null)
		{
			return string.Empty;
		}
		return dictionaryEntry.Value.ToString();
	}

	private void LoadImage(WPicture picture, string id, bool isHeaderFooter, bool isPicBullet)
	{
		bool isImageRelation = true;
		string imageName = GetImageName(id, isHeaderFooter, isPicBullet, ref isImageRelation);
		if (!isImageRelation)
		{
			return;
		}
		picture.OPictureHRef = imageName;
		if (ImageIds.ContainsKey(imageName))
		{
			picture.LoadImage(m_doc.Images[ImageIds[imageName]]);
			if (picture.ImageRecord != null)
			{
				picture.ImageRecord.OccurenceCount++;
			}
			return;
		}
		byte[] imageBytes = GetImageBytes(imageName);
		if (imageBytes != null && imageBytes.Length != 0)
		{
			picture.LoadImage(imageBytes);
			if (picture.ImageRecord != null)
			{
				ImageIds.Add(imageName, picture.ImageRecord.ImageId);
			}
		}
		if (imageBytes == null)
		{
			DocGen.DocIO.DLS.Entities.Image image = null;
			if (id != null && m_isExternalHyperlink != null && m_docRelations.ContainsKey(id) && IsExternalHyperlink.ContainsKey(id) && IsExternalHyperlink[id])
			{
				picture.ExternalLink = imageName;
			}
			if (image != null)
			{
				picture.LoadImage(image);
			}
			int num = imageName.LastIndexOf('/');
			string text = imageName.Substring(num + 1, imageName.Length - (num + 1));
			if (image == null && text.ToLower() == "null")
			{
				byte[] imageBytes2 = new byte[0];
				image = picture.GetImage(imageBytes2, isImageFromScratch: false);
				picture.LoadImage(image);
			}
		}
	}

	private byte[] GetImageBytes(string imageName)
	{
		string partName = GetPartName(ref imageName);
		Part part = FindPart(partName, imageName);
		byte[] result = null;
		if (part != null)
		{
			result = GetBytesFrom(part);
			ClearParsedImage(imageName, partName);
		}
		return result;
	}

	private byte[] GetBytesFrom(Part part)
	{
		if (part != null)
		{
			int num = (int)part.DataStream.Length;
			byte[] array = new byte[num];
			part.DataStream.Position = 0L;
			part.DataStream.Read(array, 0, num);
			return array;
		}
		return null;
	}

	private string GetPartName(ref string fileName)
	{
		if (StartsWithExt(fileName, "..") && string.IsNullOrEmpty(m_currentFile))
		{
			fileName = fileName.Remove(0, 2);
		}
		if (fileName.IndexOf('\\') != -1)
		{
			fileName = fileName.Replace('\\', '/');
		}
		if (fileName.Contains("media") && !StartsWithExt(fileName, "/"))
		{
			fileName = fileName.Remove(0, fileName.IndexOf("media"));
		}
		int num = fileName.LastIndexOf('/');
		string text = string.Empty;
		if (num > 0 && fileName.Substring(num + 1, fileName.Length - (num + 1)).Length > 0)
		{
			text = fileName.Remove(num + 1);
		}
		else if (StartsWithExt(fileName, "/"))
		{
			fileName = fileName.Remove(0, 1);
		}
		if (!string.IsNullOrEmpty(text))
		{
			fileName = fileName.Replace(text, null);
		}
		if (StartsWithExt(text, "/"))
		{
			text = text.Remove(0, 1);
		}
		else if (!StartsWithExt(text, "word/"))
		{
			text = "word/" + text;
		}
		return text;
	}

	private Part FindPart(string partContainer, string partName)
	{
		partName = partName.Replace(partContainer, string.Empty);
		PartContainer partContainer2 = m_doc.DocxPackage.FindPartContainer(partContainer);
		if (partContainer2.XmlParts.ContainsKey(partName))
		{
			return partContainer2.XmlParts[partName];
		}
		return null;
	}

	private Dictionary<string, DictionaryEntry> GetFileRelations(string name)
	{
		string text = GetPartName(ref name);
		if (!string.IsNullOrEmpty(text))
		{
			text = text.Replace("word/", null);
		}
		name = text + name;
		if (!HFRelations.ContainsKey(name))
		{
			PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("word/");
			if (!partContainer.Relations.ContainsKey("word/_rels/" + name) || partContainer.Relations["word/_rels/" + name].DataStream == null)
			{
				return null;
			}
			Relations relations = partContainer.Relations["word/_rels/" + name];
			relations.DataStream.Position = 0L;
			XmlReader relReader = UtilityMethods.CreateReader(relations.DataStream);
			Dictionary<string, DictionaryEntry> dictionary = new Dictionary<string, DictionaryEntry>();
			ParseRelations(relReader, dictionary);
			HFRelations.Add(name, dictionary);
			return HFRelations[name];
		}
		return HFRelations[name];
	}

	private Dictionary<string, DictionaryEntry> GetDiagramFileRelations(string name)
	{
		string text = GetPartName(ref name);
		if (!string.IsNullOrEmpty(text))
		{
			text = text.Replace("word/diagrams/", null);
		}
		name = text + name;
		if (!HFRelations.ContainsKey(name))
		{
			PartContainer partContainer = m_doc.DocxPackage.FindPartContainer("word/diagrams/");
			if (!partContainer.Relations.ContainsKey("word/diagrams/_rels/" + name) || partContainer.Relations["word/diagrams/_rels/" + name].DataStream == null)
			{
				return null;
			}
			Relations relations = partContainer.Relations["word/diagrams/_rels/" + name];
			relations.DataStream.Position = 0L;
			XmlReader relReader = UtilityMethods.CreateReader(relations.DataStream);
			Dictionary<string, DictionaryEntry> dictionary = new Dictionary<string, DictionaryEntry>();
			ParseRelations(relReader, dictionary);
			HFRelations.Add(name, dictionary);
			return HFRelations[name];
		}
		return HFRelations[name];
	}

	private float ParseFloatVal(string value)
	{
		if (StartsWithExt(value, "."))
		{
			value = "0" + value;
		}
		float result = 0f;
		if (value.EndsWith("in"))
		{
			float.TryParse(value.Replace("in", string.Empty), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			return (float)UnitsConvertor.Instance.ConvertUnits(result, PrintUnits.Inch, PrintUnits.Point);
		}
		try
		{
			return Convert.ToSingle(value, CultureInfo.InvariantCulture);
		}
		catch (ArgumentNullException)
		{
		}
		float.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out result);
		return result;
	}

	private bool GetBooleanValue(XmlReader reader)
	{
		bool result = true;
		if (reader.AttributeCount > 0)
		{
			string name = ((reader.LocalName == "cols") ? "equalWidth" : "val");
			switch (reader.GetAttribute(name, IsStrict ? m_strictNameSpace : m_nameSpace))
			{
			case "0":
			case "false":
			case "off":
				result = false;
				break;
			}
		}
		return result;
	}

	private CompatibilityMode GetCompatibilityMode(XmlReader reader)
	{
		CompatibilityMode result = CompatibilityMode.Word2007;
		if (reader.AttributeCount > 0)
		{
			switch (reader.GetAttribute("val", IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
			{
			case "11":
				result = CompatibilityMode.Word2003;
				break;
			case "12":
				result = CompatibilityMode.Word2007;
				break;
			case "14":
				result = CompatibilityMode.Word2010;
				break;
			case "15":
				result = CompatibilityMode.Word2013;
				break;
			}
		}
		return result;
	}

	private bool GetBooleanValue(XmlReader reader, string nameSpace)
	{
		bool result = true;
		if (reader.AttributeCount > 0)
		{
			switch (reader.GetAttribute("val", nameSpace))
			{
			case "0":
			case "false":
			case "off":
				result = false;
				break;
			}
		}
		return result;
	}

	private string GetReaderElementValue(XmlReader reader)
	{
		if (!reader.IsEmptyElement)
		{
			string localName = reader.LocalName;
			reader.Read();
			if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
			{
				string result;
				if (reader.NodeType != XmlNodeType.EndElement)
				{
					result = reader.Value;
					reader.Skip();
				}
				else
				{
					result = string.Empty;
				}
				reader.Skip();
				return result;
			}
			reader.Read();
			return string.Empty;
		}
		reader.Read();
		return string.Empty;
	}

	private Color GetColorValue(string color)
	{
		if (color == null || color == "auto")
		{
			return Color.Empty;
		}
		if (StartsWithExt(color, "fill darken") || StartsWithExt(color, "fill lighten"))
		{
			return GetGradientColor(color);
		}
		Color color2 = GetHexColor(color);
		if (color2 == Color.Empty)
		{
			color2 = GetHtmlColor(color);
		}
		return color2;
	}

	private Color GetGradientColor(string color)
	{
		int num = color.IndexOf("(") + 1;
		int num2 = color.IndexOf(")");
		if (num != -1 && num2 != -1)
		{
			int result = 0;
			int.TryParse(color.Substring(num, num2 - num), NumberStyles.Number, CultureInfo.InvariantCulture, out result);
			int num3 = 255;
			int num4 = 255;
			int num5 = 255;
			if (StartsWithExt(color, "fill darken"))
			{
				num4 = (num5 = result);
				num3 = 0;
			}
			else
			{
				num4 = (num5 = 255);
				num3 = 255 - result;
			}
			return Color.FromArgb(num3, num4, num5);
		}
		return Color.White;
	}

	private Color GetHexColor(string color)
	{
		color = color.Replace("#", string.Empty);
		if (color.Length == 3)
		{
			color = color.Insert(0, color[0].ToString());
			color = color.Insert(2, color[2].ToString());
			color = color.Insert(4, color[4].ToString());
		}
		else if (color.Length < 6)
		{
			int num = 6 - color.Length;
			for (int i = 0; i < num; i++)
			{
				color = color.Insert(0, "0");
			}
		}
		else if (color.Length > 6)
		{
			return Color.Empty;
		}
		for (int j = 0; j < 6; j++)
		{
			char c = color[j];
			if ((c < '0' || c > '9') && (c < 'A' || c > 'F') && (c < 'a' || c > 'f'))
			{
				return Color.Empty;
			}
		}
		string s = color.Substring(0, 2);
		string s2 = color.Substring(2, 2);
		string s3 = color.Substring(4, 2);
		int red = int.Parse(s, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
		int green = int.Parse(s2, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
		int blue = int.Parse(s3, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
		return Color.FromArgb(red, green, blue);
	}

	private Color GetHtmlColor(string color)
	{
		int num = color.IndexOf("[");
		if (num != -1)
		{
			color = color.Remove(num, color.Length - num);
			color = color.Trim();
		}
		try
		{
			return ColorTranslator.FromHtml(color);
		}
		catch (Exception)
		{
		}
		return Color.Empty;
	}

	private Color GetHighLightColor(string color)
	{
		Color result = Color.Empty;
		switch (color)
		{
		case "empty":
			result = WordColor.ColorsArray[0];
			break;
		case "black":
			result = WordColor.ColorsArray[1];
			break;
		case "blue":
			result = WordColor.ColorsArray[2];
			break;
		case "cyan":
			result = WordColor.ColorsArray[3];
			break;
		case "green":
			result = WordColor.ColorsArray[4];
			break;
		case "magenta":
			result = WordColor.ColorsArray[5];
			break;
		case "red":
			result = WordColor.ColorsArray[6];
			break;
		case "yellow":
			result = WordColor.ColorsArray[7];
			break;
		case "white":
			result = WordColor.ColorsArray[8];
			break;
		case "darkBlue":
			result = WordColor.ColorsArray[9];
			break;
		case "darkCyan":
			result = WordColor.ColorsArray[10];
			break;
		case "darkGreen":
			result = WordColor.ColorsArray[11];
			break;
		case "darkMagenta":
			result = WordColor.ColorsArray[12];
			break;
		case "darkRed":
			result = WordColor.ColorsArray[13];
			break;
		case "darkYellow":
			result = WordColor.ColorsArray[14];
			break;
		case "darkGray":
			result = WordColor.ColorsArray[15];
			break;
		case "lightGray":
			result = WordColor.ColorsArray[16];
			break;
		}
		return result;
	}

	private float GetFloatValue(XmlReader reader, string attrName, string attrNS)
	{
		if (attrName == null || attrName.Length == 0)
		{
			throw new ArgumentException("Attribute name must not be null or empty");
		}
		string text = ((attrNS != null) ? reader.GetAttribute(attrName, attrNS) : reader.GetAttribute(attrName));
		if (!string.IsNullOrEmpty(text))
		{
			if (attrName == "beforeLines" || attrName == "afterLines")
			{
				return (float)(short)float.Parse(text, NumberStyles.Number, CultureInfo.InvariantCulture) / 100f;
			}
			return float.Parse(text, NumberStyles.Number, CultureInfo.InvariantCulture) / 20f;
		}
		return float.MaxValue;
	}

	private MemoryStream ReadSingleNodeIntoStream(XmlReader reader)
	{
		MemoryStream memoryStream = new MemoryStream();
		XmlWriter xmlWriter = UtilityMethods.CreateWriter(memoryStream, Encoding.UTF8);
		xmlWriter.WriteNode(reader, defattr: false);
		xmlWriter.Flush();
		return memoryStream;
	}

	private void SkipWhitespaces(XmlReader reader)
	{
		if (reader.NodeType != XmlNodeType.Element)
		{
			while (reader.NodeType == XmlNodeType.Whitespace)
			{
				reader.Read();
			}
		}
	}

	internal void Close()
	{
		if (m_reader != null)
		{
			m_reader.Dispose();
			m_reader = null;
		}
		m_doc = null;
		if (m_linkStyleNames != null)
		{
			m_linkStyleNames.Clear();
			m_linkStyleNames = null;
		}
		if (m_baseStyleNames != null)
		{
			m_baseStyleNames.Clear();
			m_baseStyleNames = null;
		}
		if (m_chartRelations != null)
		{
			m_chartRelations.Clear();
			m_chartRelations = null;
		}
		if (m_docRelations != null)
		{
			m_docRelations.Clear();
			m_docRelations = null;
		}
		if (m_fontTableRelations != null)
		{
			m_fontTableRelations.Clear();
			m_fontTableRelations = null;
		}
		if (m_settingsRelations != null)
		{
			m_settingsRelations.Clear();
			m_settingsRelations = null;
		}
		if (m_isExternalHyperlink != null)
		{
			m_isExternalHyperlink.Clear();
			m_isExternalHyperlink = null;
		}
		if (m_bookmarkNames != null)
		{
			m_bookmarkNames.Clear();
			m_bookmarkNames = null;
		}
		if (m_hfRelations != null)
		{
			foreach (Dictionary<string, DictionaryEntry> value in m_hfRelations.Values)
			{
				value.Clear();
			}
			m_hfRelations.Clear();
			m_hfRelations = null;
		}
		if (m_pictureBullet != null)
		{
			m_pictureBullet.Clear();
			m_pictureBullet = null;
		}
		if (m_abstractListStyles != null)
		{
			m_abstractListStyles.Clear();
			m_abstractListStyles = null;
		}
		if (m_overrideListStyles != null)
		{
			m_overrideListStyles.Clear();
			m_overrideListStyles = null;
		}
		if (m_currentRunFormat != null)
		{
			m_currentRunFormat = null;
		}
		if (m_footnote != null)
		{
			m_footnote.Clear();
			m_footnote = null;
		}
		if (m_endnote != null)
		{
			m_endnote.Clear();
			m_endnote = null;
		}
		if (m_fieldStack != null)
		{
			m_fieldStack.Clear();
			m_fieldStack = null;
		}
		if (m_postParaItemsCollection != null)
		{
			m_postParaItemsCollection.Clear();
			m_postParaItemsCollection = null;
		}
		m_postCommMark = null;
		if (m_comments != null)
		{
			m_comments.Clear();
			m_comments = null;
		}
		if (m_commentsEx != null)
		{
			m_commentsEx.Clear();
			m_commentsEx = null;
		}
		if (m_commStack != null)
		{
			m_commStack.Clear();
			m_commStack = null;
		}
		if (m_imageIds != null)
		{
			m_imageIds.Clear();
			m_imageIds = null;
		}
		if (m_svgDataDict != null)
		{
			m_svgDataDict.Clear();
			m_svgDataDict = null;
		}
		if (m_fontFamilyRecords != null)
		{
			m_fontFamilyRecords.Clear();
			m_fontFamilyRecords = null;
		}
		if (m_autoShapeHelper != null)
		{
			m_autoShapeHelper.Close();
			m_autoShapeHelper = null;
		}
		if (m_trackchangeStack != null)
		{
			m_trackchangeStack.Clear();
			m_trackchangeStack = null;
		}
		if (m_trackchangeRevisionDetails != null)
		{
			m_trackchangeRevisionDetails.Clear();
			m_trackchangeRevisionDetails = null;
		}
		if (m_blockControls != null)
		{
			m_blockControls.Clear();
			m_blockControls = null;
		}
		if (m_inlineControls != null)
		{
			m_inlineControls.Clear();
			m_inlineControls = null;
		}
		if (m_cellControls != null)
		{
			m_cellControls.Clear();
			m_cellControls = null;
		}
	}

	internal bool StartsWithExt(string text, string value)
	{
		return text.StartsWith(value);
	}
}
