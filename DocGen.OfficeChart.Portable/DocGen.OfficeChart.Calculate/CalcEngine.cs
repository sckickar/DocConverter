using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace DocGen.OfficeChart.Calculate;

internal class CalcEngine : IDisposable
{
	public delegate string LibraryFunction(string args);

	[Flags]
	private enum FormulaArgumentType
	{
		None = 0,
		Range = 1,
		TwoTextWithNumber = 2,
		TextWithNumber = 3,
		Numbers = 4,
		Text = 5,
		Date = 6
	}

	private class LenComparer : IComparer<object>
	{
		public int Compare(object x, object y)
		{
			return y.ToString().Length - x.ToString().Length;
		}
	}

	private class LookUps
	{
		private List<string> _linearLookUpList;

		private Dictionary<string, int> _matchLookUpList;

		public List<string> LinearLookUpList
		{
			get
			{
				return _linearLookUpList;
			}
			set
			{
				_linearLookUpList = value;
			}
		}

		public Dictionary<string, int> MatchLookUpList
		{
			get
			{
				return _matchLookUpList;
			}
			set
			{
				_matchLookUpList = value;
			}
		}
	}

	private delegate double MathFunc(double d);

	private Dictionary<object, object> _formulaInfoTable;

	private List<object> breakedFormulaCells = new List<object>();

	private List<object> tempBreakedFormulaCells = new List<object>();

	private List<object> processedCells = new List<object>();

	private Dictionary<object, object> dependentFormulaCells;

	private bool _isDisposed;

	private char[] BRACEDELIMETER = new char[1] { ',' };

	private string BRACERIGHTnLEFT = ")(";

	private bool useFormulaValues;

	private bool getValueFromArgPreserveLeadingZeros;

	private bool ignoreCellValue;

	private int calcID;

	private int columnMaxCount = -1;

	private int rowMaxCount = -1;

	public bool IgnoreValueChanged;

	private bool inAPull;

	private bool useDependencies;

	private bool checkDanglingStack;

	private bool inHandleIterations;

	private bool inRecalculateRange;

	private bool isRangeOperand;

	private bool forceRefreshCall;

	private bool preserveFormula;

	private string validFunctionNameChars = "_";

	private const char BMARKER = '\u0092';

	internal string cell = string.Empty;

	[ThreadStatic]
	private static char formulaChar;

	internal int reservedWord_AND = 1;

	internal int reservedWord_IF = 3;

	internal int reservedWord_ELSE = 5;

	internal int reservedWord_NOT = 6;

	internal int reservedWord_OR;

	internal int reservedWord_THEN = 4;

	internal int reservedWord_XOR = 2;

	private string validPrecedingChars;

	private Dictionary<object, object> variableNamesToTokens;

	private Dictionary<object, object> variableTokensToNames;

	internal bool isBracesReplaced;

	private Dictionary<object, object> dependentCells;

	public const double machineepsilon = 5E-16;

	public const double maxrealnumber = 1E+300;

	public const double minrealnumber = 1E-300;

	public double ACC = 4.0;

	public double BIGNO = 10000000000.0;

	public double BIGNI = 1E-10;

	private Dictionary<object, object> refreshedCells;

	private Dictionary<object, object> libraryFunctions;

	internal char[] tokens;

	internal static int sheetID;

	private char CHAR_and = 'i';

	private char CHAR_or = 'w';

	private List<object> circCheckList = new List<object>();

	private List<object> errorStrings;

	private int computedValueLevel;

	private int dependencyLevel;

	private int maximumRecursiveCalls = 100;

	private const char CHAR_divide = '/';

	private string BRACELEFT = "{";

	private string BRACERIGHT = "}";

	private string STRING_and = "&";

	private string STRING_E = "E";

	private string STRING_EM = "E-";

	private string STRING_EP = "E+";

	private string TRUEVALUESTR = "TRUE";

	private string FALSEVALUESTR = "FALSE";

	private string STRING_or = "^";

	private string TIC = "\"";

	private const string STRING_empty = "";

	private const string STRING_fixedreference = "$";

	private const string STRING_greatereq = ">=";

	private const string STRING_lesseq = "<=";

	private const string STRING_noequal = "<>";

	private char RIGHTBRACKET = '\u0083';

	private char LEFTBRACKET = '\u0082';

	private char CHAR_EP = 'x';

	private char CHAR_EM = 'r';

	private char UNIQUESTRINGMARKER = '\u007f';

	private char MarkerChar = '`';

	private const char sheetToken = '!';

	private const char TOKEN_EM = 'v';

	private const char TOKEN_EP = 't';

	private const char TOKEN_multiply = 'm';

	private const char TOKEN_divide = 'd';

	private const char TOKEN_add = 'a';

	private const char TOKEN_subtract = 's';

	private const char CHAR_add = '+';

	private const char CHAR_subtract = '-';

	private const char TOKEN_less = 'l';

	private const char CHAR_less = '<';

	private const char CHAR_lesseq = 'f';

	private const char TOKEN_greater = 'g';

	private const char TOKEN_greatereq = 'j';

	private const char TOKEN_equal = 'e';

	private const char CHAR_equal = '=';

	private const char TOKEN_lesseq = 'k';

	private const char CHAR_greatereq = 'h';

	private const char TOKEN_noequal = 'o';

	private const char CHAR_noequal = 'p';

	private const char TOKEN_and = 'c';

	private const char CHAR_multiply = '*';

	private const char CHAR_greater = '>';

	private const char CHAR_ANDop = '\u008c';

	private const char CHAR_ELSEop = '\u0090';

	private const char CHAR_IFop = '\u008e';

	private const char CHAR_NOTop = '\u0091';

	private const char TOKEN_ANDop = '\u0085';

	private const char TOKEN_ELSEop = '\u0089';

	private const char TOKEN_IFop = '\u0087';

	private const char CHAR_ORop = '\u008b';

	private const char CHAR_THENop = '\u008f';

	private const char CHAR_XORop = '\u008d';

	private int computeFunctionLevel;

	private DateTime dateTime1900 = new DateTime(1900, 1, 1, 0, 0, 0);

	internal ICalcData grid;

	private bool exteriorFormula;

	private bool vlookupInsideIFFormula;

	private string activeFunctionName = string.Empty;

	private bool rethrowLibraryComputationExceptions;

	private bool isIndexInteriorFormula;

	private bool lockDependencies;

	private bool exceptionThrown;

	private bool currentRowNotationEnabled = true;

	private bool calculationsSuspended;

	private bool allowShortCircuitIFs;

	private bool supportLogicalOperators;

	private bool useNoAmpersandQuotes;

	private bool treatStringsAsZero = true;

	internal bool matchType;

	private bool alwaysComputeDuringRefresh = true;

	private bool ensureIFCallDuringShortCircuit;

	private bool supportRangeOperands = true;

	private bool throwCircularException;

	private bool ignoreBracet;

	private bool findRangeIfIntersect;

	private double ABSOLUTEZERO = 1E-20;

	private string BMARKER2 = '\u0092'.ToString() + '\u0092';

	[ThreadStatic]
	private static GridSheetFamilyItem defaultFamilyItem;

	[ThreadStatic]
	internal static Dictionary<object, object> modelToSheetID;

	[ThreadStatic]
	internal static Dictionary<object, object> sheetFamiliesList;

	[ThreadStatic]
	private static int sheetFamilyID;

	[ThreadStatic]
	private static char parseArgumentSeparator;

	[ThreadStatic]
	private static char parseDecimalSeparator;

	[ThreadStatic]
	private static char parseDateTimeSeparator;

	private const string TABLE_ROW = "[#THIS ROW]";

	private const string TABLE_HEADERS = "[#HEADERS]";

	private const string TABLE_TOTALS = "[#TOTALS]";

	private const string TABLE_DATA = "[#DATA]";

	private const string TABLE_ALL = "[#ALL]";

	private int iterationMaxCount;

	private double dateTime1900Double;

	private const double OADate1904 = 1462.0;

	private double iterationMaxTolerance = 0.001;

	internal int iterations_dont_converge = 27;

	private Dictionary<object, object> iterationValues;

	private Exception libraryComputationException;

	private bool supportsSheetRanges = true;

	private char tempSheetPlaceHolder = '\u0085';

	[ThreadStatic]
	internal static int TokenCount;

	private string markers = "()+-*/=><.,!";

	[ThreadStatic]
	private static int maxStackDepth;

	private char[] logicalOperators = new char[5] { 'a', 's', 'm', 'd', 'c' };

	private Dictionary<object, object> namedRanges;

	private string[] reservedWordOperators;

	private string IFMarker = "qIF\u0082";

	private const char TOKEN_NOTop = '\u008a';

	private const char TOKEN_or = '~';

	private const char TOKEN_ORop = '\u0084';

	private const char TOKEN_THENop = '\u0088';

	private const char TOKEN_XORop = '\u0086';

	internal bool UseDate1904;

	private bool isAreaCalculation;

	public static bool Treat1900AsLeapYear;

	internal bool errorFormula;

	private bool excelLikeComputations;

	internal bool IsArrayFormula;

	internal ArrayParser ArrayParser;

	internal LinearRegression LinearRegression;

	private static bool isParseArgumentSeparator;

	private static bool isParseDecimalSeparatorChanged;

	internal int operators_cannot_start_an_expression;

	internal int cannot_parse = 1;

	internal int bad_library = 2;

	internal int invalid_char_in_front_of = 3;

	internal int number_contains_2_decimal_points = 4;

	internal int expression_cannot_end_with_an_operator = 5;

	internal int invalid_characters_following_an_operator = 6;

	internal int invalid_char_in_number = 7;

	internal int mismatched_parentheses = 8;

	internal int unknown_formula_name = 9;

	internal int requires_a_single_argument = 10;

	internal int requires_3_args = 11;

	internal int invalid_Math_argument = 12;

	internal int requires_2_args = 13;

	internal int bad_index = 14;

	internal int Name_error = 14;

	internal int too_complex = 15;

	internal int circular_reference_ = 16;

	internal int missing_formula = 17;

	internal int improper_formula = 18;

	internal int invalid_expression = 19;

	internal int cell_empty = 20;

	internal int bad_formula = 21;

	internal int empty_expression = 22;

	internal int virtual_mode_required = 23;

	internal int mismatched_tics = 24;

	internal int wrong_number_arguments = 25;

	internal int invalid_arguments = 26;

	public int already_registered = 28;

	internal int calculation_overflow = 29;

	internal int missing_sheet = 30;

	internal int parameters_notvalid = 31;

	internal int invalid_parameter = 32;

	internal int value_between = 33;

	internal int invalid_argument = 34;

	internal int parameter_place = 35;

	internal int invalid_arg_value = 36;

	internal int parameter_length = 37;

	internal int invalid_suffix = 38;

	internal int num_null = 39;

	internal int min_value = 40;

	internal int incorrect_array_length = 41;

	internal int solution_converge = 42;

	public string[] FormulaErrorStrings = new string[43]
	{
		"binary operators cannot start an expression", "cannot parse", "bad library", "invalid char in front of", "number contains 2 decimal points", "expression cannot end with an operator", "invalid characters following an operator", "invalid character in number", "mismatched parentheses", "unknown formula name",
		"requires a single argument", "requires 3 arguments", "invalid Math argument", "requires 2 arguments", "#NAME?", "too complex", "circular reference: ", "missing formula", "improper formula", "invalid expression",
		"cell empty", "bad formula", "empty expression", "", "mismatched string quotes", "wrong number of arguments", "invalid arguments", "iterations do not converge", "Control named '{0}' is already registered", "Calculation overflow",
		"Missing sheet", "invalid parameters", "Parameter is not valid", "Value should be in between", "Argument is not valid", "The second parameter places should be less than or equal to 10", "Argument value is less than zero", "Total length should not exceed 10", "Suffix is not Appropriate", "inumber2 is null",
		"Passed argument value is different from minimum par", "Arrays must be the same length", "Solution did not converge"
	};

	private bool isDoubleQuotes;

	private bool isErrorString;

	private Dictionary<object, object> namedRangesNonScoped;

	internal bool findNamedRange;

	private Dictionary<object, object> scopedRangeStrings = new Dictionary<object, object>();

	private List<object> weekEndType;

	private char MarkerParseChar = '\u0085';

	private bool isInteriorFunction;

	private char CHARTIC = "'"[0];

	private bool multiTick;

	private bool rethrowExceptions;

	private bool useDatesInCalcs;

	private List<string> nativeFormats;

	private List<object> sortedSheetNames;

	private LookupCachingMode enableLookupTableCaching;

	private Dictionary<string, LookUps> lookupTables;

	private List<object> formulaErrorStrings;

	private static string[] charTable;

	private static int[] factorialTable;

	private Random rand;

	private const double PI = Math.PI;

	private static double[] gammaAs;

	private static int gauss_n;

	private static double[] gauss_x;

	private static double[] gauss_w;

	internal bool IgnoreSubtotal;

	internal int hitCount;

	public bool TreatStringsAsZero
	{
		get
		{
			return treatStringsAsZero;
		}
		set
		{
			treatStringsAsZero = value;
		}
	}

	internal bool IsAreaCalculation
	{
		get
		{
			return isAreaCalculation;
		}
		set
		{
			isAreaCalculation = value;
		}
	}

	public int MaximumRecursiveCalls
	{
		get
		{
			return maximumRecursiveCalls;
		}
		set
		{
			maximumRecursiveCalls = value;
		}
	}

	public bool CalculatingSuspended
	{
		get
		{
			return calculationsSuspended;
		}
		set
		{
			calculationsSuspended = value;
		}
	}

	public Dictionary<object, object> LibraryFunctions => libraryFunctions;

	public bool UseNoAmpersandQuotes
	{
		get
		{
			return useNoAmpersandQuotes;
		}
		set
		{
			useNoAmpersandQuotes = value;
		}
	}

	internal bool ExceptionThrown
	{
		get
		{
			return exceptionThrown;
		}
		set
		{
			exceptionThrown = value;
		}
	}

	public Exception LibraryComputationException => libraryComputationException;

	public bool RethrowLibraryComputationExceptions
	{
		get
		{
			return rethrowLibraryComputationExceptions;
		}
		set
		{
			rethrowLibraryComputationExceptions = value;
		}
	}

	[DefaultValue(false)]
	public bool ExcelLikeComputations
	{
		get
		{
			return excelLikeComputations;
		}
		set
		{
			if (excelLikeComputations != value)
			{
				excelLikeComputations = value;
			}
		}
	}

	public static int MaxStackDepth
	{
		get
		{
			if (maxStackDepth == 0)
			{
				maxStackDepth = 50;
			}
			return maxStackDepth;
		}
		set
		{
			maxStackDepth = value;
		}
	}

	public string[] ReservedWordOperators
	{
		get
		{
			if (reservedWordOperators == null)
			{
				reservedWordOperators = new string[7] { " or ", " and ", " xor ", "if ", " then ", " else ", "not " };
			}
			return reservedWordOperators;
		}
		set
		{
			reservedWordOperators = value;
		}
	}

	public static char FormulaCharacter
	{
		get
		{
			if (formulaChar == '\0')
			{
				formulaChar = '=';
			}
			return formulaChar;
		}
		set
		{
			formulaChar = value;
		}
	}

	internal bool CurrentRowNotationEnabled
	{
		get
		{
			return currentRowNotationEnabled;
		}
		set
		{
			currentRowNotationEnabled = value;
		}
	}

	internal string ActiveFunctionName => activeFunctionName;

	public string ActiveCell => cell;

	public bool AllowShortCircuitIFs
	{
		get
		{
			return allowShortCircuitIFs;
		}
		set
		{
			allowShortCircuitIFs = value;
		}
	}

	public bool AlwaysComputeDuringRefresh
	{
		get
		{
			return alwaysComputeDuringRefresh;
		}
		set
		{
			alwaysComputeDuringRefresh = value;
		}
	}

	public bool UseFormulaValues
	{
		get
		{
			return useFormulaValues;
		}
		set
		{
			useFormulaValues = value;
		}
	}

	public bool CheckDanglingStack
	{
		get
		{
			return checkDanglingStack;
		}
		set
		{
			checkDanglingStack = value;
		}
	}

	public int ColumnMaxCount
	{
		get
		{
			return columnMaxCount;
		}
		set
		{
			columnMaxCount = value;
		}
	}

	public bool EnsureIFCallDuringShortCircuit
	{
		get
		{
			return ensureIFCallDuringShortCircuit;
		}
		set
		{
			ensureIFCallDuringShortCircuit = value;
		}
	}

	public bool ForceRefreshCall
	{
		get
		{
			return forceRefreshCall;
		}
		set
		{
			forceRefreshCall = value;
		}
	}

	public Dictionary<object, object> FormulaInfoTable
	{
		get
		{
			if (IsSheeted)
			{
				GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
				if (sheetFamilyItem.sheetFormulaInfoTable == null)
				{
					sheetFamilyItem.sheetFormulaInfoTable = new Dictionary<object, object>();
				}
				return sheetFamilyItem.sheetFormulaInfoTable;
			}
			if (_formulaInfoTable == null)
			{
				_formulaInfoTable = new Dictionary<object, object>();
			}
			return _formulaInfoTable;
		}
	}

	public bool GetValueFromArgPreserveLeadingZeros
	{
		get
		{
			return getValueFromArgPreserveLeadingZeros;
		}
		set
		{
			getValueFromArgPreserveLeadingZeros = value;
		}
	}

	public int IterationMaxCount
	{
		get
		{
			return iterationMaxCount;
		}
		set
		{
			iterationMaxCount = value;
			if (iterationMaxCount > 0)
			{
				ThrowCircularException = true;
			}
		}
	}

	public double IterationMaxTolerance
	{
		get
		{
			return iterationMaxTolerance;
		}
		set
		{
			iterationMaxTolerance = value;
		}
	}

	private Dictionary<object, object> IterationValues
	{
		get
		{
			if (iterationValues == null)
			{
				iterationValues = new Dictionary<object, object>();
			}
			return iterationValues;
		}
	}

	public bool LockDependencies
	{
		get
		{
			return lockDependencies;
		}
		set
		{
			lockDependencies = value;
		}
	}

	public int RowMaxCount
	{
		get
		{
			return rowMaxCount;
		}
		set
		{
			rowMaxCount = value;
		}
	}

	public bool SupportLogicalOperators
	{
		get
		{
			return supportLogicalOperators;
		}
		set
		{
			supportLogicalOperators = value;
		}
	}

	public bool SupportRangeOperands
	{
		get
		{
			return supportRangeOperands;
		}
		set
		{
			supportRangeOperands = value;
		}
	}

	public bool SupportsSheetRanges
	{
		get
		{
			return supportsSheetRanges;
		}
		set
		{
			supportsSheetRanges = value;
		}
	}

	public bool ThrowCircularException
	{
		get
		{
			return throwCircularException;
		}
		set
		{
			throwCircularException = value;
		}
	}

	public bool UseDependencies
	{
		get
		{
			return useDependencies;
		}
		set
		{
			useDependencies = value;
		}
	}

	public string ValidPrecedingChars
	{
		get
		{
			validPrecedingChars = " (+-*/^&<>=" + ParseArgumentSeparator;
			return validPrecedingChars;
		}
		set
		{
			validPrecedingChars = value;
		}
	}

	internal bool PreserveFormula
	{
		get
		{
			return preserveFormula;
		}
		set
		{
			preserveFormula = value;
		}
	}

	internal bool IsSheeted => GetSheetFamilyItem(grid)?.isSheeted ?? false;

	public static char ParseArgumentSeparator
	{
		get
		{
			if (parseArgumentSeparator == '\0')
			{
				parseArgumentSeparator = ',';
			}
			if (!isParseArgumentSeparator && char.TryParse(CultureInfo.CurrentCulture.NumberFormat.NumberGroupSeparator, out var result) && result != parseArgumentSeparator)
			{
				parseArgumentSeparator = result;
			}
			return parseArgumentSeparator;
		}
		set
		{
			parseArgumentSeparator = value;
			isParseArgumentSeparator = true;
		}
	}

	public static char ParseDecimalSeparator
	{
		get
		{
			if (parseDecimalSeparator == '\0')
			{
				parseDecimalSeparator = '.';
			}
			if (!isParseDecimalSeparatorChanged && char.TryParse(CultureInfo.CurrentUICulture.NumberFormat.NumberDecimalSeparator, out var result) && result != parseDecimalSeparator)
			{
				parseDecimalSeparator = result;
			}
			return parseDecimalSeparator;
		}
		set
		{
			parseDecimalSeparator = value;
			isParseDecimalSeparatorChanged = true;
		}
	}

	public static char ParseDateTimeSeparator
	{
		get
		{
			return parseDateTimeSeparator;
		}
		set
		{
			if (parseDateTimeSeparator != value)
			{
				parseDateTimeSeparator = value;
			}
		}
	}

	public List<object> ErrorStrings
	{
		get
		{
			if (errorStrings == null)
			{
				errorStrings = new List<object>();
				errorStrings.AddRange(new string[8] { "#N/A", "#VALUE!", "#REF!", "#DIV/0!", "#NUM!", "#NAME?", "#NULL!", "#CALC!" });
			}
			return errorStrings;
		}
		set
		{
			errorStrings = value;
		}
	}

	public Dictionary<object, object> DependentCells
	{
		get
		{
			if (IsSheeted)
			{
				GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
				if (sheetFamilyItem.sheetDependentCells == null)
				{
					sheetFamilyItem.sheetDependentCells = new Dictionary<object, object>();
				}
				return sheetFamilyItem.sheetDependentCells;
			}
			if (dependentCells == null)
			{
				dependentCells = new Dictionary<object, object>();
			}
			return dependentCells;
		}
	}

	public Dictionary<object, object> DependentFormulaCells
	{
		get
		{
			if (IsSheeted)
			{
				GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
				if (sheetFamilyItem.sheetDependentFormulaCells == null)
				{
					sheetFamilyItem.sheetDependentFormulaCells = new Dictionary<object, object>();
				}
				return sheetFamilyItem.sheetDependentFormulaCells;
			}
			if (dependentFormulaCells == null)
			{
				dependentFormulaCells = new Dictionary<object, object>();
			}
			return dependentFormulaCells;
		}
	}

	public Dictionary<object, object> NamedRanges
	{
		get
		{
			if (namedRanges == null)
			{
				namedRanges = new Dictionary<object, object>();
				namedRangesNonScoped = new Dictionary<object, object>();
			}
			return namedRanges;
		}
		set
		{
			namedRanges = value;
			PopulateNamedRangesNonScoped();
		}
	}

	public List<object> WeekEndType
	{
		get
		{
			if (weekEndType == null)
			{
				weekEndType = new List<object>();
				weekEndType.AddRange(new string[18]
				{
					"", "6,0", "0,1", "1,2", "2,3", "3,4", "4,5", "5,6", "", "",
					"", "0", "1", "2", "3", "4", "5", "6"
				});
			}
			return weekEndType;
		}
	}

	public bool UseDatesInCalculations
	{
		get
		{
			return useDatesInCalcs;
		}
		set
		{
			useDatesInCalcs = value;
		}
	}

	public bool RethrowParseExceptions
	{
		get
		{
			return rethrowExceptions;
		}
		set
		{
			rethrowExceptions = value;
		}
	}

	private List<string> NativeFormats
	{
		get
		{
			if (nativeFormats == null)
			{
				nativeFormats = new List<string> { "[DBNUM1]", "[DBNUM2]", "[DBNUM3]", "[DBNUM4]" };
			}
			return nativeFormats;
		}
	}

	private List<object> SortedSheetNames
	{
		get
		{
			GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
			if (sortedSheetNames == null && sheetFamilyItem != null && sheetFamilyItem.SheetNameToToken != null)
			{
				string[] array = new string[sheetFamilyItem.SheetNameToToken.Keys.Count];
				Dictionary<object, object>.KeyCollection keys = sheetFamilyItem.SheetNameToToken.Keys;
				object[] array2 = array;
				keys.CopyTo(array2, 0);
				sortedSheetNames = new List<object>(array);
				sortedSheetNames.Sort(new LenComparer());
			}
			return sortedSheetNames;
		}
	}

	public LookupCachingMode EnableLookupTableCaching
	{
		get
		{
			return enableLookupTableCaching;
		}
		set
		{
			enableLookupTableCaching = value;
		}
	}

	internal event FormulaParsingEventHandler FormulaParsing;

	internal event UnknownFunctionEventHandler UnknownFunction;

	internal event UpdateNamedRangeEventHandler UpdateNamedRange;

	internal event FormulaComputedEventHandler FormulaComputed;

	internal event UpdateExternalFormulaEventHandler UpdateExternalFormula;

	internal event GetExternalWorksheetEventHandler QueryExternalWorksheet;

	internal event GetExternalNamedRangeEventHandler GetExternalNamedRange;

	static CalcEngine()
	{
		formulaChar = '=';
		sheetID = -1;
		defaultFamilyItem = null;
		modelToSheetID = null;
		sheetFamiliesList = null;
		sheetFamilyID = 0;
		parseArgumentSeparator = ',';
		parseDecimalSeparator = '.';
		parseDateTimeSeparator = '/';
		TokenCount = 0;
		maxStackDepth = 50;
		Treat1900AsLeapYear = true;
		isParseArgumentSeparator = false;
		isParseDecimalSeparatorChanged = false;
		charTable = new string[27]
		{
			string.Empty,
			"A",
			"B",
			"C",
			"D",
			"E",
			"F",
			"G",
			"H",
			"I",
			"J",
			"K",
			"L",
			"M",
			"N",
			"O",
			"P",
			"Q",
			"R",
			"S",
			"T",
			"U",
			"V",
			"W",
			"X",
			"Y",
			"Z"
		};
		factorialTable = new int[13]
		{
			1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880,
			3628800, 39916800, 479001600
		};
		gammaAs = new double[5] { 0.918938533204673, 0.000595238095238, 0.000793650793651, 0.002777777777778, 0.083333333333333 };
		gauss_n = 16;
		gauss_x = new double[16]
		{
			0.04830766569, 0.14447196158, 0.23928736225, 0.33186860228, 0.42135127613, 0.50689990893, 0.58771575724, 0.66304426693, 0.73218211874, 0.79448379597,
			0.84936761373, 0.89632115577, 0.93490607594, 0.96476225559, 0.98561151155, 0.99726386185
		};
		gauss_w = new double[16]
		{
			0.09654008851, 0.09563872008, 0.09384439908, 0.0911738787, 0.087652093, 0.08331192423, 0.07819389579, 0.07234579411, 0.06582222278, 0.05868409348,
			0.05099805926, 0.04283589802, 0.03427386291, 0.02539206531, 0.01627439473, 0.00701861001
		};
		formulaChar = '=';
	}

	public CalcEngine(ICalcData ParentObject)
	{
		grid = ParentObject;
		grid.WireParentObject();
		grid.ValueChanged += grid_ValueChanged;
		InitLibraryFunctions();
		tokens = new char[12]
		{
			'a', 's', 'm', 'd', 'l', 'g', 'e', 'k', 'j', 'o',
			'c', '~'
		};
		dateTime1900Double = CalcEngineHelper.ToOADate(dateTime1900);
		refreshedCells = new Dictionary<object, object>();
		formulaErrorStrings = new List<object>(FormulaErrorStrings.Length);
		formulaErrorStrings.AddRange(FormulaErrorStrings);
		ArrayParser = new ArrayParser(this);
		LinearRegression = new LinearRegression(this);
	}

	private string FormulaErrorStringCheck(string args, FormulaArgumentType argumentType)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		switch (argumentType)
		{
		case FormulaArgumentType.None:
			if (!string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					libraryComputationException = new Exception(FormulaErrorStrings[invalid_arguments]);
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return FormulaErrorStrings[invalid_arguments];
			}
			break;
		case FormulaArgumentType.Range:
		{
			string text5 = string.Empty;
			string[] array2 = array;
			foreach (string text6 in array2)
			{
				if (text6.IndexOf(':') > -1)
				{
					if (text6.StartsWith(TIC))
					{
						if (RethrowLibraryComputationExceptions)
						{
							libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return ErrorStrings[1].ToString();
					}
					string[] cellsFromArgs = GetCellsFromArgs(text6);
					foreach (string arg2 in cellsFromArgs)
					{
						try
						{
							text5 = GetValueFromArg(arg2);
						}
						catch
						{
						}
						if (text5.Length > 0 && ErrorStrings.Contains(text5))
						{
							if (RethrowLibraryComputationExceptions)
							{
								libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return text5;
						}
					}
					continue;
				}
				try
				{
					text5 = GetValueFromArg(text6);
				}
				catch
				{
				}
				if (text5.Length > 0)
				{
					string text7 = FormulaErrorStringCheck(text5, FormulaArgumentType.Numbers);
					if (ErrorStrings.Contains(text7))
					{
						return text7;
					}
				}
			}
			break;
		}
		case FormulaArgumentType.TwoTextWithNumber:
		{
			string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (array.Length == 3)
			{
				string text3 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text3))
				{
					return text3;
				}
			}
			break;
		}
		case FormulaArgumentType.TextWithNumber:
		{
			double result8 = 0.0;
			double result9 = 0.0;
			bool.TryParse(array[0], out var result10);
			if (array.Length == 2)
			{
				bool.TryParse(GetValueFromArg(array[1]), out result10);
			}
			else
				_ = 0;
			if (!double.TryParse(array[0].Replace(TIC, string.Empty), out result8))
			{
				string valueFromArg4 = GetValueFromArg(array[0]);
				if (ErrorStrings.Contains(valueFromArg4))
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg4;
				}
			}
			if (array.Length == 2 && !double.TryParse(array[1].Replace(TIC, string.Empty), out result9))
			{
				string text9 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text9))
				{
					return text9;
				}
			}
			break;
		}
		case FormulaArgumentType.Text:
		{
			string[] array2 = array;
			foreach (string text8 in array2)
			{
				bool.TryParse(array[0], out var _);
				if (double.TryParse(text8.Replace(TIC, string.Empty), out var _))
				{
					continue;
				}
				string valueFromArg3 = GetValueFromArg(text8);
				if (ErrorStrings.Contains(valueFromArg3))
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg3;
				}
			}
			break;
		}
		case FormulaArgumentType.Numbers:
		{
			string[] array2 = array;
			foreach (string text4 in array2)
			{
				bool result4;
				bool flag2 = bool.TryParse(GetValueFromArg(text4), out result4);
				if (IsArgumentIsNumber(text4.Replace(TIC, string.Empty)))
				{
					continue;
				}
				string valueFromArg2 = GetValueFromArg(text4);
				if (ErrorStrings.Contains(valueFromArg2))
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg2;
				}
				if ((!flag2 && !double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out var _) && !string.IsNullOrEmpty(valueFromArg2)) || (text4.Contains(":") && IsCellReference(text4)) || (valueFromArg2.StartsWith(TIC) && !IsArgumentIsNumber(valueFromArg2.Replace(TIC, string.Empty))))
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[invalid_arguments]);
						throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
					}
					return ErrorStrings[1].ToString();
				}
			}
			break;
		}
		case FormulaArgumentType.Date:
		{
			double result = 0.0;
			string[] array2 = array;
			foreach (string arg in array2)
			{
				bool result2;
				bool flag = bool.TryParse(GetValueFromArg(arg), out result2);
				string valueFromArg = GetValueFromArg(arg);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				if (!flag && !DateTime.TryParse(StripTics0(valueFromArg), out var _) && !double.TryParse(StripTics0(valueFromArg), out result) && valueFromArg != string.Empty)
				{
					if (RethrowLibraryComputationExceptions)
					{
						libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
			}
			break;
		}
		}
		return args;
	}

	private bool IsArgumentIsNumber(string arg)
	{
		string[] array = arg.Split(parseArgumentSeparator);
		bool result = false;
		for (int i = 0; i < array.Length; i++)
		{
			if (double.TryParse(array[i].Replace(TIC, string.Empty).Replace('u', '-'), NumberStyles.Any, null, out var _))
			{
				result = true;
				continue;
			}
			return false;
		}
		return result;
	}

	internal string Parse(string text)
	{
		ExceptionThrown = false;
		if (TextIsEmpty(text))
		{
			return text;
		}
		if (text.Contains(TIC))
		{
			text = CheckForStringTIC(text);
		}
		GetFormulaText(ref text);
		if (FormulaCharacter != 0 && text.Length > 0 && FormulaCharacter == text[0])
		{
			text = text.Substring(1);
		}
		if (NamedRanges.Count > 0)
		{
			text = CheckForNamedRange(text);
			while (findNamedRange)
			{
				text = CheckForNamedRange(text);
			}
		}
		Dictionary<object, object> dictionary = SaveStrings(ref text);
		if (text.Contains('{') && text.Contains('}'))
		{
			isBracesReplaced = true;
		}
		text = text.Replace(BRACELEFT, TIC);
		text = text.Replace(BRACERIGHT, TIC);
		text = text.Replace("-+", "-");
		int num = 0;
		if (!text.EndsWith('\u0092'.ToString(), StringComparison.Ordinal) || text.LastIndexOfAny(tokens) != text.Length - 2)
		{
			text = text.ToUpper(CultureInfo.InvariantCulture);
		}
		if (text.IndexOf('!') > -1)
		{
			GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
			if (sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.Count > 0)
			{
				try
				{
					if (!text.StartsWith('!'.ToString()))
					{
						PutTokensForSheets(ref text);
					}
					string text2 = SheetToken(text.Replace(TIC, string.Empty));
					string scopedRange = string.Empty;
					if (!string.IsNullOrEmpty(text2) && NamedRanges.Count > 0 && TryGetNamedRange(text.Replace("'", string.Empty).Replace(text2, string.Empty).ToUpper(), out scopedRange))
					{
						text = scopedRange;
					}
				}
				catch (Exception ex)
				{
					ExceptionThrown = true;
					if (rethrowExceptions)
					{
						throw ex;
					}
					return ex.Message;
				}
			}
		}
		if (SupportLogicalOperators)
		{
			MarkReserveWords(ref text);
		}
		if (isRangeOperand)
		{
			isRangeOperand = false;
			return GetCellFrom(ParseSimple(text));
		}
		string text3 = string.Empty;
		if (text.Contains("["))
		{
			for (num = 0; num < text.Length; num++)
			{
				if (text[num].Equals('['))
				{
					for (; text[num] != ']'; num++)
					{
						text3 += text[num];
					}
				}
				if (!text[num].Equals(' '))
				{
					text3 += text[num];
				}
			}
			text = text3;
		}
		else if (text.Contains(" ") && NamedRanges.Count > 0)
		{
			string text4 = string.Empty;
			string scopedRange2 = string.Empty;
			bool flag = false;
			string text5 = string.Empty;
			bool flag2 = false;
			double result = 0.0;
			for (int i = 0; i < text.Length; i++)
			{
				string text6 = string.Empty;
				while ((i != text.Length && char.IsLetterOrDigit(text[i])) || (i != text.Length && ((text[i] == ':') | (text[i] == '\\') | (text[i] == '_'))))
				{
					text5 += text[i++];
				}
				if (TryGetNamedRange(text5.ToUpper(), out scopedRange2) || (text5 != string.Empty && !libraryFunctions.ContainsKey(text5) && !IsCellReference(text5.ToUpper()) && !double.TryParse(text5.ToUpper(), NumberStyles.Any, CultureInfo.CurrentCulture, out result)))
				{
					text6 += text5;
					flag = true;
				}
				else if (text5 != string.Empty && libraryFunctions.ContainsKey(text5))
				{
					text6 += text5;
				}
				else if (text5 != string.Empty)
				{
					text6 += text5;
				}
				if (i != text.Length && text[i] == ' ' && i != 0 && (char.IsLetterOrDigit(text[i - 1]) | (text[i - 1] == ')')))
				{
					text5 = string.Empty;
					i++;
					while ((i != text.Length && char.IsLetterOrDigit(text[i])) || (i != text.Length && ((text[i] == ':') | (text[i] == '\\') | (text[i] == '_'))))
					{
						text5 += text[i++];
					}
					if (flag && !flag2 && (TryGetNamedRange(text5.ToUpper(), out scopedRange2) || (text5 != string.Empty && !libraryFunctions.ContainsKey(text5) && !IsCellReference(text5.ToUpper()) && !double.TryParse(text5.ToUpper(), NumberStyles.Any, CultureInfo.CurrentCulture, out result))))
					{
						text6 = string.Concat(text6, " " + text5);
					}
					else if (flag && text5.Contains(":"))
					{
						text6 = string.Concat(text6, " " + text5);
					}
					else if (!TryGetNamedRange(text5.ToUpper(), out scopedRange2) && libraryFunctions.ContainsKey(text5) && flag)
					{
						text6 = string.Concat(text6, " " + text5);
						flag2 = true;
					}
					else if (text5 != string.Empty)
					{
						text6 += text5;
					}
				}
				if (i != text.Length && text[i] == ')')
				{
					text6 += text[i];
					flag2 = false;
				}
				else if (i != text.Length && text[i] != ')' && text[i] != ' ')
				{
					text6 += text[i];
				}
				else if (i != text.Length && text[i] == ' ' && flag && (char.IsLetterOrDigit(text[i - 1]) | (text[i - 1] == ')') | (text[i - 1] == '\\') | (text[i - 1] == '_')))
				{
					text6 += text[i];
				}
				else if (i != text.Length && text5 == string.Empty && !flag && text[i] != ' ')
				{
					text6 += string.Empty;
				}
				text4 += text6;
				text5 = string.Empty;
			}
			text = text4;
		}
		else
		{
			text = text.Replace(" ", string.Empty);
		}
		text = text.Replace("=>", ">=");
		text = text.Replace("=<", "<=");
		try
		{
			MarkLibraryFormulas(ref text);
		}
		catch (Exception ex2)
		{
			ExceptionThrown = true;
			if (rethrowExceptions)
			{
				throw ex2;
			}
			return ErrorStrings[5].ToString();
		}
		if (!ignoreBracet)
		{
			while ((num = text.IndexOf(')')) > -1)
			{
				int num2 = text.Substring(0, num).LastIndexOf('(');
				if (num2 == -1)
				{
					throw new ArgumentException(FormulaErrorStrings[mismatched_parentheses]);
				}
				if (num2 == num - 1)
				{
					throw new ArgumentException(FormulaErrorStrings[empty_expression]);
				}
				string empty = string.Empty;
				text = string.Concat(str1: ParseSimple((!ignoreBracet) ? text.Substring(num2 + 1, num - num2 - 1) : text.Substring(num2, num - num2 + 1)), str0: text.Substring(0, num2), str2: text.Substring(num + 1));
			}
		}
		if (!ignoreBracet && text.IndexOf('(') > -1)
		{
			throw new ArgumentException(FormulaErrorStrings[mismatched_parentheses]);
		}
		string retValue = ParseSimple(text);
		if (dictionary != null && dictionary.Count > 0)
		{
			SetStrings(ref retValue, dictionary);
		}
		return retValue;
	}

	internal bool TryGetNamedRange(string text, out string scopedRange)
	{
		scopedRange = string.Empty;
		string text2 = text;
		int result = GetSheetID(grid);
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		if (text.StartsWith('!'.ToString()))
		{
			int num = text.IndexOf('!', 1);
			if (num > 1 && int.TryParse(text.Substring(1, num - 1), out result))
			{
				text = text.Substring(num + 1);
			}
		}
		string text3 = "!" + result + "!";
		if (sheetFamilyItem != null && sheetFamilyItem.SheetNameToToken != null)
		{
			foreach (string key2 in sheetFamilyItem.SheetNameToToken.Keys)
			{
				if (sheetFamilyItem.SheetNameToToken[key2].ToString() == text3)
				{
					string key = (key2 + "!" + text).ToUpper();
					if (NamedRanges.ContainsKey(key))
					{
						scopedRange = ((string)NamedRanges[key]).ToUpper();
						return true;
					}
					break;
				}
			}
		}
		if (NamedRanges.ContainsKey(text2.ToUpper().Replace("'", string.Empty)))
		{
			scopedRange = ((string)NamedRanges[text2.ToUpper().Replace("'", string.Empty)]).ToUpper();
			return true;
		}
		return false;
	}

	private string CheckForStringTIC(string text)
	{
		int num = 0;
		string text2 = TIC + TIC;
		if ((num = text.IndexOf(TIC)) > -1)
		{
			while (num > -1 && num < text.Length - 1)
			{
				int num2 = ((num + 1 < text.Length) ? text.IndexOf(TIC, num + 1) : (-1));
				if (num2 > -1)
				{
					if (num2 < text.Length - 2 && text[num2 + 1] == TIC[0])
					{
						num2 = text.IndexOf(TIC, num2 + 2);
						if (num2 == -1)
						{
							throw new ArgumentException(FormulaErrorStrings[mismatched_tics]);
						}
					}
					if (num2 < text.Length - 2 && text[num2 + 1] == TIC[0])
					{
						num2 = text.IndexOf(TIC, num2 + 2);
						if (num2 == -1)
						{
							throw new ArgumentException(FormulaErrorStrings[mismatched_tics]);
						}
					}
					string text3 = text.Substring(num, num2 - num + 1);
					if (text3 != text2 && text3.Contains(text2) && UseNoAmpersandQuotes && text3.Length > 1 && text3[0] == TIC[0] && text3[text3.Length - 1] == TIC[0])
					{
						text3 = text3.Substring(1, text3.Length - 2);
						text3 = text3.Replace(text2, "~");
						text3 = TIC + text3 + TIC;
						isDoubleQuotes = true;
					}
					text = text.Substring(0, num) + text3 + text.Substring(num2 + 1);
					num += text3.Length;
					if (num < text.Length - 1)
					{
						num = text.IndexOf(TIC, num);
					}
				}
				else if (num2 == -1)
				{
					return text;
				}
			}
		}
		return text;
	}

	private bool CheckHasCharBeforeNumber(string tempFormula)
	{
		bool result = false;
		for (int num = tempFormula.Length - 1; num > 0; num--)
		{
			if (char.IsLetter(tempFormula[num]))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public string ParseFormula(string formula)
	{
		try
		{
			if (formula.StartsWith(BRACELEFT) && formula.EndsWith(BRACERIGHT) && formula[1] == FormulaCharacter)
			{
				formula = ArrayParser.ParseLibraryFormula(formula);
				IsArrayFormula = true;
			}
			if (formula.Length > 0 && formula[0] == FormulaCharacter)
			{
				formula = formula.Substring(1);
			}
			if (formula.Length > 0 && formula[0] == '+')
			{
				formula = formula.Substring(1);
			}
			isRangeOperand = supportRangeOperands && IsRange(formula);
			if (CheckDanglingStack && formula.Replace(" ", string.Empty).IndexOf(BRACERIGHTnLEFT) > -1)
			{
				computedValueLevel = 0;
				return FormulaErrorStrings[improper_formula];
			}
			return Parse(formula.Trim());
		}
		finally
		{
			if (computedValueLevel <= 1)
			{
				IsArrayFormula = false;
			}
		}
	}

	public string ParseAndComputeFormula(string formula)
	{
		try
		{
			if (string.IsNullOrEmpty(formula))
			{
				return formula;
			}
			if (formula.Length > 0 && formula[0] == FormulaCharacter)
			{
				formula = formula.Substring(1);
			}
			if (formula.StartsWith(BRACELEFT) && formula.EndsWith(BRACERIGHT) && formula[1] == FormulaCharacter)
			{
				formula = ArrayParser.ParseLibraryFormula(formula);
				IsArrayFormula = true;
			}
			if (formula.Length > 0 && formula[0] == '+')
			{
				formula = formula.Substring(1);
			}
			if (formula.Length > 1 && formula[0] == '#')
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[5].ToString();
			}
			string text = formula.Replace(" ", string.Empty);
			if (formula.Length > 1 && formula[0] == ParseDecimalSeparator)
			{
				if (formula[1] >= '0' && formula[1] <= '9')
				{
					formula = "0" + ParseDecimalSeparator + formula.Substring(1);
				}
			}
			else if (formula.Length > 1 && formula.StartsWith("(") && formula.EndsWith(")") && formula.Length > formula.LastIndexOf("(") + 1 && text[text.IndexOf("(") + 1] == ParseDecimalSeparator)
			{
				int num = formula.LastIndexOf("(");
				if (text.Length > num + 1 && text[num + 1] == ParseDecimalSeparator && text.Length > num + 2 && text[num + 2] >= '0' && text[num + 2] <= '9')
				{
					formula = text.Substring(0, num + 1) + "0" + ParseDecimalSeparator + text.Substring(num + 2);
				}
			}
			string text2 = formula.Replace(" ", string.Empty);
			string[] array = text2.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = ((text2[0] == '"') ? 1 : 0); i < array.Length; i += 2)
			{
				text2 = array[i];
				int num2 = text2.IndexOf("(");
				while (num2 > 0 && num2 < text2.Length)
				{
					if (char.IsNumber(text2[num2 - 1]) && !CheckHasCharBeforeNumber(text2.Substring(0, num2)))
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula] + " " + text2.Substring(0, num2 + 1));
					}
					int num3 = text2.Substring(num2 + 1).IndexOf('(');
					if (num3 == -1)
					{
						break;
					}
					num2 += num3;
					num2++;
				}
				int num4 = text2.IndexOf(")");
				while (num4 != -1 && num4 < text2.Length - 1)
				{
					if (char.IsNumber(text2[num4 + 1]))
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula] + " " + text2.Substring(0, num4 + 2));
					}
					int num5 = text2.Substring(num4 + 1).IndexOf(')');
					if (num5 == -1)
					{
						break;
					}
					num4 += num5;
					num4++;
				}
			}
			multiTick = false;
			string formula2 = Parse(formula);
			formula2 = ComputedValue(formula2);
			if (UseNoAmpersandQuotes && formula2.Length > 1 && formula2[0] == TIC[0] && formula2[formula2.Length - 1] == TIC[0])
			{
				formula2 = formula2.Substring(1, formula2.Length - 2);
			}
			return formula2;
		}
		finally
		{
			if (computedValueLevel <= 1)
			{
				IsArrayFormula = false;
			}
		}
	}

	private string ParseSimple(string text)
	{
		if (text.Length > 0 && text[0] == '+')
		{
			text = text.Substring(1);
		}
		bool result = false;
		if (text == "#N/A" || text == "#N~A")
		{
			return "#N/A";
		}
		if (text.IndexOf("#N/A") > -1)
		{
			text = text.Replace("#N/A", "#N~A");
		}
		else if (bool.TryParse(text, out result))
		{
			return text;
		}
		if (text == "#DIV/0!" || text == "#DIV~0!")
		{
			return "#DIV/0!";
		}
		if (text.IndexOf("#DIV/0!") > -1)
		{
			text = text.Replace("#DIV/0!", "#DIV~0!");
		}
		text = HandleEmbeddedEs(text);
		StringBuilder stringBuilder = new StringBuilder(text);
		bool flag = true;
		while (flag)
		{
			stringBuilder.Replace("--", "+");
			stringBuilder.Replace("++", "+");
			stringBuilder.Replace(ParseArgumentSeparator + "-", ParseArgumentSeparator + "u").Replace(LEFTBRACKET + "-", LEFTBRACKET + "u").Replace("=-", "=u")
				.Replace(">-", ">u")
				.Replace("<-", "<u")
				.Replace("/-", "/u")
				.Replace("*-", "*u")
				.Replace("+-", "+u")
				.Replace("^-", "^u");
			stringBuilder.Replace(ParseArgumentSeparator + ",+", ParseArgumentSeparator + ",").Replace(LEFTBRACKET + "+", LEFTBRACKET.ToString()).Replace("=+", "=")
				.Replace(">+", ">")
				.Replace("<+", "<")
				.Replace("/+", "/")
				.Replace("*+", "*")
				.Replace("^+", "^");
			if (stringBuilder.Length > 0 && stringBuilder[0] == '+')
			{
				stringBuilder.Remove(0, 1);
			}
			flag = text != stringBuilder.ToString();
			text = stringBuilder.ToString();
		}
		text = stringBuilder.Replace("<=", 'f'.ToString()).Replace(">=", 'h'.ToString()).Replace("<>", 'p'.ToString())
			.Replace(STRING_or, CHAR_or.ToString())
			.Replace(STRING_and, CHAR_and.ToString())
			.ToString();
		string text2 = text;
		while (text2.Contains("$"))
		{
			int num = text2.IndexOf('$');
			char[] obj = new char[13]
			{
				')', '\0', '}', '+', '-', '*', '/', '<', '>', '=',
				'&', ':', '%'
			};
			obj[1] = ParseArgumentSeparator;
			char[] anyOf = obj;
			if ((text2.Length == 1 && num == 0) || (text2.Length - 1 == num && num > 0 && text2[num - 1].ToString().IndexOfAny(anyOf) > -1) || (num < text2.Length && text2[num + 1].ToString().IndexOfAny(anyOf) > -1))
			{
				if (RethrowLibraryComputationExceptions)
				{
					libraryComputationException = new Exception(FormulaErrorStrings[invalid_char_in_front_of] + "operator");
					throw new ArgumentException(FormulaErrorStrings[invalid_char_in_front_of] + " operator");
				}
				return ErrorStrings[5].ToString();
			}
			text2 = text2.Remove(num, 1);
			text = text2;
		}
		if (text == string.Empty)
		{
			return text;
		}
		bool needToContinue = true;
		text = ParseSimple(text, new char[2] { 't', 'v' }, new char[2] { CHAR_EP, CHAR_EM }, ref needToContinue);
		text = ParseSimple(text, new char[1] { '~' }, new char[1] { CHAR_or }, ref needToContinue);
		if (needToContinue)
		{
			text = ParseSimple(text, new char[2] { 'm', 'd' }, new char[2] { '*', '/' }, ref needToContinue);
		}
		if (needToContinue)
		{
			text = ParseSimple(text, new char[2] { 'a', 's' }, new char[2] { '+', '-' }, ref needToContinue);
		}
		if (needToContinue)
		{
			text = ParseSimple(text, new char[1] { 'c' }, new char[1] { CHAR_and }, ref needToContinue);
		}
		if (needToContinue)
		{
			text = ParseSimple(text, new char[6] { 'l', 'g', 'e', 'k', 'j', 'o' }, new char[6] { '<', '>', '=', 'f', 'h', 'p' }, ref needToContinue);
		}
		if (SupportLogicalOperators && needToContinue)
		{
			text = ParseSimple(text, new char[1] { '\u008a' }, new char[1] { '\u0091' }, ref needToContinue);
		}
		if (SupportLogicalOperators && needToContinue)
		{
			text = ParseSimple(text, new char[3] { '\u0084', '\u0085', '\u0086' }, new char[3] { '\u008b', '\u008c', '\u008d' }, ref needToContinue);
		}
		if (text.IndexOf("#N~A") > -1)
		{
			text = text.Replace("#N~A", "#N/A");
		}
		if (text.IndexOf("#DIV~0!") > -1)
		{
			text = text.Replace("#DIV~0!", "#DIV/0!");
		}
		return text;
	}

	internal bool IsUpper(char leter)
	{
		if (char.IsLetter(leter))
		{
			return !char.IsLower(leter);
		}
		return false;
	}

	private string ParseSimple(string text, char[] markers, char[] operators, ref bool needToContinue)
	{
		string text2 = string.Empty;
		foreach (char c in operators)
		{
			text2 += c;
		}
		StringBuilder stringBuilder = new StringBuilder(text);
		if (text.Contains(TIC + "-"))
		{
			int num = text.IndexOf(TIC);
			int num2 = text.LastIndexOf(TIC);
			int num3 = text.Substring(num).IndexOf('-');
			if (num3 < num2 && text.Length > num + num3 + 1 && char.IsNumber(text[num + num3 + 1]))
			{
				text = stringBuilder.Replace(TIC + "-", TIC + "u").ToString();
			}
		}
		if (text.StartsWith(parseArgumentSeparator.ToString()) || text.StartsWith("%"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				libraryComputationException = new Exception(FormulaErrorStrings[invalid_char_in_front_of] + "operator");
				throw new ArgumentException(FormulaErrorStrings[invalid_char_in_front_of] + " operator");
			}
			return ErrorStrings[5].ToString();
		}
		text = stringBuilder.Replace("---", "-").Replace("--", "+").Replace(ParseArgumentSeparator + "-", ParseArgumentSeparator + "u")
			.Replace(LEFTBRACKET + "-", LEFTBRACKET + "u")
			.Replace("=-", "=u")
			.Replace(">-", ">u")
			.Replace("<-", "<u")
			.Replace("/-", "/u")
			.Replace("*-", "*u")
			.Replace("+-", "-")
			.Replace("--", "-u")
			.Replace("w-", "wu")
			.ToString();
		text = stringBuilder.Replace(ParseArgumentSeparator + "+", ParseArgumentSeparator.ToString()).Replace(LEFTBRACKET + "+", LEFTBRACKET.ToString()).Replace("=+", "=")
			.Replace(">+", ">")
			.Replace("<+", "<")
			.Replace("/+", "/")
			.Replace("*+", "*")
			.Replace("++", "+")
			.ToString();
		if (text.Length > 0 && text[0] == '-')
		{
			text = text.Substring(1).Replace('-', '\u0084');
			text = "0-" + text;
			text = ParseSimple(text, new char[1] { 's' }, new char[1] { '-' }, ref needToContinue);
			text = text.Replace('\u0084', '-');
		}
		else if (text.Length > 0 && text[0] == '+')
		{
			text = text.Substring(1);
		}
		try
		{
			if (text.IndexOfAny(operators) > -1)
			{
				int num4;
				while ((num4 = text.IndexOfAny(operators)) > -1)
				{
					string text3 = string.Empty;
					string empty = string.Empty;
					int num5 = 0;
					int num6 = 0;
					int num7;
					if (!SupportLogicalOperators || text[num4] != '\u0091')
					{
						if (num4 < 1 && text[num4] != '-')
						{
							throw new ArgumentException(FormulaErrorStrings[operators_cannot_start_an_expression]);
						}
						num7 = num4 - 1;
						if (num4 == 0 && text[num4] == '-')
						{
							text = "\u0092nu" + text.Substring(1) + "\u0092";
							continue;
						}
						if (text[num7] == TIC[0])
						{
							int num8 = text.Substring(0, num7 - 1).LastIndexOf(TIC);
							if (num8 < 0)
							{
								throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
							}
							text3 = text.Substring(num8, num7 - num8 + 1);
							num5 = num8;
						}
						else if (text[num7] == '\u0092')
						{
							int num9 = FindLastNonQB(text.Substring(0, num7 - 1));
							if (num9 < 0)
							{
								throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
							}
							text3 = text.Substring(num9 + 1, num7 - num9 - 1);
							num5 = num9 + 1;
						}
						else if (text[num7] == '!' || text[num7] == '?')
						{
							int num10 = 1;
							num7--;
							while (text[num7] != '#')
							{
								num10++;
								num7--;
							}
							text3 = text.Substring(num7, num10 + 1);
							num5 = num7;
						}
						else if ((num4 > text.IndexOf("#N/A") && text.IndexOf("#N/A") > -1) || (num4 > text.IndexOf("#N~A") && text.IndexOf("#N~A") > -1))
						{
							int num11 = 4;
							num7 -= 3;
							text3 = text.Substring(num4 - num11, num11);
							num5 = num7;
						}
						else if (text[num7] == RIGHTBRACKET)
						{
							int num12 = 0;
							int num13 = num7 - 1;
							while (num13 > 0 && (text[num13] != 'q' || num12 != 0))
							{
								if (text[num13] == 'q')
								{
									num12--;
								}
								else if (text[num13] == RIGHTBRACKET)
								{
									num12++;
								}
								num13--;
							}
							if (num13 < 0)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_library]);
							}
							text3 = text.Substring(num13, num7 - num13 + 1);
							num5 = num13;
						}
						else if (!char.IsDigit(text[num7]) && text[num7] != '%' && (!text.Contains(":") || (text.Contains(":") && num4 < text.IndexOf(':'))))
						{
							bool flag = false;
							while (num7 >= 0 && (IsUpper(text[num7]) || text[num7] == '_' || text[num7] == '.' || text[num7] == '[' || text[num7] == ']' || text[num7] == '#' || text[num7] == ' ' || text[num7] == '%' || (text[num7] == parseArgumentSeparator && flag) || text[num7] == '\\'))
							{
								if (text[num7] == '[' && text[num7 + 1] == '[')
								{
									flag = false;
								}
								if (text[num7] == ']' && text[num7 + 1] == ']')
								{
									flag = true;
								}
								num7--;
							}
							while (num7 > -1 && (IsUpper(text[num7]) || char.IsDigit(text[num7]) || text[num7] == '_' || text[num7] == '.'))
							{
								num7--;
							}
							text3 = text.Substring(num7 + 1, num4 - num7 - 1);
							num5 = num7 + 1;
							if (NamedRanges.Count > 0 && !string.IsNullOrEmpty(text3.Trim()))
							{
								text3 = CheckForNamedRange(text3);
							}
							if (!findNamedRange)
							{
								if (text3 == TRUEVALUESTR)
								{
									text3 = "n" + TRUEVALUESTR;
								}
								else if (text3 == FALSEVALUESTR)
								{
									text3 = "n" + FALSEVALUESTR;
								}
								else if (NamedRanges.Count > 0 && !IsCellReference(text3) && text3 != string.Empty && (text3.Contains(" ") || !text3.StartsWith(TIC)))
								{
									text3 = ErrorStrings[5].ToString();
								}
								else
								{
									if (RethrowLibraryComputationExceptions)
									{
										libraryComputationException = new Exception(FormulaErrorStrings[invalid_char_in_front_of] + " " + text[num4]);
										throw new ArgumentException(FormulaErrorStrings[invalid_char_in_front_of] + " " + text[num4]);
									}
									if (!text.Substring(0, num5).Replace(LEFTBRACKET.ToString(), string.Empty).Contains("IFERROR") && !text.Substring(0, num5).Replace(LEFTBRACKET.ToString(), string.Empty).Contains("ISERROR"))
									{
										return ErrorStrings[5].ToString();
									}
									text3 = ErrorStrings[5].ToString();
								}
							}
							findNamedRange = false;
						}
						else
						{
							bool flag2 = false;
							bool flag3 = false;
							while (num7 > -1 && (char.IsDigit(text[num7]) || (!flag2 && text[num7] == ParseDecimalSeparator) || (!flag3 && text[num7] == '%') || text[num7] == 'u' || text[num7] == '_'))
							{
								if (text[num7] == ParseDecimalSeparator)
								{
									flag2 = true;
								}
								else if (text[num7] == '%')
								{
									flag3 = true;
								}
								num7--;
							}
							if (num7 > -1 && flag2 && text[num7] == ParseDecimalSeparator)
							{
								throw new ArgumentException(FormulaErrorStrings[number_contains_2_decimal_points]);
							}
							num7++;
							if (num7 == 0 || (num7 > 0 && !IsUpper(text[num7 - 1])))
							{
								text3 = "n" + text.Substring(num7, num4 - num7);
								num5 = num7;
							}
							else
							{
								num7--;
								while (num7 > -1 && (IsUpper(text[num7]) | char.IsDigit(text[num7]) | (text[num7] == '_') | (text[num7] == '\\')))
								{
									num7--;
								}
								if (num7 > -1 && text[num7] == 'u')
								{
									num7--;
								}
								if (num7 > -1 && text[num7] == '!')
								{
									num7--;
									while (num7 > -1 && text[num7] != '!')
									{
										num7--;
									}
									if (num7 > -1 && text[num7] == '!')
									{
										num7--;
									}
									if (num7 > -1 && text[num7] == 'u')
									{
										num7--;
									}
								}
								if (num7 > -1 && text[num7] == ':')
								{
									num7--;
									while (num7 > -1 && char.IsDigit(text[num7]))
									{
										num7--;
									}
									while (num7 > -1 && IsUpper(text[num7]))
									{
										num7--;
									}
									if (num7 > -1 && text[num7] == '!')
									{
										num7--;
										while (num7 > -1 && text[num7] != '!')
										{
											num7--;
										}
										if (num7 > -1 && text[num7] == '!')
										{
											num7--;
										}
										if (num7 > -1 && text[num7] == 'u')
										{
											num7--;
										}
									}
									num7++;
									text3 = text.Substring(num7, num4 - num7);
									string[] cellsFromArgs = GetCellsFromArgs(text3, findCellsFromRange: false);
									if (cellsFromArgs.Length != 0)
									{
										text3 = cellsFromArgs[0];
									}
								}
								else
								{
									num7++;
									text3 = text.Substring(num7, num4 - num7);
								}
								UpdateDependencies(text3);
								num5 = num7;
								if (NamedRanges.Count > 0)
								{
									text3 = CheckForNamedRange(text3);
								}
							}
						}
					}
					else
					{
						num5 = num4;
					}
					if (num4 == text.Length - 1)
					{
						throw new ArgumentException(FormulaErrorStrings[expression_cannot_end_with_an_operator]);
					}
					num7 = num4 + 1;
					bool flag4 = text[num7] == 'u';
					if (flag4)
					{
						num7++;
					}
					if (text[num7] == TIC[0])
					{
						string text4 = TIC + TIC;
						int num14 = text.Substring(num7 + 1).IndexOf(TIC);
						if (num14 < 0)
						{
							throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
						}
						empty = text.Substring(num7, num14 + 2);
						if (empty == text4 && isBracesReplaced)
						{
							num14 = text.Substring(num7 + 1).IndexOf(text4);
							empty = text.Substring(num7, num14 + 3);
							num6 = num14 + num7 + 3;
						}
						else
						{
							num6 = num14 + num7 + 2;
						}
					}
					else if (text[num7] == '\u0092')
					{
						int num15 = FindNonQB(text.Substring(num7 + 1));
						if (num15 < 0)
						{
							throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
						}
						empty = text.Substring(num7 + 1, num15);
						if (flag4)
						{
							empty += "nu1m";
						}
						num6 = num15 + num7 + 2;
					}
					else if (text[num7] == '#')
					{
						int num16 = 0;
						foreach (string errorString in ErrorStrings)
						{
							string text5 = errorString.Replace('/', '~');
							if (text.IndexOf(text5) > -1)
							{
								num16 += text5.Length;
								num7 += text5.Length - 1;
								break;
							}
						}
						empty = text.Substring(num4 + 1, num16);
						num6 = num7 + 1;
					}
					else if (text[num7] == 'q')
					{
						int num17 = 0;
						int j;
						for (j = num7 + 1; j < text.Length && (text[j] != RIGHTBRACKET || num17 != 0); j++)
						{
							if (text[j] == RIGHTBRACKET)
							{
								num17++;
							}
							else if (text[j] == 'q')
							{
								num17--;
							}
						}
						if (j == text.Length)
						{
							throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
						}
						empty = text.Substring(num7, j - num7 + 1);
						if (flag4)
						{
							empty = "u" + empty;
						}
						num6 = j + 1;
					}
					else if (char.IsDigit(text[num7]) || text[num7] == ParseDecimalSeparator)
					{
						bool flag5 = text[num7] == ParseDecimalSeparator;
						for (num7++; num7 < text.Length && (char.IsDigit(text[num7]) || (!flag5 && text[num7] == ParseDecimalSeparator)); num7++)
						{
							if (text[num7] == ParseDecimalSeparator)
							{
								flag5 = true;
							}
						}
						if (num7 < text.Length && text[num7] == '%')
						{
							num7++;
						}
						if (flag5 && num7 < text.Length && text[num7] == ParseDecimalSeparator)
						{
							throw new ArgumentException(FormulaErrorStrings[number_contains_2_decimal_points]);
						}
						empty = "n" + text.Substring(num4 + 1, num7 - num4 - 1);
						num6 = num7;
					}
					else if (IsUpper(text[num7]) || text[num7] == '!' || text[num7] == 'u')
					{
						if (text[num7] == '!')
						{
							for (num7++; num7 < text.Length && text[num7] != '!'; num7++)
							{
							}
						}
						num7++;
						int num18 = 0;
						bool flag6 = false;
						while (num7 < text.Length && (IsUpper(text[num7]) || text[num7] == '_' || text[num7] == '.' || text[num7] == '[' || text[num7] == ']' || text[num7] == '#' || text[num7] == ' ' || text[num7] == '%' || (text[num7] == parseArgumentSeparator && flag6) || text[num7] == '\\'))
						{
							if (num7 != text.Length - 1 && text[num7] == '[' && text[num7 + 1] == '[')
							{
								flag6 = true;
							}
							if (num7 != text.Length - 1 && text[num7] == ']' && text[num7 + 1] == ']')
							{
								flag6 = false;
							}
							num7++;
							num18++;
						}
						if (num7 == text.Length)
						{
							_ = 1;
						}
						else
							_ = !char.IsDigit(text[num7]);
						if (num18 > 1)
						{
							for (; num7 < text.Length && (IsUpper(text[num7]) || char.IsDigit(text[num7]) || char.IsWhiteSpace(text[num7]) || text[num7] == '_' || text[num7] == '.' || text[num7] == '\\'); num7++)
							{
							}
						}
						for (; num7 < text.Length && (IsUpper(text[num7]) | char.IsDigit(text[num7]) | (text[num7] == '_') | (text[num7] == '.')); num7++)
						{
						}
						if (num7 < text.Length && text[num7] == ':')
						{
							num7++;
							if (num7 < text.Length && text[num7] == '!')
							{
								for (num7++; num7 < text.Length && text[num7] != '!'; num7++)
								{
								}
								if (num7 < text.Length && text[num7] == '!')
								{
									num7++;
								}
							}
							for (; num7 < text.Length && IsUpper(text[num7]); num7++)
							{
							}
							for (; num7 < text.Length && char.IsDigit(text[num7]); num7++)
							{
							}
							num7--;
							empty = text.Substring(num4 + 1, num7 - num4);
							string[] cellsFromArgs2 = GetCellsFromArgs(empty, findCellsFromRange: false);
							if (cellsFromArgs2.Length != 0)
							{
								empty = cellsFromArgs2[0];
							}
						}
						else
						{
							num7--;
							empty = text.Substring(num4 + 1, num7 - num4);
							if (text[num7] == 'u')
							{
								empty = "u" + empty;
							}
						}
						if (IsCellReference(empty))
						{
							UpdateDependencies(empty);
						}
						else
						{
							if (NamedRanges.Count > 0 && !string.IsNullOrEmpty(empty.Trim()))
							{
								empty = CheckForNamedRange(empty);
							}
							if (!findNamedRange)
							{
								if (empty == TRUEVALUESTR)
								{
									empty = "n" + TRUEVALUESTR;
								}
								else if (empty == FALSEVALUESTR)
								{
									empty = "n" + FALSEVALUESTR;
								}
								else if (!ExcelLikeComputations && empty.ToUpper().Equals(double.NaN.ToString().ToUpper()))
								{
									empty = "n" + empty;
								}
								else if (NamedRanges.Count > 0 && !IsCellReference(empty) && empty != string.Empty && (empty.Contains(" ") || !empty.StartsWith(TIC)))
								{
									empty = ErrorStrings[5].ToString();
								}
								else
								{
									if (RethrowLibraryComputationExceptions)
									{
										libraryComputationException = new Exception(FormulaErrorStrings[invalid_characters_following_an_operator]);
										throw new ArgumentException(FormulaErrorStrings[invalid_characters_following_an_operator]);
									}
									if (!text.Substring(0, num5).Replace(LEFTBRACKET.ToString(), string.Empty).Contains("IFERROR") && !text.Substring(0, num5).Replace(LEFTBRACKET.ToString(), string.Empty).Contains("ISERROR"))
									{
										return ErrorStrings[5].ToString();
									}
									empty = ErrorStrings[5].ToString();
								}
							}
							findNamedRange = false;
						}
						num6 = num7 + 1;
					}
					else
					{
						if (ExcelLikeComputations || !text[num7].ToString().Equals(double.PositiveInfinity.ToString()))
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_characters_following_an_operator]);
						}
						empty = "n" + double.PositiveInfinity;
						num6 = num7 + 1;
					}
					int num19 = text2.IndexOf(text[num4]);
					string text6 = "\u0092" + ZapBlocks(text3) + ZapBlocks(empty) + markers[num19] + "\u0092";
					if (num5 > 0)
					{
						text6 = text.Substring(0, num5) + text6;
					}
					if (num6 < text.Length)
					{
						text6 += text.Substring(num6);
					}
					text6 = text6.Replace(BMARKER2, '\u0092'.ToString());
					text = text6;
				}
			}
			else
			{
				int num20 = text.Length - 1;
				if (text[num20] == '\u0092')
				{
					if (FindLastNonQB(text.Substring(0, num20 - 1)) < 0)
					{
						throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
					}
				}
				else if (text[num20] == RIGHTBRACKET)
				{
					int num21 = 0;
					int num22 = num20 - 1;
					while (num22 > 0 && (text[num22] != 'q' || num21 != 0))
					{
						if (text[num22] == 'q')
						{
							num21--;
						}
						else if (text[num22] == RIGHTBRACKET)
						{
							num21++;
						}
						num22--;
					}
					if (num22 < 0)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_library]);
					}
				}
				else if (char.IsDigit(text[num20]))
				{
					bool flag7 = false;
					bool flag8 = false;
					while (num20 > -1 && (char.IsDigit(text[num20]) || (!flag7 && text[num20] == ParseDecimalSeparator) || (!flag8 && text[num20] == '%')))
					{
						if (text[num20] == ParseDecimalSeparator)
						{
							flag7 = true;
						}
						else if (text[num20] == '%')
						{
							flag8 = true;
						}
						num20--;
					}
					if (num20 > -1 && flag7 && text[num20] == ParseDecimalSeparator)
					{
						throw new ArgumentException(FormulaErrorStrings[number_contains_2_decimal_points]);
					}
				}
				if (text.Length > 0 && (char.IsUpper(text, 0) || text[0] == '!'))
				{
					bool flag9 = true;
					bool flag10 = true;
					bool flag11 = false;
					for (int k = 0; k < text.Length; k++)
					{
						if (text[k] == '!')
						{
							if (k > 0 && !flag11)
							{
								if (rethrowExceptions)
								{
									throw new ArgumentException(FormulaErrorStrings[missing_sheet]);
								}
								return ErrorStrings[2].ToString();
							}
							flag11 = true;
							for (k++; k < text.Length && char.IsDigit(text[k]); k++)
							{
							}
							if (k == text.Length || text[k] != '!')
							{
								flag9 = false;
								break;
							}
						}
						else
						{
							if (!flag10 && char.IsLetter(text, k))
							{
								flag9 = false;
								break;
							}
							if (!char.IsLetterOrDigit(text, k) && text[k] != '!')
							{
								flag9 = false;
								break;
							}
							flag10 = char.IsUpper(text, k);
						}
					}
					if (flag9)
					{
						UpdateDependencies(text);
						needToContinue = false;
					}
				}
			}
			return text;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				libraryComputationException = ex;
				throw ex;
			}
			return ex.Message;
		}
	}

	public void PutTokensForSheets(ref string text)
	{
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		if (SupportsSheetRanges)
		{
			HandleSheetRanges(ref text, sheetFamilyItem);
		}
		if (SortedSheetNames != null)
		{
			foreach (string sortedSheetName in SortedSheetNames)
			{
				string text3 = (string)sheetFamilyItem.SheetNameToToken[sortedSheetName];
				if (text3 != null)
				{
					text3 = text3.Replace('!', tempSheetPlaceHolder);
					string text4 = "'" + sortedSheetName.ToUpper() + "'!";
					if (text.IndexOf(text4) == -1)
					{
						text4 = "!" + sortedSheetName.ToUpper() + "!";
					}
					text = text.Replace(text4, text3);
					text4 = sortedSheetName.ToUpper() + "!";
					text = text.Replace(text4, text3);
				}
			}
		}
		text = text.Replace(tempSheetPlaceHolder, '!');
	}

	private void HandleSheetRanges(ref string text, GridSheetFamilyItem family)
	{
		int num = text.IndexOf('!');
		int num2 = 0;
		char[] anyOf = "%!@#$%^&*()?/>.<,:;'\\|}]{[_~`+=-\"".ToCharArray();
		while (num > 0)
		{
			int num3 = text.Substring(num2, num).LastIndexOf(':');
			if (num3 > -1)
			{
				string text2 = text.Substring(num2 + num3 + 1, num - num3 - 1).ToUpper().Replace("'", string.Empty);
				if (family.SheetNameToToken.ContainsKey(text2.Trim()))
				{
					int num4 = num2 + num3 - 1;
					if (SortedSheetNames.Contains(text2) && text2.IndexOfAny(anyOf) != -1)
					{
						num4 = num4 - text2.Length - 1;
					}
					else
					{
						while (num4 > 0 && markers.IndexOf(text[num4]) == -1)
						{
							num4--;
						}
					}
					string text3 = text.Substring(num4 + 1, num3 - num4 + num2 - 1).ToUpper().Replace("'", string.Empty);
					if (family.SheetNameToToken.ContainsKey(text3.Trim()))
					{
						int i = num + num2 + 1;
						if (SortedSheetNames.Contains(text3.Trim()) && text3.IndexOfAny(anyOf) != -1)
						{
							i = text.Length - 1;
						}
						else
						{
							for (; i < text.Length && markers.IndexOf(text[i]) == -1; i++)
							{
							}
						}
						string text4 = text.Substring(num2 + num + 1, i - num2 - num - 1);
						string text5 = family.SheetNameToToken[text3.Trim()].ToString();
						string text6 = family.SheetNameToToken[text2.Trim()].ToString();
						if (text6.CompareTo(text5) == -1)
						{
							string text7 = text5;
							text5 = text6;
							text6 = text7;
						}
						string text8 = string.Empty;
						foreach (string sortedSheetName in SortedSheetNames)
						{
							int num5 = int.Parse(family.SheetNameToToken[sortedSheetName].ToString().Replace("!", string.Empty));
							int value = int.Parse(text5.Replace("!", string.Empty));
							int value2 = int.Parse(text6.Replace("!", string.Empty));
							if (num5.CompareTo(value) >= 0 && num5.CompareTo(value2) <= 0)
							{
								if (text8.Length > 0)
								{
									text8 += ParseArgumentSeparator;
								}
								text8 = text8 + sortedSheetName + "\u0083" + text4;
							}
						}
						text = text.Substring(0, num4 + 1) + text8 + text.Substring(i);
						num2 = text.Length - i;
					}
					else
					{
						num2 = num + num2;
					}
				}
				else
				{
					num2 = num + num2;
				}
			}
			else
			{
				num2 = num + num2;
			}
			num = text.Substring(num2 + 1).IndexOf('!') + 1;
		}
		text = text.Replace('\u0083', '!');
	}

	private bool NotInBlock(string text, int position)
	{
		int num = text.IndexOf('\u0092');
		bool flag = false;
		while (num > -1 && num < position)
		{
			flag = !flag;
			num = text.IndexOf('\u0092', num + 1);
		}
		return !flag;
	}

	private void MarkLibraryFormulas(ref string formula)
	{
		int num = formula.IndexOf(')');
		if (num == -1)
		{
			MarkNamedRanges(ref formula);
		}
		else
		{
			while (num > -1)
			{
				int num2 = 0;
				int num3 = num - 1;
				while (num3 > -1 && (formula[num3] != '(' || num2 != 0))
				{
					if (formula[num3] == ')')
					{
						num2++;
					}
					else if (formula[num3] == ')')
					{
						num2--;
					}
					num3--;
				}
				if (num3 == -1)
				{
					throw new ArgumentException(FormulaErrorStrings[mismatched_parentheses]);
				}
				int num4 = num3 - 1;
				while (num4 > -1 && (char.IsLetterOrDigit(formula[num4]) || validFunctionNameChars.IndexOf(formula[num4]) > -1 || formula[num4].Equals(parseDecimalSeparator)))
				{
					num4--;
				}
				int num5 = num3 - num4 - 1;
				if (num5 > 0 && libraryFunctions.ContainsKey(formula.Substring(num4 + 1, num5)))
				{
					if (formula.Substring(num4 + 1, num5) == "AREAS")
					{
						ignoreBracet = true;
					}
					else
					{
						ignoreBracet = false;
					}
					if (formula.Substring(num4 + 1, num5) == "IFERROR" || formula.Substring(num4 + 1, num5) == "ISERROR")
					{
						errorFormula = true;
					}
					string argList = formula.Substring(num3, num - num3 + 1);
					if (argList.Contains("({") && argList.Contains("})"))
					{
						string text = string.Empty;
						string text2 = string.Empty;
						for (int i = 0; i < argList.Length; i++)
						{
							string text3 = string.Empty;
							if (argList[i].Equals('{'))
							{
								text3 += argList[i++];
								while (argList[i] != '}')
								{
									text2 += argList[i++];
								}
							}
							if (text2.IndexOf("[") > -1 && text2.IndexOf("]") == -1)
							{
								text2 += argList[i++];
								while (argList[i] != '}')
								{
									if (argList[i] == ']')
									{
										text2 = CheckForNamedRange(text2.Replace("{", "(").Replace("}", ")") + argList[i++]);
									}
									text2 += argList[i++];
								}
							}
							text3 += text2;
							text3 += argList[i];
							if (NamedRanges.Count > 0 && !string.IsNullOrEmpty(text2.Trim()))
							{
								CheckForNamedRange(text2.ToUpper());
								if (findNamedRange)
								{
									text3 = text3.Replace("{", string.Empty).Replace("}", string.Empty);
								}
								findNamedRange = false;
							}
							text2 = string.Empty;
							text += text3;
						}
						argList = text;
					}
					MarkNamedRanges(ref argList);
					formula = formula.Substring(0, num4 + 1) + "q" + formula.Substring(num4 + 1, num5) + argList.Replace('(', LEFTBRACKET).Replace(')', RIGHTBRACKET) + formula.Substring(num + 1);
				}
				else if (num5 > 0)
				{
					if (this.UnknownFunction != null)
					{
						GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
						ICalcData obj = grid;
						string text4 = SheetToken(cell);
						string text5 = cell;
						if (text4.Length > 0)
						{
							obj = sheetFamilyItem.TokenToParentObject[text4] as ICalcData;
							text5 = text5.Substring(text5.LastIndexOf('!') + 1);
						}
						foreach (string key in sheetFamilyItem.SheetNameToParentObject.Keys)
						{
							if (sheetFamilyItem.SheetNameToParentObject[key].Equals(obj))
							{
								text5 = key + "!" + text5;
								break;
							}
						}
						UnknownFunctionEventArgs unknownFunctionEventArgs = new UnknownFunctionEventArgs();
						unknownFunctionEventArgs.MissingFunctionName = formula.Substring(num4 + 1, num5);
						unknownFunctionEventArgs.CellLocation = text5;
						this.UnknownFunction(this, unknownFunctionEventArgs);
						if (formula.Substring(num4 + 1, num5) == "AREAS")
						{
							ignoreBracet = true;
						}
						else
						{
							ignoreBracet = false;
						}
					}
					if ((!formula.Contains("IFERROR") || !formula.Substring(0, formula.IndexOf(formula.Substring(num4 + 1, num5)) - 1).EndsWith("IFERROR")) && (!formula.Contains("ISERROR") || !formula.Substring(0, formula.IndexOf(formula.Substring(num4 + 1, num5)) - 1).EndsWith("ISERROR")))
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					formula = formula.Replace(formula.Substring(num4 + 1, num5), ErrorStrings[5].ToString());
					MarkLibraryFormulas(ref formula);
				}
				else
				{
					string text7 = string.Empty;
					if (num3 > 0)
					{
						text7 = formula.Substring(0, num3);
					}
					text7 = text7 + "{" + formula.Substring(num3 + 1, num - num3 - 1) + "}";
					if (num < formula.Length)
					{
						text7 += formula.Substring(num + 1);
					}
					if (!text7.Contains("((") && !text7.Contains("))"))
					{
						MarkNamedRanges(ref text7);
					}
					formula = text7;
				}
				num = formula.IndexOf(')');
			}
		}
		formula = formula.Replace('{', '(').Replace('}', ')');
	}

	internal Dictionary<object, object> SaveStrings(ref string text)
	{
		Dictionary<object, object> dictionary = null;
		string oldValue = TIC + TIC;
		int num = 0;
		int num2 = -1;
		if ((num2 = text.IndexOf(TIC)) > -1)
		{
			while (num2 > -1 && num2 < text.Length)
			{
				if (dictionary == null)
				{
					dictionary = new Dictionary<object, object>();
				}
				int num3 = ((num2 + 1 < text.Length) ? text.IndexOf(TIC, num2 + 1) : (-1));
				if (num3 > -1)
				{
					string text2 = TIC + UNIQUESTRINGMARKER + num + TIC;
					while (text.Contains(text2))
					{
						num++;
						text2 = TIC + UNIQUESTRINGMARKER + num + TIC;
					}
					if (num3 < text.Length - 2 && text[num3 + 1] == TIC[0])
					{
						num3 = text.IndexOf(TIC, num3 + 2);
						if (num3 == -1)
						{
							throw new ArgumentException(FormulaErrorStrings[mismatched_tics]);
						}
					}
					string text3 = text.Substring(num2, num3 - num2 + 1);
					dictionary.Add(text2, text3);
					text3 = text3.Replace(oldValue, TIC);
					num++;
					text = text.Substring(0, num2) + text2 + text.Substring(num3 + 1);
					num2 += text2.Length;
					if (num2 < text.Length)
					{
						num2 = text.IndexOf(TIC, num2);
					}
					continue;
				}
				if (num3 == -1 && text.IndexOf('!') > -1 && num2 < text.IndexOf('!', num2))
				{
					string text4 = string.Empty;
					int num4 = text.IndexOf('!', num2) - 1;
					while (num4 > -1 && !ValidPrecedingChars.Contains(text[num4].ToString()))
					{
						text4 = text[num4] + text4;
						num4--;
					}
					if (!text4.StartsWith("'") || !text4.EndsWith("'"))
					{
						throw new ArgumentException(FormulaErrorStrings[mismatched_tics]);
					}
					if (text4.StartsWith("'"))
					{
						text4 = text4.Remove(0, 1);
					}
					if (text4.EndsWith("'"))
					{
						text4 = text4.Remove(text4.Length - 1, 1);
					}
					if (!SortedSheetNames.Contains(text4.ToUpper()))
					{
						throw new ArgumentException(FormulaErrorStrings[missing_sheet]);
					}
					if (num2 + 1 < text.Length)
					{
						num2 = text.IndexOf(TIC, num2 + 1);
					}
					continue;
				}
				throw new ArgumentException(FormulaErrorStrings[mismatched_tics]);
			}
		}
		return dictionary;
	}

	internal void SetStrings(ref string retValue, Dictionary<object, object> strings)
	{
		foreach (string key in strings.Keys)
		{
			retValue = retValue.Replace(key, (string)strings[key]);
		}
	}

	private int FindLastNonQB(string text)
	{
		int result = -1;
		if (text.IndexOf('\u0092') > -1)
		{
			int num = 0;
			for (int num2 = text.Length - 1; num2 >= 0; num2--)
			{
				if (text[num2] == RIGHTBRACKET)
				{
					num--;
				}
				else if (text[num2] == LEFTBRACKET)
				{
					num++;
				}
				else if (text[num2] == '\u0092' && num == 0)
				{
					result = num2;
					break;
				}
			}
		}
		return result;
	}

	private string GetCellFrom(string range)
	{
		string text = string.Empty;
		string[] cellsFromArgs = GetCellsFromArgs(range);
		if (cellsFromArgs.Length == 1)
		{
			return cellsFromArgs[0];
		}
		int num = cellsFromArgs.Length - 1;
		int num2 = RowIndex(cellsFromArgs[0]);
		int col;
		if (num2 == RowIndex(cellsFromArgs[num]))
		{
			int num3 = ColIndex(cellsFromArgs[0]);
			int num4 = ColIndex(cellsFromArgs[num]);
			int num5 = ColIndex(cell);
			if (num5 >= num3 && num5 <= num4)
			{
				text = $"{RangeInfo.GetAlphaLabel(num5)}{num2}";
			}
		}
		else if ((col = ColIndex(cellsFromArgs[0])) == ColIndex(cellsFromArgs[num]))
		{
			int num6 = 0;
			int num7 = RowIndex(cellsFromArgs[num]);
			if (cell != string.Empty)
			{
				num6 = RowIndex(cell);
			}
			if (num6 >= num2 && num6 <= num7)
			{
				return $"{RangeInfo.GetAlphaLabel(col)}{num6}";
			}
			return ErrorStrings[1].ToString();
		}
		if (text.Equals(string.Empty) && IsRange(range))
		{
			text = $"{RangeInfo.GetAlphaLabel(ColIndex(cellsFromArgs[0]))}{num2}";
		}
		return text;
	}

	private int FindNonQB(string text)
	{
		int result = -1;
		if (text.IndexOf('\u0092') > -1)
		{
			int num = 0;
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] == RIGHTBRACKET)
				{
					num--;
				}
				else if (text[i] == LEFTBRACKET)
				{
					num++;
				}
				else if (text[i] == '\u0092' && num == 0)
				{
					result = i;
					break;
				}
			}
		}
		return result;
	}

	private string ZapBlocks(string text)
	{
		if (text.IndexOf('\u0092') > -1)
		{
			int num = 0;
			for (int num2 = text.Length - 1; num2 > 0; num2--)
			{
				if (text[num2] == RIGHTBRACKET)
				{
					num--;
				}
				else if (text[num2] == LEFTBRACKET)
				{
					num++;
				}
				else if (text[num2] == '\u0092' && num == 0)
				{
					text.Remove(num2, 1);
				}
			}
		}
		return text;
	}

	public bool AddFunction(string name, LibraryFunction func)
	{
		name = name.ToUpper(CultureInfo.InvariantCulture);
		if (!LibraryFunctions.ContainsKey(name))
		{
			LibraryFunctions.Add(name, func);
			return true;
		}
		return false;
	}

	public bool RemoveFunction(string name)
	{
		if (LibraryFunctions[name] != null)
		{
			LibraryFunctions.Remove(name);
			return true;
		}
		return false;
	}

	public virtual void InitLibraryFunctions()
	{
		libraryFunctions = new Dictionary<object, object>();
		AddFunction("Sum", ComputeSum);
		AddFunction("Avg", ComputeAvg);
		AddFunction("Max", ComputeMax);
		AddFunction("Min", ComputeMin);
		AddFunction("Pi", ComputePI);
		AddFunction("Sign", ComputeSign);
		AddFunction("Pow", ComputePow);
		AddFunction("Power", ComputePow);
		AddFunction("And", ComputeAnd);
		AddFunction("Or", ComputeOr);
		AddFunction("Xor", ComputeXor);
		AddFunction("If", ComputeIf);
		AddFunction("Not", ComputeNot);
		AddFunction("False", ComputeFalse);
		AddFunction("TRUE", ComputeTrue);
		AddFunction("IfNA", ComputeIfNA);
		AddFunction("HLookUp", ComputeHLookUp);
		AddFunction("VLookUp", ComputeVLookUp);
		AddFunction("LookUp", ComputeLookUp);
		AddFunction("Left", ComputeLeft);
		AddFunction("Right", ComputeRight);
		AddFunction("Len", ComputeLen);
		AddFunction("Mid", ComputeMid);
		AddFunction("Product", ComputeProduct);
		AddFunction("Value", ComputeValue);
		AddFunction("Mod", ComputeMod);
		AddFunction("Trunc", ComputeTrunc);
		AddFunction("SumProduct", ComputeSumProduct);
		AddFunction("Average", ComputeAvg);
		AddFunction("Int", ComputeInt);
		AddFunction("OffSet", ComputeOffSet);
		AddFunction("Index", ComputeIndex);
		AddFunction("Match", ComputeMatch);
		AddFunction("Exact", ComputeExact);
		AddFunction("Find", ComputeFind);
		AddFunction("Column", ComputeColumn);
		AddFunction("Choose", ComputeChoose);
		AddFunction("Clean", ComputeClean);
		AddFunction("XLookUp", ComputeXLookUp);
		AddFunction("XMatch", ComputeXMatch);
		AddFunction("Dollar", ComputeDollar);
		AddFunction("DollarDe", ComputeDollarDe);
		AddFunction("DollarFr", ComputeDollarFr);
		AddFunction("Duration", ComputeDuration);
		AddFunction("Fvschedule", ComputeFvschedule);
		AddFunction("Disc", ComputeDisc);
		AddFunction("INTRATE", ComputeIntrate);
		AddFunction("CUMIPMT", ComputeCUMIPMT);
		AddFunction("CUMPRINC", ComputeCUMPRINC);
		AddFunction("Fixed", ComputeFixed);
		AddFunction("Lower", ComputeLower);
		AddFunction("Upper", ComputeUpper);
		AddFunction("Trim", ComputeTrim);
		AddFunction("Text", ComputeText);
		AddFunction("Concatenate", ComputeConcatenate);
		AddFunction("Indirect", ComputeIndirect);
		AddFunction("Substitute", ComputeSubstitute);
		AddFunction("Char", ComputeChar);
		AddFunction("IsError", ComputeIsError);
		AddFunction("IsNumber", ComputeIsNumber);
		AddFunction("IsLogical", ComputeIsLogical);
		AddFunction("IsNA", ComputeIsNA);
		AddFunction("IsErr", ComputeIsErr);
		AddFunction("IsBlank", ComputeIsBlank);
		AddFunction("IsText", ComputeIsText);
		AddFunction("IsNonText", ComputeIsNonText);
		AddFunction("IsEven", ComputeIsEven);
		AddFunction("IsOdd", ComputeIsOdd);
		AddFunction("IsRef", ComputeIsRef);
		AddFunction("N", ComputeN);
		AddFunction("NA", ComputeNA);
		AddFunction("ERROR.TYPE", ComputeErrorType);
		AddFunction("IfError", ComputeIfError);
		AddFunction("T", ComputeT);
		AddFunction("Acos", ComputeAcos);
		AddFunction("Asin", ComputeAsin);
		AddFunction("Atan", ComputeAtan);
		AddFunction("Cos", ComputeCos);
		AddFunction("Sin", ComputeSin);
		AddFunction("Cosh", ComputeCosh);
		AddFunction("Sinh", ComputeSinh);
		AddFunction("Tanh", ComputeTanh);
		AddFunction("Round", ComputeRound);
		AddFunction("Ceiling", ComputeCeiling);
		AddFunction("Floor", ComputeFloor);
		AddFunction("Log", ComputeLog);
		AddFunction("Log10", ComputeLog10);
		AddFunction("Exp", ComputeExp);
		AddFunction("Sqrt", ComputeSqrt);
		AddFunction("Abs", ComputeAbs);
		AddFunction("Tan", ComputeTan);
		AddFunction("SUBTOTAL", ComputeSubTotal);
		AddFunction("Floor.Math", ComputeFloorMath);
		AddFunction("Floor.Precise", ComputeFloorPrecise);
		AddFunction("Ceiling.Precise", ComputeCeilingPrecise);
		AddFunction("Iso.Ceiling", ComputeIsoCeiling);
		AddFunction("Db", ComputeDb);
		AddFunction("Ddb", ComputeDdb);
		AddFunction("Fv", ComputeFv);
		AddFunction("Ipmt", ComputeIpmt);
		AddFunction("Irr", ComputeIrr);
		AddFunction("Xirr", ComputeXirr);
		AddFunction("Ispmt", ComputeIspmt);
		AddFunction("Mirr", ComputeMirr);
		AddFunction("Nper", ComputeNper);
		AddFunction("Npv", ComputeNpv);
		AddFunction("Pmt", ComputePmt);
		AddFunction("Ppmt", ComputePpmt);
		AddFunction("Pv", ComputePv);
		AddFunction("Rate", ComputeRate);
		AddFunction("Sln", ComputeSln);
		AddFunction("Syd", ComputeSyd);
		AddFunction("Vdb", ComputeVdb);
		AddFunction("ACCRINT", ComputeACCRINT);
		AddFunction("ACCRINTM", ComputeACCRINTM);
		AddFunction("EFFECT", ComputeEffect);
		AddFunction("Rand", ComputeRand);
		AddFunction("Acosh", ComputeAcosh);
		AddFunction("Asinh", ComputeAsinh);
		AddFunction("Atanh", ComputeAtanh);
		AddFunction("Atan2", ComputeAtan2);
		AddFunction("Combin", ComputeCombin);
		AddFunction("Degrees", ComputeDegrees);
		AddFunction("Even", ComputeEven);
		AddFunction("Fact", ComputeFact);
		AddFunction("Ln", ComputeLn);
		AddFunction("Odd", ComputeOdd);
		AddFunction("Radians", ComputeRadians);
		AddFunction("Round", ComputeRound);
		AddFunction("Rounddown", ComputeRounddown);
		AddFunction("Roundup", ComputeRoundup);
		AddFunction("Sumif", ComputeSumif);
		AddFunction("Sumsq", ComputeSumsq);
		AddFunction("Sumx2my2", ComputeSumx2my2);
		AddFunction("Sumx2py2", ComputeSumx2py2);
		AddFunction("Sumxmy2", ComputeSumxmy2);
		AddFunction("Date", ComputeDate);
		AddFunction("Datevalue", ComputeDatevalue);
		AddFunction("Day", ComputeDay);
		AddFunction("Days360", ComputeDays360);
		AddFunction("Hour", ComputeHour);
		AddFunction("Minute", ComputeMinute);
		AddFunction("Second", ComputeSecond);
		AddFunction("Month", ComputeMonth);
		AddFunction("Now", ComputeNow);
		AddFunction("Time", ComputeTime);
		AddFunction("Timevalue", ComputeTimevalue);
		AddFunction("Today", ComputeToday);
		AddFunction("Weekday", ComputeWeekday);
		AddFunction("Year", ComputeYear);
		AddFunction("Multinomial", ComputeMultinomial);
		AddFunction("Mround", ComputeMround);
		AddFunction("Randbetween", ComputeRandbetween);
		AddFunction("Sqrtpi", ComputeSqrtpi);
		AddFunction("Quotient", ComputeQuotient);
		AddFunction("Factdouble", ComputeFactdouble);
		AddFunction("Gcd", ComputeGcd);
		AddFunction("Lcm", ComputeLcm);
		AddFunction("Roman", ComputeRoman);
		AddFunction("Search", ComputeSearch);
		AddFunction("Avedev", ComputeAvedev);
		AddFunction("Averagea", ComputeAveragea);
		AddFunction("Gammaln", ComputeGammaln);
		AddFunction("Gammadist", ComputeGammadist);
		AddFunction("Gammainv", ComputeGammainv);
		AddFunction("Geomean", ComputeGeomean);
		AddFunction("Harmean", ComputeHarmean);
		AddFunction("Hypgeomdist", ComputeHypgeomdist);
		AddFunction("Intercept", ComputeIntercept);
		AddFunction("Binomdist", ComputeBinomdist);
		AddFunction("Chidist", ComputeChidist);
		AddFunction("Chiinv", ComputeChiinv);
		AddFunction("Chitest", ComputeChitest);
		AddFunction("Normdist", ComputeNormdist);
		AddFunction("Norminv", ComputeNorminv);
		AddFunction("NormsDist", ComputeNormsDist);
		AddFunction("NormsInv", ComputeNormsInv);
		AddFunction("Confidence", ComputeConfidence);
		AddFunction("Correl", ComputeCorrel);
		AddFunction("Count", ComputeCount);
		AddFunction("Counta", ComputeCounta);
		AddFunction("Countblank", ComputeCountblank);
		AddFunction("Countif", ComputeCountif);
		AddFunction("Covar", ComputeCovar);
		AddFunction("CritBinom", ComputeCritbinom);
		AddFunction("Devsq", ComputeDevsq);
		AddFunction("Expondist", ComputeExpondist);
		AddFunction("Fdist", ComputeFdist);
		AddFunction("Finv", ComputeFinv);
		AddFunction("Fisher", ComputeFisher);
		AddFunction("Fisherinv", ComputeFisherinv);
		AddFunction("Forecast", ComputeForecast);
		AddFunction("Growth", ComputeGrowth);
		AddFunction("Kurt", ComputeKurt);
		AddFunction("Large", ComputeLarge);
		AddFunction("Logest", ComputeLogest);
		AddFunction("Logestb", ComputeLogestb);
		AddFunction("Lognormdist", ComputeLognormdist);
		AddFunction("Loginv", ComputeLoginv);
		AddFunction("Maxa", ComputeMaxa);
		AddFunction("Median", ComputeMedian);
		AddFunction("Mina", ComputeMina);
		AddFunction("Mode", ComputeMode);
		AddFunction("Negbinomdist", ComputeNegbinomdist);
		AddFunction("Pearson", ComputePearson);
		AddFunction("Percentile", ComputePercentile);
		AddFunction("Percentrank", ComputePercentrank);
		AddFunction("Permut", ComputePermut);
		AddFunction("Poisson", ComputePoisson);
		AddFunction("Prob", ComputeProb);
		AddFunction("Quartile", ComputeQuartile);
		AddFunction("Rank", ComputeRank);
		AddFunction("Rsq", ComputeRsq);
		AddFunction("Skew", ComputeSkew);
		AddFunction("Slope", ComputeSlope);
		AddFunction("Small", ComputeSmall);
		AddFunction("Standardize", ComputeStandardize);
		AddFunction("Stdev", ComputeStdev);
		AddFunction("Stdeva", ComputeStdeva);
		AddFunction("Stdevp", ComputeStdevp);
		AddFunction("Stdevpa", ComputeStdevpa);
		AddFunction("Steyx", ComputeSteyx);
		AddFunction("Linest", ComputeLinest);
		AddFunction("Trimmean", ComputeTrimmean);
		AddFunction("Var", ComputeVar);
		AddFunction("Vara", ComputeVara);
		AddFunction("Varp", ComputeVarp);
		AddFunction("Varpa", ComputeVarpa);
		AddFunction("Weibull", ComputeWeibull);
		AddFunction("Ztest", ComputeZtest);
		AddFunction("Address", ComputeAddress);
		AddFunction("AverageIF", ComputeAverageIF);
		AddFunction("AverageIFS", ComputeAverageIFS);
		AddFunction("SumIFS", ComputeSumIFS);
		AddFunction("NetworkDays", ComputeNetworkDays);
		AddFunction("Sec", ComputeSecant);
		AddFunction("SecH", ComputeSecanth);
		AddFunction("Cot", ComputeCot);
		AddFunction("CotH", ComputeCoth);
		AddFunction("Csc", ComputeCsc);
		AddFunction("CscH", ComputeCsch);
		AddFunction("ACot", ComputeAcot);
		AddFunction("ACotH", ComputeAcoth);
		AddFunction("AsecH", ComputeAsech);
		AddFunction("AcscH", ComputeAcsch);
		AddFunction("BigMul", ComputeBigMul);
		AddFunction("DivRem", ComputeDivRem);
		AddFunction("IEEERemainder", ComputeIEEERemainder);
		AddFunction("Truncate", ComputeTruncate);
		AddFunction("Combina", ComputeCombinA);
		AddFunction("Confidence.T", ComputeConfidenceT);
		AddFunction("Skew.P", ComputeSkewP);
		AddFunction("Covariance.P", ComputeCovarianceP);
		AddFunction("Covariance.S", ComputeCovarianceS);
		AddFunction("Percentile.Exc", ComputePercentileExc);
		AddFunction("Percentile.Inc", ComputePercentileInc);
		AddFunction("PercentRank.Exc", ComputePercentrankExc);
		AddFunction("PercentRank.Inc", ComputePercentrankInc);
		AddFunction("Stdev.P", ComputeStdevaP);
		AddFunction("Stdev.S", ComputeStdevaS);
		AddFunction("PermutationA", ComputePermutationA);
		AddFunction("Norm.Dist", ComputeNormOdist);
		AddFunction("Norm.Inv", ComputeNormOinv);
		AddFunction("Norm.S.Dist", ComputeNormOsODist);
		AddFunction("Norm.S.Inv", ComputeNormOsOInv);
		AddFunction("WeiBull.Dist", ComputeWeiBullODist);
		AddFunction("Expon.Dist", ComputeExponODist);
		AddFunction("Gamma.Dist", ComputeGammaOdist);
		AddFunction("Gamma.Inv", ComputeGammaOinv);
		AddFunction("Gammaln.Precise", ComputeGammaln0Precise);
		AddFunction("F.Inv.Rt", ComputeFOinvORt);
		AddFunction("Binom.Inv", ComputeBinomOInv);
		AddFunction("Hypgeom.Dist", ComputeHypgeomOdist);
		AddFunction("Lognorm.Dist", ComputeLognormOdist);
		AddFunction("Lognorm.Inv", ComputeLognormOinv);
		AddFunction("Confidence.Norm", ComputeConfidenceOnorm);
		AddFunction("Chisq.Dist", ComputeChisqOdist);
		AddFunction("chisq.Dist.Rt", ComputeChisqOdistORt);
		AddFunction("F.Dist", ComputeFOdist);
		AddFunction("F.Dist.Rt", ComputeFOdistORt);
		AddFunction("Beta.Dist", ComputeBetaDist);
		AddFunction("CHISQ.TEST", ComputeChisqOTest);
		AddFunction("CHISQ.INV", ComputeChisqOinv);
		AddFunction("CHISQ.INV.RT", ComputeChisqOinvORt);
		AddFunction("BINOM.DIST", ComputeBinomOdist);
		AddFunction("Z.TEST", ComputeZOtest);
		AddFunction("RANK.AVG", ComputeRankOAvg);
		AddFunction("RANK.EQ", ComputeRankOEq);
		AddFunction("IHDIST", ComputeIHDIST);
		AddFunction("UNIDIST", ComputeUnidist);
		AddFunction("QUARTILE.EXC", ComputeQuartileOExc);
		AddFunction("QUARTILE.INC", ComputeQuartileOInc);
		AddFunction("NEGBINOM.DIST", ComputeNegbinomODist);
		AddFunction("MODE.SNGL", ComputeModeOsngl);
		AddFunction("MODE.MULT", ComputeModeOMult);
		AddFunction("POISSON.DIST", ComputePoissonODist);
		AddFunction("T.DIST", ComputeTOdist);
		AddFunction("T.INV", ComputeTOInv);
		AddFunction("Var.S", ComputeVarS);
		AddFunction("Gauss", ComputeGauss);
		AddFunction("Gamma", ComputeGamma);
		AddFunction("Dec2Bin", ComputeDec2Bin);
		AddFunction("Dec2Oct", ComputeDec2Oct);
		AddFunction("Dec2Hex", ComputeDec2Hex);
		AddFunction("Bin2Dec", ComputeBin2Dec);
		AddFunction("Bin2Oct", ComputeBin2Oct);
		AddFunction("Bin2Hex", ComputeBin2Hex);
		AddFunction("Hex2Bin", ComputeHex2Bin);
		AddFunction("Hex2Oct", ComputeHex2Oct);
		AddFunction("Hex2Dec", ComputeHex2Dec);
		AddFunction("Oct2Bin", ComputeOct2Bin);
		AddFunction("Oct2Hex", ComputeOct2Hex);
		AddFunction("Oct2Dec", ComputeOct2Dec);
		AddFunction("IMABS", ComputeImABS);
		AddFunction("Imaginary", ComputeImaginary);
		AddFunction("ImaginaryDifference", ComputeImaginaryDifference);
		AddFunction("ImReal", ComputeReal);
		AddFunction("Complex", ComputeComplex);
		AddFunction("ImSum", ComputeImSum);
		AddFunction("ImSub", ComputeImSub);
		AddFunction("ImProduct", ComputeImProduct);
		AddFunction("ImDiv", ComputeImDiv);
		AddFunction("ImConjugate", ComputeImConjugate);
		AddFunction("IMSQRT", ComputeImSqrt);
		AddFunction("ImArgument", ComputeImArgument);
		AddFunction("ImSin", ComputeIMSin);
		AddFunction("ImCSC", ComputeIMCSC);
		AddFunction("ImCos", ComputeIMCos);
		AddFunction("ImSec", ComputeIMSEC);
		AddFunction("ImTan", ComputeIMTan);
		AddFunction("ImCot", ComputeImCot);
		AddFunction("ImSinH", ComputeImSinH);
		AddFunction("ImCSCH", ComputeIMCSCH);
		AddFunction("ImCosH", ComputeImCosH);
		AddFunction("ImSECH", ComputeIMSecH);
		AddFunction("ImTanH", ComputeIMTanH);
		AddFunction("ImCotH", ComputeIMCotH);
		AddFunction("IMLOG10", ComputeIMLOG10);
		AddFunction("IMLOG2", ComputeIMLOG2);
		AddFunction("IMLN", ComputeIMLN);
		AddFunction("IMEXP", ComputeImEXP);
		AddFunction("IMPOWER", ComputeImPower);
		AddFunction("Gestep", ComputeGestep);
		AddFunction("Delta", ComputeDelta);
		AddFunction("BitAnd", ComputeBitAnd);
		AddFunction("BitOr", ComputeBitOr);
		AddFunction("BitXor", ComputeBitXor);
		AddFunction("BitLShift", ComputeBitLShift);
		AddFunction("BitRShift", ComputeBitRShift);
		AddFunction("ERF", ComputeErf);
		AddFunction("ERF.PRECISE", ComputeErfPrecise);
		AddFunction("ERFC.PRECISE", ComputeErfCPrecise);
		AddFunction("ERFC", ComputeErfCPrecise);
		AddFunction("BESSELI", ComputeBesselI);
		AddFunction("BESSELJ", ComputeBesselJ);
		AddFunction("BESSELY", ComputeBesselY);
		AddFunction("BESSELK", ComputebesselK);
		AddFunction("CONVERT", ComputeConversion);
		AddFunction("Replace", ComputeReplace);
		AddFunction("Code", ComputeCode);
		AddFunction("NumberValue", ComputeNumberValue);
		AddFunction("Proper", ComputeProper);
		AddFunction("UniChar", ComputeUniChar);
		AddFunction("UniCode", ComputeUniCode);
		AddFunction("Rept", ComputeRept);
		AddFunction("FormulaText", ComputeFormulaText);
		AddFunction("IsFormula", ComputeIsFormula);
		AddFunction("Type", ComputeType);
		AddFunction("Sheet", ComputeSheet);
		AddFunction("_Xlfn.Sheet", ComputeSheet);
		AddFunction("Sheets", ComputeSheets);
		AddFunction("_Xlfn.Sheets", ComputeSheets);
		AddFunction("ToCol", ComputeToCol);
		AddFunction("ToRow", ComputeToRow);
		AddFunction("ArrayToText", ComputeArrayToText);
		AddFunction("Take", ComputeTake);
		AddFunction("Drop", ComputeDrop);
		AddFunction("WrapRows", ComputeWrapRows);
		AddFunction("WrapCols", ComputeWrapCols);
		AddFunction("Sort", ComputeSort);
		AddFunction("FINDB", ComputeFindB);
		AddFunction("LEFTB", ComputeLeftB);
		AddFunction("RightB", ComputeRightB);
		AddFunction("MidB", ComputeMidB);
		AddFunction("LenB", ComputeLenB);
		AddFunction("ReplaceB", ComputeReplaceB);
		AddFunction("ASC", ComputeAsc);
		AddFunction("JIS", ComputeJis);
		AddFunction("ValueToText", ComputeValueToText);
		AddFunction("TextAfter", ComputeTextAfter);
		AddFunction("TextBefore", ComputeTextBefore);
		AddFunction("Sequence", ComputeSequence);
		AddFunction("TextSplit", ComputeTextSplit);
		AddFunction("MDETERM", ComputeMdeterm);
		AddFunction("MMULT", ComputeMmult);
		AddFunction("MInverse", ComputeMInverse);
		AddFunction("MUnit", ComputeMUnit);
		AddFunction("_Xlfn.MUnit", ComputeMUnit);
		AddFunction("Base", ComputeBase);
		AddFunction("Decimal", ComputeDecimal);
		AddFunction("Intrate", ComputeIntrate);
		AddFunction("Seriessum", ComputeSeriessum);
		AddFunction("Arabic", ComputeArabic);
		AddFunction("Ceiling.Math", ComputeCeilingMath);
		AddFunction("ChooseCols", ComputeChooseCols);
		AddFunction("ChooseRows", ComputeChooseRows);
		AddFunction("NETWORKDAYS.INTL", ComputeNetworkDaysintl);
		AddFunction("WeekNum", ComputeWeeknum);
		AddFunction("ISOWeekNum", ComputeISOWeeknum);
		AddFunction("Days", ComputeDays);
		AddFunction("EDate", ComputeEDate);
		AddFunction("EOMonth", ComputeEOMonth);
		AddFunction("WorkDay.INTL", ComputeWorkDayintl);
		AddFunction("WorkDay", ComputeWorkDay);
		AddFunction("YearFrac", ComputeYearFrac);
		AddFunction("Hyperlink", ComputeHyperlink);
		AddFunction("Info", ComputeInfo);
		AddFunction("Row", ComputeRow);
		AddFunction("Rows", ComputeRows);
		AddFunction("Columns", ComputeColumns);
		AddFunction("Areas", ComputeAreas);
		AddFunction("Cell", ComputeCell);
		AddFunction("Transpose", ComputeTranspose);
		AddFunction("SearchB", ComputeSearchB);
		AddFunction("EncodeURl", ComputeEncodeURL);
		AddFunction("DatedIF", ComputeDatedIF);
		AddFunction("Unique", ComputeUnique);
		AddFunction("Expand", ComputeExpand);
		AddFunction("VStack", ComputeVStack);
		AddFunction("HStack", ComputeHStack);
		AddFunction("FilterXml", ComputeFilterXml);
	}

	public static int CreateSheetFamilyID()
	{
		if (sheetFamilyID == int.MaxValue)
		{
			sheetFamilyID = int.MinValue;
		}
		return sheetFamilyID++;
	}

	public void RegisterGridAsSheet(string refName, ICalcData model, int sheetFamilyID)
	{
		if (modelToSheetID != null)
		{
			model.WireParentObject();
			model.ValueChanged += grid_ValueChanged;
		}
		refName = refName.Replace("'", "''");
		if (modelToSheetID == null)
		{
			modelToSheetID = new Dictionary<object, object>();
		}
		if (!modelToSheetID.ContainsKey(model))
		{
			modelToSheetID.Add(model, sheetFamilyID);
		}
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(model);
		sheetFamilyItem.isSheeted = true;
		string key = refName.ToUpper();
		if (sheetFamilyItem.SheetNameToParentObject == null)
		{
			sheetFamilyItem.SheetNameToParentObject = new Dictionary<object, object>();
		}
		if (sheetFamilyItem.TokenToParentObject == null)
		{
			sheetFamilyItem.TokenToParentObject = new Dictionary<object, object>();
		}
		if (sheetFamilyItem.SheetNameToToken == null)
		{
			sheetFamilyItem.SheetNameToToken = new Dictionary<object, object>();
		}
		if (sheetFamilyItem.ParentObjectToToken == null)
		{
			sheetFamilyItem.ParentObjectToToken = new Dictionary<object, object>();
		}
		if (sheetFamilyItem.SheetNameToParentObject.ContainsKey(key))
		{
			string text = (string)sheetFamilyItem.SheetNameToToken[key];
			sheetFamilyItem.TokenToParentObject[text] = model;
			sheetFamilyItem.ParentObjectToToken[model] = text;
			return;
		}
		string text2 = "!" + TokenCount + "!";
		TokenCount++;
		sheetFamilyItem.TokenToParentObject.Add(text2, model);
		sheetFamilyItem.SheetNameToToken.Add(key, text2);
		sheetFamilyItem.SheetNameToParentObject.Add(key, model);
		sheetFamilyItem.ParentObjectToToken.Add(model, text2);
		sortedSheetNames = null;
	}

	public static void UnregisterGridAsSheet(string refName, ICalcData model)
	{
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(model);
		string key = refName.ToUpper();
		if (sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.ContainsKey(key))
		{
			sheetFamilyItem.SheetNameToParentObject.Remove(key);
			string key2 = (string)sheetFamilyItem.SheetNameToToken[key];
			sheetFamilyItem.SheetNameToToken.Remove(key);
			sheetFamilyItem.TokenToParentObject.Remove(key2);
			sheetFamilyItem.ParentObjectToToken.Remove(model);
		}
	}

	public void RenameSheet(string sheetName, ICalcData model)
	{
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(model);
		string key = string.Empty;
		if (sheetName.Contains("/") || sheetName.Contains("?") || sheetName.Contains("*") || sheetName.Contains("[") || sheetName.Contains("]") || sheetName.Contains(":") || sheetName.Contains("\\"))
		{
			throw new ArgumentException("The name does not contain any of following characters:  / ? *  [ ] : \\");
		}
		foreach (string key2 in sheetFamilyItem.SheetNameToParentObject.Keys)
		{
			if (sheetFamilyItem.SheetNameToParentObject[key2].Equals(model))
			{
				key = key2;
				break;
			}
		}
		object obj = sheetFamilyItem.SheetNameToToken[key];
		if (sheetFamilyItem.SheetNameToParentObject.ContainsKey(key))
		{
			sheetFamilyItem.SheetNameToParentObject.Remove(key);
			sheetFamilyItem.SheetNameToParentObject.Add(sheetName, model);
		}
		if (sheetFamilyItem.TokenToParentObject.ContainsKey(obj))
		{
			sheetFamilyItem.TokenToParentObject.Remove(obj);
			sheetFamilyItem.TokenToParentObject.Add(obj, model);
		}
		if (sheetFamilyItem.SheetNameToToken.ContainsKey(key))
		{
			sheetFamilyItem.SheetNameToToken.Remove(key);
			sheetFamilyItem.SheetNameToToken.Add(sheetName, obj);
		}
		if (sheetFamilyItem.ParentObjectToToken.ContainsKey(key))
		{
			sheetFamilyItem.ParentObjectToToken.Remove(key);
			sheetFamilyItem.ParentObjectToToken.Add(sheetName, obj);
		}
	}

	public void UpdateDependenciesAndCell(string cell1)
	{
		ICalcData calcData = grid;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		string text = SheetToken(cell1);
		if (text.Length > 0)
		{
			grid = sheetFamilyItem.TokenToParentObject[text] as ICalcData;
		}
		if (!FormulaInfoTable.ContainsKey(cell1))
		{
			return;
		}
		FormulaInfo formulaInfo = FormulaInfoTable[cell1] as FormulaInfo;
		if (formulaInfo.calcID != calcID)
		{
			string text2 = cell;
			cell = cell1;
			formulaInfo.ParsedFormula = ParseFormula(formulaInfo.FormulaText);
			if (iterationMaxCount > 0 && circCheckList.IndexOf(cell) > -1)
			{
				HandleIterations(formulaInfo);
			}
			else
			{
				formulaInfo.FormulaValue = ComputeFormula(formulaInfo.ParsedFormula);
			}
			if (DependentCells.ContainsKey(cell1))
			{
				foreach (string item in (List<object>)DependentCells[cell1])
				{
					FormulaInfo formulaInfo2 = (FormulaInfoTable.ContainsKey(item) ? (FormulaInfoTable[item] as FormulaInfo) : null);
					if (formulaInfo2 != null)
					{
						formulaInfo2.calcID = int.MinValue;
					}
				}
			}
			formulaInfo.calcID = calcID;
			cell = text2;
		}
		bool ignoreValueChanged = IgnoreValueChanged;
		IgnoreValueChanged = true;
		int row = RowIndex(cell1);
		int col = ColIndex(cell1);
		if (PreserveFormula)
		{
			grid.SetValueRowCol(formulaInfo.FormulaText, row, col);
		}
		IgnoreValueChanged = ignoreValueChanged;
		grid = calcData;
		if (processedCells.Contains(cell1))
		{
			return;
		}
		processedCells.Add(cell1);
		grid.SetValueRowCol(formulaInfo.FormulaValue, row, col);
		if (!DependentFormulaCells.ContainsKey(cell1))
		{
			return;
		}
		foreach (string key in ((Dictionary<object, object>)DependentFormulaCells[cell1]).Keys)
		{
			UpdateDependenciesAndCell(key);
		}
	}

	private void HandleIterations(FormulaInfo formula)
	{
		inHandleIterations = true;
		double oldValue = 0.0;
		double result = 0.0;
		int i = 1;
		bool flag = true;
		for (; i < iterationMaxCount - 1; i++)
		{
			if (!flag && CheckUnderTolerance(result, oldValue))
			{
				break;
			}
			flag = false;
			if (!IterationValues.ContainsKey(cell))
			{
				IterationValues.Add(cell, "0");
			}
			IterationValues[cell] = ((formula.FormulaValue == string.Empty) ? "0" : formula.FormulaValue);
			formula.FormulaValue = ComputeFormula(formula.ParsedFormula);
			oldValue = result;
			double.TryParse(formula.FormulaValue, NumberStyles.Any, null, out result);
		}
		IterationValues[cell] = ((formula.FormulaValue == string.Empty) ? "0" : formula.FormulaValue);
		inHandleIterations = false;
	}

	private bool CheckUnderTolerance(double d, double oldValue)
	{
		if (Math.Abs(oldValue) > ABSOLUTEZERO)
		{
			return Math.Abs((d - oldValue) / oldValue) < iterationMaxTolerance;
		}
		return Math.Abs(d - oldValue) < iterationMaxTolerance;
	}

	internal void UpdateDependencies(string s)
	{
		if (lockDependencies || !UseDependencies)
		{
			return;
		}
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		string text = cell;
		if (sheetFamilyItem.ParentObjectToToken != null && sheetFamilyItem.ParentObjectToToken.ContainsKey(grid) && text.IndexOf('!') == -1)
		{
			text = (sheetFamilyItem.ParentObjectToToken[grid] as string) + text;
		}
		if (sheetFamilyItem.ParentObjectToToken != null && sheetFamilyItem.ParentObjectToToken.ContainsKey(grid) && s.IndexOf('!') == -1)
		{
			s = (sheetFamilyItem.ParentObjectToToken[grid] as string) + s;
		}
		if (!DependentCells.ContainsKey(s))
		{
			List<object> list = new List<object>();
			DependentCells.Add(s, list);
			list.Add(text);
			if (DependentFormulaCells.ContainsKey(s))
			{
				Dictionary<object, object> dictionary = (Dictionary<object, object>)DependentFormulaCells[s];
				if (dictionary != null)
				{
					foreach (object key3 in dictionary.Keys)
					{
						string key = key3 as string;
						List<object> list2 = (List<object>)DependentCells[key];
						if (list2 == null)
						{
							list2 = new List<object>();
							DependentCells.Add(key, list2);
						}
						if (list2.IndexOf(text) == -1)
						{
							list2.Add(text);
						}
					}
				}
			}
			AddToFormulaDependentCells(s);
			if (!DependentCells.ContainsKey(text))
			{
				return;
			}
			List<object> list3 = (List<object>)DependentCells[text];
			if (list3 == null || list3 == list)
			{
				return;
			}
			{
				foreach (object item2 in list3)
				{
					string item = item2 as string;
					list.Add(item);
				}
				return;
			}
		}
		List<object> list4 = (List<object>)DependentCells[s];
		if (list4.IndexOf(text) == -1)
		{
			list4.Add(text);
		}
		AddToFormulaDependentCells(s);
		if (!DependentFormulaCells.ContainsKey(s))
		{
			return;
		}
		Dictionary<object, object> dictionary2 = (Dictionary<object, object>)DependentFormulaCells[s];
		if (dictionary2 == null)
		{
			return;
		}
		foreach (object key4 in dictionary2.Keys)
		{
			string key2 = key4 as string;
			List<object> list5 = (List<object>)DependentCells[key2];
			if (list5 == null)
			{
				list5 = new List<object>();
				DependentCells.Add(key2, list5);
			}
			if (list5.IndexOf(text) == -1)
			{
				list5.Add(text);
			}
		}
	}

	internal void ClearFormulaDependentCells(string cell)
	{
		Dictionary<object, object> dictionary = (Dictionary<object, object>)DependentFormulaCells[cell];
		if (dictionary == null)
		{
			return;
		}
		foreach (object key2 in dictionary.Keys)
		{
			string key = key2 as string;
			List<object> obj = DependentCells[key] as List<object>;
			obj.Remove(cell);
			if (obj.Count == 0)
			{
				DependentCells.Remove(key);
			}
		}
		DependentFormulaCells.Remove(cell);
	}

	internal static GridSheetFamilyItem GetSheetFamilyItem(ICalcData model)
	{
		if (model == null)
		{
			return null;
		}
		if (sheetFamilyID == 0)
		{
			if (defaultFamilyItem == null)
			{
				defaultFamilyItem = new GridSheetFamilyItem();
			}
			return defaultFamilyItem;
		}
		if (sheetFamiliesList == null)
		{
			sheetFamiliesList = new Dictionary<object, object>();
		}
		int num = (modelToSheetID.ContainsKey(model) ? ((int)modelToSheetID[model]) : 0);
		if (!sheetFamiliesList.ContainsKey(num))
		{
			sheetFamiliesList.Add(num, new GridSheetFamilyItem());
		}
		return sheetFamiliesList[num] as GridSheetFamilyItem;
	}

	private void AddToFormulaDependentCells(string s)
	{
		string text = cell;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		if (sheetFamilyItem.ParentObjectToToken != null && sheetFamilyItem.ParentObjectToToken.ContainsKey(grid) && text.IndexOf('!') == -1)
		{
			text = (sheetFamilyItem.ParentObjectToToken[grid] as string) + text;
		}
		if (!DependentFormulaCells.ContainsKey(text))
		{
			DependentFormulaCells.Add(text, new Dictionary<object, object>());
			((Dictionary<object, object>)DependentFormulaCells[text]).Add(s, s);
		}
		else if (!((Dictionary<object, object>)DependentFormulaCells[text]).ContainsKey(s))
		{
			((Dictionary<object, object>)DependentFormulaCells[text]).Add(s, s);
		}
	}

	private string SheetToken(string s)
	{
		int i = 0;
		string result = string.Empty;
		if (i < s.Length && s[i] == '!')
		{
			for (i++; i < s.Length && s[i] != '!'; i++)
			{
			}
			if (i < s.Length)
			{
				result = s.Substring(0, i + 1);
			}
		}
		if (i < s.Length)
		{
			return result;
		}
		throw new ArgumentException(FormulaErrorStrings[improper_formula]);
	}

	public void Dispose()
	{
		if (!_isDisposed)
		{
			int num = 0;
			if (_formulaInfoTable != null)
			{
				_formulaInfoTable.Clear();
				_formulaInfoTable = null;
			}
			if (circCheckList != null)
			{
				circCheckList.Clear();
				circCheckList = null;
			}
			if (dependentFormulaCells != null)
			{
				dependentFormulaCells.Clear();
				dependentFormulaCells = null;
			}
			if (grid != null && modelToSheetID != null && modelToSheetID.ContainsKey(grid) && modelToSheetID[grid] != null)
			{
				num = (int)modelToSheetID[grid];
				grid.ValueChanged -= grid_ValueChanged;
				grid.ValueChanged -= grid_ValueChanged;
			}
			if (sheetFamiliesList != null && sheetFamiliesList.Count > 0 && sheetFamiliesList.ContainsKey(num))
			{
				sheetFamiliesList[num] = null;
				sheetFamiliesList.Remove(num);
			}
			if (modelToSheetID != null && modelToSheetID.Count > 0 && grid != null && modelToSheetID.ContainsKey(grid))
			{
				modelToSheetID.Remove(grid);
			}
			if (dependentCells != null)
			{
				dependentCells.Clear();
				dependentCells = null;
			}
			if (iterationValues != null)
			{
				iterationValues.Clear();
				iterationValues = null;
			}
			if (libraryFunctions != null)
			{
				libraryFunctions.Clear();
				libraryFunctions = null;
			}
			if (lookupTables != null)
			{
				lookupTables.Clear();
				lookupTables = null;
			}
			if (errorStrings != null)
			{
				errorStrings.Clear();
			}
			if (namedRanges != null)
			{
				namedRanges.Clear();
			}
			if (refreshedCells != null)
			{
				refreshedCells.Clear();
				refreshedCells = null;
			}
			if (TokenCount > 0)
			{
				TokenCount--;
			}
			if (TokenCount == 0)
			{
				sheetID = -1;
			}
			grid = null;
			_isDisposed = true;
		}
	}

	private bool FindNextSeparator(string formula, ref int location)
	{
		int num = 0;
		bool flag = false;
		while (!flag && location < formula.Length)
		{
			if (formula[location] == 'q')
			{
				num++;
			}
			else if (formula[location] == RIGHTBRACKET)
			{
				num--;
			}
			else if (num == 0 && formula[location] == ParseArgumentSeparator)
			{
				flag = true;
				location--;
			}
			location++;
		}
		return flag;
	}

	private void MarkupResultToIncludeInFormula(ref string s)
	{
		if (s.Length > 0 && s[0] == '-' && double.TryParse(s, out var _))
		{
			s = "nu" + s.Substring(1);
		}
		else
		{
			if ((s.Length > 0 && (s[0] == TIC[0] || s[0] == '\u0092' || s[0] == '#')) || s.StartsWith(TRUEVALUESTR) || s.StartsWith(FALSEVALUESTR))
			{
				return;
			}
			double result2 = 0.0;
			if (double.TryParse(s, out result2))
			{
				s = $"{s:d}";
				s = s.Replace(ParseArgumentSeparator, ' ');
				s = "n" + s;
			}
			else if (!IsRange(s) && s.StartsWith(BRACELEFT) && s.EndsWith(BRACERIGHT))
			{
				s = s.Replace("{", "").Replace("}", "");
				string text = string.Empty;
				string[] array = SplitArgsPreservingQuotedCommas(s);
				foreach (string text2 in array)
				{
					double result3 = 0.0;
					if (double.TryParse(text2, out result3))
					{
						text = text + "n" + text2 + ParseArgumentSeparator;
					}
				}
				s = text.Remove(text.Length - 1);
			}
			else if (!IsRange(s))
			{
				s = TIC + s + TIC;
			}
		}
	}

	public bool GetFormulaArrayBounds(string currentCell, int arrayHeight, int arrayWidth, out int firstRowIndex, out int firstColIndex, out int lastRowIndex, out int lastColIndex)
	{
		int num = ColIndex(cell);
		int num2 = RowIndex(cell);
		string empty = string.Empty;
		FormulaInfo formulaInfo = (FormulaInfoTable.ContainsKey(cell) ? (FormulaInfoTable[cell] as FormulaInfo) : null);
		empty = ((formulaInfo == null) ? grid.GetValueRowCol(num2, num).ToString() : formulaInfo.FormulaText);
		int num3 = 1;
		int num4 = 1;
		for (int i = 1; i <= arrayHeight; i++)
		{
			if (num - i > 0)
			{
				string key = GetSheetTokenFromReference(cell) + RangeInfo.GetAlphaLabel(num - i) + num2;
				string empty2 = string.Empty;
				FormulaInfo formulaInfo2 = (FormulaInfoTable.ContainsKey(key) ? (FormulaInfoTable[key] as FormulaInfo) : null);
				empty2 = ((formulaInfo2 == null) ? grid.GetValueRowCol(num2, num - i).ToString() : formulaInfo2.FormulaText);
				num4 = num - i;
				if (!string.IsNullOrEmpty(empty) && empty2 != empty)
				{
					num4++;
					break;
				}
			}
		}
		for (int j = 1; j <= arrayWidth; j++)
		{
			if (num2 - j > 0)
			{
				string key2 = GetSheetTokenFromReference(cell) + RangeInfo.GetAlphaLabel(num4) + (num2 - j);
				string empty3 = string.Empty;
				FormulaInfo formulaInfo3 = (FormulaInfoTable.ContainsKey(key2) ? (FormulaInfoTable[key2] as FormulaInfo) : null);
				empty3 = ((formulaInfo3 == null) ? grid.GetValueRowCol(num2 - j, num4).ToString() : formulaInfo3.FormulaText);
				num3 = num2 - j;
				if (!string.IsNullOrEmpty(empty) && empty3 != empty)
				{
					num3++;
					break;
				}
			}
		}
		firstRowIndex = num3;
		firstColIndex = num4;
		lastRowIndex = num3 + arrayHeight;
		lastColIndex = num4 + arrayWidth;
		return true;
	}

	private string HandleEmbeddedEs(string text)
	{
		int num = 0;
		while (num > -1 && (num = text.IndexOf(STRING_EP, num)) > -1)
		{
			if (NotInBlock(text, num))
			{
				int num2 = num;
				while (num2 > 0 && (char.IsDigit(text[num2 - 1]) || text[num2 - 1] == ParseDecimalSeparator))
				{
					num2--;
				}
				if (num2 != num && (num2 == 0 || !char.IsUpper(text[num2 - 1])))
				{
					int i;
					for (i = num + STRING_EP.Length; i < text.Length && char.IsDigit(text[i]); i++)
					{
					}
					if (i != num + STRING_EP.Length)
					{
						text = text.Substring(0, num) + CHAR_EP + text.Substring(num + STRING_EP.Length);
					}
				}
			}
			num++;
		}
		num = 0;
		while (num > -1 && (num = text.IndexOf(STRING_EM, num)) > -1)
		{
			if (NotInBlock(text, num))
			{
				int num3 = num;
				while (num3 > 0 && (char.IsDigit(text[num3 - 1]) || text[num3 - 1] == ParseDecimalSeparator))
				{
					num3--;
				}
				if (num3 != num && (num3 == 0 || !char.IsUpper(text[num3 - 1])))
				{
					int j;
					for (j = num + STRING_EM.Length; j < text.Length && char.IsDigit(text[j]); j++)
					{
					}
					if (j != num + STRING_EM.Length)
					{
						text = text.Substring(0, num) + CHAR_EM + text.Substring(num + STRING_EM.Length);
					}
				}
			}
			num++;
		}
		num = 0;
		while (num > -1 && (num = text.IndexOf(STRING_E, num)) > -1 && text[0] != '\u0092')
		{
			if (NotInBlock(text, num))
			{
				int num4 = num;
				while (num4 > 0 && (char.IsDigit(text[num4 - 1]) || text[num4 - 1] == ParseDecimalSeparator))
				{
					num4--;
				}
				if (num4 != num && (num4 == 0 || !char.IsUpper(text[num4 - 1])))
				{
					int k;
					for (k = num + STRING_E.Length; k < text.Length && char.IsDigit(text[k]); k++)
					{
					}
					if (k != num + STRING_E.Length && (num4 == -1 || !char.IsUpper(text[num4])))
					{
						text = text.Substring(0, num) + CHAR_EP + text.Substring(num + STRING_E.Length);
					}
				}
			}
			num++;
		}
		return text;
	}

	public int RowIndex(string s)
	{
		if (CurrentRowNotationEnabled && s.Length == 0)
		{
			return 0;
		}
		int i = 0;
		bool flag = false;
		if (i < s.Length && s[i] == '!')
		{
			for (i++; i < s.Length && s[i] != '!'; i++)
			{
			}
			i++;
		}
		for (; i < s.Length && char.IsLetter(s[i]); i++)
		{
			flag = true;
		}
		if (i < s.Length && int.TryParse(s.Substring(i), out var result))
		{
			return result;
		}
		if (flag)
		{
			return -1;
		}
		throw new ArgumentException(FormulaErrorStrings[bad_index]);
	}

	public int ColIndex(string s)
	{
		int i = 0;
		int num = 0;
		s = s.ToUpper(CultureInfo.InvariantCulture);
		if (i < s.Length && s[i] == '!')
		{
			for (i++; i < s.Length && s[i] != '!'; i++)
			{
			}
			i++;
		}
		for (; i < s.Length && char.IsLetter(s[i]); i++)
		{
			num = num * 26 + s[i] - 65 + 1;
		}
		if (num == 0)
		{
			return -1;
		}
		return num;
	}

	internal bool IsCellReference(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			return false;
		}
		PutTokensForSheets(ref args);
		string text = SheetToken(args);
		bool flag = false;
		if (!string.IsNullOrEmpty(text))
		{
			args = args.Replace(text, string.Empty);
		}
		bool flag2 = false;
		bool flag3 = false;
		if (args.IndexOf(':') != args.LastIndexOf(':'))
		{
			return false;
		}
		char[] array = args.ToCharArray();
		foreach (char c in array)
		{
			if (char.IsLetter(c))
			{
				flag2 = true;
				continue;
			}
			if (char.IsDigit(c))
			{
				flag3 = true;
				continue;
			}
			if (object.Equals(c, ':'))
			{
				if (flag2 && flag3)
				{
					flag = true;
				}
				flag2 = false;
				flag3 = false;
				continue;
			}
			return false;
		}
		if (args.Contains(":") && !args.Contains(TIC))
		{
			if (flag && flag2 && flag3)
			{
				return true;
			}
			if (((flag2 && !flag3) || (!flag2 && flag3)) && !flag)
			{
				return true;
			}
			return false;
		}
		if (flag2 && flag3 && !args.Contains(TIC))
		{
			return true;
		}
		return false;
	}

	private bool CanGetRowIndex(string s)
	{
		int i = 0;
		if (i < s.Length && s[i] == '!')
		{
			for (i++; i < s.Length && s[i] != '!'; i++)
			{
			}
			i++;
		}
		for (; i < s.Length && char.IsLetter(s[i]); i++)
		{
		}
		if (i < s.Length)
		{
			if (char.IsDigit(s[i]))
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private void MarkColonsInQuotes(ref string args)
	{
		bool flag = false;
		if (args.IndexOf(':') == -1)
		{
			return;
		}
		for (int i = 0; i < args.Length; i++)
		{
			if (args[i] == TIC[0])
			{
				flag = !flag;
			}
			else if (args[i] == ':' && flag)
			{
				args = args.Replace(':', MarkerChar);
			}
		}
	}

	private int MatchingRightBracket(string formula)
	{
		int num = -1;
		int num2 = 1;
		int num3 = 0;
		string sheet = SheetToken(formula);
		while (num == -1 && num2 < formula.Length)
		{
			if (formula[num2] == RIGHTBRACKET)
			{
				if (num3 == 0)
				{
					num = num2;
				}
				else
				{
					num3--;
				}
			}
			else if (formula[num2] == 'q')
			{
				int i = num2 + 1;
				if (i < formula.Length)
				{
					string text = ProcessUpperCase(ref formula, ref i, ref sheet);
					if (text != string.Empty && LibraryFunctions.ContainsKey(text))
					{
						num3++;
					}
				}
			}
			num2++;
		}
		return num;
	}

	internal string[] SplitArguments(string args, char argSeperator)
	{
		List<object> list = new List<object>();
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < args.Length; i++)
		{
			if (args[i].Equals('"'))
			{
				num2 = ((num2 == 0) ? (num2 + 1) : 0);
			}
			if (args[i].Equals(argSeperator) && !num2.Equals(1))
			{
				list.Add(args.Substring(num, i - num));
				num = i + 1;
			}
			if (i.Equals(args.Length - 1))
			{
				list.Add(args.Substring(num, i - num + 1));
			}
		}
		string[] array = new string[list.Count];
		Array.Copy(list.ToArray(), array, array.Length);
		return array;
	}

	private string StripTics0(string s)
	{
		if (s.Length > 1 && s[0] == TIC[0] && s[s.Length - 1] == TIC[0])
		{
			s = s.Substring(1, s.Length - 2);
		}
		return s;
	}

	public string StripTics(string s)
	{
		if (s.Length > 1 && s[0] == TIC[0] && s[s.Length - 1] == TIC[0])
		{
			if (s.Substring(1, s.Length - 2).IndexOf(TIC) == -1)
			{
				s = s.Substring(1, s.Length - 2);
			}
			else if (multiTick)
			{
				s = s.Substring(1, s.Length - 2);
			}
		}
		return s;
	}

	private string[] SplitArguments(string array)
	{
		if (array.IndexOf(';') > -1)
		{
			return array.Split(new char[1] { ';' });
		}
		return array.Split(new char[1] { ParseArgumentSeparator });
	}

	public string[] SplitArgsPreservingQuotedCommas(string args)
	{
		if (args.IndexOf(TIC) == -1)
		{
			return args.Split(new char[1] { ParseArgumentSeparator });
		}
		Dictionary<object, object> strings = SaveStrings(ref args);
		string[] array = args.Split(new char[1] { ParseArgumentSeparator });
		List<string> list = new List<string>();
		string[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			string retValue = array2[i];
			SetStrings(ref retValue, strings);
			list.Add(retValue);
		}
		return list.ToArray();
	}

	private static bool TextIsEmpty(string s)
	{
		if (s != null)
		{
			return s == string.Empty;
		}
		return true;
	}

	private string PopString(Stack<object> _stack)
	{
		object obj = _stack.Pop();
		if (obj == null)
		{
			obj = string.Empty;
		}
		if (!GetValueFromArgPreserveLeadingZeros && double.TryParse(obj.ToString(), out var result))
		{
			return result.ToString();
		}
		ErrorStrings.Contains(obj.ToString().Replace(TIC, string.Empty));
		return obj.ToString();
	}

	private double Pop(Stack<object> _stack)
	{
		object obj = _stack.Pop();
		string text = string.Empty;
		if (obj != null)
		{
			if (obj.ToString() == TIC + TIC || (!ExcelLikeComputations && obj.ToString().ToUpper().Equals(double.NaN.ToString().ToUpper())))
			{
				return double.NaN;
			}
			text = obj.ToString().Replace(TIC, string.Empty);
			if (text.Contains("i") || text.Contains("j") || text.Contains("I") || text.Contains("J"))
			{
				switch (text.Substring(text.Length - 1, 1))
				{
				case "i":
				case "j":
				case "I":
				case "J":
					return double.NaN;
				}
			}
			if (ErrorStrings.Contains(text))
			{
				isErrorString = true;
				return ErrorStrings.IndexOf(text);
			}
			if (text.StartsWith("#") || text == string.Empty)
			{
				return 0.0;
			}
			if (text == TRUEVALUESTR)
			{
				return 1.0;
			}
			if (text == FALSEVALUESTR)
			{
				return 0.0;
			}
			if (double.TryParse(text, NumberStyles.Any, CultureInfo.CurrentCulture, out var result))
			{
				return result;
			}
			if (useDatesInCalcs)
			{
				if (TryParseExactDateTime(text, out var result2))
				{
					return GetSerialDateTimeFromDate(result2) - GetSerialDateTimeFromDate(DateTime.Today);
				}
				if (IsDate(text, out result2))
				{
					return GetSerialDateTimeFromDate(result2);
				}
			}
		}
		if (string.IsNullOrEmpty(text) && treatStringsAsZero)
		{
			return 0.0;
		}
		if (obj != null && obj.ToString().Length > 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return double.NaN;
		}
		return 0.0;
	}

	internal void GetFormulaText(ref string s)
	{
		if (this.FormulaParsing != null)
		{
			FormulaParsingEventArgs formulaParsingEventArgs = new FormulaParsingEventArgs(s);
			this.FormulaParsing(this, formulaParsingEventArgs);
			s = formulaParsingEventArgs.Text;
		}
	}

	public void AdjustRangeArg(ref string range)
	{
		if (range.Length > 1 && range[0] == '\u0092' && range[range.Length - 1] == '\u0092' && range.Substring(1, range.Length - 2).IndexOf('\u0092') == -1)
		{
			range = ComputedValue(range);
		}
		if (range.Length > 1 && range[0] == TIC[0] && range[range.Length - 1] == TIC[0])
		{
			range = range.Substring(1, range.Length - 2);
		}
	}

	private double comb(int k, int n)
	{
		double num = 1.0;
		for (int i = k + 1; i <= n; i++)
		{
			num *= (double)i;
		}
		double num2 = 1.0;
		for (int j = 2; j <= n - k; j++)
		{
			num2 *= (double)j;
		}
		return num / num2;
	}

	public void ClearLibraryComputationException()
	{
		libraryComputationException = null;
	}

	public string GetValueFromParentObject(string cell1, bool calculateFormula)
	{
		if (cell1 == TRUEVALUESTR || cell1 == FALSEVALUESTR)
		{
			return cell1;
		}
		int num = cell1.LastIndexOf('!');
		int num2 = 0;
		int num3 = 0;
		ICalcData calcData = grid;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		if (num > -1 && sheetFamilyItem.TokenToParentObject != null)
		{
			grid = (ICalcData)sheetFamilyItem.TokenToParentObject[cell1.Substring(0, num + 1)];
			num2 = RowIndex(cell1);
			if (num2 == -1 && grid is ISheetData)
			{
				num2 = ((ISheetData)grid).GetFirstRow();
			}
			num3 = ColIndex(cell1);
			if (num3 == -1 && grid is ISheetData)
			{
				num3 = ((ISheetData)grid).GetFirstColumn();
			}
		}
		else if (num == -1)
		{
			int i = 0;
			bool flag = false;
			for (; i < cell1.Length && (char.IsLetterOrDigit(cell1[i]) | (cell1[i] == '_') | (cell1[i] == '.') | (cell1[i] == '\\') | (cell1[i] == ' ')); i++)
			{
				if (i > 0 && i < cell1.Length && char.IsLetter(cell1[i]) && (char.IsDigit(cell1[i - 1]) || i == 3))
				{
					flag = true;
				}
			}
			if (i == cell1.Length && (flag || (!flag && !IsCellReference(cell1))))
			{
				cell1 = cell1.ToLower(CultureInfo.InvariantCulture);
				if (RethrowLibraryComputationExceptions)
				{
					libraryComputationException = new Exception(FormulaErrorStrings[invalid_arguments]);
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return ErrorStrings[5].ToString();
			}
			num2 = RowIndex(cell1);
			if (num2 == -1 && grid is ISheetData)
			{
				num2 = ((ISheetData)grid).GetFirstRow();
			}
			num3 = ColIndex(cell1);
			if (num3 == -1 && grid is ISheetData)
			{
				num3 = ((ISheetData)grid).GetFirstColumn();
			}
			if (IsSheeted && sheetFamilyItem.ParentObjectToToken != null && sheetFamilyItem.ParentObjectToToken.ContainsKey(grid))
			{
				cell1 = sheetFamilyItem.ParentObjectToToken[grid]?.ToString() + cell1;
			}
		}
		string text = cell;
		cell = cell1;
		if (iterationMaxCount > 0)
		{
			if (circCheckList.IndexOf(cell) > -1 && computedValueLevel > 0)
			{
				grid = calcData;
				cell = text;
				if (!IterationValues.ContainsKey(cell))
				{
					IterationValues.Add(cell, "0");
				}
				return IterationValues[cell].ToString();
			}
			if (IterationValues.ContainsKey(cell) && computedValueLevel > 0)
			{
				return IterationValues[cell].ToString();
			}
		}
		string empty = string.Empty;
		if (calculateFormula)
		{
			empty = GetValueComputeFormulaIfNecessary(num2, num3, grid);
		}
		else
		{
			object valueRowCol = grid.GetValueRowCol(num2, num3);
			empty = ((valueRowCol != null) ? valueRowCol.ToString() : string.Empty);
		}
		grid = calcData;
		cell = text;
		return empty;
	}

	private int FindLastqNotInBrackets(string s)
	{
		int result = -1;
		bool flag = false;
		for (int num = s.Length - 1; num > -1; num--)
		{
			if (s[num] == 'q' && flag)
			{
				result = num;
				break;
			}
			if (s[num] == LEFTBRACKET)
			{
				flag = true;
			}
			else if (s[num] == RIGHTBRACKET)
			{
				flag = false;
			}
		}
		return result;
	}

	public string GetValueFromGrid(int row, int col)
	{
		return GetValueFromParentObject(row, col);
	}

	private bool TryParseExactDateTime(string value, out DateTime result)
	{
		if (Regex.IsMatch(value, "^(\\d{1,4})(:(\\d{1,2}))?:(\\d{1,2})(" + NumberFormatInfo.CurrentInfo.NumberDecimalSeparator + "[\\d]+){0,1}([\\s]+(AM|PM|am|pm)){0,1}[\\s]*$"))
		{
			int num = Convert.ToInt16(value.Substring(0, value.IndexOf(":")));
			int value2 = 0;
			if (value.Contains(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator) && !value.Substring(0, value.IndexOf(":")).Contains(":"))
			{
				num = 0;
			}
			else if (num >= 24)
			{
				value2 = num / 24;
				num %= 24;
				value = value.Substring(0, value.IndexOf(":")).Replace(value.Substring(0, value.IndexOf(":")), num.ToString()) + value.Substring(value.IndexOf(":"));
			}
			if (DateTime.TryParse(value, null, DateTimeStyles.None, out result))
			{
				result = result.AddDays(Convert.ToDouble(value2));
				return true;
			}
			if (DateTime.TryParseExact(value, "mm:ss" + NumberFormatInfo.CurrentInfo.NumberDecimalSeparator + "0", CultureInfo.InvariantCulture, DateTimeStyles.None, out result))
			{
				result = result.AddDays(Convert.ToDouble(value2));
				return true;
			}
			return false;
		}
		return DateTime.TryParseExact(value, "", null, DateTimeStyles.None, out result);
	}

	private string GetValueComputeFormulaIfNecessary(int row, int col, ICalcData grd)
	{
		try
		{
			bool flag = false;
			FormulaInfo formulaInfo = (FormulaInfoTable.ContainsKey(cell) ? (FormulaInfoTable[cell] as FormulaInfo) : null);
			matchType = false;
			object valueRowCol = grd.GetValueRowCol(row, col);
			string text = ((valueRowCol != null && valueRowCol.ToString() != string.Empty) ? valueRowCol.ToString() : string.Empty);
			if (text != string.Empty)
			{
				matchType = true;
			}
			if ((text.EndsWith("}") && text.StartsWith("{") && formulaInfo != null) || (text != string.Empty && text.EndsWith("}") && text.StartsWith("{") && text[1].Equals(FormulaCharacter)))
			{
				IsArrayFormula = true;
			}
			if ((text == string.Empty && formulaInfo == null) || (text != string.Empty && text[0] != FormulaCharacter && !text.EndsWith("%") && !text.EndsWith("}") && !text.StartsWith("{")))
			{
				if (formulaInfo != null && text == formulaInfo.FormulaValue)
				{
					return formulaInfo.FormulaValue;
				}
				return text;
			}
			if ((text.Length > 0 && text[0] == FormulaCharacter) || IsArrayFormula)
			{
				if (formulaInfo != null)
				{
					if (UseFormulaValues && !IgnoreSubtotal)
					{
						formulaInfo.calcID = calcID;
					}
				}
				else
				{
					formulaInfo = new FormulaInfo();
					formulaInfo.FormulaText = valueRowCol.ToString();
					if (!DependentFormulaCells.ContainsKey(cell))
					{
						DependentFormulaCells.Add(cell, new Dictionary<object, object>());
					}
					bool flag2 = true;
					bool isArrayFormula = IsArrayFormula;
					try
					{
						formulaInfo.ParsedFormula = ParseFormula(text);
					}
					catch (Exception ex)
					{
						if (inAPull)
						{
							text = ex.Message;
							formulaInfo = null;
						}
						else
						{
							formulaInfo.FormulaValue = ex.Message;
						}
						flag2 = false;
					}
					IsArrayFormula = isArrayFormula;
					bool ignoreSubtotal = IgnoreSubtotal;
					if (formulaInfo != null && !formulaInfo.ParsedFormula.Contains("SUBTOTAL"))
					{
						IgnoreSubtotal = false;
					}
					if (flag2)
					{
						formulaInfo.FormulaValue = ComputeFormula(formulaInfo.ParsedFormula);
						flag = true;
					}
					if (formulaInfo != null)
					{
						if (!IgnoreSubtotal)
						{
							formulaInfo.calcID = calcID;
						}
						if (!FormulaInfoTable.ContainsKey(cell))
						{
							FormulaInfoTable.Add(cell, formulaInfo);
						}
						text = ((formulaInfo.FormulaValue != null) ? formulaInfo.FormulaValue : string.Empty);
					}
					IgnoreSubtotal = ignoreSubtotal;
				}
			}
			if (formulaInfo != null)
			{
				if (IgnoreSubtotal && formulaInfo.ParsedFormula.Contains("SUBTOTAL"))
				{
					return text;
				}
				if (UseFormulaValues || (CalculatingSuspended && (!inAPull || flag)))
				{
					text = ((formulaInfo.FormulaValue != null) ? formulaInfo.FormulaValue : string.Empty);
				}
				else if (!flag)
				{
					if (calcID == formulaInfo.calcID)
					{
						text = formulaInfo.FormulaValue;
					}
					else
					{
						bool ignoreSubtotal2 = IgnoreSubtotal;
						if (!formulaInfo.ParsedFormula.Contains("SUBTOTAL"))
						{
							IgnoreSubtotal = false;
						}
						text = (formulaInfo.FormulaValue = ComputeFormula(formulaInfo.ParsedFormula));
						if (!IgnoreSubtotal || ignoreSubtotal2)
						{
							formulaInfo.calcID = calcID;
						}
						IgnoreSubtotal = ignoreSubtotal2;
					}
				}
				if (treatStringsAsZero && string.IsNullOrEmpty(text) && computedValueLevel > 1 && !formulaInfo.ParsedFormula.StartsWith(IFMarker))
				{
					return "0";
				}
			}
			if (string.IsNullOrEmpty(text))
			{
				text = string.Empty;
			}
			return text;
		}
		finally
		{
			if (computedValueLevel <= 1)
			{
				IsArrayFormula = false;
			}
		}
	}

	public string GetValueFromParentObject(ICalcData grd, int row, int col)
	{
		return GetValueFromParentObject(grd, row, col, calculateFormula: true);
	}

	public string GetValueFromParentObject(ICalcData grd, int row, int col, bool calculateFormula)
	{
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grd);
		string text = ((sheetFamilyItem.ParentObjectToToken == null || sheetFamilyItem.ParentObjectToToken.Count == 0) ? string.Empty : sheetFamilyItem.ParentObjectToToken[grd].ToString());
		text = text + RangeInfo.GetAlphaLabel(col) + row;
		ICalcData calcData = grid;
		string text2 = cell;
		cell = text;
		grid = grd;
		string empty = string.Empty;
		if (calculateFormula)
		{
			empty = GetValueComputeFormulaIfNecessary(row, col, grd);
		}
		else
		{
			object valueRowCol = grid.GetValueRowCol(row, col);
			empty = ((valueRowCol != null) ? valueRowCol.ToString() : string.Empty);
		}
		if (ExcelLikeComputations && UseDatesInCalculations && !double.TryParse(empty, out var _) && DateTime.TryParse(empty, CultureInfo.CurrentCulture, DateTimeStyles.None, out var result2) && dateTime1900 <= result2)
		{
			empty = result2.ToOADate().ToString();
		}
		grid = calcData;
		cell = text2;
		return empty;
	}

	public virtual string GetValueFromArg(string arg)
	{
		if (TextIsEmpty(arg))
		{
			return string.Empty;
		}
		DateTime result = dateTime1900;
		if (arg.Contains(" ") && !arg.Replace('\u0092'.ToString(), string.Empty).StartsWith(TIC))
		{
			CheckIfNameRangesIntersect(arg, out var finalValue);
			arg = ((finalValue != string.Empty) ? finalValue : arg);
		}
		if (arg[0] == TIC[0] && !multiTick)
		{
			if (ExcelLikeComputations && UseDatesInCalculations && !double.TryParse(arg.Replace(TIC, string.Empty), out var _) && DateTime.TryParse(arg, CultureInfo.CurrentCulture, DateTimeStyles.None, out result) && dateTime1900 <= result)
			{
				return result.ToOADate().ToString();
			}
			return arg;
		}
		if (arg[0] == '\u0092' || arg[0] == 'q' || (arg[0] == '!' && arg.Contains(":")))
		{
			if (arg.StartsWith("{") && arg.EndsWith("}"))
			{
				arg = arg.Replace('{', '(');
				arg = arg.Replace('}', ')');
			}
			return ComputedValue(arg);
		}
		if (arg.Length > 1 && arg.Substring(0, 2) == "ub")
		{
			arg = arg.Replace('{', '(');
			arg = arg.Replace('}', ')');
			string formula = arg.Substring(1);
			formula = ComputedValue(formula);
			double result3 = 0.0;
			if (double.TryParse(formula, out result3))
			{
				return (0.0 - result3).ToString();
			}
			return ComputedValue(arg);
		}
		if (arg.StartsWith("unu"))
		{
			arg = "n" + arg.Substring(3);
		}
		else if (arg.StartsWith("un", StringComparison.Ordinal))
		{
			arg = "-" + arg.Substring(2);
		}
		arg = arg.Replace('u', '-');
		arg = arg.Replace("~", TIC + TIC);
		double result4;
		if (!char.IsUpper(arg[0]) && (char.IsDigit(arg[0]) || arg[0] == ParseDecimalSeparator || arg[0] == '+' || arg[0] == '-' || arg[0] == 'n' || (arg.Length == 1 && (arg[0] == 'i' || arg[0] == 'j' || arg[0] == ''))))
		{
			if (arg[0] == 'n')
			{
				arg = arg.Substring(1);
			}
			string text = arg.Substring(arg.Length - 1, 1);
			if (text == "i" || text == "j")
			{
				return arg;
			}
			if (double.TryParse(arg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result4))
			{
				if (!GetValueFromArgPreserveLeadingZeros)
				{
					return result4.ToString();
				}
				return arg;
			}
			if (arg.StartsWith(TRUEVALUESTR) || arg.StartsWith(FALSEVALUESTR))
			{
				return arg;
			}
		}
		if (ignoreCellValue && !arg.StartsWith(TRUEVALUESTR) && !arg.StartsWith(FALSEVALUESTR))
		{
			ignoreCellValue = false;
			return arg;
		}
		if ((arg.IndexOfAny(new char[7] { '+', '-', '/', '*', ')', ')', '{' }) == -1 && char.IsUpper(arg[0])) || arg[0] == '!')
		{
			if (arg == cell)
			{
				List<object> list = (List<object>)DependentCells[arg];
				if (list != null && list.IndexOf(arg) > -1)
				{
					list.Remove(arg);
				}
				if (DependentFormulaCells.ContainsKey(cell))
				{
					ClearFormulaDependentCells(cell);
				}
				throw new ArgumentException(FormulaErrorStrings[circular_reference_] + arg);
			}
			string text2 = GetValueFromParentObject(arg);
			if (arg != TRUEVALUESTR && arg != FALSEVALUESTR)
			{
				if (!GetValueFromArgPreserveLeadingZeros && !IsCellReference(arg) && text2.Length > 0 && double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result4))
				{
					text2 = result4.ToString();
				}
				UpdateDependencies(arg);
			}
			return text2;
		}
		arg = arg.Replace('{', '(');
		arg = arg.Replace('}', ')');
		arg = Parse(arg);
		if (arg.EndsWith("%") && double.TryParse(arg.Substring(0, arg.Length - 1), NumberStyles.Any, null, out result4))
		{
			arg = (result4 / 100.0).ToString();
		}
		if (ErrorStrings.Contains(arg))
		{
			return arg;
		}
		return ComputedValue(arg);
	}

	public string[] GetCellsFromArgs(string args)
	{
		return GetCellsFromArgs(args, findCellsFromRange: true);
	}

	internal string[] GetCellsFromArgs(string args, bool findCellsFromRange)
	{
		MarkColonsInQuotes(ref args);
		int num = 0;
		int num2 = 0;
		int num3 = args.IndexOf(':');
		if (num3 > -1 && args.Contains(" ") && !args.Replace('\u0092'.ToString(), string.Empty).StartsWith(TIC))
		{
			string[] array = null;
			int num4 = args.LastIndexOf(':');
			int num5 = args.IndexOf(':');
			array = ((num5 >= args.IndexOf(' ')) ? new string[2]
			{
				args.Substring(0, num4),
				(num4 < args.Length) ? args.Substring(num4 + 1, args.Length - 1 - num5) : null
			} : new string[2]
			{
				args.Substring(0, num5),
				(num5 < args.Length) ? args.Substring(num5 + 1, args.Length - 1 - num5) : null
			});
			args = string.Empty;
			for (int i = 0; i < array.Length; i++)
			{
				findRangeIfIntersect = true;
				if (array[i].Contains(" "))
				{
					CheckIfNameRangesIntersect(array[i], out var finalValue);
					array[i] = ((finalValue != string.Empty) ? finalValue : array[i]);
				}
				args += ((i != array.Length - 1) ? (array[i] + ":") : array[i]);
			}
			findRangeIfIntersect = false;
		}
		if (num3 == -1)
		{
			args = args.Replace(MarkerChar, ':');
			num3 = args.IndexOf(ParseArgumentSeparator);
			if (num3 == -1)
			{
				num = RowIndex(args);
				num2 = ColIndex(args);
				return new string[1] { args };
			}
			return SplitArgsPreservingQuotedCommas(args);
		}
		string text = string.Empty;
		string text2 = args;
		int num6 = args.IndexOf('!');
		if (num6 > -1)
		{
			int num7 = args.IndexOf('!', num6 + 1);
			if (num7 > -1)
			{
				text = args.Substring(num6, num7 - num6 + 1);
				args = args.Replace(text, string.Empty);
				num3 = args.IndexOf(':');
			}
		}
		if (num3 > 0 && char.IsLetter(args[num3 - 1]))
		{
			int num8 = ((rowMaxCount > 0) ? rowMaxCount : 50);
			GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
			ISheetData sheetData = null;
			if (text != string.Empty)
			{
				sheetData = sheetFamilyItem.TokenToParentObject[text] as ISheetData;
			}
			if (sheetFamilyItem.TokenToParentObject != null && sheetData != null)
			{
				num8 = sheetData.GetLastRow();
			}
			else if (grid is ISheetData)
			{
				num8 = ((ISheetData)grid).GetLastRow();
			}
			args = args.Substring(0, num3) + "1:" + args.Substring(num3 + 1) + num8;
			num3 = args.IndexOf(':');
		}
		else if (num3 > 0 && char.IsDigit(args[num3 - 1]))
		{
			int num9 = num3 - 2;
			while (num9 >= 0 && char.IsDigit(args[num9]))
			{
				num9--;
			}
			if (num9 == -1 || !char.IsLetter(args[num9]))
			{
				int col = ((columnMaxCount > 0) ? columnMaxCount : 16384);
				if (grid is ISheetData)
				{
					col = ((ISheetData)grid).GetLastColumn();
				}
				args = "A" + args.Substring(0, num3) + ":" + RangeInfo.GetAlphaLabel(col) + args.Substring(num3 + 1);
				num3 = args.IndexOf(':');
			}
		}
		if (!findCellsFromRange)
		{
			return new string[1] { text + args };
		}
		int num10 = 0;
		int num11 = 0;
		string[] array2 = args.Split(':');
		if (array2.Length > 2)
		{
			int num12;
			int num13 = (num12 = int.MaxValue);
			int num14;
			int num15 = (num14 = int.MinValue);
			string[] array3 = array2;
			foreach (string s in array3)
			{
				int val = RowIndex(s);
				num12 = Math.Min(num12, val);
				num14 = Math.Max(num14, val);
				val = ColIndex(s);
				num13 = Math.Min(num13, val);
				num15 = Math.Max(num15, val);
			}
			num = num12;
			num10 = num14;
			num2 = num13;
			num11 = num15;
		}
		else
		{
			num = RowIndex(array2[0]);
			num2 = ColIndex(array2[0]);
			num10 = RowIndex(array2[1]);
			num11 = ColIndex(array2[1]);
		}
		if (!CanGetRowIndex(args.Substring(0, num3)))
		{
			ignoreCellValue = true;
			args = text2;
			return SplitArgsPreservingQuotedCommas(args);
		}
		_ = new string[1];
		if (!(!num.Equals(-1) || num10.Equals(-1)).Equals(num.Equals(-1) || !num10.Equals(-1)))
		{
			throw new ArgumentException(ErrorStrings[5].ToString());
		}
		if (num == -1 && grid is ISheetData)
		{
			num = ((ISheetData)grid).GetFirstRow();
		}
		if (num2 == -1 && grid is ISheetData)
		{
			num2 = ((ISheetData)grid).GetFirstColumn();
		}
		if (num10 == -1 && grid is ISheetData)
		{
			num10 = ((ISheetData)grid).GetLastRow();
		}
		if (num11 == -1 && grid is ISheetData)
		{
			num11 = ((ISheetData)grid).GetLastColumn();
		}
		if (num > num10)
		{
			num3 = num10;
			num10 = num;
			num = num3;
		}
		if (num2 > num11)
		{
			num3 = num11;
			num11 = num2;
			num2 = num3;
		}
		string[] array4 = new string[(num10 - num + 1) * (num11 - num2 + 1)];
		int num16 = 0;
		for (num3 = num; num3 <= num10; num3++)
		{
			for (num6 = num2; num6 <= num11; num6++)
			{
				try
				{
					array4[num16++] = text + RangeInfo.GetAlphaLabel(num6) + num3;
				}
				catch
				{
				}
			}
		}
		return array4;
	}

	public void RecalculateRange(RangeInfo range, ICalcData data)
	{
		inRecalculateRange = true;
		for (int i = range.Top; i <= range.Bottom; i++)
		{
			for (int j = range.Left; j <= range.Right; j++)
			{
				data.SetValueRowCol(data.GetValueRowCol(i, j), i, j);
			}
		}
		inRecalculateRange = false;
	}

	public override string ToString()
	{
		return "CalcEngine { Cell: " + ((cell != null) ? cell.ToString() : "null") + " " + ((DependentCells != null) ? DependentCells.Count : (-1)) + "}";
	}

	private bool FindRightBracket(string formula, ref int location)
	{
		int num = 0;
		bool flag = false;
		while (!flag && location < formula.Length)
		{
			if (formula[location] == 'q')
			{
				num++;
			}
			else if (num == 0 && formula[location] == RIGHTBRACKET)
			{
				flag = true;
				location--;
			}
			else if (formula[location] == RIGHTBRACKET)
			{
				num--;
			}
			location++;
		}
		return flag;
	}

	private string HandleEmbeddedIf(string formula)
	{
		int location = IFMarker.Length;
		int num = location + 1;
		double result = 0.0;
		if (EnsureIFCallDuringShortCircuit)
		{
			if (FindNextSeparator(formula, ref location))
			{
				num = location + 1;
				FindRightBracket(formula, ref num);
				if (num > -1)
				{
					LibraryFunction libraryFunction = (LibraryFunction)LibraryFunctions["IF"];
					if (libraryFunction != null)
					{
						string text = formula.Substring(IFMarker.Length, num - IFMarker.Length);
						for (int num2 = text.IndexOf(IFMarker); num2 > -1; num2 = text.IndexOf(IFMarker))
						{
							int num3 = MatchingRightBracket(text.Substring(num2));
							if (num3 > -1)
							{
								text = text.Substring(0, num2) + HandleEmbeddedIf(text.Substring(num2)) + text.Substring(num2 + num3 + 1);
							}
						}
						string text2 = libraryFunction(text);
						if (double.TryParse(text2, out result))
						{
							text2 = ((!(result < 0.0)) ? ("n" + result) : ("nu" + (0.0 - result)));
						}
						formula = text2;
					}
				}
			}
			return formula;
		}
		if (FindNextSeparator(formula, ref location))
		{
			num = location + 1;
			if (!FindNextSeparator(formula, ref num))
			{
				num = formula.IndexOf(RIGHTBRACKET, location);
				if (num > -1)
				{
					formula = formula.Substring(0, num) + ParseArgumentSeparator + FALSEVALUESTR + formula.Substring(num);
				}
			}
			string text3 = ComputedValue(formula.Substring(IFMarker.Length, location - IFMarker.Length));
			if (text3 == TRUEVALUESTR || (double.TryParse(text3, NumberStyles.Any, null, out result) && result != 0.0))
			{
				formula = formula.Substring(location + 1, num - location - 1);
			}
			else
			{
				int location2 = num + 1;
				if (FindRightBracket(formula, ref location2))
				{
					formula = formula.Substring(num + 1, location2 - num - 1);
				}
			}
			if (double.TryParse(formula, out result))
			{
				formula = ((!(result < 0.0)) ? ("n" + result) : ("nu" + (0.0 - result)));
			}
		}
		return formula;
	}

	public string GetValueFromParentObject(string cell1)
	{
		return GetValueFromParentObject(cell1, calculateFormula: true);
	}

	public string GetValueFromParentObject(int row, int col)
	{
		return GetValueComputeFormulaIfNecessary(row, col, grid);
	}

	public string ComputedValue(string formula)
	{
		ExceptionThrown = false;
		bool flag = false;
		if (TextIsEmpty(formula))
		{
			return formula;
		}
		if (CheckIfNameRangesIntersect(formula, out var finalValue))
		{
			return finalValue;
		}
		try
		{
			computedValueLevel++;
			if (computedValueLevel > maximumRecursiveCalls)
			{
				computedValueLevel = 0;
				throw new ArgumentException(FormulaErrorStrings[too_complex]);
			}
			Stack<object> stack = new Stack<object>(MaxStackDepth);
			int num = 0;
			stack.Clear();
			string sheet = string.Empty;
			_ = string.Empty;
			if (AllowShortCircuitIFs && formula.Length > 0 && formula.IndexOf(IFMarker) > -1)
			{
				if (EnsureIFCallDuringShortCircuit)
				{
					ComputeEnsureIFCall(ref formula);
				}
				else
				{
					ComputeShortCircuitIFFormula(ref formula);
				}
				if (formula.StartsWith(TIC) && formula.EndsWith(TIC))
				{
					return formula;
				}
			}
			num = 0;
			while (num < formula.Length)
			{
				if (formula[num] == '\u0092')
				{
					num++;
					continue;
				}
				bool flag2 = formula[num] == 'u';
				if (flag2)
				{
					num++;
					if (num >= formula.Length)
					{
						continue;
					}
					if (formula[num] == '\u0092')
					{
						num++;
					}
					if (num >= formula.Length)
					{
						continue;
					}
				}
				if (formula[num] == '%' && stack.Count > 0)
				{
					if (double.TryParse(stack.Peek().ToString(), NumberStyles.Any, null, out var result))
					{
						stack.Pop();
						stack.Push(result / 100.0);
					}
					num++;
					continue;
				}
				if (formula[num] == '!')
				{
					sheet = formula[num].ToString();
					for (num++; num < formula.Length && formula[num] != '!'; num++)
					{
						sheet += formula[num];
					}
					if (num >= formula.Length)
					{
						continue;
					}
					sheet += formula[num];
					num++;
				}
				if (formula[num] == '*')
				{
					stack.Push('*');
					num++;
					continue;
				}
				if (formula.Substring(num).StartsWith(TRUEVALUESTR))
				{
					stack.Push(TRUEVALUESTR);
					num += TRUEVALUESTR.Length;
					continue;
				}
				if (formula.Substring(num).StartsWith(FALSEVALUESTR))
				{
					stack.Push(FALSEVALUESTR);
					num += FALSEVALUESTR.Length;
					continue;
				}
				if (formula[num] == TIC[0] || formula[num] == '|')
				{
					if (stack.Count == 3)
					{
						stack = CombineStack(formula, num - 2, stack);
					}
					string text = formula[num].ToString();
					for (num++; num < formula.Length && formula[num] != TIC[0]; num++)
					{
						text += formula[num];
					}
					if (multiTick)
					{
						text = text.Replace("|", TIC);
					}
					stack.Push(text + TIC);
					num++;
					continue;
				}
				if (char.IsUpper(formula[num]))
				{
					string text2 = ProcessUpperCase(ref formula, ref num, ref sheet);
					if (ErrorStrings.Contains(text2))
					{
						return text2;
					}
					if (flag2)
					{
						text2 = GetValueFromParentObject(text2);
						if (double.TryParse(text2, out var result2))
						{
							result2 = 0.0 - result2;
							stack.Push(result2.ToString());
						}
						else
						{
							stack.Push(text2);
						}
						continue;
					}
					if (UseFormulaValues && computedValueLevel > MaxStackDepth)
					{
						if (!breakedFormulaCells.Contains(text2) && UseFormulaValues)
						{
							GetSheetFamilyItem(grid);
							if (!text2.StartsWith('!'.ToString()))
							{
								text2 = string.Concat("!" + GetSheetID(grid) + "!", text2);
							}
							breakedFormulaCells.Add(text2);
							tempBreakedFormulaCells.Add(text2);
							break;
						}
						stack.Push("FALSE");
					}
					if (IsAreaCalculation && IsRange(text2) && text2.Contains(":"))
					{
						stack.Push(text2);
					}
					else
					{
						stack.Push(GetValueFromParentObject(text2));
					}
					continue;
				}
				if (formula[num] == 'q')
				{
					formula = ComputeInteriorFunctions(formula);
					int num2 = formula.Substring(num + 1).IndexOf(LEFTBRACKET);
					if (num2 > 0)
					{
						int num3 = 0;
						bool flag3 = false;
						int num4 = num2 + num + 2;
						int i;
						for (i = num4; i < formula.Length && (formula[i] != RIGHTBRACKET || num3 > 0); i++)
						{
							if (formula[i] == LEFTBRACKET)
							{
								num3++;
								flag3 = true;
							}
							else if (formula[i] == LEFTBRACKET)
							{
								num3--;
							}
						}
						if (flag3)
						{
							string args = formula.Substring(num4, i - num4 - 2);
							string text3 = string.Empty;
							string[] array = SplitArgsPreservingQuotedCommas(args);
							foreach (string text4 in array)
							{
								if (text3.Length > 0)
								{
									text3 += ",";
								}
								int num5 = FindLastqNotInBrackets(text4);
								text3 = ((num5 <= 0) ? (text3 + ComputedValue(text4)) : (text3 + text4.Substring(0, num5) + ComputedValue(text4.Substring(num5))));
							}
							formula = formula.Substring(0, num4) + text3 + formula.Substring(i - 2);
						}
						string text5 = formula.Substring(num + 1, num2);
						if (text5 == "AVG" && excelLikeComputations)
						{
							return FormulaErrorStrings[bad_index];
						}
						if (LibraryFunctions[text5] != null)
						{
							int num6 = formula.Substring(num + num2 + 1).IndexOf(RIGHTBRACKET);
							string args2 = formula.Substring(num + num2 + 2, num6 - 1);
							try
							{
								LibraryFunction libraryFunction = (LibraryFunction)LibraryFunctions[text5];
								string[] array2 = SplitArgsPreservingQuotedCommas(args2);
								StringBuilder stringBuilder = new StringBuilder();
								bool flag4 = false;
								for (int k = 0; k < array2.Length; k++)
								{
									string text6 = array2[k];
									findNamedRange = false;
									if (NamedRanges.Count > 0 && !string.IsNullOrEmpty(text6.Trim()))
									{
										text6 = CheckForNamedRange(text6);
									}
									if (!findNamedRange && !text6.StartsWith("!") && text6.Contains("!") && text6.Contains("'[") && text6.Contains("]"))
									{
										UpdateExternalFormulaEventArgs updateExternalFormulaEventArgs = new UpdateExternalFormulaEventArgs(text6);
										this.UpdateExternalFormula(this, updateExternalFormulaEventArgs);
										if (updateExternalFormulaEventArgs.IsFormulaUpdated)
										{
											text6 = updateExternalFormulaEventArgs.parsedFormula;
											flag4 = true;
										}
									}
									if (k == array2.Length - 1)
									{
										stringBuilder.Append(text6);
									}
									else
									{
										stringBuilder.Append(text6 + ParseArgumentSeparator);
									}
								}
								if (flag4 || findNamedRange)
								{
									args2 = stringBuilder.ToString();
								}
								findNamedRange = false;
								string text7 = libraryFunction(args2);
								if (this.FormulaComputed != null)
								{
									FormulaComputedEventArgs formulaComputedEventArgs = new FormulaComputedEventArgs(text5, text7, cell, computedValueLevel > 1);
									this.FormulaComputed(this, formulaComputedEventArgs);
									if (formulaComputedEventArgs.Handled)
									{
										text7 = formulaComputedEventArgs.ComputedValue;
									}
								}
								stack.Push(text7);
							}
							catch (Exception ex)
							{
								ExceptionThrown = true;
								if (rethrowLibraryComputationExceptions)
								{
									libraryComputationException = ex;
									throw ex;
								}
								if (ErrorStrings.Contains(ex.Message))
								{
									return ex.Message;
								}
								return ErrorStrings[1].ToString();
							}
							num += num6 + num2 + 2;
							continue;
						}
						return FormulaErrorStrings[missing_formula];
					}
					if (formula[0] == '\u0092' && formula[formula.Length - 1] == '\u0092')
					{
						num = 0;
						stack.Clear();
						continue;
					}
					if (RethrowLibraryComputationExceptions)
					{
						throw new Exception(FormulaErrorStrings[improper_formula]);
					}
					return FormulaErrorStrings[improper_formula];
				}
				if (char.IsDigit(formula[num]) || formula[num] == 'u')
				{
					string text8 = string.Empty;
					if (formula[num] == 'u' || flag2)
					{
						text8 = "-";
						if (!flag2)
						{
							num++;
						}
						else
						{
							flag2 = false;
						}
					}
					if (num < formula.Length && char.IsUpper(formula[num]))
					{
						text8 += GetValueFromParentObject(ProcessUpperCase(ref formula, ref num, ref sheet));
					}
					else
					{
						for (; num < formula.Length && (char.IsDigit(formula[num]) || formula[num] == ParseDecimalSeparator || formula[num].Equals(':')); num++)
						{
							text8 += formula[num];
						}
					}
					stack.Push(text8);
					continue;
				}
				if (formula[num] == ParseDateTimeSeparator)
				{
					string text9 = "";
					for (; num < formula.Length && formula[num] == ParseDateTimeSeparator; num++)
					{
						text9 += formula[num];
					}
					while (stack.Count > 0)
					{
						text9 = stack.Pop()?.ToString() + text9;
					}
					stack.Push(text9);
					continue;
				}
				if (formula[num] == ParseArgumentSeparator)
				{
					num++;
					continue;
				}
				switch (formula[num])
				{
				case '#':
				{
					int num14 = 0;
					if (formula.Substring(num).Contains("#N/A") || formula.Substring(num).Contains("#VALUE!") || formula.Substring(num).Contains("#REF!") || formula.Substring(num).Contains("#DIV/0!") || formula.Substring(num).Contains("#NUM!") || formula.Substring(num).Contains("#NAME?") || formula.Substring(num).Contains("#NULL!"))
					{
						num14 = ((formula.IndexOf('!') != -1 && formula.Substring(num).IndexOf('!') != -1) ? (formula.Substring(num).IndexOf('!') + 1 + num) : ((formula.Substring(num).IndexOf("#N/A") > -1) ? (formula.Substring(num).IndexOf("#N/A") + 4 + num) : (formula.Substring(num).IndexOf('?') + 1 + num)));
						stack.Push(formula.Substring(num, num14 - num));
					}
					else
					{
						num14 = num + 1;
						stack.Push(formula.Substring(num, num14 - num));
					}
					num = num14;
					break;
				}
				case 'n':
				{
					num++;
					string text14 = string.Empty;
					if (formula.Substring(num).StartsWith("Infinity") || formula.Substring(num).StartsWith(double.PositiveInfinity.ToString()))
					{
						text14 = double.PositiveInfinity.ToString();
						num += text14.Length;
					}
					else if (formula.Substring(num).StartsWith("uInfinity") || formula.Substring(num).StartsWith(double.NegativeInfinity.ToString()))
					{
						text14 = double.NegativeInfinity.ToString();
						num += text14.Length + 1;
					}
					else if (formula.Substring(num).StartsWith(TRUEVALUESTR))
					{
						text14 = TRUEVALUESTR;
						num += text14.Length;
					}
					else if (formula.Substring(num).StartsWith(FALSEVALUESTR))
					{
						text14 = FALSEVALUESTR;
						num += text14.Length;
					}
					else if (num <= formula.Length - 3 && formula.Substring(num, 3).ToUpper() == Convert.ToString(double.NaN).ToUpper())
					{
						num += 3;
						text14 = ((!ExcelLikeComputations) ? Convert.ToString(double.NaN) : ErrorStrings[1].ToString());
					}
					else
					{
						if (formula[num] == 'u' || flag2)
						{
							text14 = "-";
							if (!flag2)
							{
								num++;
							}
							else
							{
								flag2 = false;
							}
						}
						for (; num < formula.Length && (char.IsDigit(formula[num]) || formula[num] == ParseDecimalSeparator); num++)
						{
							text14 += formula[num];
						}
						if (num < formula.Length && formula[num] == '%')
						{
							num++;
							if (text14 == string.Empty)
							{
								if (stack.Count > 0 && double.TryParse(stack.Peek().ToString(), NumberStyles.Any, null, out var result11))
								{
									stack.Pop();
									text14 = (result11 / 100.0).ToString();
								}
							}
							else
							{
								text14 = (double.Parse(text14) / 100.0).ToString();
							}
						}
						else if (num < formula.Length - 2 && formula[num] == 'E' && (formula[num + 1] == '+' || formula[num + 1] == '-'))
						{
							text14 += formula.Substring(num, 4);
							num += 4;
						}
					}
					stack.Push(text14);
					break;
				}
				case 'a':
				{
					double num12 = Pop(stack);
					if (int.TryParse(num12.ToString(), out var result8) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result8].ToString();
					}
					double num13 = Pop(stack);
					if (int.TryParse(num13.ToString(), out result8) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result8].ToString();
					}
					if (num12.Equals(double.NaN) || num13.Equals(double.NaN) || num12.Equals("#VALUE!") || num13.Equals("#VALUE!"))
					{
						if (excelLikeComputations)
						{
							stack.Push("#VALUE!");
						}
						else if (num12.Equals(double.NaN) || num13.Equals(double.NaN))
						{
							stack.Push(double.NaN.ToString());
						}
					}
					else
					{
						stack.Push((num13 + num12).ToString());
					}
					num++;
					break;
				}
				case 's':
				{
					double num17 = Pop(stack);
					if (int.TryParse(num17.ToString(), out var result20) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result20].ToString();
					}
					double num18 = Pop(stack);
					if (int.TryParse(num18.ToString(), out result20) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result20].ToString();
					}
					if (num17.Equals(double.NaN) || num18.Equals(double.NaN) || num17.Equals("#VALUE!") || num18.Equals("#VALUE!"))
					{
						if (excelLikeComputations)
						{
							stack.Push("#VALUE!");
						}
						else if (num17.Equals(double.NaN) || num18.Equals(double.NaN))
						{
							stack.Push(double.NaN.ToString());
						}
					}
					else
					{
						stack.Push((num18 - num17).ToString());
					}
					num++;
					break;
				}
				case 'm':
				{
					double num7 = Pop(stack);
					if (int.TryParse(num7.ToString(), out var result3) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result3].ToString();
					}
					double num8 = Pop(stack);
					if (int.TryParse(num8.ToString(), out result3) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result3].ToString();
					}
					if (num7.Equals(double.NaN) || num8.Equals(double.NaN) || num7.Equals("#VALUE!") || num8.Equals("#VALUE!"))
					{
						if (excelLikeComputations)
						{
							stack.Push("#VALUE!");
						}
						else if (num7.Equals(double.NaN) || num8.Equals(double.NaN))
						{
							stack.Push(double.NaN.ToString());
						}
					}
					else if (num7.Equals(double.PositiveInfinity) || num7.Equals(double.NegativeInfinity) || num8.Equals(double.PositiveInfinity) || num8.Equals(double.NegativeInfinity))
					{
						stack.Push(double.NaN.ToString());
					}
					else
					{
						stack.Push((num8 * num7).ToString());
					}
					num++;
					break;
				}
				case 'd':
				{
					double num10 = Pop(stack);
					if (int.TryParse(num10.ToString(), out var result7) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result7].ToString();
					}
					double num11 = Pop(stack);
					if (int.TryParse(num11.ToString(), out result7) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result7].ToString();
					}
					if (num10.Equals(double.NaN) || num11.Equals(double.NaN) || num10.Equals("#VALUE!") || num11.Equals("#VALUE!"))
					{
						if (ExcelLikeComputations)
						{
							stack.Push("#VALUE!");
						}
						else
						{
							stack.Push(double.NaN.ToString());
						}
					}
					else if (num10.Equals(0.0))
					{
						if (ExcelLikeComputations)
						{
							stack.Push(ErrorStrings[3].ToString());
						}
						else if (num11 == 0.0)
						{
							stack.Push(double.NaN.ToString());
						}
						else if (num11 > 0.0)
						{
							stack.Push(double.PositiveInfinity.ToString());
						}
						else
						{
							stack.Push(double.NegativeInfinity.ToString());
						}
					}
					else
					{
						stack.Push((num11 / num10).ToString());
					}
					num++;
					break;
				}
				case 't':
				{
					double y2 = Pop(stack);
					if (int.TryParse(y2.ToString(), out var result6) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result6].ToString();
					}
					double num9 = Pop(stack);
					if (int.TryParse(num9.ToString(), out result6) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result6].ToString();
					}
					stack.Push((num9 * Math.Pow(10.0, y2)).ToString("R"));
					num++;
					break;
				}
				case 'v':
				{
					double num15 = Pop(stack);
					if (int.TryParse(num15.ToString(), out var result13) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result13].ToString();
					}
					double num16 = Pop(stack);
					if (int.TryParse(num16.ToString(), out result13) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result13].ToString();
					}
					stack.Push((num16 * Math.Pow(10.0, 0.0 - num15)).ToString("R"));
					num++;
					break;
				}
				case 'l':
				{
					string text25 = PopString(stack);
					string text26 = PopString(stack);
					string item6 = string.Empty;
					if (text25.Replace(TIC, string.Empty) == string.Empty && treatStringsAsZero)
					{
						text25 = "0";
					}
					if (text26.Replace(TIC, string.Empty) == string.Empty && treatStringsAsZero)
					{
						text26 = "0";
					}
					if (double.TryParse(text25, NumberStyles.Any, null, out var result21) && double.TryParse(text26, NumberStyles.Any, null, out var result22))
					{
						item6 = ((result22 < result21) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					else if (text25.Length > 0 && text25[0] == '#' && ErrorStrings.IndexOf(text25) > -1)
					{
						item6 = text25;
					}
					else if (text26.Length > 0 && text26[0] == '#' && ErrorStrings.IndexOf(text26) > -1)
					{
						item6 = text26;
					}
					else if ((text25.Contains(TIC) || text26.Contains(TIC)) && (double.TryParse(text25.Replace(TIC, string.Empty), out result21) || double.TryParse(text26.Replace(TIC, string.Empty), out result22)))
					{
						if (text25.StartsWith(TIC) && text26.IndexOf(TIC) == -1)
						{
							item6 = TRUEVALUESTR;
						}
						else if (text26.StartsWith(TIC) && text25.IndexOf(TIC) == -1)
						{
							item6 = FALSEVALUESTR;
						}
					}
					else
					{
						item6 = ((text26.ToUpper().Replace(TIC, string.Empty).CompareTo(text25.ToUpper().Replace(TIC, string.Empty)) < 0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					stack.Push(item6);
					num++;
					break;
				}
				case 'g':
				{
					string text11 = PopString(stack);
					string text12 = PopString(stack);
					if (text11.Replace(TIC, string.Empty) == string.Empty)
					{
						text11 = ((!TreatStringsAsZero) ? (text12 + 1) : "0");
					}
					if (text12.Replace(TIC, string.Empty) == string.Empty)
					{
						text12 = ((!TreatStringsAsZero) ? (text11 + 1) : "0");
					}
					string text13 = string.Empty;
					if (double.TryParse(text11, NumberStyles.Any, null, out var result9) && double.TryParse(text12, NumberStyles.Any, null, out var result10))
					{
						text13 = ((result10 > result9) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					if (text13 == string.Empty)
					{
						if (text11.Length > 0 && text11[0] == '#' && ErrorStrings.IndexOf(text11) > -1)
						{
							text13 = text11;
						}
						else if (text12.Length > 0 && text12[0] == '#' && ErrorStrings.IndexOf(text12) > -1)
						{
							text13 = text12;
						}
						else if ((text11.Contains(TIC) || text12.Contains(TIC)) && (double.TryParse(text11.Replace(TIC, string.Empty), out result9) || double.TryParse(text12.Replace(TIC, string.Empty), out result10)))
						{
							if (text11.StartsWith(TIC) && text12.IndexOf(TIC) == -1)
							{
								text13 = FALSEVALUESTR;
							}
							else if (text12.StartsWith(TIC) && text11.IndexOf(TIC) == -1)
							{
								text13 = TRUEVALUESTR;
							}
						}
						else
						{
							text13 = ((text12.ToUpper().Replace(TIC, string.Empty).CompareTo(text11.ToUpper().Replace(TIC, string.Empty)) > 0) ? TRUEVALUESTR : FALSEVALUESTR);
						}
					}
					stack.Push(text13);
					num++;
					break;
				}
				case 'e':
				{
					string text27 = PopString(stack);
					string text28 = PopString(stack);
					string text29 = string.Empty;
					if (TreatStringsAsZero && (text27 == string.Empty || (text27.Replace(TIC, string.Empty) == string.Empty && text28 == string.Empty)))
					{
						text27 = "0";
					}
					if (TreatStringsAsZero && (text28 == string.Empty || (text28.Replace(TIC, string.Empty) == string.Empty && text27 == string.Empty)))
					{
						text28 = "0";
					}
					if (text29 == string.Empty)
					{
						text29 = ((text27.Length > 0 && text27[0] == '#' && ErrorStrings.IndexOf(text27) > -1) ? text27 : ((text28.Length > 0 && text28[0] == '#' && ErrorStrings.IndexOf(text28) > -1) ? text28 : (((text27.Length <= 0 || formulaErrorStrings.IndexOf(text27) <= -1) && (text28.Length <= 0 || formulaErrorStrings.IndexOf(text28) <= -1)) ? (((!text27.StartsWith(TIC) || text28.IndexOf(TIC) != -1) && (!text28.StartsWith(TIC) || text27.IndexOf(TIC) != -1)) ? ((text27.ToUpper() == text28.ToUpper()) ? TRUEVALUESTR : FALSEVALUESTR) : (((double.TryParse(text27.Replace(TIC, string.Empty), out var result23) || double.TryParse(text28.Replace(TIC, string.Empty), out var result24)) && (!double.TryParse(text27.Replace(TIC, string.Empty), out result23) || !double.TryParse(text28.Replace(TIC, string.Empty), out result24))) ? FALSEVALUESTR : ((text27.Replace(TIC, string.Empty).ToUpper() == text28.Replace(TIC, string.Empty).ToUpper()) ? TRUEVALUESTR : FALSEVALUESTR))) : "#VALUE!")));
					}
					stack.Push(text29);
					num++;
					break;
				}
				case 'k':
				{
					string text19 = PopString(stack);
					string text20 = PopString(stack);
					string item3 = string.Empty;
					if (text19.Replace(TIC, string.Empty) == string.Empty && TreatStringsAsZero)
					{
						text19 = "0";
					}
					if (text20.Replace(TIC, string.Empty) == string.Empty && TreatStringsAsZero)
					{
						text20 = "0";
					}
					if (double.TryParse(text19, NumberStyles.Any, null, out var result14) && double.TryParse(text20, NumberStyles.Any, null, out var result15))
					{
						item3 = ((result15 <= result14) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					else if (text19.Length > 0 && text19[0] == '#' && ErrorStrings.IndexOf(text19) > -1)
					{
						item3 = text19;
					}
					else if (text20.Length > 0 && text20[0] == '#' && ErrorStrings.IndexOf(text20) > -1)
					{
						item3 = text20;
					}
					else if ((text19.Contains(TIC) || text20.Contains(TIC)) && (double.TryParse(text19.Replace(TIC, string.Empty), out result14) || double.TryParse(text20.Replace(TIC, string.Empty), out result15)))
					{
						if (text19.StartsWith(TIC) && text20.IndexOf(TIC) == -1)
						{
							item3 = TRUEVALUESTR;
						}
						else if (text20.StartsWith(TIC) && text19.IndexOf(TIC) == -1)
						{
							item3 = FALSEVALUESTR;
						}
					}
					else
					{
						item3 = ((text19.ToUpper().Replace(TIC, string.Empty).CompareTo(text20.ToUpper().Replace(TIC, string.Empty)) <= 0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					stack.Push(item3);
					num++;
					break;
				}
				case 'j':
				{
					string text23 = PopString(stack);
					string text24 = PopString(stack);
					string item5 = string.Empty;
					if (text23.Replace(TIC, string.Empty) == string.Empty && TreatStringsAsZero)
					{
						text23 = "0";
					}
					if (text24.Replace(TIC, string.Empty) == string.Empty && TreatStringsAsZero)
					{
						text24 = "0";
					}
					if (double.TryParse(text23, NumberStyles.Any, null, out var result18) && double.TryParse(text24, NumberStyles.Any, null, out var result19))
					{
						item5 = ((result19 >= result18) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					else if (text23.Length > 0 && text23[0] == '#' && ErrorStrings.IndexOf(text23) > -1)
					{
						item5 = text23;
					}
					else if (text24.Length > 0 && text24[0] == '#' && ErrorStrings.IndexOf(text24) > -1)
					{
						item5 = text24;
					}
					else if ((text23.Contains(TIC) || text24.Contains(TIC)) && (double.TryParse(text23.Replace(TIC, string.Empty), out result18) || double.TryParse(text24.Replace(TIC, string.Empty), out result19)))
					{
						if (text23.StartsWith(TIC) && text24.IndexOf(TIC) == -1)
						{
							item5 = FALSEVALUESTR;
						}
						else if (text24.StartsWith(TIC) && text23.IndexOf(TIC) == -1)
						{
							item5 = TRUEVALUESTR;
						}
					}
					else
					{
						item5 = ((text24.ToUpper().Replace(TIC, string.Empty).CompareTo(text23.ToUpper().Replace(TIC, string.Empty)) >= 0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					stack.Push(item5);
					num++;
					break;
				}
				case 'o':
				{
					string text21 = PopString(stack);
					string text22 = PopString(stack);
					if (TreatStringsAsZero && (text21 == string.Empty || (text21.Replace(TIC, string.Empty) == string.Empty && text22 == string.Empty)))
					{
						text21 = "0";
					}
					if (TreatStringsAsZero && (text22 == string.Empty || (text22.Replace(TIC, string.Empty) == string.Empty && text21 == string.Empty)))
					{
						text22 = "0";
					}
					double result16;
					double result17;
					string item4 = ((double.TryParse(text21, NumberStyles.Any, null, out result16) && double.TryParse(text22, NumberStyles.Any, null, out result17)) ? ((result17 != result16) ? TRUEVALUESTR : FALSEVALUESTR) : ((text21.Length > 0 && text21[0] == '#' && ErrorStrings.IndexOf(text21) > -1) ? text21 : ((text22.Length > 0 && text22[0] == '#' && ErrorStrings.IndexOf(text22) > -1) ? text22 : (((!text21.StartsWith(TIC) || text22.IndexOf(TIC) != -1) && (!text22.StartsWith(TIC) || text21.IndexOf(TIC) != -1)) ? ((text21.ToUpper().Replace(TIC, string.Empty) != text22.ToUpper().Replace(TIC, string.Empty)) ? TRUEVALUESTR : FALSEVALUESTR) : ((double.TryParse(text21.Replace(TIC, string.Empty), out result16) || double.TryParse(text22.Replace(TIC, string.Empty), out result17)) ? TRUEVALUESTR : ((text21.Replace(TIC, string.Empty).ToUpper() != text22.Replace(TIC, string.Empty).ToUpper()) ? TRUEVALUESTR : FALSEVALUESTR))))));
					stack.Push(item4);
					num++;
					break;
				}
				case 'c':
				{
					string text15 = PopString(stack);
					if (text15.Length > 0 && text15[0] == TIC[0] && text15.Length > 1 && text15[text15.Length - 1] == TIC[0])
					{
						text15 = text15.Substring(1, text15.Length - 2);
					}
					string text16 = string.Empty;
					if (stack.Count > 0)
					{
						text16 = PopString(stack);
					}
					if (text16.Length > 0 && text16[0] == TIC[0] && text16.Length > 1 && text16[text16.Length - 1] == TIC[0])
					{
						text16 = text16.Substring(1, text16.Length - 2);
					}
					if (text15 == string.Empty && text16 == string.Empty)
					{
						flag = true;
					}
					if (text15.Length > 0 && text15[0] == '#' && ErrorStrings.IndexOf(text15) > -1)
					{
						stack.Push(text15);
					}
					else if (text16.Length > 0 && text16[0] == '#' && ErrorStrings.IndexOf(text16) > -1)
					{
						stack.Push(text16);
					}
					else
					{
						stack.Push(TIC + text16 + text15 + TIC);
					}
					num++;
					break;
				}
				case '~':
				{
					double y = Pop(stack);
					if (int.TryParse(y.ToString(), out var result4) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result4].ToString();
					}
					double x = Pop(stack);
					if (int.TryParse(x.ToString(), out result4) && isErrorString)
					{
						isErrorString = false;
						return ErrorStrings[result4].ToString();
					}
					stack.Push(Math.Pow(x, y).ToString("R"));
					num++;
					break;
				}
				case '\u0084':
				{
					string text32 = PopString(stack);
					string text33 = PopString(stack);
					double result26;
					if (text32 == string.Empty)
					{
						text32 = FALSEVALUESTR;
					}
					else if (double.TryParse(text32, NumberStyles.Any, null, out result26))
					{
						text32 = ((result26 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					if (text33 == string.Empty)
					{
						text33 = FALSEVALUESTR;
					}
					else if (double.TryParse(text33, NumberStyles.Any, null, out result26))
					{
						text33 = ((result26 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					string item8 = ((text32.Length > 0 && text32[0] == '#' && ErrorStrings.IndexOf(text32) > -1) ? text32 : ((text33.Length <= 0 || text33[0] != '#' || ErrorStrings.IndexOf(text33) <= -1) ? ((text32.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR || text33.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR) ? TRUEVALUESTR : FALSEVALUESTR) : text33));
					stack.Push(item8);
					num++;
					break;
				}
				case '\u0085':
				{
					string text17 = PopString(stack);
					string text18 = PopString(stack);
					double result12;
					if (text17 == string.Empty)
					{
						text17 = FALSEVALUESTR;
					}
					else if (double.TryParse(text17, NumberStyles.Any, null, out result12))
					{
						text17 = ((result12 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					if (text18 == string.Empty)
					{
						text18 = FALSEVALUESTR;
					}
					else if (double.TryParse(text18, NumberStyles.Any, null, out result12))
					{
						text18 = ((result12 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					string item2 = ((text17.Length > 0 && text17[0] == '#' && ErrorStrings.IndexOf(text17) > -1) ? text17 : ((text18.Length <= 0 || text18[0] != '#' || ErrorStrings.IndexOf(text18) <= -1) ? ((text17.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR && text18.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR) ? TRUEVALUESTR : FALSEVALUESTR) : text18));
					stack.Push(item2);
					num++;
					break;
				}
				case '\u0086':
				{
					string text30 = PopString(stack);
					string text31 = PopString(stack);
					double result25;
					if (text30 == string.Empty)
					{
						text30 = FALSEVALUESTR;
					}
					else if (double.TryParse(text30, NumberStyles.Any, null, out result25))
					{
						text30 = ((result25 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					if (text31 == string.Empty)
					{
						text31 = FALSEVALUESTR;
					}
					else if (double.TryParse(text31, NumberStyles.Any, null, out result25))
					{
						text31 = ((result25 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					string item7 = ((text30.Length > 0 && text30[0] == '#' && ErrorStrings.IndexOf(text30) > -1) ? text30 : ((text31.Length <= 0 || text31[0] != '#' || ErrorStrings.IndexOf(text31) <= -1) ? (((text30.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR && text31.ToUpper().Replace(TIC, string.Empty) != TRUEVALUESTR) || (text31.ToUpper().Replace(TIC, string.Empty) == TRUEVALUESTR && text30.ToUpper().Replace(TIC, string.Empty) != TRUEVALUESTR)) ? TRUEVALUESTR : FALSEVALUESTR) : text31));
					stack.Push(item7);
					num++;
					break;
				}
				case '\u008a':
				{
					string text10 = PopString(stack);
					double result5;
					if (text10 == string.Empty)
					{
						text10 = FALSEVALUESTR;
					}
					else if (double.TryParse(text10, NumberStyles.Any, null, out result5))
					{
						text10 = ((result5 != 0.0) ? TRUEVALUESTR : FALSEVALUESTR);
					}
					string item = ((text10.Length <= 0 || text10[0] != '#' || ErrorStrings.IndexOf(text10) <= -1) ? ((text10.ToUpper().Replace(TIC, string.Empty) == FALSEVALUESTR) ? TRUEVALUESTR : FALSEVALUESTR) : text10);
					stack.Push(item);
					num++;
					break;
				}
				default:
					computedValueLevel = 0;
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_expression]);
					}
					return ErrorStrings[1].ToString();
				}
			}
			if (checkDanglingStack && stack.Count > 1 && formula.Length > 1 && (!formula.StartsWith('\u0092'.ToString()) || !formula.EndsWith('\u0092'.ToString()) || formula.IndexOf(BMARKER2) > -1))
			{
				computedValueLevel = 0;
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(FormulaErrorStrings[improper_formula]);
				}
				return FormulaErrorStrings[improper_formula];
			}
			if (stack.Count == 0)
			{
				return string.Empty;
			}
			string text34 = string.Empty;
			int num19 = stack.Count;
			bool flag5 = false;
			do
			{
				if (stack.Count > 1 && IsAreaCalculation)
				{
					text34 = parseArgumentSeparator + stack.Pop().ToString() + text34;
				}
				else
				{
					string text35 = stack.Pop().ToString();
					if (ErrorStrings.Contains(text35))
					{
						text34 = text35;
						break;
					}
					text34 = text35 + text34;
				}
				if (text34 == string.Empty && IsCellReference(formula) && treatStringsAsZero && !flag)
				{
					text34 = "0";
				}
				if (!checkDanglingStack && double.TryParse(text34, out var _))
				{
					return text34;
				}
				if (text34.Contains("~") && isDoubleQuotes)
				{
					text34 = text34.Replace("~", TIC + TIC);
				}
				num19--;
			}
			while (num19 > 0 && !text34.Contains(FALSEVALUESTR) && !text34.Contains(TRUEVALUESTR));
			if (isDoubleQuotes && flag5)
			{
				isDoubleQuotes = false;
			}
			if (text34.Contains(TIC + TIC) && !text34.Equals(TIC + TIC) && !multiTick)
			{
				text34 = text34.Replace(TIC + TIC, TIC);
			}
			if (ErrorStrings.Contains(text34))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException("bad formula");
				}
				return text34;
			}
			return text34;
		}
		catch (Exception ex2)
		{
			ExceptionThrown = true;
			computedValueLevel = 0;
			if (ex2.Message.IndexOf(FormulaErrorStrings[circular_reference_]) > -1 || (rethrowLibraryComputationExceptions && LibraryComputationException != null))
			{
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				throw ex2;
			}
			if (ex2.Message.IndexOf(FormulaErrorStrings[cell_empty]) > -1)
			{
				return string.Empty;
			}
			if (RethrowLibraryComputationExceptions)
			{
				libraryComputationException = ex2;
				throw ex2;
			}
			return ex2.Message;
		}
		finally
		{
			computedValueLevel--;
			if (computedValueLevel < 0)
			{
				computedValueLevel = 0;
			}
		}
	}

	private string ProcessUpperCase(ref string formula, ref int i, ref string sheet)
	{
		string text = string.Empty;
		while (i < formula.Length && (char.IsUpper(formula[i]) || formula[i] == ' '))
		{
			text += formula[i];
			i++;
		}
		while (i < formula.Length && char.IsDigit(formula[i]))
		{
			text += formula[i];
			i++;
		}
		if (supportRangeOperands && i < formula.Length && formula[i] == ':')
		{
			text += formula[i];
			i++;
			if (i < formula.Length && formula[i] == '!')
			{
				text += formula[i];
				i++;
				while (i < formula.Length && formula[i] != '!')
				{
					text += formula[i];
					i++;
				}
			}
			while (i < formula.Length && char.IsUpper(formula[i]))
			{
				text += formula[i];
				i++;
			}
			while (i < formula.Length && char.IsDigit(formula[i]))
			{
				text += formula[i];
				i++;
			}
			text = (IsAreaCalculation ? (sheet + text) : ((!ErrorStrings.Contains(GetCellFrom(text))) ? (sheet + GetCellFrom(text)) : GetCellFrom(text)));
			sheet = string.Empty;
		}
		else
		{
			text = sheet + text;
			sheet = string.Empty;
		}
		return text;
	}

	private void ComputeEnsureIFCall(ref string formula)
	{
		int num = 0;
		int num2 = -1;
		do
		{
			if (num >= formula.Length || (num = formula.IndexOf(IFMarker, num)) <= -1)
			{
				continue;
			}
			num2 = MatchingRightBracket(formula.Substring(num));
			if (num2 <= -1)
			{
				continue;
			}
			LibraryFunction libraryFunction = (LibraryFunction)LibraryFunctions["IF"];
			string s = string.Empty;
			try
			{
				s = libraryFunction(formula.Substring(num + IFMarker.Length, num2 - IFMarker.Length));
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					libraryComputationException = ex;
					throw ex;
				}
			}
			MarkupResultToIncludeInFormula(ref s);
			string text = string.Empty;
			if (num + num2 + 1 < formula.Length)
			{
				text = formula.Substring(num + num2 + 1);
			}
			formula = formula.Substring(0, num) + s + text;
		}
		while (formula.Contains(IFMarker) && num2 > -1);
	}

	private void ComputeShortCircuitIFFormula(ref string formula)
	{
		int num = 0;
		int location = -1;
		do
		{
			if (num >= formula.Length || (num = formula.IndexOf(IFMarker, num)) <= -1)
			{
				continue;
			}
			if (num != 0)
			{
				ComputeInteriorFunctions(formula);
			}
			else
			{
				location = MatchingRightBracket(formula.Substring(num));
			}
			if (location <= -1)
			{
				continue;
			}
			string s = string.Empty;
			int num2 = formula.IndexOf(IFMarker, location);
			try
			{
				do
				{
					location = num;
					Dictionary<object, object> dictionary = SaveStrings(ref formula);
					FindNextSeparator(formula, ref location);
					string text = formula.Substring(num + IFMarker.Length, location - IFMarker.Length - 1);
					List<string> list = new List<string>();
					int location2 = 0;
					while (location2 < text.Length)
					{
						if (FindNextSeparator(text, ref location2))
						{
							list.Add(text.Substring(0, location2));
							text = text.Substring(location2 + 1);
							location2 = 0;
						}
						else if (location2 > 0)
						{
							list.Add(text.Substring(0, location2));
						}
					}
					string text2 = string.Empty;
					if (dictionary != null && dictionary.Count > 0)
					{
						List<string> list2 = new List<string>();
						int num3 = 0;
						foreach (string item in list)
						{
							string retValue = item;
							SetStrings(ref retValue, dictionary);
							if (IsArrayFormula)
							{
								text2 = ((num3 >= list.Count - 1) ? (text2 + retValue) : (text2 + retValue + ","));
								num3++;
							}
							list2.Add(retValue);
						}
						list = list2;
					}
					double result = 0.0;
					if (list.Count == 0 && (list.IndexOf(":") == -1 || list.IndexOf(parseArgumentSeparator.ToString()) == -1))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[requires_3_args]);
						}
						s = FormulaErrorStrings[requires_3_args];
					}
					if (!double.TryParse(list[0], out result))
					{
						if (ErrorStrings.Contains(list[0]))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							s = list[0];
						}
						if ((!IsCellReference(list[0]) && !bool.TryParse(list[0].Replace(TIC, string.Empty), out var _) && list[0].StartsWith(TIC)) || (IsCellReference(list[0]) && list[0].StartsWith(TIC)))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							s = ErrorStrings[1].ToString();
						}
					}
					if (IsArrayFormula && list[0].IndexOf(':') > -1 && IsRange(list[0]))
					{
						s = ArrayParser.ComputeInteriorFunction(text2, "IF", computeFunctionLevel);
					}
					else if (list.Count == 2 || list.Count == 3)
					{
						if (list[0].Contains("qINDEX"))
						{
							isIndexInteriorFormula = true;
							hitCount = computedValueLevel;
						}
						string valueFromArg = GetValueFromArg(list[0]);
						bool flag = false;
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							s = valueFromArg;
							flag = true;
						}
						if (hitCount == computedValueLevel)
						{
							isIndexInteriorFormula = false;
						}
						if (valueFromArg == TRUEVALUESTR || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0))
						{
							s = GetValueFromArg(list[1]);
							if (string.IsNullOrEmpty(s) && TreatStringsAsZero)
							{
								s = GetExactResultsFromCellReference(list[1], s);
							}
							else if (!string.IsNullOrEmpty(s) && s[0] == TIC[0] && !IsCellReference(list[1]))
							{
								s = Regex.Replace(s, "^\"|\"$", "");
							}
						}
						else if (list.Count == 2 && (valueFromArg.Replace(TIC, string.Empty).ToUpper().Equals(FALSEVALUESTR) || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result == 0.0)))
						{
							s = FALSEVALUESTR;
						}
						else if (!flag)
						{
							s = GetValueFromArg(list[2]);
							if (string.IsNullOrEmpty(s) && TreatStringsAsZero)
							{
								s = GetExactResultsFromCellReference(list[2], s);
							}
							else if (!string.IsNullOrEmpty(s) && s[0] == TIC[0] && !IsCellReference(list[2]))
							{
								s = ((list.Count == 3) ? s : FALSEVALUESTR);
								s = Regex.Replace(s, "^\"|\"$", "");
							}
						}
						flag = false;
					}
					else
					{
						if (rethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[requires_3_args]);
						}
						s = FormulaErrorStrings[requires_3_args];
					}
					num2 = formula.IndexOf(IFMarker, location);
				}
				while (formula.Contains(IFMarker) && num2 > -1);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					libraryComputationException = ex;
					throw ex;
				}
			}
			MarkupResultToIncludeInFormula(ref s);
			string text3 = string.Empty;
			if (num + location + 1 < formula.Length)
			{
				text3 = formula.Substring(num + location + 1);
			}
			formula = formula.Substring(0, num) + s + text3;
		}
		while (formula.Contains(IFMarker) && location > -1);
	}

	internal string GetExactResultsFromCellReference(string cellReference, string result)
	{
		string empty = string.Empty;
		empty = (cellReference.StartsWith('!'.ToString()) ? cellReference : string.Concat("!" + GetSheetID(grid) + "!", cellReference));
		int row = RowIndex(empty);
		int col = ColIndex(empty);
		string empty2 = string.Empty;
		FormulaInfo formulaInfo = (FormulaInfoTable.ContainsKey(empty) ? (FormulaInfoTable[empty] as FormulaInfo) : null);
		empty2 = ((formulaInfo == null) ? grid.GetValueRowCol(row, col).ToString() : formulaInfo.FormulaText);
		if (string.IsNullOrEmpty(empty2))
		{
			return "0";
		}
		return result;
	}

	internal string ComputeInteriorFunctions(string formula)
	{
		try
		{
			if (TextIsEmpty(formula))
			{
				return formula;
			}
			computeFunctionLevel++;
			for (int num = FindLastqNotInBrackets(formula); num > 0; num = FindLastqNotInBrackets(formula))
			{
				int num2 = formula.Substring(num).IndexOf(RIGHTBRACKET);
				if (num2 == -1)
				{
					return FormulaErrorStrings[bad_formula];
				}
				string text = formula.Substring(num, num2 + 1);
				int num3 = FindLastqNotInBrackets(formula.Substring(0, num));
				string text2 = ((num3 >= 0) ? formula.Substring(num3, formula.Substring(num3).IndexOf(RIGHTBRACKET)) : string.Empty);
				if ((text.Contains("qVALUE") || text.Contains("qINT") || text.Contains("qROW")) && text2.Contains("SUMPRODUCT"))
				{
					exteriorFormula = true;
				}
				if (text2.Contains("qINDEX") && (text2.Contains("qCELL") || text2.Contains("qCOUNT") || text2.Contains("qOFFSET") || text2.Contains("qSUM")))
				{
					isIndexInteriorFormula = true;
					if (text.StartsWith("qINDEX"))
					{
						hitCount = computedValueLevel + 1;
					}
				}
				if (formula.StartsWith("qIF") && text2.Contains("qVLOOKUP"))
				{
					vlookupInsideIFFormula = true;
				}
				text = ComputedValue(text);
				if (!string.IsNullOrEmpty(text) && text[0] == TIC[0] && text[text.Length - 1] == TIC[0])
				{
					string text3 = text.Substring(1, text.Length - 2);
					if (text3.IndexOf(TIC) != -1)
					{
						multiTick = true;
						text3 = text3.Replace(TIC, "|");
					}
					text = TIC + text3 + TIC;
				}
				if (!isInteriorFunction)
				{
					MarkupResultToIncludeInFormula(ref text);
				}
				isInteriorFunction = false;
				formula = formula.Substring(0, num) + text + formula.Substring(num + num2 + 1);
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
			{
				throw LibraryComputationException;
			}
			return ex.Message;
		}
		finally
		{
			computeFunctionLevel--;
		}
		if (computeFunctionLevel == 0 && vlookupInsideIFFormula)
		{
			vlookupInsideIFFormula = false;
		}
		return formula;
	}

	public string ComputeFormula(string parsedFormula)
	{
		if (throwCircularException)
		{
			if (iterationMaxCount > 0)
			{
				if (computedValueLevel == 0)
				{
					circCheckList.Clear();
					circCheckList.Add(cell);
				}
				else if (circCheckList.IndexOf(cell) > -1)
				{
					if (!IterationValues.ContainsKey(cell))
					{
						IterationValues.Add(cell, "0");
					}
					return IterationValues[cell].ToString();
				}
			}
			else
			{
				if (computedValueLevel == 0)
				{
					circCheckList.Clear();
				}
				else if (circCheckList.IndexOf(cell) > -1)
				{
					computedValueLevel = 0;
					circCheckList.Clear();
					throw new ArgumentException(FormulaErrorStrings[circular_reference_]);
				}
				circCheckList.Add(cell);
			}
		}
		string text = ComputedValue(parsedFormula);
		if (UseNoAmpersandQuotes && text.Length > 1 && text[0] == TIC[0] && text[text.Length - 1] == TIC[0])
		{
			text = text.Substring(1, text.Length - 2);
		}
		return text;
	}

	public string PullUpdatedValue(string cellRef)
	{
		bool flag = false;
		inAPull = true;
		multiTick = false;
		ICalcData calcData = grid;
		string text = cell;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		string text2 = cellRef.ToUpper();
		int num;
		if ((num = text2.IndexOf('!')) == -1 && cell != string.Empty)
		{
			num = cell.IndexOf('!', 1);
			if (num > -1 && sheetFamilyItem.TokenToParentObject != null)
			{
				text2 = cell.Substring(0, num + 1) + text2;
				grid = (ICalcData)sheetFamilyItem.TokenToParentObject[cell.Substring(0, num + 1)];
			}
		}
		else if (num > 0 && sheetFamilyItem.SheetNameToToken != null && sheetFamilyItem.TokenToParentObject != null)
		{
			string text3 = sheetFamilyItem.SheetNameToToken[text2.Substring(0, num)] as string;
			text2 = text3 + text2.Substring(num + 1);
			grid = (ICalcData)sheetFamilyItem.TokenToParentObject[text3];
			cell = text2;
		}
		UpdateCalcID();
		string valueFromParentObject;
		if (!DependentFormulaCells.ContainsKey(text2) && !FormulaInfoTable.ContainsKey(text2))
		{
			valueFromParentObject = GetValueFromParentObject(text2);
			while (breakedFormulaCells.Count == 1)
			{
				UpdateCalcID();
				valueFromParentObject = GetValueFromParentObject(breakedFormulaCells[0].ToString());
				breakedFormulaCells.RemoveAt(0);
				UseFormulaValues = true;
			}
			if (UseFormulaValues)
			{
				flag = true;
				UseFormulaValues = false;
			}
			if (tempBreakedFormulaCells.Count > 0)
			{
				for (int i = 1; i <= tempBreakedFormulaCells.Count; i++)
				{
					valueFromParentObject = GetValueFromParentObject(tempBreakedFormulaCells[tempBreakedFormulaCells.Count - i].ToString());
				}
				tempBreakedFormulaCells.Clear();
				valueFromParentObject = GetValueFromParentObject(text2);
			}
			UseFormulaValues = flag;
			bool ignoreValueChanged = IgnoreValueChanged;
			IgnoreValueChanged = true;
			int row = RowIndex(text2);
			int col = ColIndex(text2);
			if (PreserveFormula)
			{
				string text4 = SheetToken(cellRef);
				if (text4.Equals(string.Empty))
				{
					text4 = "!" + GetSheetID(grid) + "!";
					FormulaInfo formulaInfo = (FormulaInfoTable.ContainsKey(text4 + text2) ? (FormulaInfoTable[text4 + text2] as FormulaInfo) : null);
					if (formulaInfo != null)
					{
						grid.SetValueRowCol(formulaInfo.FormulaText, row, col);
					}
				}
				else
				{
					grid.SetValueRowCol(valueFromParentObject, row, col);
				}
			}
			else
			{
				grid.SetValueRowCol(valueFromParentObject, row, col);
			}
			IgnoreValueChanged = ignoreValueChanged;
		}
		else
		{
			processedCells.Clear();
			UpdateDependenciesAndCell(text2);
			processedCells.Clear();
			valueFromParentObject = GetValueFromParentObject(text2);
		}
		grid = calcData;
		cell = text;
		inAPull = false;
		return valueFromParentObject;
	}

	public void PullUpdatedValue(int targetSheetID, int row, int col)
	{
		ICalcData calcData = grid;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		string text = "!" + targetSheetID + "!";
		grid = sheetFamilyItem.TokenToParentObject[text] as ICalcData;
		inAPull = true;
		string text2 = text + RangeInfo.GetAlphaLabel(col) + row;
		UpdateCalcID();
		if (!DependentFormulaCells.ContainsKey(text2) && !FormulaInfoTable.ContainsKey(text2))
		{
			string valueFromParentObject = GetValueFromParentObject(text2);
			bool ignoreValueChanged = IgnoreValueChanged;
			IgnoreValueChanged = true;
			grid.SetValueRowCol(valueFromParentObject, row, col);
			IgnoreValueChanged = ignoreValueChanged;
		}
		else
		{
			processedCells.Clear();
			UpdateDependenciesAndCell(text2);
			processedCells.Clear();
		}
		grid = calcData;
		inAPull = false;
	}

	internal void grid_ValueChanged(object sender, ValueChangedEventArgs e)
	{
		ExceptionThrown = false;
		if (IgnoreValueChanged)
		{
			return;
		}
		ICalcData calcData = sender as ICalcData;
		grid = sender as ICalcData;
		bool flag = true;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(calcData);
		string text = RangeInfo.GetAlphaLabel(e.ColIndex) + e.RowIndex;
		if (sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.Count > 0)
		{
			string text2 = string.Empty;
			object value = null;
			sheetFamilyItem.ParentObjectToToken.TryGetValue(grid, out value);
			if (value != null)
			{
				text2 = value.ToString();
			}
			text = text2 + text;
		}
		if (e.Value.Length > 0 && e.Value[0] == FormulaCharacter)
		{
			cell = text;
			bool flag2 = true;
			FormulaInfo formulaInfo;
			if (FormulaInfoTable.ContainsKey(text))
			{
				formulaInfo = FormulaInfoTable[text] as FormulaInfo;
				if (e.Value != formulaInfo.FormulaText || formulaInfo.ParsedFormula == null)
				{
					formulaInfo.FormulaText = e.Value;
					if (DependentFormulaCells.ContainsKey(cell))
					{
						ClearFormulaDependentCells(cell);
					}
					try
					{
						formulaInfo.ParsedFormula = ParseFormula(e.Value);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						formulaInfo.FormulaValue = ex.Message;
						flag2 = false;
					}
				}
				if (flag2)
				{
					string text3 = ComputeFormula(formulaInfo.ParsedFormula);
					flag = text3 != formulaInfo.FormulaValue || forceRefreshCall;
					formulaInfo.FormulaValue = text3;
				}
				formulaInfo.calcID = calcID;
			}
			else
			{
				formulaInfo = new FormulaInfo();
				formulaInfo.FormulaText = e.Value;
				if (!DependentFormulaCells.ContainsKey(text))
				{
					DependentFormulaCells.Add(text, new Dictionary<object, object>());
				}
				try
				{
					formulaInfo.ParsedFormula = ParseFormula(e.Value);
				}
				catch (Exception ex2)
				{
					ExceptionThrown = true;
					formulaInfo.FormulaValue = ex2.Message;
					flag2 = false;
				}
				if (flag2)
				{
					formulaInfo.FormulaValue = ComputeFormula(formulaInfo.ParsedFormula);
				}
				formulaInfo.calcID = calcID;
				if (FormulaInfoTable.ContainsKey(text))
				{
					FormulaInfoTable[text] = formulaInfo;
				}
				else
				{
					FormulaInfoTable.Add(text, formulaInfo);
				}
			}
			if (iterationMaxCount > 0 && flag2 && !inHandleIterations && text == cell)
			{
				HandleIterations(formulaInfo);
			}
			bool ignoreValueChanged = IgnoreValueChanged;
			IgnoreValueChanged = true;
			calcData.SetValueRowCol(formulaInfo.FormulaValue, e.RowIndex, e.ColIndex);
			IgnoreValueChanged = ignoreValueChanged;
		}
		else if (!inRecalculateRange && FormulaInfoTable.ContainsKey(text))
		{
			FormulaInfoTable.Remove(text);
			if (DependentFormulaCells.ContainsKey(text))
			{
				ClearFormulaDependentCells(text);
			}
		}
		if (flag && DependentCells.ContainsKey(text))
		{
			dependencyLevel = 0;
			Refresh(text);
		}
	}

	public void UpdateCalcID()
	{
		calcID++;
		if (calcID == int.MaxValue)
		{
			calcID = -2147483647;
		}
	}

	public void Refresh(string s)
	{
		if (CalculatingSuspended)
		{
			return;
		}
		if (dependencyLevel == 0)
		{
			refreshedCells.Clear();
		}
		if (!DependentCells.ContainsKey(s) || DependentCells[s] == null)
		{
			return;
		}
		dependencyLevel++;
		try
		{
			GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
			List<object> obj = (List<object>)DependentCells[s];
			bool flag = lockDependencies;
			lockDependencies = true;
			foreach (object item in obj)
			{
				if (!(item is string text))
				{
					continue;
				}
				ICalcData calcData = grid;
				string text2 = SheetToken(text);
				if (text2.Length > 0)
				{
					grid = sheetFamilyItem.TokenToParentObject[text2] as ICalcData;
				}
				try
				{
					int row = RowIndex(text);
					int col = ColIndex(text);
					FormulaInfo formulaInfo = (FormulaInfoTable.ContainsKey(text) ? (FormulaInfoTable[text] as FormulaInfo) : null);
					if (formulaInfo != null)
					{
						string text3 = cell;
						cell = text;
						if (AlwaysComputeDuringRefresh || formulaInfo.calcID != calcID || formulaInfo.FormulaValue == string.Empty)
						{
							string text4 = ComputeFormula(formulaInfo.ParsedFormula);
							if (text4 != formulaInfo.FormulaValue && refreshedCells.ContainsKey(text))
							{
								refreshedCells.Remove(text);
							}
							formulaInfo.FormulaValue = text4;
						}
						formulaInfo.calcID = calcID;
						cell = text3;
						bool ignoreValueChanged = IgnoreValueChanged;
						IgnoreValueChanged = true;
						grid.SetValueRowCol(formulaInfo.FormulaValue, row, col);
						IgnoreValueChanged = ignoreValueChanged;
						if (!refreshedCells.ContainsKey(text))
						{
							refreshedCells.Add(text, 0);
							Refresh(text);
						}
					}
				}
				catch
				{
					continue;
				}
				grid = calcData;
			}
			lockDependencies = flag;
		}
		finally
		{
			if (!refreshedCells.ContainsKey(s))
			{
				refreshedCells.Add(s, 0);
			}
			dependencyLevel--;
			if (dependencyLevel == 0)
			{
				refreshedCells.Clear();
			}
		}
	}

	public string ComputeDCount(string args)
	{
		int num = 0;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeDCountA(string args)
	{
		int num = 0;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeDAverage(string args)
	{
		double num = 0.0;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeDGet(string args)
	{
		string empty = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDMax(string args)
	{
		string empty = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDMin(string args)
	{
		string empty = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDProduct(string args)
	{
		double num = 1.0;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeDVar(string args)
	{
		string empty = string.Empty;
		_ = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDVarp(string args)
	{
		string empty = string.Empty;
		_ = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDStdev(string args)
	{
		string empty = string.Empty;
		_ = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDStdevp(string args)
	{
		string empty = string.Empty;
		_ = string.Empty;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			return empty;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
	}

	public string ComputeDSum(string args)
	{
		double num = 0.0;
		try
		{
			if (SplitArgsPreservingQuotedCommas(args).Length < 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeAcsch(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.StartsWith(TIC) && argList.EndsWith(TIC))
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		if (argList == string.Empty)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text = argList;
			text = (text.Contains("u") ? text.Replace("u", string.Empty) : text);
			if (Convert.ToDouble(text) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			if (double.TryParse(argList, out var result))
			{
				return Math.Log(((double)Math.Sign(result) * Math.Sqrt(result * result + 1.0) + 1.0) / result).ToString();
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[5].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeBigMul(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.Contains(TIC))
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		if (ComputeIsNumber(argList[0].ToString()) != TRUEVALUESTR && ComputeIsNumber(argList[1].ToString()) != TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		if (argList.Length > 150)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		int num = Convert.ToInt32(GetValueFromArg(array[0]));
		int num2 = Convert.ToInt32(GetValueFromArg(array[1]));
		try
		{
			return (num * num2).ToString().ToString();
		}
		catch
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
	}

	private long DivRem(long a, long b, out long divRem)
	{
		long num = a / b;
		divRem = a - b * num;
		return num;
	}

	public string ComputeDivRem(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.Length > 15)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		int num = Convert.ToInt32(GetValueFromArg(array[0]));
		int num2 = Convert.ToInt32(GetValueFromArg(array[1]));
		long divRem = 0L;
		try
		{
			return DivRem(num, num2, out divRem).ToString();
		}
		catch
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeIEEERemainder(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.Length > 15)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[27].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		double x = Convert.ToDouble(GetValueFromArg(array[0]));
		double y = Convert.ToDouble(GetValueFromArg(array[1]));
		return Math.IEEERemainder(x, y).ToString();
	}

	private double NormalCumulativeDistribution(double x, double mean, double standardDeviation)
	{
		double x2 = (x - mean) / standardDeviation;
		return StandardNormalCumulativeDistribution(x2);
	}

	private double FCumulativeDistributionInverse(double p, int k1, int k2)
	{
		if (k1 <= 4 || k2 <= 4)
		{
			throw new ArgumentException("k1 and k2 must be greater than 4.");
		}
		if (p < 0.0 || p > 1.0)
		{
			throw new ArgumentException("Probability must be between 0 and 1");
		}
		if (p == 0.0)
		{
			return 0.0;
		}
		if (p == 1.0)
		{
			return double.PositiveInfinity;
		}
		double mean = (double)k2 / ((double)k2 - 2.0);
		double standardDeviation = (double)(2 * k2 * k2) * ((double)(k1 + k2) - 2.0) / ((double)k1 * ((double)k2 - 2.0) * ((double)k2 - 2.0) * ((double)k2 - 4.0));
		double num = Math.Max(0.0, NormalCumulativeDistributionInverse(p, mean, standardDeviation));
		double val = ((k1 < 10 && k2 < 10) ? ((!(p < 0.03)) ? (0.1819022 * num + 6.0340494 * Math.Log(p) / Math.Sqrt(k1 + k2) - 10.4102348 / Math.Sqrt(k1 + k2) - 3.8062818 * Math.Log(p) / (double)k2 - 2.1284338 * Math.Log(p) / (double)k1 - 0.0446516 * (double)k2 - 0.1014539 * (double)k1 - 7.980049829 * p + 7.988783845 * p * p + 6.864968931) : 0.1592355) : ((k1 < 10) ? (0.8100214 * num + 3.1485113 * Math.Log(p) / Math.Sqrt(k1 + k2) - 5.6399235 / Math.Sqrt(k1 + k2) - 6.8494933 * Math.Log(p) / (double)k2 - 0.5725057 * Math.Log(p) / (double)k1 - 0.0102242 * (double)k2 - 0.0099565 * (double)k1 - 2.8208596 * p + 3.0360586 * p * p + 2.103689) : ((k2 >= 10) ? (0.8717865 * num + 0.9139534 * Math.Log(p) / Math.Sqrt(k1 + k2) - 0.0864391 / Math.Sqrt(k1 + k2) - 1.5438103 * Math.Log(p) / (double)k2 - 0.1495274 * Math.Log(p) / (double)k1 + 0.0004922 * (double)k2 - 0.0003965 * (double)k1 - 0.6362346 * p + 1.1776505 * p * p + 0.1039345) : (0.1944974 * num + 5.5846823 * Math.Log(p) / Math.Sqrt(k1 + k2) - 2.6254457 / Math.Sqrt(k1 + k2) - 0.7057866 * Math.Log(p) / (double)k2 - 6.4964935 * Math.Log(p) / (double)k1 + 0.0048548 * (double)k2 - 0.0088253 * (double)k1 - 6.523519381 * p + 6.710305803 * p * p + 3.305158009))));
		val = Math.Max(1E-05, val);
		double num2 = double.MaxValue;
		double num3 = 0.0;
		for (int i = 0; i < 16; i++)
		{
			double num4 = FCumulativeDensity(val, k1, k2);
			double num5 = Math.Abs(p - num4);
			if (num5 < 0.0001)
			{
				return val;
			}
			if (num5 > num2)
			{
				val -= 0.5 * num3;
				num4 = FCumulativeDensity(val, k1, k2);
				num5 = Math.Abs(p - num4);
			}
			num2 = num5;
			double num6 = val;
			double num7 = FProbabilityDensity(val, k1, k2);
			num3 = (p - num4) / num7;
			if (num3 < 0.0 - val)
			{
				num3 = -0.5 * val;
			}
			if (num3 > 1.0)
			{
				num3 = 1.0;
			}
			val += num3;
			if (val < 0.0)
			{
				val = 0.5 * num6;
			}
		}
		throw new Exception("Solution did not converge");
	}

	private double DerivativeOfFProbabilityDensity(double x, double k1, double k2, double pdf)
	{
		double num = k1 * k2 * (1.0 - x) / (k1 * x + k2);
		return pdf * (1.0 / x) * (0.5 * num - 1.0);
	}

	private double NormalCumulativeDistributionInverse(double p, double mean, double standardDeviation)
	{
		double num = StandardNormalCumulativeDistributionInverse(p);
		return standardDeviation * num + mean;
	}

	public string ComputeReplaceB(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int result = 0;
		int result2 = 0;
		if (length != 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = StripTics0(GetValueFromArg(array[0]));
		string text2 = StripTics0(GetValueFromArg(array[3]));
		string empty = string.Empty;
		if (int.TryParse(GetValueFromArg(array[1]), out result) && int.TryParse(GetValueFromArg(array[2]), out result2))
		{
			try
			{
				string empty2 = string.Empty;
				if (string.IsNullOrEmpty(text))
				{
					return text2;
				}
				if (text.Length <= result && result > result2)
				{
					return text + text2;
				}
				if (text.Length <= result)
				{
					empty2 = text;
					return text.Replace(empty2, text2);
				}
				empty2 = text.Substring(result, result2);
				return text.Replace(empty2, text2);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw ex;
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeBahtText(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length > 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 0.0;
		if (!double.TryParse(GetValueFromArg(array[0]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		string input = Spell((int)result) + " baht";
		string languagePair = "en|th";
		return TranslateText(input, languagePair);
	}

	public string ComputeLogest(string range)
	{
		string[] array = range.Split(new char[1] { ParseArgumentSeparator });
		int length = array.GetLength(0);
		bool flag = length == 1;
		if (length == 0 || length > 4)
		{
			string[] array2 = range.Split(new char[1] { TIC[0] });
			List<string> list = new List<string>();
			for (int i = 0; i < array2.Length; i++)
			{
				if (i % 2 != 0)
				{
					list.Add(array2[i]);
				}
			}
			array = list.ToArray();
			length = array.GetLength(0);
			flag = length == 1;
			if (length == 0 || length > 4)
			{
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] array3 = null;
		array3 = ((length <= 1 || !(array[1] == string.Empty)) ? (flag ? new double[doubleArray.GetLength(0)] : GetDoubleArray(array[1])) : doubleArray);
		int length2 = array3.GetLength(0);
		if (length2 <= 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (flag)
		{
			for (int j = 0; j < length2; j++)
			{
				array3[j] = j + 1;
			}
		}
		for (int k = 0; k < length2; k++)
		{
			doubleArray[k] = Math.Log10(doubleArray[k]);
		}
		double m = 0.0;
		double b = 1.0;
		ComputeLogestMB(doubleArray, array3, out m, out b);
		return m.ToString();
	}

	public string ComputeLogestb(string range)
	{
		string[] array = range.Split(new char[1] { ParseArgumentSeparator });
		int length = array.GetLength(0);
		bool flag = length == 1;
		if (length == 0 || length > 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] array2 = (flag ? new double[doubleArray.GetLength(0)] : GetDoubleArray(array[1]));
		int length2 = array2.GetLength(0);
		if (length2 <= 2 || length2 != doubleArray.GetLength(0))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (flag)
		{
			for (int i = 0; i < length2; i++)
			{
				array2[i] = i + 1;
			}
		}
		for (int j = 0; j < length2; j++)
		{
			doubleArray[j] = Math.Log10(doubleArray[j]);
		}
		double m = 0.0;
		double b = 1.0;
		ComputeLogestMB(doubleArray, array2, out m, out b);
		return b.ToString();
	}

	public static double[] MostRecentValues(double[] inArray, int length)
	{
		if (inArray.Length == length)
		{
			return inArray;
		}
		if (inArray.Length < length)
		{
			throw new ArgumentException("length of inArray must be greater than or equal to length");
		}
		double[] array = new double[length];
		Array.Copy(inArray, array, length);
		return array;
	}

	public double Mean(double[] array, double decayFactor, int length)
	{
		return Mean(MostRecentValues(array, length), decayFactor);
	}

	public double WeightedMean(double[] valueArray, double[] weightArray)
	{
		if (valueArray.Length != weightArray.Length)
		{
			throw new ArgumentException("valueArray and weightArray must have the same number of elements");
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < valueArray.Length; i++)
		{
			num += valueArray[i] * weightArray[i];
			num2 += weightArray[i];
		}
		return num / num2;
	}

	public static double UniformCumulativeDensityFunction(double x, double min, double max)
	{
		if (max <= min)
		{
			throw new ArgumentException("max must be greater than min");
		}
		return (x - min) / (max - min);
	}

	public static double HalfLifeOfGeometricSeries(double decayFactor, int length)
	{
		if (length < 1)
		{
			return double.NaN;
		}
		return Math.Log(0.5 + 0.5 * Math.Pow(decayFactor, length)) / Math.Log(decayFactor);
	}

	public static double SumOfGeometricSeries(double decayFactor, int length)
	{
		if (length < 1)
		{
			return double.NaN;
		}
		if (decayFactor == 1.0)
		{
			return length;
		}
		return (1.0 - Math.Pow(decayFactor, length)) / (1.0 - decayFactor);
	}

	public static double SumOfInfiniteGeometricSeries(double decayFactor)
	{
		if (decayFactor >= 1.0)
		{
			return double.PositiveInfinity;
		}
		if (decayFactor <= 1.0)
		{
			return double.NaN;
		}
		return 1.0 / (1.0 - decayFactor);
	}

	public double Covariance(double[] array1, double[] array2, double decayFactor)
	{
		if (array1.Length != array2.Length)
		{
			throw new ArgumentException("Arrays must be the same length");
		}
		int num = array1.Length;
		if (num == 1)
		{
			return double.NaN;
		}
		double num2 = 0.0;
		double num3 = 1.0;
		for (int i = 0; i < num; i++)
		{
			num2 += num3 * array1[num - 1 - i] * array2[num - 1 - i];
			num3 *= decayFactor;
		}
		double num4 = Mean(array1, decayFactor);
		double num5 = Mean(array2, decayFactor);
		double num6 = SumOfGeometricSeries(decayFactor, num);
		double num7 = SumOfGeometricSeries(decayFactor * decayFactor, num);
		double num8 = num6 / (num6 * num6 - num7);
		double num9 = num6 * num8;
		return num8 * num2 - num9 * num4 * num5;
	}

	public void RefreshRange(RangeInfo range)
	{
		for (int i = range.Top; i <= range.Bottom; i++)
		{
			for (int j = range.Left; j <= range.Right; j++)
			{
				string text = RangeInfo.GetAlphaLabel(j) + i;
				dependencyLevel = 0;
				GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
				string text2 = "!" + GetSheetID(grid) + "!";
				if (sheetFamilyItem.TokenToParentObject != null && sheetFamilyItem.TokenToParentObject.ContainsKey(text2))
				{
					grid = sheetFamilyItem.TokenToParentObject[text2] as ICalcData;
				}
				text = text2 + text;
				Refresh(text);
			}
		}
	}

	public void ResetVariableNames()
	{
		if (variableNamesToTokens != null)
		{
			variableNamesToTokens.Clear();
			variableNamesToTokens = null;
			variableTokensToNames.Clear();
			variableTokensToNames = null;
		}
	}

	public void RegisterVariableNames(string[] list)
	{
		if (variableNamesToTokens == null)
		{
			variableNamesToTokens = new Dictionary<object, object>();
			variableTokensToNames = new Dictionary<object, object>();
		}
		foreach (string text in list)
		{
			string key = text.Trim().ToLower();
			if (!variableNamesToTokens.ContainsKey(key))
			{
				string text2 = "A" + (variableNamesToTokens.Count + 1);
				variableNamesToTokens.Add(key, text2);
				variableTokensToNames.Add(text2, text);
			}
		}
	}

	private string ZapQuotedColons(string s)
	{
		int num = s.IndexOf(TIC);
		while (num > -1)
		{
			int num2 = s.Substring(num + 1).IndexOf(TIC);
			if (num2 > -1)
			{
				int num3 = s.Substring(num + 1).IndexOf(':');
				while (num3 > -1 && num3 < num2)
				{
					s = s.Substring(num3 + num) + " " + s.Substring(num3 + num + 1);
					num3 = s.Substring(num + 1).IndexOf(':');
				}
			}
			num = num2;
		}
		return s;
	}

	public string PlaceVariablenameTokensIntoFormula(string formula)
	{
		int num = formula.IndexOf(LEFTBRACKET);
		while (num > -1)
		{
			int num2 = formula.IndexOf(RIGHTBRACKET, num);
			if (num2 > -1)
			{
				string key = formula.Substring(num + 1, num2 - 1).ToLower().Trim();
				key = variableNamesToTokens[key].ToString();
				if (key != null)
				{
					string text = string.Empty;
					if (num2 < formula.Length - 1)
					{
						text = formula.Substring(num2 + 1);
					}
					formula = ((num <= 0) ? (key + text) : (formula.Substring(0, num) + key + text));
					num = formula.IndexOf(LEFTBRACKET);
					continue;
				}
				return string.Empty;
			}
			return string.Empty;
		}
		return formula;
	}

	private bool IsEqual(double d1, double d2)
	{
		return Math.Abs(d1 - d2) < ABSOLUTEZERO;
	}

	private string IsBlankOrVal(string args)
	{
		string valueFromArg = GetValueFromArg(args);
		if (!valueFromArg.Equals(string.Empty))
		{
			return valueFromArg;
		}
		return TRUEVALUESTR;
	}

	public static double besseli1(double x)
	{
		double num = 0.0;
		double b = 0.0;
		double b2 = 0.0;
		double b3 = 0.0;
		num = Math.Abs(x);
		if (num <= 8.0)
		{
			double x2 = num / 2.0 - 2.0;
			besselm1firstcheb(2.7779141127610464E-18, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -2.111421214358166E-17, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 1.5536319577362005E-16, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -1.1055969477353862E-15, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 7.600684294735408E-15, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -5.042185504727912E-14, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 3.223793365945575E-13, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -1.9839743977649436E-12, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 1.1736186298890901E-11, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -6.663489723502027E-11, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 3.625590281552117E-10, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -1.8872497517228294E-09, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 9.381537386495773E-09, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -4.445059128796328E-08, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 2.0032947535521353E-07, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -8.568720264695455E-07, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 3.4702513081376785E-06, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -1.3273163656039436E-05, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 4.781565107550054E-05, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.00016176081582589674, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 0.0005122859561685758, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.0015135724506312532, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 0.004156422944312888, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.010564084894626197, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 0.024726449030626516, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.05294598120809499, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 0.1026436586898471, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.17641651835783406, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 0.25258718644363365, ref b, ref b2, ref b3);
			num = 0.5 * (b - b3) * num * Math.Exp(num);
		}
		else
		{
			double x3 = 32.0 / num - 2.0;
			besselm1firstcheb(7.517296310842105E-18, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 4.414348323071708E-18, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -4.6503053684893586E-17, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -3.209525921993424E-17, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 2.96262899764595E-16, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 3.3082023109209285E-16, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -1.8803547755107825E-15, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -3.8144030724370075E-15, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 1.0420276984128802E-14, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 4.272440016711951E-14, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -2.1015418427726643E-14, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -4.0835511110921974E-13, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -7.198551776245908E-13, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 2.0356285441470896E-12, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 1.4125807436613782E-11, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 3.2526035830154884E-11, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -1.8974958123505413E-11, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -5.589743462196584E-10, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -3.835380385964237E-09, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -2.6314688468895196E-08, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -2.512236237870209E-07, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -3.882564808877691E-06, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -0.00011058893876262371, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, -0.009761097491361469, ref b, ref b2, ref b3);
			besselm1nextcheb(x3, 0.7785762350182801, ref b, ref b2, ref b3);
			num = 0.5 * (b - b3) * Math.Exp(num) / Math.Sqrt(num);
		}
		if (x < 0.0)
		{
			num = 0.0 - num;
		}
		return num;
	}

	public static double besselk1(double x)
	{
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		double b = 0.0;
		double b2 = 0.0;
		double b3 = 0.0;
		num2 = 0.5 * x;
		if (x <= 2.0)
		{
			double x2 = x * x - 2.0;
			besselm1firstcheb(-7.023863479386288E-18, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -2.427449850519366E-15, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -6.666901694199329E-13, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -1.4114883926335278E-10, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -2.213387630734726E-08, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -2.4334061415659684E-06, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.0001730288957513052, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.006975723859639864, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.12261118082265715, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, -0.3531559607765449, ref b, ref b2, ref b3);
			besselm1nextcheb(x2, 1.5253002273389478, ref b, ref b2, ref b3);
			num3 = 0.5 * (b - b3);
			return Math.Log(num2) * besseli1(x) + num3 / x;
		}
		double x3 = 8.0 / x - 2.0;
		besselm1firstcheb(-5.756744483665017E-18, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 1.7940508731475592E-17, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -5.689462558442859E-17, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 1.838093544366639E-16, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -6.057047248373319E-16, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 2.038703165624334E-15, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -7.019837090418314E-15, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 2.4771544244813043E-14, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -8.976705182324994E-14, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 3.3484196660784293E-13, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -1.2891739609510289E-12, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 5.13963967348173E-12, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -2.1299678384275683E-11, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 9.218315187605006E-11, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -4.1903547593418965E-10, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 2.015049755197033E-09, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -1.0345762465678097E-08, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 5.7410841254500495E-08, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -3.5019606030878126E-07, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 2.406484947837217E-06, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -1.936197974166083E-05, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 0.00019521551847135162, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, -0.002857816859622779, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 0.10392373657681724, ref b, ref b2, ref b3);
		besselm1nextcheb(x3, 2.7206261904844427, ref b, ref b2, ref b3);
		num3 = 0.5 * (b - b3);
		return Math.Exp(0.0 - x) * num3 / Math.Sqrt(x);
	}

	public static double besselk0(double x)
	{
		double num = 0.0;
		double b = 0.0;
		double b2 = 0.0;
		double b3 = 0.0;
		if (x <= 2.0)
		{
			double x2 = x * x - 2.0;
			besselmfirstcheb(1.374465435613523E-16, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 4.25981614279661E-14, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 1.0349695257633842E-11, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 1.904516377220209E-09, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 2.5347910790261494E-07, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 2.286212103119452E-05, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.001264615411446926, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.0359799365153615, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.3442898999246285, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.5353273932339028, ref b, ref b2, ref b3);
			num = 0.5 * (b - b3);
			return num - Math.Log(0.5 * x) * besseli0(x);
		}
		double x3 = 8.0 / x - 2.0;
		besselmfirstcheb(5.300433772686263E-18, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.6475804301524212E-17, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 5.2103915050390274E-17, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.678231096805412E-16, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 5.512055978524319E-16, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.848593377343779E-15, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 6.3400764774050706E-15, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -2.2275133269916698E-14, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 8.032890775363575E-14, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -2.9800969231727303E-13, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.140340588208475E-12, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -4.514597883373944E-12, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.8559491149547177E-11, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -7.957489244477107E-11, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 3.577397281400301E-10, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.69753450938906E-09, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 8.574034017414225E-09, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -4.660489897687948E-08, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 2.766813639445015E-07, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.8317555227191195E-06, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.39498137188765E-05, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -0.00012849549581627802, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 0.0015698838857300533, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -0.0314481013119645, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 2.4403030820659555, ref b, ref b2, ref b3);
		num = 0.5 * (b - b3);
		return num * Math.Exp(0.0 - x) / Math.Sqrt(x);
	}

	private double[,] generateSubArray(double[,] a, int N, int j1)
	{
		double[,] array = new double[N - 1, 3];
		for (int i = 1; i < N; i++)
		{
			int num = 0;
			for (int k = 0; k < N; k++)
			{
				if (k != j1)
				{
					array[i - 1, num] = a[i, k];
					num++;
				}
			}
		}
		return array;
	}

	public static string getBetween(string strSource, string strStart, string strEnd)
	{
		if (strSource.Contains(strStart) && strSource.Contains(strEnd))
		{
			int num = strSource.IndexOf(strStart, 0) + strStart.Length;
			int num2 = strSource.IndexOf(strEnd, num);
			return strSource.Substring(num, num2 - num);
		}
		return "";
	}

	public string GetFormulaRowCol(ICalcData grd, int row, int col)
	{
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grd);
		string text = RangeInfo.GetAlphaLabel(col) + row;
		if (sheetFamilyItem.SheetNameToParentObject != null)
		{
			text = (sheetFamilyItem.ParentObjectToToken[grd] as string) + text;
		}
		if (FormulaInfoTable.ContainsKey(text))
		{
			string s = (FormulaInfoTable[text] as FormulaInfo).FormulaText;
			GetFormulaText(ref s);
			return s;
		}
		return string.Empty;
	}

	public int GetCalcID()
	{
		return calcID;
	}

	public double[] ListToDouble(List<object> arrayList)
	{
		List<double> list = new List<double>();
		foreach (object array in arrayList)
		{
			list.Add((double)array);
		}
		return list.ToArray();
	}

	private void Mark(ref string copy, ref string text, string op, char token, bool checkPrecedingChar)
	{
		int loc = 0;
		loc = (checkPrecedingChar ? FindAndCheckPrecedingChar(ref copy, op, loc) : copy.IndexOf(op));
		int length = op.Length;
		while (loc > -1)
		{
			copy = copy.Substring(0, loc) + token + copy.Substring(loc + length);
			text = text.Substring(0, loc) + token + text.Substring(loc + length);
			loc = (checkPrecedingChar ? FindAndCheckPrecedingChar(ref copy, op, loc) : copy.IndexOf(op, loc));
		}
	}

	private void MarkIF(ref string copy, ref string text)
	{
		copy.IndexOf(ReservedWordOperators[reservedWord_IF]);
		int num = copy.IndexOf(ReservedWordOperators[reservedWord_THEN]);
		int num2 = copy.IndexOf(ReservedWordOperators[reservedWord_ELSE]);
		if (num2 > -1 && num > -1)
		{
			int length = ReservedWordOperators[reservedWord_IF].Length;
			int length2 = num - length;
			int num3 = num + ReservedWordOperators[reservedWord_THEN].Length;
			int length3 = num2 - num3;
			int num4 = num2 + ReservedWordOperators[reservedWord_ELSE].Length;
			int length4 = text.Length - num4;
			text = string.Format("IF(({0}){3}({1}){3}({2}))", text.Substring(length, length2), text.Substring(num3, length3), text.Substring(num4, length4), ParseArgumentSeparator);
			copy = string.Format("IF(({0}){3}({1}){3}({2}))", copy.Substring(length, length2), copy.Substring(num3, length3), copy.Substring(num4, length4), ParseArgumentSeparator);
		}
		else if (num > -1)
		{
			int startIndex = 0;
			int length5 = num;
			int num5 = num + ReservedWordOperators[reservedWord_THEN].Length;
			int length6 = text.Length - num5 + 1;
			text = string.Format("IF(({0}){2}({1}))", text.Substring(startIndex, length5), text.Substring(num5, length6), ParseArgumentSeparator);
			copy = string.Format("IF(({0}){2}({1}))", copy.Substring(startIndex, length5), copy.Substring(num5, length6), ParseArgumentSeparator);
		}
	}

	private void MarkReserveWords(ref string text)
	{
		string copy = text.ToLower();
		if (copy.TrimStart().StartsWith(ReservedWordOperators[reservedWord_IF]))
		{
			MarkIF(ref copy, ref text);
		}
		Mark(ref copy, ref text, ReservedWordOperators[reservedWord_NOT], '\u0091', checkPrecedingChar: true);
		Mark(ref copy, ref text, ReservedWordOperators[reservedWord_OR], '\u008b', checkPrecedingChar: false);
		Mark(ref copy, ref text, ReservedWordOperators[reservedWord_AND], '\u008c', checkPrecedingChar: false);
		Mark(ref copy, ref text, ReservedWordOperators[reservedWord_XOR], '\u008d', checkPrecedingChar: false);
	}

	private int FindAndCheckPrecedingChar(ref string copy, string op, int loc)
	{
		int num = copy.IndexOf(op, loc);
		if (num > 0)
		{
			while (num > -1 && ValidPrecedingChars.IndexOf(copy[num - 1]) == -1)
			{
				num = copy.IndexOf(op, num + 1);
			}
		}
		return num;
	}

	private Stack<object> CombineStack(string formula, int i, Stack<object> _tempStack)
	{
		string text = string.Empty;
		if (_tempStack.Count == 2)
		{
			int num = 3;
			string text2 = formula.Substring(i);
			while (num > 1)
			{
				string text3 = _tempStack.Pop().ToString();
				text = (text3.Equals(TIC + TIC) ? (text + TIC) : (text3 + text));
				text2 = ((num == 3) ? text3 : text2);
				num--;
			}
			if (_tempStack.Peek().Equals(TIC + TIC))
			{
				_tempStack.Pop();
			}
			text = ((formula.Length == i && string.IsNullOrEmpty(text2.Replace(TIC, string.Empty))) ? (text + text2) : text);
			_tempStack.Push(text);
		}
		return _tempStack;
	}

	public static void ResetSheetFamilyID()
	{
		sheetFamilyID = 0;
		if (modelToSheetID != null)
		{
			modelToSheetID.Clear();
			modelToSheetID = null;
		}
		if (sheetFamiliesList != null)
		{
			sheetFamiliesList.Clear();
			sheetFamiliesList = null;
			ResetSheetIDs();
		}
	}

	public static void ResetSheetIDs()
	{
		TokenCount = 0;
	}

	internal string HandleIteration(string s, FormulaInfo formula)
	{
		if (FormulaInfoTable.ContainsKey(s))
		{
			FormulaInfoTable[s] = formula;
		}
		else
		{
			FormulaInfoTable.Add(s, formula);
		}
		if (iterationMaxCount > 0 && s == cell)
		{
			HandleIterations(formula);
		}
		return formula.FormulaValue;
	}

	private void PopulateNamedRangesNonScoped()
	{
		if (namedRangesNonScoped == null)
		{
			namedRangesNonScoped = new Dictionary<object, object>();
		}
		namedRangesNonScoped.Clear();
		foreach (string key in NamedRanges.Keys)
		{
			CheckAddNonScopedNamedRange(key);
		}
	}

	private void CheckAddNonScopedNamedRange(string key)
	{
		int num = -1;
		if ((num = key.IndexOf('!')) > -1)
		{
			string key2 = key.Substring(num + 1);
			if (!namedRangesNonScoped.ContainsKey(key2))
			{
				namedRangesNonScoped.Add(key2, NamedRanges[key]);
			}
		}
	}

	public bool AddNamedRange(string name, string range)
	{
		name = name.ToUpper(CultureInfo.InvariantCulture);
		if (!NamedRanges.ContainsKey(name))
		{
			NamedRanges.Add(name, range);
			CheckAddNonScopedNamedRange(name);
			return true;
		}
		return false;
	}

	public bool RemoveNamedRange(string name)
	{
		name = name.ToUpper(CultureInfo.InvariantCulture);
		if (NamedRanges[name] != null)
		{
			NamedRanges.Remove(name);
			PopulateNamedRangesNonScoped();
			return true;
		}
		return false;
	}

	internal void MarkNamedRanges(ref string argList)
	{
		argList.IndexOf(')');
		char[] obj = new char[13]
		{
			')', '\0', '}', '+', '-', '*', '/', '<', '>', '=',
			'&', ':', '%'
		};
		obj[1] = ParseArgumentSeparator;
		char[] anyOf = obj;
		int i;
		for (i = 0; i < argList.Length - 1 && (argList[i] == '(' || argList[i] == '{'); i++)
		{
		}
		if (argList.IndexOf("#N/A") > -1)
		{
			argList = argList.Replace("#N/A", "#N~A");
		}
		if (argList.IndexOf("#DIV/0!") > -1)
		{
			argList = argList.Replace("#DIV/0!", "#DIV~0!");
		}
		int location = i;
		if ((argList.IndexOf("[") == -1 && !argList.StartsWith('!'.ToString())) || argList.Substring(i).IndexOf("[") > argList.Substring(i).IndexOfAny(anyOf))
		{
			location = argList.Substring(i).IndexOfAny(anyOf);
		}
		else
		{
			FindNextEndIndex(argList, ref location);
		}
		while (location > -1 && location + i < argList.Length)
		{
			string text = null;
			string scopedRange = string.Empty;
			text = CheckForNamedRange(argList.Substring(i, location));
			if ((string.IsNullOrEmpty(text) || !findNamedRange) && argList.Substring(i, location).StartsWith('!'.ToString()))
			{
				int num = argList.Substring(i, location).IndexOf('!', 1);
				if (num > 1 && !argList.Substring(i, location + 1).Contains(":"))
				{
					string text2 = argList.Substring(i).Substring(num + 1, location - num - 1);
					if (TryGetNamedRange(text2, out scopedRange))
					{
						findNamedRange = true;
						text = Convert.ToString(scopedRange);
					}
				}
			}
			if (!string.IsNullOrEmpty(text) && findNamedRange)
			{
				text = CheckForNamedRange(text);
				if (text.Contains(parseArgumentSeparator.ToString()) && errorFormula)
				{
					text = text.Replace(parseArgumentSeparator, ':');
					errorFormula = false;
				}
				if (text.StartsWith(BRACELEFT) && text.EndsWith(BRACERIGHT))
				{
					text = text.Replace(BRACELEFT, TIC);
					text = text.Replace(BRACERIGHT, TIC);
				}
				MarkLibraryFormulas(ref text);
			}
			if (!string.IsNullOrEmpty(text))
			{
				argList = argList.Substring(0, i) + text + argList.Substring(i + location);
				i += text.Length + 1;
			}
			else
			{
				for (i += location + 1; i < argList.Length && char.IsDigit(argList[i]) && argList[i] != '!'; i++)
				{
				}
			}
			findNamedRange = false;
			if (i < argList.Length - 1 && (argList[i] == '{' || argList[i] == '('))
			{
				i++;
			}
			location = i;
			if (argList.IndexOf("[") == -1 || argList.Substring(i).IndexOf("[") > argList.Substring(i).IndexOfAny(anyOf))
			{
				location = argList.Substring(i).IndexOfAny(anyOf);
			}
			else
			{
				FindNextEndIndex(argList, ref location);
			}
			while (location == 0 && i < argList.Length - 1)
			{
				i++;
				i += ((argList.Substring(i)[0] == '(' || argList.Substring(i)[0] == '{') ? 1 : 0);
				if (argList.Substring(i).IndexOf("[") > argList.Substring(i).IndexOfAny(anyOf))
				{
					location = argList.Substring(i).IndexOfAny(anyOf);
				}
				else
				{
					FindNextEndIndex(argList.Substring(i), ref location);
				}
			}
			if ((location != -1 && !argList.Substring(i).Contains("[")) || i >= argList.Length)
			{
				continue;
			}
			text = CheckForNamedRange(argList.Substring(i));
			if (string.IsNullOrEmpty(text) || !findNamedRange)
			{
				continue;
			}
			findNamedRange = false;
			MarkLibraryFormulas(ref text);
			if (text != null)
			{
				if (argList.Substring(i).EndsWith(")"))
				{
					argList = argList.Substring(0, i) + text + ")";
				}
				else
				{
					argList = argList.Substring(0, i) + text;
				}
				i += text.ToString().Length + 1;
			}
		}
		if (errorFormula)
		{
			errorFormula = false;
		}
		if (argList.IndexOf("#N~A") > -1)
		{
			argList = argList.Replace("#N~A", "#N/A");
		}
		if (argList.IndexOf("#DIV~0!") > -1)
		{
			argList = argList.Replace("#DIV~0!", "#DIV/0!");
		}
	}

	internal string GetTableRange(string text)
	{
		string text2 = null;
		string text3 = text.Replace("[#DATA]", "");
		string scopedRange = string.Empty;
		string empty = string.Empty;
		if (text3.IndexOf(ParseArgumentSeparator) > -1 && !NamedRanges.ContainsKey(text3))
		{
			text3.Substring(0, text3.IndexOf(ParseArgumentSeparator));
			text3 = text3.Replace(ParseArgumentSeparator.ToString(), "");
		}
		string text4 = "";
		if (text.ToUpper().Contains("[#THIS ROW]"))
		{
			text3 = (text3.EndsWith(")") ? text3.Replace(")", "") : text3);
			if (text3.Contains(":"))
			{
				string text5 = string.Empty;
				string[] array = text3.ToUpper().Split(new string[1] { "[#THIS ROW]" }, StringSplitOptions.None);
				string[] array2 = SplitArguments(array[1], ':');
				for (int i = 0; i <= array2.Length - 1; i++)
				{
					array2[i] = array[0] + array2[i];
					empty = array2[i].ToUpper().Replace("[#THIS ROW]", "").Replace("[[", "[")
						.Replace("]]", "]");
					if (TryGetNamedRange(empty, out scopedRange))
					{
						findNamedRange = true;
						text2 = Convert.ToString(scopedRange);
					}
					if (text2 == null)
					{
						findNamedRange = false;
						return text2;
					}
					text2 = text2.ToUpper();
					PutTokensForSheets(ref text2);
					text2 = text2.Replace("$", "");
					text5 = SheetToken(text2.Replace(TIC, string.Empty));
					text4 = ((i != array2.Length - 1) ? (text4 + GetCellFrom(text2) + ":") : (text4 + GetCellFrom(text2)));
				}
				text4 = text5 + text4;
			}
			else
			{
				empty = text3.ToUpper().Replace("[#THIS ROW]", "").Replace("[[", "[")
					.Replace("]]", "]");
				if (TryGetNamedRange(empty, out scopedRange))
				{
					findNamedRange = true;
					text2 = Convert.ToString(scopedRange);
				}
				if (text2 == null)
				{
					findNamedRange = false;
					return text2;
				}
				text2 = text2.ToUpper();
				int num = RowIndex(cell);
				text2 = text2.Replace("$", "");
				PutTokensForSheets(ref text2);
				int topRowIndexFromRange = GetTopRowIndexFromRange(text2);
				text4 = GetCellsFromArgs(text2)[num - topRowIndexFromRange];
			}
		}
		else
		{
			if (text3.EndsWith("["))
			{
				text3 = text3.Replace("[", "");
			}
			text3 = (text3.EndsWith(")") ? text3.Replace(")", "") : text3);
			if (text3.ToUpper().Contains("[#TOTALS]") || (text3.ToUpper().Contains("#ALL") && text3.IndexOf("[") == text3.ToUpper().IndexOf("#ALL") - 1) || text3.ToUpper().Contains("[#HEADERS]") || text3.ToUpper().Contains("[#DATA]"))
			{
				text3 = text3.Replace("#", "");
			}
			if (TryGetNamedRange(text3.ToUpper(), out scopedRange))
			{
				findNamedRange = true;
				text4 = Convert.ToString(scopedRange);
			}
			if (text3.Contains(":") && text3.EndsWith("]") && string.IsNullOrEmpty(text4))
			{
				string text6 = string.Empty;
				string text7 = string.Empty;
				int j = 0;
				if (!text3[j].Equals('['))
				{
					for (; !text3[j].Equals('['); j++)
					{
						text7 += text[j];
					}
				}
				if (NamedRanges.ContainsKey(text7))
				{
					text7 += "[";
					string[] array3 = SplitArguments(text3.Substring(j + 1), ':');
					for (int k = 0; k <= array3.Length - 1; k++)
					{
						array3[k] = text7 + array3[k];
						empty = array3[k].ToUpper().Replace("[[", "[").Replace("]]", "]");
						if (TryGetNamedRange(empty, out scopedRange))
						{
							findNamedRange = true;
							text2 = Convert.ToString(scopedRange);
						}
						if (text2 == null)
						{
							findNamedRange = false;
							return text2;
						}
						text2 = text2.ToUpper();
						PutTokensForSheets(ref text2);
						text2 = text2.Replace("$", "");
						text6 = SheetToken(text2.Replace(TIC, string.Empty));
						string[] cellsFromArgs = GetCellsFromArgs(text2);
						text4 = ((k != array3.Length - 1) ? (text4 + $"{RangeInfo.GetAlphaLabel(ColIndex(cellsFromArgs[0]))}{RowIndex(cellsFromArgs[0])}" + ":") : (text4 + $"{RangeInfo.GetAlphaLabel(ColIndex(cellsFromArgs[^1]))}{RowIndex(cellsFromArgs[^1])}"));
					}
					text4 = text6 + text4;
				}
			}
			if (string.IsNullOrEmpty(text4))
			{
				findNamedRange = false;
				return null;
			}
		}
		return text4.ToUpper();
	}

	internal int GetTopRowIndexFromRange(string range)
	{
		MarkColonsInQuotes(ref range);
		int num = range.IndexOf(':');
		if (num == -1)
		{
			return RowIndex(range);
		}
		string empty = string.Empty;
		int num2 = range.IndexOf('!');
		if (num2 > -1)
		{
			int num3 = range.IndexOf('!', num2 + 1);
			if (num3 > -1)
			{
				empty = range.Substring(num2, num3 - num2 + 1);
				range = range.Replace(empty, string.Empty);
				num = range.IndexOf(':');
			}
		}
		return RowIndex(range.Substring(0, num));
	}

	internal string CheckForNamedRange(string text)
	{
		string scopedRange = string.Empty;
		bool flag = false;
		if (text.Contains("["))
		{
			string tableRange = GetTableRange(text);
			if (tableRange != null)
			{
				findNamedRange = true;
				flag = true;
				text = tableRange;
			}
		}
		else if (TryGetNamedRange(text.ToUpper().Replace("'", string.Empty), out scopedRange))
		{
			findNamedRange = true;
			flag = true;
			text = scopedRange;
		}
		else if (NamedRanges.Count > 0 && !string.IsNullOrEmpty(text.Trim()) && this.UpdateNamedRange != null)
		{
			UpdateNamedRangeEventArgs updateNamedRangeEventArgs = new UpdateNamedRangeEventArgs(text);
			this.UpdateNamedRange(this, updateNamedRangeEventArgs);
			if (updateNamedRangeEventArgs.IsFormulaUpdated)
			{
				findNamedRange = true;
				flag = true;
				text = updateNamedRangeEventArgs.Address;
				text = text.ToUpper();
			}
		}
		if (!flag && findNamedRange)
		{
			findNamedRange = false;
		}
		if (findNamedRange)
		{
			if (!text.StartsWith('!'.ToString()) && !text.StartsWith("q") && !text.StartsWith("bq"))
			{
				PutTokensForSheets(ref text);
			}
			if (text.Contains("$"))
			{
				if (IsCellReference(text.Replace("$", "")) && !text.Contains(":"))
				{
					string text2 = string.Empty;
					string text3 = SheetToken(text.Replace(TIC, string.Empty));
					if (!string.IsNullOrEmpty(text3))
					{
						text = text.Replace(text3, string.Empty);
					}
					if (text.Split('$').Length > 2)
					{
						return text3 + text.Replace("$", "");
					}
					string text4 = string.Empty;
					int num = 0;
					int col = 0;
					if (cell != string.Empty)
					{
						num = RowIndex(cell);
						col = ColIndex(cell);
					}
					if (text.StartsWith("$"))
					{
						text2 += text[0];
						for (int i = 1; i < text.Length; i++)
						{
							if (i < text.Length && char.IsLetter(text[i]))
							{
								text2 += text[i];
							}
							else if (i < text.Length && char.IsDigit(text[i]))
							{
								text4 += text[i];
							}
						}
						text4 = num.ToString();
						text2 += text4;
					}
					else
					{
						for (int j = 0; j < text.Length; j++)
						{
							if (j < text.Length && char.IsLetter(text[j]))
							{
								text4 += text[j];
								continue;
							}
							if (j < text.Length && text[j] == '$')
							{
								text4 = RangeInfo.GetAlphaLabel(col).ToString();
								text2 = text2 + text4 + text[j];
							}
							if (j < text.Length && char.IsDigit(text[j]))
							{
								text2 += text[j];
							}
						}
					}
					text = text3 + text2;
				}
				text = text.Replace("$", "");
			}
		}
		return text;
	}

	private bool CheckIfNameRangesIntersect(string formula, out string finalValue)
	{
		string[] array = null;
		string text = string.Empty;
		string scopedRange = string.Empty;
		if (NamedRanges != null && formula.Contains(" ") && NamedRanges.Count > 0 && !formula.Contains("[") && !formula.Contains(TIC + TIC))
		{
			bool flag = false;
			if (formula.Contains(TIC))
			{
				flag = true;
				array = formula.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
				for (int i = 0; i < array.Length; i++)
				{
					if (TryGetNamedRange(array[i].ToUpper(), out scopedRange))
					{
						flag = false;
					}
					text = ((i != array.Length - 1) ? (text + array[i] + TIC) : (text + array[i]));
				}
				finalValue = text;
			}
			if (!flag)
			{
				text = string.Empty;
				string text2 = string.Empty;
				string text3 = string.Empty;
				array = formula.Split(new string[1] { " " }, StringSplitOptions.RemoveEmptyEntries);
				for (int j = 0; j < array.Length; j++)
				{
					if (TryGetNamedRange(array[j].ToUpper(), out scopedRange))
					{
						array[j] = scopedRange.ToUpper();
					}
					else if (array[j].StartsWith("q") && array[j].EndsWith(RIGHTBRACKET.ToString()))
					{
						array[j] = ComputedValue(array[j]);
					}
					else if (array[j].Contains(":") && array[j].IndexOfAny(tokens) == -1)
					{
						array[j] = array[j];
					}
					else
					{
						int num = 0;
						array[j] = array[j].Replace('\u0092'.ToString(), string.Empty);
						string text4 = SheetToken(array[j]);
						if (text4 != string.Empty)
						{
							array[j] = array[j].Replace(text4, string.Empty);
						}
						while (num < array[j].Length && (char.IsDigit(array[j][num]) | (array[j][num] == ':') | (num != 0 && IsUpper(array[j][num]) && !char.IsDigit(array[j][num - 1])) | (num != 0 && array[j][num] == '!' && !char.IsDigit(array[j][num - 1])) | (num == 0 && IsUpper(array[j][num]))))
						{
							text3 += array[j][num++];
						}
						while (num != array[j].Length && ((array[j][num] == '"') | char.IsLetter(array[j][num]) | char.IsDigit(array[j][num])))
						{
							text2 += array[j][num++];
						}
						array[j] = text4 + text3;
					}
					text = ((j != array.Length - 1) ? (text + array[j] + " ") : (text + array[j]));
				}
				UpdateNamedRangeEventArgs updateNamedRangeEventArgs = new UpdateNamedRangeEventArgs(text);
				if (this.UpdateNamedRange != null)
				{
					this.UpdateNamedRange(this, updateNamedRangeEventArgs);
					if (updateNamedRangeEventArgs.IsFormulaUpdated)
					{
						text = updateNamedRangeEventArgs.Address;
						text = text.Replace("$", "");
						text = text.ToUpper();
						PutTokensForSheets(ref text);
						if (!findRangeIfIntersect)
						{
							text = GetValueFromParentObject(text);
							if (text2 != string.Empty && text == string.Empty)
							{
								finalValue = ComputedValue("0" + text2);
							}
							else if (text2 != string.Empty)
							{
								finalValue = ComputedValue(text + text2);
							}
							else if (text == string.Empty)
							{
								finalValue = "0";
							}
							else
							{
								finalValue = text;
							}
						}
						else
						{
							finalValue = text;
						}
						return true;
					}
				}
			}
		}
		finalValue = string.Empty;
		return false;
	}

	private bool FindNextEndIndex(string formula, ref int location)
	{
		int num = 0;
		char[] obj = new char[13]
		{
			')', '\0', '}', '+', '-', '*', '/', '<', '>', '=',
			'&', ':', '%'
		};
		obj[1] = ParseArgumentSeparator;
		char[] anyOf = obj;
		int num2 = location;
		bool flag = false;
		if (formula.Substring(num2).IndexOf('[') > -1 && formula.Substring(num2).IndexOf(']') > -1)
		{
			while (!flag && location < formula.Length)
			{
				if (formula[location] == '[')
				{
					num++;
				}
				else if (formula[location] == ']')
				{
					num--;
					if (num == 0)
					{
						flag = true;
					}
				}
				location++;
			}
		}
		else
		{
			location += formula.Substring(num2).IndexOfAny(anyOf);
		}
		location -= num2;
		return flag;
	}

	public string ComputeDate(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 0.0;
		double result2 = 0.0;
		int num = 0;
		for (int i = 0; i < length; i++)
		{
			string empty = string.Empty;
			array[i] = GetValueFromArg(array[i]);
			empty = ((!double.TryParse(array[i].Replace(TIC, string.Empty), NumberStyles.Any, null, out var _)) ? FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers) : array[i]);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		array[0] = (bool.TryParse(array[0], out var result4) ? Convert.ToInt16(result4).ToString() : ((string.IsNullOrEmpty(array[0]) && TreatStringsAsZero) ? "0" : array[0]));
		array[1] = (bool.TryParse(array[1], out result4) ? Convert.ToInt16(result4).ToString() : ((string.IsNullOrEmpty(array[1]) && TreatStringsAsZero) ? "0" : array[1]));
		array[2] = (bool.TryParse(array[2], out result4) ? Convert.ToInt16(result4).ToString() : ((string.IsNullOrEmpty(array[2]) && TreatStringsAsZero) ? "0" : array[2]));
		if (double.TryParse(array[0].Replace(TIC, string.Empty), NumberStyles.Any, null, out var result5) && double.TryParse(array[1].Replace(TIC, string.Empty), NumberStyles.Any, null, out result) && double.TryParse(array[2].Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
		{
			num = GetSerialDateFromDate((int)result5, (int)result, (int)result2);
		}
		if (num == -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[4].ToString();
		}
		if (computedValueLevel <= 1 && ExcelLikeComputations)
		{
			return CalcEngineHelper.FromOADate(num).ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		return num.ToString();
	}

	public string ComputeDatevalue(string argList)
	{
		argList = argList.Replace(TIC, string.Empty);
		double result = 0.0;
		DateTime result2;
		try
		{
			if (double.TryParse(argList, NumberStyles.Any, CultureInfo.CurrentUICulture, out result) || !DateTime.TryParse(argList, CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
			{
				result2 = ((!(result > 0.0)) ? DateTime.Parse(ComputedValue(argList).Replace(TIC, string.Empty)) : CalcEngineHelper.FromOADate(result));
			}
		}
		catch
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = 1 + (result2 - dateTime1900).Days;
		if (Treat1900AsLeapYear && num > 59)
		{
			num++;
		}
		return num.ToString();
	}

	public string ComputeDay(string argList)
	{
		double num = 1.0;
		if (DateTime.TryParse(GetValueFromArg(argList).Replace(TIC, string.Empty), out var result))
		{
			num = result.Day;
		}
		else
		{
			if (!double.TryParse(GetValueFromArg(argList), NumberStyles.Any, null, out var result2))
			{
				return FormulaErrorStrings[invalid_arguments];
			}
			num = ((!(result2 < 1.0)) ? ((double)GetDateFromSerialDate((int)result2).Day) : 0.0);
		}
		return num.ToString();
	}

	public string ComputeDays360(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		int num = 0;
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		valueFromArg2 = (bool.TryParse(valueFromArg2, out result) ? Convert.ToInt16(result).ToString() : valueFromArg2);
		double result2;
		bool num2 = double.TryParse(valueFromArg, out result2);
		double result3;
		bool flag = double.TryParse(valueFromArg2, out result3);
		if ((num2 && result2 == 0.0) || (flag && result3 == 0.0))
		{
			return (result2 - result3).ToString();
		}
		DateTime result4 = dateTime1900;
		DateTime result5 = dateTime1900;
		double result6;
		bool num3 = double.TryParse(valueFromArg, NumberStyles.Any, null, out result6) || DateTime.TryParse(GetValueFromArg(array[0]).Replace(TIC, string.Empty), CultureInfo.CurrentCulture, DateTimeStyles.None, out result4);
		double result7;
		bool flag2 = double.TryParse(valueFromArg2, NumberStyles.Any, null, out result7) || DateTime.TryParse(GetValueFromArg(array[1]).Replace(TIC, string.Empty), CultureInfo.CurrentCulture, DateTimeStyles.None, out result5);
		bool flag3 = length == 3 && (array[2] == TRUEVALUESTR || array[2] == FALSEVALUESTR);
		if (num3 && flag2 && (length == 2 || flag3))
		{
			result4 = ((result6 > 0.0) ? GetDateFromSerialDate((int)result6) : result4);
			result5 = ((result7 > 0.0) ? GetDateFromSerialDate((int)result7) : result5);
			bool flag4 = false;
			if (result4.Day == 31)
			{
				result4 = result4.AddDays(-1.0);
			}
			if (result5.Day == 31 && !flag3 && result4.Day < 30)
			{
				result5 = result5.AddDays(1.0);
			}
			else if (result5.Day == 31)
			{
				result5 = (((!flag3 || !(array[2] == TRUEVALUESTR)) && length != 2) ? result5.AddDays(1.0) : result5.AddDays(-1.0));
			}
			if (result5 < result4)
			{
				flag4 = true;
				DateTime dateTime = result4;
				result4 = result5;
				result5 = dateTime;
			}
			num = result5.Day - result4.Day;
			num += 30 * (result5.Month - result4.Month);
			num += 360 * (result5.Year - result4.Year);
			if (flag4)
			{
				num = -num;
			}
			return num.ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeYearFrac(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		new List<DateTime>();
		double num = 0.0;
		if (length != 2 && length > 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]);
		string text2 = GetValueFromArg(array[1]);
		string text3 = ((length == 3) ? GetValueFromArg(array[2]).Replace(TIC, "") : "0");
		DateTime result = dateTime1900;
		DateTime result2 = dateTime1900;
		double result3 = -1.0;
		double result4 = -1.0;
		if ((!double.TryParse(text, NumberStyles.Any, null, out result3) && !DateTime.TryParse(text.Replace(TIC, string.Empty), null, DateTimeStyles.None, out result)) || (!DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out result2) && !double.TryParse(text2, NumberStyles.Any, null, out result4)) || !double.TryParse(text3, NumberStyles.Any, null, out var result5))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		if (result5 > 4.0 && result5 < 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (result3 > 0.0)
		{
			result = GetDateFromSerialDate((int)result3);
			text = result.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		else if (result3 == 0.0)
		{
			text = result.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		if (result4 > 0.0)
		{
			result2 = GetDateFromSerialDate((int)result4);
			text2 = result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		double num2 = double.Parse(ComputeDatevalue(text2)) - double.Parse(ComputeDatevalue(text));
		if (num2 < 0.0)
		{
			result = DateTime.Parse(text2);
			result2 = DateTime.Parse(text);
		}
		double num3 = result.Year;
		double num4 = result.Month;
		double num5 = result.Day;
		double num6 = result2.Year;
		double num7 = result2.Month;
		double num8 = result2.Day;
		double num9 = DateTime.DaysInMonth(result.Year, result.Month);
		double num10 = DateTime.DaysInMonth(result2.Year, result2.Month);
		switch (text3)
		{
		case "0":
			if (num5 == 31.0 && num8 == 31.0)
			{
				num5 = 30.0;
				num8 = 30.0;
			}
			else if (num5 == 31.0)
			{
				num5 = 30.0;
			}
			else if (num5 == 30.0 && num8 == 31.0)
			{
				num8 = 30.0;
			}
			else if (num4 == 1.0 && num7 == 1.0 && num9 == num5 && num10 == num8)
			{
				num5 = 30.0;
				num8 = 30.0;
			}
			else if (num4 == 1.0 && num9 == num5)
			{
				num5 = 30.0;
			}
			num = num8 + num7 * 30.0 + num6 * 360.0 - (num5 + num4 * 30.0 + num3 * 360.0);
			num /= 360.0;
			break;
		case "1":
		{
			double num11 = 366.0;
			if (num3 == num6 || (num3 + 1.0 == num6 && (num4 > num7 || (num4 == num7 && num5 >= num8))))
			{
				if (num3 == num6 && DateTime.IsLeapYear(int.Parse(num3.ToString())))
				{
					num11 = 366.0;
				}
				else if (Daysfeb29(result, result2) || (num7 == 1.0 && num8 == 29.0))
				{
					num11 = 366.0;
				}
				num = num2 / num11;
				break;
			}
			double num12 = num6 - num3 + 1.0;
			double num13 = 0.0;
			if (num12 < 4.0)
			{
				for (int i = 0; (double)i <= num12; i++)
				{
					if (IsLeap(num3 + (double)i))
					{
						num13 = 1.0;
						break;
					}
				}
			}
			else
			{
				num13 = Math.Floor(num12 / 4.0) + (double)((IsLeap(num3) || IsLeap(num6)) ? 1 : 0);
			}
			double num14 = 365.0 + num13 / num12;
			num = num2 / num14;
			break;
		}
		case "2":
			num = num2 / 360.0;
			break;
		case "3":
			num = num2 / 365.0;
			break;
		case "4":
			if (num5 == 31.0)
			{
				num5 = 30.0;
			}
			if (num8 == 31.0)
			{
				num8 = 30.0;
			}
			num = (num8 + num7 * 30.0 + num6 * 360.0 - (num5 + num4 * 30.0 + num3 * 360.0)) / 360.0;
			break;
		}
		return num.ToString();
	}

	private bool IsLeap(double year)
	{
		if (year % 4.0 != 0.0 || year % 100.0 == 0.0)
		{
			return year % 400.0 == 0.0;
		}
		return true;
	}

	public string ComputeDays(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg2 = (bool.TryParse(valueFromArg2, out result) ? Convert.ToInt16(result).ToString() : valueFromArg2);
		if ((valueFromArg.StartsWith(TIC) && string.IsNullOrEmpty(valueFromArg.Replace(TIC, string.Empty))) || (valueFromArg2.StartsWith(TIC) && string.IsNullOrEmpty(valueFromArg2.Replace(TIC, string.Empty))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		valueFromArg = (string.IsNullOrEmpty(valueFromArg.Replace(TIC, string.Empty)) ? DateTime.Parse("1899-12-31").ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) : valueFromArg.Replace(TIC, string.Empty));
		valueFromArg2 = (string.IsNullOrEmpty(valueFromArg2.Replace(TIC, string.Empty)) ? DateTime.Parse("1899-12-31").ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) : valueFromArg2.Replace(TIC, string.Empty));
		double result2 = 0.0;
		double result3 = 0.0;
		if ((double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, CultureInfo.CurrentUICulture, out result2) || DateTime.TryParse(valueFromArg.Replace(TIC, string.Empty), CultureInfo.CurrentCulture, DateTimeStyles.None, out var _)) && (double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, CultureInfo.CurrentUICulture, out result3) || DateTime.TryParse(valueFromArg2.Replace(TIC, string.Empty), CultureInfo.CurrentCulture, DateTimeStyles.None, out var _)))
		{
			if (result2 < 0.0 || result3 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException("invalid expression");
				}
				return ErrorStrings[4].ToString();
			}
			if (result2 >= 1.0 && result3 >= 1.0)
			{
				double num = result2 - result3;
				return Math.Round(num - 0.4999999999 * (double)Math.Sign(num)).ToString();
			}
			if (result2 > 0.0)
			{
				valueFromArg = CalcEngineHelper.FromOADate((result2 < 59.0) ? (result2 + 1.0) : result2).ToString();
			}
			if (result3 > 0.0)
			{
				valueFromArg2 = CalcEngineHelper.FromOADate((result3 < 59.0) ? (result3 + 1.0) : result3).ToString();
			}
			if (result2 > 0.0 && result2 < 1.0)
			{
				valueFromArg = CalcEngineHelper.FromOADate(result2).ToString();
			}
			if (result3 > 0.0 && result3 < 1.0)
			{
				valueFromArg2 = CalcEngineHelper.FromOADate(result3).ToString();
			}
			array[0] = GetValueFromArg(array[0]);
			array[1] = GetValueFromArg(array[1]);
			array[0] = (bool.TryParse(array[0], out result) ? Convert.ToInt16(result).ToString() : array[0]);
			array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
			double result6;
			bool num2 = double.TryParse(array[0], out result6);
			double result7;
			bool flag = double.TryParse(array[1], out result7);
			if ((num2 && result6 == 0.0) || (flag && result7 == 0.0))
			{
				return (result6 - result7).ToString();
			}
			return (int.Parse(ComputeDatevalue(valueFromArg.Replace(TIC, string.Empty))) - int.Parse(ComputeDatevalue(valueFromArg2.Replace(TIC, string.Empty)))).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[5].ToString());
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeEDate(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string s = GetValueFromArg(array[0]).Replace(TIC, "");
		string text = GetValueFromArg(array[1]).Replace(TIC, "");
		int result = 0;
		if (!DateTime.TryParse(s, out var result2) || (!int.TryParse(text, out result) && !int.TryParse(ComputeDatevalue(text), out result)))
		{
			try
			{
				DateTime now = DateTime.Now;
				double num = double.Parse(s);
				int num2 = int.Parse(text);
				if (num2 < 0 && (double)num2 < num && num <= 1.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[4].ToString();
				}
				if (num == 0.0)
				{
					result2 = now.AddMonths(num2);
					return ComputeDays(now.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + ParseArgumentSeparator + result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern));
				}
				DateTime dateTime = dateTime1900;
				result2 = CalcEngineHelper.FromOADate(num).AddMonths(num2);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[bad_formula] + ex.Message);
				}
				return ErrorStrings[1].ToString();
			}
		}
		result2 = result2.AddMonths(result);
		if (ExcelLikeComputations)
		{
			return result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		return ((int)result2.ToOADate()).ToString();
	}

	public string ComputeEOMonth(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = GetValueFromArg(array[0]).Replace(TIC, "");
		if (ErrorStrings.Contains(text2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return text2;
		}
		double result = 0.0;
		if (!double.TryParse(GetValueFromArg(array[1]).Replace(TIC, ""), out result) || !DateTime.TryParse(text2, out var result2))
		{
			try
			{
				_ = DateTime.Now;
				int result3 = 0;
				result2 = dateTime1900;
				double result4 = 0.0;
				if (!int.TryParse(text2, out result3))
				{
					if (result3 == 0 && double.TryParse(text2, out result4))
					{
						if (result4 >= 1.0)
						{
							result2 = CalcEngineHelper.FromOADate(result4);
						}
						if ((result < result4 && result4 <= 0.0) || result4 + result < 0.0)
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_index]);
							}
							return ErrorStrings[4].ToString();
						}
					}
					result = double.Parse(GetValueFromArg(array[1]).Replace(TIC, ""));
				}
				else
				{
					if (result3 >= 1)
					{
						result2 = CalcEngineHelper.FromOADate(result3);
					}
					result = double.Parse(GetValueFromArg(array[1]).Replace(TIC, ""));
				}
				if (result3 < 0 || (result3 <= 0 && result < (double)result3 && result4 == 0.0))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[4].ToString();
				}
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[bad_formula] + ex.Message);
				}
				return ErrorStrings[1].ToString();
			}
		}
		result2 = result2.AddMonths((int)result);
		int num = DateTime.DaysInMonth(result2.Year, result2.Month);
		result2 = DateTime.Parse(result2.Year + "/" + result2.Month + "/" + num);
		if (ExcelLikeComputations)
		{
			return result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		return result2.ToOADate().ToString();
	}

	public string ComputeWeeknum(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (text.Equals("invalid expression"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		DateTime dateTime = dateTime1900;
		if (!DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out var result))
		{
			try
			{
				result = CalcEngineHelper.FromOADate(double.Parse(text));
				text = result.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[bad_formula] + ex.Message);
				}
				return ErrorStrings[4].ToString();
			}
		}
		List<object> list = new List<object>();
		list.AddRange(new string[22]
		{
			"", "0", "1", "", "", "", "", "", "", "",
			"", "1", "2", "3", "4", "5", "6", "0", "", "",
			"", "1"
		});
		int result2 = 0;
		if (length != 2 || !int.TryParse(GetValueFromArg(array[1]), out result2))
		{
			result2 = 1;
		}
		if (result2 == 21)
		{
			return ComputeISOWeeknum(TIC + text + TIC);
		}
		int num = int.Parse(list[result2].ToString());
		dateTime = new DateTime(result.Year, 1, 1);
		int day = dateTime.Day;
		int days = ((day < num) ? (num - day + 1) : (day - num));
		TimeSpan value = new TimeSpan(days, 0, 0, 0);
		DateTime dateTime2 = dateTime.Subtract(value);
		return (Math.Floor((double.Parse(ComputeDatevalue(text)) - double.Parse(ComputeDatevalue(dateTime2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)))) / 7.0) + 1.0 + (double)num).ToString();
	}

	public string ComputeISOWeeknum(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string valueFromArg = GetValueFromArg(array[0]);
		DateTime result;
		bool flag = TryParseExactDateTime(valueFromArg.Replace(TIC, string.Empty), out result);
		if (valueFromArg.Contains(":") && flag)
		{
			array[0] = "0";
		}
		if (valueFromArg.StartsWith(TIC) && string.IsNullOrEmpty(valueFromArg.Replace(TIC, string.Empty)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		if (string.IsNullOrEmpty(valueFromArg))
		{
			argList = ComputeDatevalue(new DateTime(1990, 12, 28).ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern));
		}
		if (flag && (argList.Contains(":") || (!IsCellReference(GetValueFromArg(array[0])) && GetValueFromArg(array[0]).Contains(":"))))
		{
			argList = "0";
		}
		string s = GetValueFromArg(array[0]).Replace(TIC, "");
		DateTime dateTime = dateTime1900;
		if (!DateTime.TryParse(s, CultureInfo.CurrentCulture, DateTimeStyles.None, out var result2))
		{
			try
			{
				result2 = CalcEngineHelper.FromOADate(double.Parse(s));
				s = result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
			}
			catch
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException("Bad Cell reference");
				}
				return ErrorStrings[1].ToString();
			}
		}
		int num = 0;
		int num2 = 0;
		List<object> list = new List<object>();
		list.AddRange(new string[7] { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" });
		string item = new DateTime(result2.Year, 1, 1).DayOfWeek.ToString();
		if (list.Contains(item))
		{
			num = list.IndexOf(item) + 1;
		}
		double num4;
		if (result2.Month == 1 && num > 4 && result2.Day < 4)
		{
			DateTime dateTime2 = new DateTime(result2.Year - 1, 1, 1);
			DateTime dateTime3 = new DateTime(result2.Year, 1, 1);
			double num3 = Math.Abs((dateTime3 - dateTime2).TotalDays + (double)(7 - num));
			string item2 = dateTime2.DayOfWeek.ToString();
			if (list.Contains(item2))
			{
				num2 = list.IndexOf(item2) + 1;
			}
			num4 = ((num2 > 4) ? Math.Floor(num3 / 7.0) : (Math.Floor(num3 / 7.0) + 1.0));
		}
		else if (result2.Month == 1 && num <= 4 && result2.Day <= 4)
		{
			DateTime dateTime3 = new DateTime(result2.Year, 1, 1);
			double num3 = Math.Abs((result2 - dateTime3).TotalDays + (double)(num - 1) + 7.0);
			num4 = Math.Floor(num3 / 7.0);
		}
		else
		{
			if (result2.Month == 12 && result2.Day > 28 && num <= 3)
			{
				return 1.ToString();
			}
			DateTime dateTime3 = new DateTime(result2.Year, 1, 1);
			double num5 = Math.Abs((result2 - dateTime3).TotalDays);
			if (num <= 4)
			{
				num5 += (double)(num - 1);
			}
			else if (num > 4)
			{
				num5 -= (double)(7 - num);
			}
			double num3 = num5;
			num4 = Math.Floor(num3 / 7.0) + 1.0;
		}
		return num4.ToString();
	}

	public string ComputeWorkDay(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		DateTime dateTime = default(DateTime);
		if (length != 2 && length > 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = "";
		double result = 0.0;
		text = ((length != 3) ? (array[0] + ParseArgumentSeparator + array[1] + ParseArgumentSeparator + "1") : (array[0] + ParseArgumentSeparator + array[1] + ParseArgumentSeparator + "1" + ParseArgumentSeparator + array[2]));
		string text2 = ComputeWorkDayintl(text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (!double.TryParse(text2, out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		return CalcEngineHelper.FromOADate(result).ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
	}

	public string ComputeNetworkDays(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		List<DateTime> list = new List<DateTime>();
		if (length != 2 && length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		string text2 = GetValueFromArg(array[1]).Replace(TIC, "");
		if (!DateTime.TryParse(text, out var result))
		{
			double result2 = 0.0;
			if (!double.TryParse(text, NumberStyles.Any, null, out result2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			result = CalcEngineHelper.FromOADate(result2);
		}
		if (!DateTime.TryParse(text2, out var result3))
		{
			double result4 = 0.0;
			if (!double.TryParse(text2, NumberStyles.Any, null, out result4))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			result3 = CalcEngineHelper.FromOADate(result4);
		}
		if (length == 3)
		{
			string range = array[2];
			AdjustRangeArg(ref range);
			DateTime result5;
			if (range.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(range);
				foreach (string arg in cellsFromArgs)
				{
					string text3;
					try
					{
						text3 = GetValueFromArg(arg).Replace(TIC, string.Empty);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (text3 != string.Empty && DateTime.TryParse(text3, out result5) && !list.Contains(result5) && result5.CompareTo(result) != -1 && result5.CompareTo(result3) != 1 && result5.DayOfWeek != 0 && result5.DayOfWeek != DayOfWeek.Saturday)
					{
						list.Add(result5);
					}
				}
			}
			else
			{
				string text3;
				try
				{
					text3 = GetValueFromArg(range).Replace(TIC, string.Empty);
				}
				catch (Exception ex2)
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return ex2.Message;
				}
				if (text3.Length > 0 && DateTime.TryParse(array[2].Replace(TIC, string.Empty), out result5) && !list.Contains(result5) && result5.CompareTo(result) != -1 && result5.CompareTo(result3) != 1 && result5.DayOfWeek != 0 && result5.DayOfWeek != DayOfWeek.Saturday)
				{
					list.Add(result5);
				}
			}
		}
		int num = 0;
		int num2 = int.Parse(ComputeDatevalue(text2)) - int.Parse(ComputeDatevalue(text));
		DayOfWeek dayOfWeek = result.DayOfWeek;
		int num3 = (int)result3.DayOfWeek;
		if (result3.DayOfWeek == DayOfWeek.Saturday)
		{
			num3--;
			num2--;
		}
		int num4 = (int)(dayOfWeek - 1);
		int num5 = 7 - num3;
		num2 = num2 + num4 + num5;
		int num6 = num2 / 7 * 2;
		return (num2 - num4 - num5 - num6 + 1 - list.Count).ToString();
	}

	public string ComputeNetworkDaysintl(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		List<DateTime> list = new List<DateTime>();
		if (length != 2 && length > 4)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		string text2 = GetValueFromArg(array[1]).Replace(TIC, "");
		if (!DateTime.TryParse(text, out var result) || !DateTime.TryParse(text2, out var result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (length == 4)
		{
			string range = array[3];
			AdjustRangeArg(ref range);
			DateTime result3;
			if (range.IndexOf(':') > -1 || range.IndexOf(',') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(range);
				foreach (string arg in cellsFromArgs)
				{
					string text3;
					try
					{
						text3 = GetValueFromArg(arg).Replace(TIC, string.Empty);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (text3 != string.Empty && DateTime.TryParse(text3, out result3) && !list.Contains(result3) && result3.CompareTo(result) != -1 && result3.CompareTo(result2) != 1 && result3.DayOfWeek != 0 && result3.DayOfWeek != DayOfWeek.Saturday)
					{
						list.Add(result3);
					}
				}
			}
			else
			{
				string text3;
				try
				{
					text3 = GetValueFromArg(range).Replace(TIC, string.Empty);
				}
				catch (Exception ex2)
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return ex2.Message;
				}
				if (text3.Length > 0 && DateTime.TryParse(range, out result3) && !list.Contains(result3) && result3.CompareTo(result) != -1 && result3.CompareTo(result2) != 1 && result3.DayOfWeek != 0 && result3.DayOfWeek != DayOfWeek.Saturday)
				{
					list.Add(result3);
				}
			}
		}
		int result4 = 0;
		if (length <= 2 || !int.TryParse(array[2], out result4))
		{
			result4 = 1;
			List<object> list2 = new List<object>();
			list2.AddRange(SplitArguments(WeekEndType[result4].ToString(), ','));
			int num = int.Parse(ComputeDatevalue(text2)) - int.Parse(ComputeDatevalue(text)) + 1;
			int num2 = num;
			int j = 1;
			DateTime item = result;
			for (; j <= num; j++)
			{
				if (list2.IndexOf(((int)item.DayOfWeek).ToString()) >= 0)
				{
					num2--;
				}
				else if (list.IndexOf(item) >= 0)
				{
					num2--;
				}
				item = item.AddDays(1.0);
			}
			return num2.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeWorkDayintl(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		List<DateTime> list = new List<DateTime>();
		if (length > 4 || length < 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string s = GetValueFromArg(array[0]).Replace(TIC, "");
		double result = 0.0;
		double result2 = 0.0;
		if ((DateTime.TryParse(s, CultureInfo.CurrentCulture, DateTimeStyles.None, out var result3) || double.TryParse(s, out result2)) && double.TryParse(GetValueFromArg(array[1]).Replace(TIC, string.Empty), out result))
		{
			try
			{
				if (result2 > 0.0)
				{
					result3 = CalcEngineHelper.FromOADate(result2);
				}
				CalcEngineHelper.FromOADate(result);
				result2 += result;
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			int num = (int)result;
			if (length == 4)
			{
				string range = array[3];
				AdjustRangeArg(ref range);
				DateTime result4;
				if (range.IndexOf(':') > -1 || range.IndexOf(',') > -1)
				{
					string[] cellsFromArgs = GetCellsFromArgs(range);
					foreach (string arg in cellsFromArgs)
					{
						string text;
						try
						{
							text = GetValueFromArg(arg).Replace(TIC, string.Empty);
						}
						catch (Exception)
						{
							ExceptionThrown = true;
							if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
							{
								throw LibraryComputationException;
							}
							return ErrorStrings[4].ToString();
						}
						if (text != string.Empty && DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out result4) && !list.Contains(result4) && result4.CompareTo(result3) != -1)
						{
							list.Add(result4);
						}
					}
				}
				else
				{
					string text;
					try
					{
						double result5 = 0.0;
						text = GetValueFromArg(range).Replace(TIC, string.Empty);
						if (!double.TryParse(range, out result5) && !DateTime.TryParse(range, out var _))
						{
							return ErrorStrings[1].ToString();
						}
					}
					catch (Exception)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ErrorStrings[4].ToString();
					}
					if (text.Length > 0 && DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out result4) && !list.Contains(result4) && result4.CompareTo(result3) != -1)
					{
						list.Add(result4);
					}
				}
			}
			int result7 = -1;
			if (length <= 2 || !int.TryParse(array[2], out result7))
			{
				result7 = 1;
			}
			if (result7 == 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			List<object> list2 = new List<object>();
			list2.AddRange(SplitArguments(WeekEndType[result7].ToString(), ','));
			int num2 = 0;
			DateTime item = result3;
			if (num < 0)
			{
				while (num2 > num)
				{
					item = item.AddDays(-1.0);
					if (list2.IndexOf(((int)item.DayOfWeek).ToString()) < 0 && list.IndexOf(item) < 0)
					{
						num2--;
					}
				}
			}
			else
			{
				while (num2 < num)
				{
					item = item.AddDays(1.0);
					if (list2.IndexOf(((int)item.DayOfWeek).ToString()) < 0 && list.IndexOf(item) < 0)
					{
						num2++;
					}
				}
			}
			return ComputeDatevalue(item.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern));
		}
		if (array[0].Replace(TIC, string.Empty).Equals(string.Empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[1].ToString());
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeHour(string argList)
	{
		DateTime dateTime = DateTime.Now;
		if (SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		if (argList.IndexOf(TIC) > -1)
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		DateTime result = default(DateTime);
		double result2;
		if (DateTime.TryParse(argList, out result))
		{
			dateTime = DateTime.Parse(argList);
		}
		else if (double.TryParse(argList, NumberStyles.Any, null, out result2))
		{
			dateTime = CalcEngineHelper.FromOADate(result2);
		}
		return dateTime.Hour.ToString();
	}

	public string ComputeMinute(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		DateTime result = default(DateTime);
		double result2 = 0.0;
		if (!DateTime.TryParse(StripTics0(argList), out result) && !double.TryParse(argList, out result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		DateTime dateTime = DateTime.Now;
		if (argList.IndexOf(TIC) > -1)
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		double result3;
		if (DateTime.TryParse(argList, out result))
		{
			dateTime = DateTime.Parse(argList);
		}
		else if (double.TryParse(argList, NumberStyles.Any, null, out result3))
		{
			dateTime = CalcEngineHelper.FromOADate(result3);
		}
		return dateTime.Minute.ToString();
	}

	public string ComputeSecond(string argList)
	{
		DateTime dateTime = DateTime.Now;
		if (SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		if (argList.IndexOf(TIC) > -1)
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		DateTime result = default(DateTime);
		double result2;
		if (DateTime.TryParse(argList, out result))
		{
			dateTime = DateTime.Parse(argList);
		}
		else if (double.TryParse(argList, NumberStyles.Any, null, out result2))
		{
			dateTime = CalcEngineHelper.FromOADate(result2);
		}
		return dateTime.Second.ToString();
	}

	public string ComputeMonth(string argList)
	{
		double num = 1.0;
		if (SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (DateTime.TryParse(GetValueFromArg(argList).Replace(TIC, string.Empty), out var result))
		{
			num = result.Month;
		}
		else
		{
			if (!double.TryParse(GetValueFromArg(argList), NumberStyles.Any, null, out var result2))
			{
				return FormulaErrorStrings[invalid_arguments];
			}
			num = ((!(result2 < 1.0)) ? ((double)GetDateFromSerialDate((int)result2).Month) : 1.0);
		}
		return num.ToString();
	}

	public string ComputeNow(string argList)
	{
		if (!string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException("No argument required for this formula");
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		DateTime now = DateTime.Now;
		if (ExcelLikeComputations)
		{
			return now.ToString();
		}
		return now.ToOADate().ToString();
	}

	public string ComputeToday(string argList)
	{
		if (!string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException("No argument required for this formula");
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		DateTime now = DateTime.Now;
		if (ExcelLikeComputations && DateTime.TryParse(now.Year + "/" + now.Month + "/" + now.Day, out var result))
		{
			return result.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
		}
		if (computedValueLevel > 1)
		{
			return GetSerialDateTimeFromDate(now.Date).ToString();
		}
		return GetSerialDateFromDate(now.Year, now.Month, now.Day).ToString();
	}

	public string ComputeTime(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			TimeSpan timeSpan = new TimeSpan((int)result2, (int)result3, (int)result4);
			num = ((double)timeSpan.Hours + ((double)timeSpan.Minutes + (double)timeSpan.Seconds / 60.0) / 60.0) / 24.0;
			if (ExcelLikeComputations)
			{
				return timeSpan.ToString();
			}
		}
		return num.ToString("0.0########");
	}

	public string ComputeTimevalue(string argList)
	{
		DateTime result = DateTime.Now;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		double num;
		try
		{
			text2 = text2.Replace(TIC, string.Empty);
			if (!DateTime.TryParse(text2, CultureInfo.CurrentCulture, DateTimeStyles.None, out result))
			{
				double result2 = 0.0;
				double.TryParse(text2, NumberStyles.Any, null, out result2);
				result = CalcEngineHelper.FromOADate(result2);
			}
			num = ((double)result.Hour + ((double)result.Minute + (double)result.Second / 60.0) / 60.0) / 24.0;
		}
		catch
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		return num.ToString("0.0###########");
	}

	public string ComputeWeekday(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 1 && length != 2) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (array.Length == 2)
		{
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
		}
		double result = 1.0;
		double num = 0.0;
		if (DateTime.TryParse(GetValueFromArg(array[0]), out var result2) && (length == 1 || double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result)))
		{
			num = (double)result2.DayOfWeek;
		}
		else
		{
			if (!double.TryParse(GetValueFromArg(array[0]), NumberStyles.Any, null, out var result3) || (length != 1 && !double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result)))
			{
				return num.ToString();
			}
			num = (double)GetDateFromSerialDate((int)result3).DayOfWeek;
		}
		if (result == 1.0)
		{
			num += 1.0;
		}
		else
		{
			if (num == 0.0)
			{
				num = 7.0;
			}
			if (result == 3.0)
			{
				num -= 1.0;
			}
		}
		return num.ToString();
	}

	public string ComputeYear(string argList)
	{
		string valueFromArg = GetValueFromArg(argList);
		double num = 1.0;
		if (SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (DateTime.TryParse(valueFromArg.Replace(TIC, string.Empty), out var result))
		{
			num = result.Year;
		}
		else
		{
			if (!double.TryParse(GetValueFromArg(argList), NumberStyles.Any, null, out var result2))
			{
				return FormulaErrorStrings[invalid_arguments];
			}
			num = ((!(result2 < 1.0)) ? ((double)GetDateFromSerialDate((int)result2).Year) : 1900.0);
		}
		return num.ToString();
	}

	public string ComputeDatedIF(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		string result = string.Empty;
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[requires_3_args];
		}
		for (int i = 0; i < length; i++)
		{
			string empty = string.Empty;
			empty = ((i > 1) ? FormulaErrorStringCheck(array[i], FormulaArgumentType.Text) : FormulaErrorStringCheck(array[i].Replace(TIC, string.Empty), FormulaArgumentType.Date));
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		if (length == 3)
		{
			array[0] = GetValueFromArg(array[0]);
			array[1] = GetValueFromArg(array[1]);
			array[2] = array[2].Replace(TIC, string.Empty);
			DateTime result2 = dateTime1900;
			DateTime result3 = dateTime1900;
			if (double.TryParse(array[0], out var result4))
			{
				result2 = CalcEngineHelper.FromOADate(double.Parse(array[0]));
			}
			else
			{
				DateTime.TryParse(array[0].Replace(TIC, string.Empty), null, DateTimeStyles.None, out result2);
			}
			if (double.TryParse(array[1], out var _))
			{
				result3 = CalcEngineHelper.FromOADate(double.Parse(array[1]));
			}
			else
			{
				DateTime.TryParse(array[1].Replace(TIC, string.Empty), null, DateTimeStyles.None, out result3);
			}
			if (!double.TryParse(array[0], out result4) && !array[0].StartsWith(TIC))
			{
				array[0] = TIC + result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			}
			if (!double.TryParse(array[1], out result4) && !array[1].StartsWith(TIC))
			{
				array[1] = TIC + result3.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			}
			if (result2 > result3 && !result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern).Equals(result3.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (array[2].ToUpper().Equals("Y"))
			{
				double num = result3.Year - result2.Year;
				if ((result2.Month == result3.Month && result3.Day < result2.Day) || result3.Month < result2.Month)
				{
					num -= 1.0;
				}
				result = num.ToString();
			}
			else if (array[2].ToUpper().Equals("M"))
			{
				string s = ComputeDays(array[1] + parseArgumentSeparator + array[0]);
				int num2 = DateTime.DaysInMonth(result2.Year, result2.Month);
				result = (int.Parse(s) / num2).ToString();
			}
			else if (array[2].ToUpper().Equals("D"))
			{
				result = ComputeDays(array[1] + parseArgumentSeparator + array[0]);
			}
			else if (array[2].ToUpper().Equals("YM"))
			{
				string text = TIC + result3.Month + "/" + result3.Day + "/" + result2.Year + TIC;
				string s2 = ComputeDays(text + parseArgumentSeparator + array[0]);
				int num3 = DateTime.DaysInMonth(result2.Year, result2.Month);
				result = (int.Parse(s2) / num3).ToString();
			}
			else if (array[2].ToUpper().Equals("MD"))
			{
				result = (result3.Day - result2.Day).ToString();
			}
			else
			{
				if (!array[2].ToUpper().Equals("YD"))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[4].ToString());
					}
					return ErrorStrings[4].ToString();
				}
				string text2 = TIC + result3.Month + "/" + result3.Day + "/" + result2.Year + TIC;
				result = ComputeDays(text2 + parseArgumentSeparator + array[0]);
			}
		}
		return result;
	}

	private bool Daysfeb29(DateTime sDate, DateTime eDate)
	{
		DateTime dateTime = new DateTime(sDate.Year, 2, 1);
		DateTime dateTime2 = new DateTime(eDate.Year, 2, 1);
		int num = int.Parse(ComputeDatevalue(sDate.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern))) - int.Parse(ComputeDatevalue(dateTime.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)));
		int num2 = int.Parse(ComputeDatevalue(eDate.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern))) - int.Parse(ComputeDatevalue(dateTime.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)));
		int num3 = int.Parse(ComputeDatevalue(sDate.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern))) - int.Parse(ComputeDatevalue(dateTime2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)));
		int num4 = int.Parse(ComputeDatevalue(eDate.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern))) - int.Parse(ComputeDatevalue(dateTime2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern)));
		if (DateTime.IsLeapYear(sDate.Year) && num < 0 && num2 >= 0)
		{
			return true;
		}
		if (DateTime.IsLeapYear(eDate.Year) && num3 < 0 && num4 >= 0)
		{
			return true;
		}
		return false;
	}

	private int GetSerialDateFromDate(int y, int m, int d)
	{
		int num = 0;
		if (y < 1900)
		{
			y += 1900;
		}
		bool flag = false;
		while (!flag)
		{
			while (m > 12)
			{
				m -= 12;
				y++;
			}
			while (m < 1 && y > 1900)
			{
				m += 12;
				y--;
			}
			if (y < 1900 || (m < 1 && y <= 1900))
			{
				return -1;
			}
			flag = true;
			int day = new DateTime(y, m, 1).AddMonths(1).AddDays(-1.0).Day;
			while (d > day)
			{
				d -= day;
				m++;
				if (m > 12)
				{
					m -= 12;
					y++;
				}
				day = new DateTime(y, m, 1).AddMonths(1).AddDays(-1.0).Day;
				flag = false;
			}
			while (d < 1)
			{
				m--;
				day = new DateTime(y, m + 1, 1).AddHours(-1.0).Day;
				d = day + d;
			}
		}
		num = 1 + (new DateTime(y, m, d, 0, 0, 0) - dateTime1900).Days;
		if (Treat1900AsLeapYear && num > 59)
		{
			num++;
		}
		return num;
	}

	internal double GetSerialDateTimeFromDate(DateTime dt)
	{
		double num = CalcEngineHelper.ToOADate(dt) - dateTime1900Double;
		num = 1.0 + CalcEngineHelper.ToOADate(dt) - dateTime1900Double;
		if (Treat1900AsLeapYear && num > 59.0)
		{
			num += 1.0;
		}
		if (UseDate1904)
		{
			num -= 1462.0;
		}
		return num;
	}

	private DateTime GetDateFromSerialDate(int days)
	{
		days--;
		if (Treat1900AsLeapYear && days > 59)
		{
			days--;
		}
		return dateTime1900.AddDays(days);
	}

	public string BaseToBase(string argList, int from, int to)
	{
		argList = argList.Replace(TIC, string.Empty);
		return Convert.ToString(Convert.ToInt64(argList, from), to);
	}

	public string ComputeDec2Bin(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text2 = ((array.Length > 1) ? GetValueFromArg(array[1]).Replace(TIC, string.Empty) : "10");
		text2 = ((array.Length > 1 && !string.IsNullOrEmpty(array[0]) && string.IsNullOrEmpty(array[1]) && !array[1].Contains(TIC)) ? "10" : text2);
		string text3 = string.Empty;
		if (string.IsNullOrEmpty(argList) || array.Length > 2 || array.Length < 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (double.TryParse(text2, out var result) && result < 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[4].ToString();
		}
		string text4 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		if ((!double.TryParse(text, out var _) || !double.TryParse(text2.Replace(TIC, string.Empty), out result)) && (string.IsNullOrEmpty(text) || (string.IsNullOrEmpty(text) && string.IsNullOrEmpty(text2.Replace(TIC, string.Empty)))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[0].ToString();
		}
		try
		{
			if (array.Length > 1 && !string.IsNullOrEmpty(array[1]))
			{
				num = int.Parse(GetValueFromArg(array[1]).Replace(TIC, string.Empty));
			}
			if (double.Parse(text) < -512.0 || double.Parse(text) > 511.0)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[value_between] + " -512 & 512");
				}
				return ErrorStrings[4].ToString();
			}
			text3 = BaseToBase(text, 10, 2);
			if (double.TryParse(text, out var result3) && result3 < 0.0)
			{
				text3 = text3.Substring(text3.Length - 10);
			}
			if (array.Length > 1)
			{
				if (num > 10 || (!string.IsNullOrEmpty(array[1]) && num < text3.Length && text3.Length != 10))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[4].ToString();
				}
				if (num <= 10)
				{
					text3 = text3.PadLeft(num, '0');
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
		}
		return text3;
	}

	public string ComputeDec2Oct(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text2 = ((array.Length > 1) ? GetValueFromArg(array[1]).Replace(TIC, string.Empty) : "10");
		text2 = ((array.Length > 1 && !string.IsNullOrEmpty(array[0]) && string.IsNullOrEmpty(array[1]) && !array[1].Contains(TIC)) ? "10" : text2);
		if (string.IsNullOrEmpty(argList) || array.Length > 2 || array.Length < 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (double.TryParse(text2, out var result) && result < 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if ((!double.TryParse(text, out var _) || !double.TryParse(text2, out result)) && (string.IsNullOrEmpty(text) || (string.IsNullOrEmpty(text) && string.IsNullOrEmpty(text2.Replace(TIC, string.Empty)))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[0].ToString();
		}
		string text4 = string.Empty;
		if (array.Length > 1 && !string.IsNullOrEmpty(array[1]))
		{
			num = int.Parse(GetValueFromArg(array[1]).Replace(TIC, string.Empty));
		}
		try
		{
			if (ComputeIsNumber(text) != TRUEVALUESTR || double.Parse(text) < -536870912.0 || double.Parse(text) > 536870911.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[value_between] + " -536870912 & 536870911");
				}
				return ErrorStrings[4].ToString();
			}
			text4 = (text4 = BaseToBase(text, 10, 8));
			if (double.TryParse(text, out var result3) && result3 < 0.0)
			{
				text4 = text4.Substring(text4.Length - 10);
			}
			if (array.Length > 1)
			{
				if (num > 10 || (!string.IsNullOrEmpty(array[1]) && num < text4.Length && text4.Length != 10))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[4].ToString();
				}
				if (num <= 10)
				{
					text4 = text4.PadLeft(num, '0');
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
		}
		return text4;
	}

	public string ComputeDec2Hex(string argList)
	{
		int num = 0;
		int result = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text2 = ((array.Length > 1) ? GetValueFromArg(array[1]).Replace(TIC, string.Empty) : "10");
		text2 = ((array.Length > 1 && !string.IsNullOrEmpty(array[0]) && string.IsNullOrEmpty(array[1]) && !array[1].Contains(TIC)) ? "10" : text2);
		if (string.IsNullOrEmpty(argList) || array.Length > 2 || array.Length < 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (double.TryParse(text2, out var result2) && result2 < 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if ((!double.TryParse(text, out var _) || !double.TryParse(text2.Replace(TIC, string.Empty), out result2)) && (string.IsNullOrEmpty(text) || (string.IsNullOrEmpty(text) && string.IsNullOrEmpty(text2.Replace(TIC, string.Empty)))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[0].ToString();
		}
		if (!int.TryParse(text, out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[value_between] + " -549,755,813,888 & 549,755,813,887");
			}
			return ErrorStrings[4].ToString();
		}
		string text4 = string.Empty;
		if (array.Length > 1 && !string.IsNullOrEmpty(array[1]))
		{
			num = int.Parse(GetValueFromArg(array[1]).Replace(TIC, string.Empty));
		}
		try
		{
			if (ComputeIsNumber(text) != TRUEVALUESTR || int.Parse(text) < -536870912 || int.Parse(text) > 536870911)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[value_between] + " -536870912 & 536870911");
				}
				text4 = ErrorStrings[4].ToString();
			}
			else
			{
				text4 = (text4 = BaseToBase(text, 10, 16));
				if (double.TryParse(text, out var result4) && result4 < 0.0)
				{
					text4 = text4.Substring(text4.Length - 10);
				}
				if (array.Length > 1)
				{
					if (num > 10 || (!string.IsNullOrEmpty(array[1]) && num < text4.Length && text4.Length != 10))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_index]);
						}
						return ErrorStrings[4].ToString();
					}
					if (num <= 10)
					{
						text4 = text4.PadLeft(num, '0');
					}
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
		}
		return text4.ToUpper();
	}

	public string ComputeBin2Oct(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string empty = string.Empty;
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		try
		{
			if (bool.TryParse(text, out var result) || (array.Length > 1 && bool.TryParse(GetValueFromArg(array[1]), out result)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0 || (array.Length > 1 && double.Parse(GetValueFromArg(array[1])) < 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (array.Length > 1)
			{
				num = int.Parse(array[1]);
			}
			if (text.Length == 10 && text.Substring(0, 1) == "1")
			{
				int num2 = 10;
				string text3 = "";
				for (int i = 0; i < 3; i++)
				{
					num2 -= 3;
					string argList2 = text.Substring(num2, 3);
					int num3 = int.Parse(BaseToBase(argList2, 2, 8));
					int num4 = 0;
					for (int num5 = num3; num5 > 0; num5 /= 10)
					{
						num4 += num5 % 10;
					}
					text3 = num4 + text3;
				}
				return "7777777" + text3;
			}
			if (text.Length > 10)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				empty = ErrorStrings[4].ToString();
			}
			else
			{
				empty = BaseToBase(text, 2, 8);
				if (array.Length > 1)
				{
					if (num >= empty.Length && num <= 10)
					{
						empty = empty.PadLeft(num, '0');
					}
					else
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
						}
						empty = ErrorStrings[4].ToString();
					}
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[4].ToString();
		}
		return empty;
	}

	public string ComputeBin2Dec(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		try
		{
			if (text2 == "")
			{
				text2 = "0";
			}
			string result = Convert.ToInt32(text2, 2).ToString();
			if (text2.Length == 10 && text2.Substring(0, 1) == "1")
			{
				return (Convert.ToInt32(text2.Substring(1), 2) - 512).ToString();
			}
			return result;
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text2 == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeBin2Hex(string argList)
	{
		double num = 0.0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string valueFromArg = GetValueFromArg(StripTics0(array[0]));
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		string empty = string.Empty;
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		try
		{
			if (bool.TryParse(valueFromArg, out var result) || (array.Length > 1 && bool.TryParse(GetValueFromArg(array[1]), out result)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(valueFromArg) < 0.0 || (array.Length > 1 && double.Parse(GetValueFromArg(array[1])) < 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (array.Length > 1)
			{
				num = double.Parse(GetValueFromArg(array[1]));
			}
			if (valueFromArg == "1111111111")
			{
				return valueFromArg.Replace('1', 'F');
			}
			if (valueFromArg.Length == 10 && valueFromArg.Substring(0, 1) == "1")
			{
				return (1073741312 + int.Parse(Convert.ToString(Convert.ToInt32(valueFromArg, 2), 8))).ToString();
			}
			if (valueFromArg.Length > 10)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				empty = ErrorStrings[4].ToString();
			}
			else if (double.Parse(valueFromArg) < -1.0 || num < -1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				empty = ErrorStrings[4].ToString();
			}
			else
			{
				empty = BaseToBase(valueFromArg, 2, 16);
				if (array.Length > 1)
				{
					if (num >= (double)empty.Length && num <= 10.0)
					{
						empty = empty.PadLeft((int)num, '0');
					}
					else
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
						}
						empty = ErrorStrings[4].ToString();
					}
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(valueFromArg) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (valueFromArg == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
		return empty.ToUpper();
	}

	public string ComputeHex2Bin(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.Equals(ParseArgumentSeparator.ToString()))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		if (array.Length == 2)
		{
			string text = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string text2 = ((array.Length == 2) ? GetValueFromArg(array[1]) : "1");
		text2 = (string.IsNullOrEmpty(text2) ? "1" : text2);
		double result = 0.0;
		if (double.TryParse(text2, out result) && (result < 0.0 || result > 10.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (bool.TryParse(GetValueFromArg(array[0]), out var result2) || (array.Length == 2 && bool.TryParse(GetValueFromArg(array[1]), out result2)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (!valueFromArg.Equals(string.Empty))
		{
			if (!valueFromArg.StartsWith(TIC) && !IsCellReference(valueFromArg) && !double.TryParse(valueFromArg, out var _))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[5].ToString());
				}
				return ErrorStrings[5].ToString();
			}
		}
		else if (IsCellReference(array[0]) && valueFromArg.Equals(string.Empty))
		{
			return "0";
		}
		if (valueFromArg.StartsWith(TIC) && string.IsNullOrEmpty(valueFromArg.Replace(TIC, string.Empty)))
		{
			return "0";
		}
		if (text2.StartsWith(TIC) && !double.TryParse(text2.Replace(TIC, string.Empty), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (!double.TryParse(text2.Replace(TIC, string.Empty), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		num = (int)result;
		if (num < 0 || valueFromArg.StartsWith("-"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		string empty = string.Empty;
		try
		{
			empty = BaseToBase(valueFromArg, 16, 2);
			if (valueFromArg.Replace(TIC, string.Empty) == "FFFFFFFFFF")
			{
				return valueFromArg.Replace('F', '1').Replace(TIC, string.Empty);
			}
			if (empty.Length > 10 || num > 10 || (num < empty.Length && num != 0 && array.Length > 1) || (num == 0 && array.Length > 1))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (num >= empty.Length)
			{
				empty = empty.PadLeft(num, '0');
			}
			else if (num != 0 && array.Length > 1)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (double.TryParse(empty, out var result4) && result4 > 536870911.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter] + ex.Message);
			}
			return ErrorStrings[4].ToString();
		}
		return empty;
	}

	public string ComputeHex2Oct(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (array.Length == 1 && array[0].Contains(parseArgumentSeparator.ToString()) && !double.TryParse(array[0].Replace(TIC, string.Empty), out var _))
		{
			return ErrorStrings[4].ToString();
		}
		if (argList.Equals(ParseArgumentSeparator.ToString()))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		if (array.Length == 2)
		{
			string text = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		string text2 = GetValueFromArg(array[0]);
		string text3 = ((array.Length == 2) ? GetValueFromArg(array[1]) : "0");
		double result2 = 0.0;
		if (!text2.Equals(string.Empty) && !text2.StartsWith(TIC) && !IsCellReference(text2) && !double.TryParse(text2, out var _))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		if (bool.TryParse(GetValueFromArg(array[0]), out var result4) || (array.Length == 2 && bool.TryParse(GetValueFromArg(array[1]), out result4)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (text2.StartsWith(TIC) && string.IsNullOrEmpty(text2.Replace(TIC, string.Empty)))
		{
			return "0";
		}
		if (text2.Contains(ParseArgumentSeparator.ToString()))
		{
			int num2 = text2.IndexOf(ParseArgumentSeparator);
			text2 = text2.Replace(TIC, string.Empty).Substring(0, num2 - 1);
		}
		string empty = string.Empty;
		if (!double.TryParse(text3.Replace(TIC, string.Empty), out result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		num = (int)result2;
		if (num < 0 || text2.StartsWith("-"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (array.Length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new Exception(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[25];
		}
		if (array.Length > 1)
		{
			num = int.Parse(StripTics0(array[1]));
		}
		try
		{
			text2 = text2.Replace(TIC, string.Empty);
			empty = BaseToBase(text2, 16, 8);
			double result5 = 0.0;
			string text4 = BaseToBase(text2, 16, 2);
			if (text4.Length > 10 && text4.Length % 4 == 0)
			{
				if (text4.StartsWith("1") && double.TryParse(BaseToBase(text2, 16, 10), out result5) && result5 < 1098974756864.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[4].ToString());
					}
					return ErrorStrings[4].ToString();
				}
				if (text4.StartsWith("0") && result5 > 536870911.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[4].ToString());
					}
					return ErrorStrings[4].ToString();
				}
			}
			else if (double.TryParse(BaseToBase(text2, 16, 10), out result5) && result5 > 536870911.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (empty.Length > 10)
			{
				empty = empty.Substring(empty.Length - 10);
			}
			if (array.Length > 1)
			{
				if (num >= empty.Length && num <= 10)
				{
					empty = empty.PadLeft(num, '0');
				}
				else
				{
					if (rethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[parameter_place]);
					}
					empty = ErrorStrings[4].ToString();
				}
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[4].ToString();
			}
			if (text2 == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
		return empty;
	}

	public string ComputeHex2Dec(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (string.IsNullOrEmpty(StripTics0(argList)))
		{
			return "0";
		}
		string text = GetValueFromArg(array[0]);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double.TryParse(text, out result);
		if (result < 0.0 || text.Replace(TIC, string.Empty).Length > 10 || string.IsNullOrEmpty(StripTics0(argList).Trim()))
		{
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (text.Contains(ParseArgumentSeparator.ToString()))
		{
			int num = text.IndexOf(ParseArgumentSeparator);
			text = text.Replace(TIC, string.Empty).Substring(0, num - 1);
		}
		string empty = string.Empty;
		try
		{
			text = text.Replace(TIC, string.Empty);
			if (array.Length > 1)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
				}
				return FormulaErrorStrings[10].ToString();
			}
			empty = BaseToBase(text, 16, 10);
			if (text.Replace(TIC, string.Empty) == "FFFFFFFFFF")
			{
				return "-1";
			}
			return empty;
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeOct2Bin(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string empty = string.Empty;
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[25];
		}
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		try
		{
			if (bool.TryParse(text, out var result) || (array.Length > 1 && bool.TryParse(GetValueFromArg(array[1]), out result)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0 || (array.Length > 1 && double.Parse(GetValueFromArg(array[1])) < 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (array.Length > 1)
			{
				num = int.Parse(array[1]);
			}
			empty = BaseToBase(text, 8, 2);
			if (array.Length > 1)
			{
				if (num >= empty.Length && num <= 10)
				{
					empty = empty.PadLeft(num, '0');
				}
				else
				{
					if (rethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[parameter_place]);
					}
					empty = ErrorStrings[4].ToString();
				}
			}
			else if (empty.Length > 10)
			{
				empty = empty.Substring(empty.Length - 10, 10);
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
		return empty;
	}

	public string ComputeOct2Hex(string argList)
	{
		int num = 0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[25];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		bool flag = array.Length == 2 && array[1].Contains("u");
		if (array[0].Contains("u") || flag)
		{
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
			}
			return ErrorStrings[4].ToString();
		}
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		flag = array.Length == 2 && ComputeIsNumber(array[1]) != TRUEVALUESTR;
		string empty = string.Empty;
		try
		{
			if (array.Length > 2)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return FormulaErrorStrings[25];
			}
			if (array.Length > 1)
			{
				num = int.Parse(array[1]);
			}
			if (bool.TryParse(text, out var result) || (array.Length > 1 && bool.TryParse(GetValueFromArg(array[1]), out result)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			if (text.Length > 10)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[parameter_length]);
				}
				return ErrorStrings[4].ToString();
			}
			empty = (empty = BaseToBase(text, 8, 16));
			if (array.Length > 1)
			{
				if (num < empty.Length || num > 10)
				{
					if (rethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[parameter_place]);
					}
					return ErrorStrings[4].ToString();
				}
				empty = empty.PadLeft(num, '0');
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[4].ToString();
		}
		return empty.ToUpper();
	}

	public string ComputeOct2Dec(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]);
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		string empty = string.Empty;
		try
		{
			text = text.Replace(TIC, string.Empty);
			if (array.Length > 1)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
				}
				return formulaErrorStrings[10].ToString();
			}
			if (text.Length > 10)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[parameter_length]);
				}
				return ErrorStrings[4].ToString();
			}
			return BaseToBase(text, 8, 10);
		}
		catch
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeReal(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		string valueFromArg = GetValueFromArg(array[0]);
		if (ErrorStrings.Contains(valueFromArg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return valueFromArg;
		}
		valueFromArg = valueFromArg.Replace(TIC, string.Empty);
		valueFromArg = valueFromArg.TrimEnd();
		if (valueFromArg == "")
		{
			return ErrorStrings[4].ToString();
		}
		int num = valueFromArg.IndexOf('+');
		int num2 = valueFromArg.IndexOf('-');
		if (num == 0)
		{
			num = valueFromArg.IndexOf('+', 1);
		}
		if (num2 == 0)
		{
			num2 = valueFromArg.IndexOf('-', 1);
		}
		string text = valueFromArg.Substring(valueFromArg.Length - 1, 1);
		bool flag = text == "i" || text == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(valueFromArg) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		if (valueFromArg.ToUpper().Equals(TRUEVALUESTR) || valueFromArg.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		if (num >= 0 || num2 >= 0)
		{
			if (!flag)
			{
				return ErrorStrings[4].ToString();
			}
			if (num >= 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					if (!(ComputeIsText(valueFromArg.Substring(0, num)) == TRUEVALUESTR))
					{
						return valueFromArg.Substring(0, num);
					}
					return FormulaErrorStrings[invalid_parameter];
				}
				if (!(ComputeIsText(valueFromArg.Substring(0, num)) == TRUEVALUESTR))
				{
					return valueFromArg.Substring(0, num);
				}
				return ErrorStrings[4].ToString();
			}
			if (RethrowParseExceptions)
			{
				if (!(ComputeIsText(valueFromArg.Substring(0, num2 - 1)) == TRUEVALUESTR) && !(ComputeIsText(valueFromArg.Substring(num2 + 1, valueFromArg.Length - num2 - 2)) == TRUEVALUESTR))
				{
					return valueFromArg.Substring(0, num2);
				}
				return FormulaErrorStrings[invalid_parameter];
			}
			if (!(ComputeIsText(valueFromArg.Substring(0, num2 - 1)) == TRUEVALUESTR) && !(ComputeIsText(valueFromArg.Substring(num2 + 1, valueFromArg.Length - num2 - 2)) == TRUEVALUESTR))
			{
				return valueFromArg.Substring(0, num2);
			}
			return ErrorStrings[4].ToString();
		}
		if (flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				if (!(ComputeIsText(valueFromArg.Substring(0, valueFromArg.Length - 1)) == TRUEVALUESTR))
				{
					return "0";
				}
				return FormulaErrorStrings[invalid_parameter];
			}
			if (!(ComputeIsText(valueFromArg.Substring(0, valueFromArg.Length - 1)) == TRUEVALUESTR))
			{
				return "0";
			}
			return ErrorStrings[4].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			if (!(ComputeIsText(valueFromArg) == TRUEVALUESTR))
			{
				return valueFromArg;
			}
			return FormulaErrorStrings[invalid_parameter];
		}
		if (!(ComputeIsText(valueFromArg) == TRUEVALUESTR))
		{
			return valueFromArg;
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeImaginary(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = text.Replace("+i", "+1i").Replace("-i", "-1i").Replace("+j", "+1j")
			.Replace("-j", "-1j");
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		int num = text.IndexOf('+');
		int num2 = text.IndexOf('-');
		if (num == 0)
		{
			num = text.IndexOf('+', 1);
		}
		if (num2 == 0)
		{
			num2 = text.IndexOf('-', 1);
		}
		string text2 = text.Substring(text.Length - 1, 1);
		bool flag = text2 == "i" || text2 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		if (num >= 0 || num2 >= 0)
		{
			if (!flag)
			{
				return ErrorStrings[4].ToString();
			}
			if (num >= 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					if (!(ComputeIsText(text.Substring(0, num)) == TRUEVALUESTR))
					{
						return text.Substring(num + 1, text.Length - num - 2);
					}
					return FormulaErrorStrings[invalid_parameter];
				}
				if (!(ComputeIsText(text.Substring(0, num)) == TRUEVALUESTR))
				{
					return text.Substring(num + 1, text.Length - num - 2);
				}
				return ErrorStrings[4].ToString();
			}
			if (RethrowLibraryComputationExceptions)
			{
				if (!(ComputeIsText(text.Substring(0, num2 - 1)) == TRUEVALUESTR) && !(ComputeIsText(text.Substring(num2 + 1, text.Length - num2 - 2)) == TRUEVALUESTR))
				{
					return "-" + text.Substring(num2 + 1, text.Length - num2 - 2);
				}
				return FormulaErrorStrings[invalid_parameter];
			}
			if (!(ComputeIsText(text.Substring(0, num2 - 1)) == TRUEVALUESTR) && !(ComputeIsText(text.Substring(num2 + 1, text.Length - num2 - 2)) == TRUEVALUESTR))
			{
				return "-" + text.Substring(num2 + 1, text.Length - num2 - 2);
			}
			return ErrorStrings[4].ToString();
		}
		if (flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				if (!(ComputeIsText(text.Substring(0, text.Length - 1)) == TRUEVALUESTR))
				{
					return text.Substring(0, text.Length - 1);
				}
				return FormulaErrorStrings[invalid_parameter];
			}
			string text3 = ((ComputeIsText(text.Substring(0, text.Length - 1)) == TRUEVALUESTR) ? ErrorStrings[4].ToString() : text.Substring(0, text.Length - 1));
			if (text3 == "")
			{
				return "1";
			}
			return text3;
		}
		if (!(ComputeIsText(text) == TRUEVALUESTR))
		{
			return "0";
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeImABS(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[25].ToString();
		}
		if (ErrorStrings.Contains(text))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return text;
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1, 1);
		bool flag = text2 == "i" || text2 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			return Math.Sqrt(Math.Pow(double.Parse(text3), 2.0) + Math.Pow(double.Parse(text4), 2.0)).ToString();
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[1].ToString();
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeImProduct(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string empty = string.Empty;
		int num = 0;
		array[0] = GetValueFromArg(array[0]);
		string text = ComputeReal(array[0]);
		string text2 = ComputeImaginary(array[0]);
		if (array.Length < 1)
		{
			return ErrorStrings[5].ToString();
		}
		empty = array[0].Replace(TIC, string.Empty);
		if (empty == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (array.Length == 1 && ComputeIsText(array[num]) == FALSEVALUESTR)
		{
			empty = array[num];
		}
		if (empty.ToUpper().Equals(TRUEVALUESTR) || empty.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text3 = empty.Substring(empty.Length - 1, 1);
		bool flag = text3 == "i" || text3 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(empty) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		for (num = 1; num < array.Length; num++)
		{
			if (empty != string.Empty)
			{
				text = ComputeReal(empty);
				text2 = ComputeImaginary(empty);
			}
			string text4 = ComputeReal(array[num]);
			string text5 = ComputeImaginary(array[num]);
			if (array[num].Contains(TIC))
			{
				array[num] = array[num].Replace(TIC, string.Empty);
			}
			if (array[num] == "")
			{
				return ErrorStrings[4].ToString();
			}
			string text6 = array[num].Substring(array[num].Length - 1, 1);
			bool flag2 = text6 == "i" || text6 == "j";
			if (text3 != text6 && flag2 && flag)
			{
				return ErrorStrings[1].ToString();
			}
			text3 = text6;
			flag = flag2;
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			try
			{
				double num2 = double.Parse(text);
				double num3 = double.Parse(text2);
				double num4 = double.Parse(text4);
				double num5 = double.Parse(text5);
				empty = ComputeComplex((num2 * num4 - num3 * num5).ToString() + ParseArgumentSeparator + (num2 * num5 + num3 * num4));
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions)
				{
					throw;
				}
				return FormulaErrorStrings[21].ToString();
			}
		}
		return empty;
	}

	public string ComputeComplex(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length < 2 || array.Length > 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[13].ToString());
			}
			return FormulaErrorStrings[13].ToString();
		}
		for (int i = 0; i < 2; i++)
		{
			string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = valueFromArg.Replace(TIC, "");
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg2 = valueFromArg2.Replace(TIC, "");
		try
		{
			if (double.IsInfinity(double.Parse(valueFromArg)) || double.IsInfinity(double.Parse(valueFromArg2)) || double.IsNaN(double.Parse(valueFromArg)) || double.IsNaN(double.Parse(valueFromArg2)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException();
				}
				return ErrorStrings[4].ToString();
			}
			if (array.Length <= 3)
			{
				string text2 = ((array.Length != 3) ? "" : array[2]);
				text2 = ((text2 == "") ? "i" : (text2 = array[2]));
				text2 = text2.Replace(TIC, string.Empty);
				if (text2 != "i" && text2 != "j")
				{
					if (rethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_suffix]);
					}
					return ErrorStrings[1].ToString();
				}
				if (double.Parse(valueFromArg) == 0.0 && double.Parse(valueFromArg2) == 0.0)
				{
					return "0";
				}
				if (double.Parse(valueFromArg) == 0.0)
				{
					return (double.Parse(valueFromArg2) == 1.0) ? text2 : (valueFromArg2.ToString() + text2);
				}
				if (double.Parse(valueFromArg2) == 0.0)
				{
					return valueFromArg;
				}
				string text3 = ((double.Parse(valueFromArg2) > 0.0) ? "+" : "");
				return valueFromArg + text3 + ((double.Parse(valueFromArg2) == 1.0) ? text2 : (valueFromArg2 + text2));
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[21].ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(valueFromArg) == TRUEVALUESTR || ComputeIsText(valueFromArg2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (valueFromArg == "" || valueFromArg2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImSum(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		string text2 = null;
		string text3 = null;
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text4 = text.Substring(text.Length - 1, 1);
		bool flag = text4 == "i" || text4 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		for (int i = 1; i < array.Length; i++)
		{
			string text5 = ComputeReal(text);
			string text6 = ComputeImaginary(text);
			if (array.Length > 1)
			{
				text2 = ComputeReal(array[i]);
				text3 = ComputeImaginary(array[i]);
				if (array[i].Contains(TIC))
				{
					array[i] = array[i].Replace(TIC, string.Empty);
				}
			}
			else
			{
				text2 = "0";
				text3 = "0";
			}
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			if (ErrorStrings.Contains(text6))
			{
				return text6;
			}
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
			string text7 = array[i].Substring(array[i].Length - 1, 1);
			bool flag2 = text7 == "i" || text7 == "j";
			if (text7 != text4 && flag && flag2)
			{
				return ErrorStrings[1].ToString();
			}
			text4 = text7;
			flag = flag2;
			try
			{
				string argList2 = (double.Parse(text5) + double.Parse(text2)).ToString() + ParseArgumentSeparator + (double.Parse(text6) + double.Parse(text3));
				text = ComputeComplex(argList2);
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
				}
				if (ComputeIsText(text) == TRUEVALUESTR)
				{
					return ErrorStrings[5].ToString();
				}
				if (text == "")
				{
					return ErrorStrings[4].ToString();
				}
				return ErrorStrings[1].ToString();
			}
		}
		return text;
	}

	public string ComputeImSub(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		string text2 = GetValueFromArg(array[1]).Replace(TIC, "");
		if (text == "" || text2 == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text3 = text.Substring(text.Length - 1, 1);
		bool flag = text3 == "i" || text3 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		for (int i = 1; i < array.Length; i++)
		{
			array[i] = array[i].Replace(TIC, string.Empty);
			string text4 = ComputeReal(text);
			string text5 = ComputeImaginary(text);
			string text6 = ComputeReal(text2);
			string text7 = ComputeImaginary(text2);
			string text8 = array[i].Substring(array[i].Length - 1, 1);
			bool flag2 = text8 == "i" || text8 == "j";
			if (text8 != text3 && flag && flag2)
			{
				return ErrorStrings[1].ToString();
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			if (ErrorStrings.Contains(text6))
			{
				return text6;
			}
			if (ErrorStrings.Contains(text7))
			{
				return text7;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			try
			{
				string argList2 = (double.Parse(text4) - double.Parse(text6)).ToString() + ParseArgumentSeparator + (double.Parse(text5) - double.Parse(text7));
				text = ComputeComplex(argList2);
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions)
				{
					throw;
				}
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[21].ToString());
				}
				return FormulaErrorStrings[21].ToString();
			}
		}
		return text;
	}

	public string ComputeImConjugate(string argList)
	{
		string text = string.Empty;
		bool flag = false;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		string valueFromArg = GetValueFromArg(array[0]);
		if (valueFromArg == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (valueFromArg.ToUpper().Equals(TRUEVALUESTR) || valueFromArg.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = valueFromArg.Replace(TIC, "");
		if (text2.Length > 1)
		{
			text = text2.Substring(valueFromArg.Length - 3);
			flag = text == "i" || text == "j";
			text = ((text == "i" || text == "j") ? text : "i");
		}
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(valueFromArg) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(valueFromArg);
		string text4 = ComputeImaginary(valueFromArg);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string argList2 = double.Parse(text3).ToString() + ParseArgumentSeparator + "-" + double.Parse(text4) + ParseArgumentSeparator + text;
			return (text4 != "0") ? ComputeComplex(argList2) : valueFromArg;
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[21].ToString();
		}
	}

	public string ComputeImDiv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1, 1);
		bool flag = text2 == "i" || text2 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		try
		{
			if (array.Length <= 1 || array.Length > 2)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = ComputeReal(array[0].Replace(TIC, ""));
			string text4 = ComputeImaginary(array[0].Replace(TIC, ""));
			string text5 = GetValueFromArg(array[1]).Replace(TIC, "");
			string text6 = text5.Substring(text5.Length - 1, 1);
			bool flag2 = text6 == "i" || text6 == "j";
			if (text6 != text2 && flag && flag2)
			{
				return ErrorStrings[4].ToString();
			}
			string text7 = ComputeReal(text5);
			string text8 = ComputeImaginary(text5);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			if (ErrorStrings.Contains(text7))
			{
				return text7;
			}
			if (ErrorStrings.Contains(text8))
			{
				return text8;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (text7 == "0" && text8 == "0")
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[num_null]);
				}
				return ErrorStrings[4].ToString();
			}
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = double.Parse(text7);
			double num4 = double.Parse(text8);
			double num5 = num3 * num3 + num4 * num4;
			string argList2 = ((num * num3 + num2 * num4) / num5).ToString() + ParseArgumentSeparator + (num2 * num3 - num * num4) / num5;
			return ComputeComplex(argList2).ToString();
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ex.Message);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImSqrt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string text5 = Math.Sqrt((double.Parse(Math.Sqrt(double.Parse(text3) * double.Parse(text3) + double.Parse(text4) * double.Parse(text4)).ToString()) - double.Parse(text3)) / 2.0).ToString();
			string argList2 = (double.Parse(text4) / (2.0 * double.Parse(text5))).ToString() + ParseArgumentSeparator + text5;
			return ComputeComplex(argList2);
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImArgument(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1, 1);
		bool flag = text2 == "i" || text2 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		try
		{
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			if (num == 0.0 && num2 == 0.0)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[3].ToString();
			}
			if (num == 0.0 && num2 > 0.0)
			{
				return (Math.PI / 2.0).ToString();
			}
			if (num == 0.0 && num2 < 0.0)
			{
				return (-Math.PI / 2.0).ToString();
			}
			if (num2 == 0.0 && num > 0.0)
			{
				return "0";
			}
			if (num2 == 0.0 && num < 0.0)
			{
				return (-Math.PI).ToString();
			}
			if (num > 0.0)
			{
				return Math.Atan(num2 / num).ToString();
			}
			if (num < 0.0 && num2 >= 0.0)
			{
				return (Math.Atan(num2 / num) + Math.PI).ToString();
			}
			return (Math.Atan(num2 / num) - Math.PI).ToString();
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw;
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeIMSin(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Sin(num) * (Math.Exp(num2) + Math.Exp(0.0 - num2)) / 2.0;
			double num4 = Math.Cos(num) * (Math.Exp(num2) - Math.Exp(0.0 - num2)) / 2.0;
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImSinH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Cos(num2) * ((Math.Exp(num) - Math.Exp(0.0 - num)) / 2.0);
			double num4 = Math.Sin(num2) * (Math.Exp(num) + Math.Exp(0.0 - num)) / 2.0;
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4;
			return ComputeComplex(argList2);
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[1].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			if (double.Parse(text) < 0.0)
			{
				return ErrorStrings[5].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMCSC(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string text5 = ComputeIMSin(argList);
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			string argList2 = "1" + ParseArgumentSeparator + text5;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[21].ToString();
		}
	}

	public string ComputeIMCos(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Cos(num) * (Math.Exp(num2) + Math.Exp(0.0 - num2)) / 2.0;
			double num4 = (0.0 - Math.Sin(num)) * (Math.Exp(num2) - Math.Exp(0.0 - num2)) / 2.0;
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMSEC(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		string text5 = ComputeIMCos(argList);
		if (ErrorStrings.Contains(text5))
		{
			return text5;
		}
		string argList2 = "1" + ParseArgumentSeparator + text5;
		return ComputeImDiv(argList2);
	}

	public string ComputeIMTan(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string text5 = ComputeIMSin(argList);
			string text6 = ComputeIMCos(argList);
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			if (ErrorStrings.Contains(text6))
			{
				return text6;
			}
			string argList2 = text5 + ParseArgumentSeparator + text6;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			_ = text == "";
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImCot(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1 || array.Length < 1)
		{
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		try
		{
			string text3 = ComputeIMCos(argList);
			string text4 = ComputeIMSin(argList);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			string argList2 = text3 + ParseArgumentSeparator + text4;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[21].ToString());
			}
			return FormulaErrorStrings[21].ToString();
		}
	}

	public string ComputeIMCSCH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string text5 = ComputeImSinH(argList);
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			string argList2 = "1" + ParseArgumentSeparator + text5;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImCosH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		try
		{
			string text3 = ComputeReal(text);
			string text4 = ComputeImaginary(text);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Cos(num2) * (Math.Exp(num) + Math.Exp(0.0 - num)) / 2.0;
			double num4 = Math.Sin(num2) * (Math.Exp(num) - Math.Exp(0.0 - num)) / 2.0;
			if (num3.ToString() == "Infinity" || num3.ToString() == "NaN" || num4.ToString() == "Infinity" || num4.ToString() == "NaN")
			{
				return ErrorStrings[4].ToString();
			}
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[1].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[5].ToString();
		}
	}

	public string ComputeIMTanH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			string text5 = ComputeImSinH(argList);
			string text6 = ComputeImCosH(argList);
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			if (ErrorStrings.Contains(text6))
			{
				return text6;
			}
			string argList2 = text5 + ParseArgumentSeparator + text6;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			_ = text == "";
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMCotH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		if (array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		try
		{
			string text2 = ComputeImSinH(argList);
			string text3 = ComputeImCosH(argList);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			string argList2 = text3 + ParseArgumentSeparator + text2;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			_ = text == "";
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMSecH(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		try
		{
			if (array.Length > 1)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return FormulaErrorStrings[10].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
			{
				return ErrorStrings[1].ToString();
			}
			string text2 = text.Substring(text.Length - 1);
			bool flag = text2 == "i" || text2 == "j";
			if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			string text3 = ComputeReal(text);
			string text4 = ComputeImaginary(text);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			string text5 = ComputeImCosH(argList);
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			string argList2 = "1" + ParseArgumentSeparator + text5;
			return ComputeImDiv(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			_ = text == "";
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMLOG10(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		if (array.Length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[13].ToString();
		}
		text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Log(Math.Sqrt(num * num + num2 * num2)) / Math.Log(10.0);
			double num4 = Math.Atan(num2 / num) / Math.Log(10.0);
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[5].ToString() + ": " + FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString() + ": " + FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString() + ": " + FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[4].ToString();
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString() + ": " + FormulaErrorStrings[invalid_parameter]);
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMLOG2(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		if (array.Length > 1)
		{
			return FormulaErrorStrings[10].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Log(Math.Sqrt(num * num + num2 * num2)) / Math.Log(2.0);
			double num4 = Math.Atan(num2 / num) / Math.Log(2.0);
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeIMLN(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_a_single_argument]);
			}
			return FormulaErrorStrings[13].ToString();
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double num = double.Parse(text3);
			double num2 = double.Parse(text4);
			double num3 = Math.Log(Math.Sqrt(num * num + num2 * num2));
			double num4 = Math.Atan(num2 / num);
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "")
			{
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeImEXP(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(argList) || length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[25].ToString();
		}
		if (text == "")
		{
			return ErrorStrings[4].ToString();
		}
		if (IsCellReference(array[0]) && string.IsNullOrEmpty(text))
		{
			return "1";
		}
		if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
		{
			return ErrorStrings[1].ToString();
		}
		string text2 = text.Substring(text.Length - 1);
		bool flag = text2 == "i" || text2 == "j";
		text2 = ((text2 == "i" || text2 == "j") ? text2 : "i");
		if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		string text3 = ComputeReal(text);
		string text4 = ComputeImaginary(text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (ErrorStrings.Contains(text4))
		{
			return text4;
		}
		try
		{
			double d = double.Parse(text3);
			double num = double.Parse(text4);
			double num2 = Math.Exp(d);
			double num3 = num2 * Math.Cos(num);
			double num4 = num2 * Math.Sin(num);
			string argList2 = num3.ToString() + ParseArgumentSeparator + num4 + ParseArgumentSeparator + text2;
			return ComputeComplex(argList2);
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (text.Contains(TIC))
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[5].ToString();
		}
	}

	public string ComputeImPower(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length == 2)
		{
			string text = GetValueFromArg(array[0]).Replace(TIC, "");
			string text2 = GetValueFromArg(array[1]).Replace(TIC, "");
			if (text == "")
			{
				return ErrorStrings[4].ToString();
			}
			if (text.ToUpper().Equals(TRUEVALUESTR) || text.ToUpper().Equals(FALSEVALUESTR))
			{
				return ErrorStrings[1].ToString();
			}
			string text3 = text.Substring(text.Length - 1);
			bool flag = text3 == "i" || text3 == "j";
			text3 = ((text3 == "i" || text3 == "j") ? text3 : "i");
			if (ComputeIsText(GetValueFromArg(array[0])) == TRUEVALUESTR && !IsCellReference(text) && !flag)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			string text4 = ComputeReal(text);
			string text5 = ComputeImaginary(text);
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			if (ErrorStrings.Contains(text5))
			{
				return text5;
			}
			try
			{
				double num = double.Parse(text4);
				double num2 = double.Parse(text5);
				double x = Math.Sqrt(num * num + num2 * num2);
				double num3 = Math.Atan2(num2, num);
				string text6 = ComputeRound((Math.Pow(x, double.Parse(text2)) * double.Parse(ComputeCos((num3 * double.Parse(text2)).ToString()))).ToString());
				string text7 = ComputeRound((Math.Pow(x, double.Parse(text2)) * double.Parse(ComputeSin((num3 * double.Parse(text2)).ToString()))).ToString());
				string argList2 = text6 + ParseArgumentSeparator + text7 + ParseArgumentSeparator + text3;
				return ComputeComplex(argList2);
			}
			catch
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
				}
				if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
				{
					return ErrorStrings[5].ToString();
				}
				if (!(text == ""))
				{
					_ = text2 == "";
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
		}
		return FormulaErrorStrings[wrong_number_arguments].ToString();
	}

	public string ComputeImaginaryDifference(string argList)
	{
		return ComputeImSub(argList);
	}

	internal bool InvertMatrix(double[,] A, out double[,] invA)
	{
		bool result = true;
		if (A.GetLength(0) != A.GetLength(1))
		{
			invA = A;
			return false;
		}
		int length = A.GetLength(0);
		double[,] array = (double[,])A.Clone();
		double[,] array2 = new double[length, length];
		for (int i = 0; i < length; i++)
		{
			array2[i, i] = 1.0;
		}
		for (int j = 0; j < length; j++)
		{
			int num = j;
			double num2 = 0.0;
			int num3 = num;
			for (int k = num; k < length; k++)
			{
				double num4 = array[k, num];
				if (num4 > num2)
				{
					num2 = num4;
					num3 = k;
				}
			}
			if (num3 != num)
			{
				for (int l = num; l < length; l++)
				{
					double num5 = array[num, l];
					array[num, l] = array[num3, l];
					array[num3, l] = num5;
				}
				for (int m = 0; m < length; m++)
				{
					double num5 = array2[num, m];
					array2[num, m] = array2[num3, m];
					array2[num3, m] = num5;
				}
			}
			for (int n = num + 1; n < length; n++)
			{
				if (array[num, num] == 0.0)
				{
					result = false;
					array[num, num] = 1E-60;
				}
				double num6 = array[n, num] / array[num, num];
				if (num6 != 0.0)
				{
					for (int num7 = num; num7 < length; num7++)
					{
						array[n, num7] -= num6 * array[num, num7];
					}
					for (int num8 = 0; num8 < length; num8++)
					{
						array2[n, num8] -= num6 * array2[num, num8];
					}
				}
			}
		}
		for (int num9 = length - 1; num9 >= 0; num9--)
		{
			int num10 = num9;
			if (array[num10, num10] == 0.0)
			{
				result = false;
				array[num10, num10] = 1E-60;
			}
			for (int num11 = num10 - 1; num11 >= 0; num11--)
			{
				double num12 = array[num11, num10] / array[num10, num10];
				array[num11, num10] = 0.0;
				if (num12 != 0.0)
				{
					for (int num13 = 0; num13 < length; num13++)
					{
						array2[num11, num13] -= num12 * array2[num10, num13];
					}
				}
			}
		}
		for (int num14 = 0; num14 < length; num14++)
		{
			double num15 = array[num14, num14];
			for (int num16 = 0; num16 < length; num16++)
			{
				array2[num14, num16] /= num15;
			}
		}
		invA = array2;
		return result;
	}

	public string ComputeBitOr(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		string text2 = null;
		try
		{
			if (array.Length != 2)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text = GetValueFromArg(array[0]);
			text = (string.IsNullOrEmpty(text) ? "0" : text);
			text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
			text = text.Replace(TIC, "");
			text2 = GetValueFromArg(array[1]);
			text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
			text2 = (bool.TryParse(text2, out result) ? Convert.ToInt16(result).ToString() : text2);
			text2 = text2.Replace(TIC, "");
			int num = int.Parse(text);
			int num2 = int.Parse(text2);
			return (num | num2).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (!(text == ""))
			{
				_ = text2 == "";
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeBitXor(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		string text2 = null;
		try
		{
			if (array.Length != 2)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text = GetValueFromArg(array[0]);
			text = (string.IsNullOrEmpty(text) ? "0" : text);
			text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
			text = text.Replace(TIC, "");
			text2 = GetValueFromArg(array[1]);
			text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
			text2 = (bool.TryParse(text2, out result) ? Convert.ToInt16(result).ToString() : text2);
			text2 = text2.Replace(TIC, "");
			long num = int.Parse(text);
			long num2 = int.Parse(text2);
			if (num > 281474976710655L || num2 > 281474976710655L || num < 0 || num2 < 0 || Math.Floor(double.Parse(text)) != (double)num || Math.Floor(double.Parse(text2)) != (double)num2)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			return (num ^ num2).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[1].ToString();
			}
			if (!(text == ""))
			{
				_ = text2 == "";
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeBitAnd(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		string text2 = null;
		try
		{
			if (array.Length != 2)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text = GetValueFromArg(array[0]);
			text = (string.IsNullOrEmpty(text) ? "0" : text);
			text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
			text = text.Replace(TIC, "");
			text2 = GetValueFromArg(array[1]);
			text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
			text2 = (bool.TryParse(text2, out result) ? Convert.ToInt16(result).ToString() : text2);
			text2 = text2.Replace(TIC, "");
			int num = int.Parse(text);
			int num2 = int.Parse(text2);
			return (num & num2).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (!(text == ""))
			{
				_ = text2 == "";
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeBitLShift(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		string text2 = null;
		try
		{
			if (array.Length != 2)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text = GetValueFromArg(array[0]);
			text = (string.IsNullOrEmpty(text) ? "0" : text);
			text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
			text = text.Replace(TIC, "");
			text2 = GetValueFromArg(array[1]);
			text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
			text2 = (bool.TryParse(text2, out result) ? Convert.ToInt16(result).ToString() : text2);
			text2 = text2.Replace(TIC, "");
			long num = long.Parse(text);
			int num2 = int.Parse(text2);
			if (num > 281474976710655L || Math.Abs(num2) > 53 || Math.Floor(double.Parse(text)) != (double)num || num < 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			return ((num2 >= 0) ? (num << num2) : (num >> -num2)).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "" || text2 == "")
			{
				return ErrorStrings[1].ToString();
			}
			if (double.Parse(text) < 0.0 || double.Parse(text2) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeBitRShift(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string text = null;
		string text2 = null;
		try
		{
			if (array.Length != 2)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return FormulaErrorStrings[13].ToString();
			}
			string text3 = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text = GetValueFromArg(array[0]);
			text = (string.IsNullOrEmpty(text) ? "0" : text);
			text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
			text = text.Replace(TIC, "");
			text2 = GetValueFromArg(array[1]);
			text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
			text2 = (bool.TryParse(text2, out result) ? Convert.ToInt16(result).ToString() : text2);
			text2 = text2.Replace(TIC, "");
			long num = long.Parse(text);
			int num2 = int.Parse(text2);
			if (num > 281474976710655L || Math.Abs(num2) > 53 || Math.Floor(double.Parse(text)) != (double)num || num < 0)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
				}
				return ErrorStrings[4].ToString();
			}
			return ((num2 >= 0) ? (num >> num2) : (num << -num2)).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text) == TRUEVALUESTR || ComputeIsText(text2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text == "" || text2 == "")
			{
				return ErrorStrings[1].ToString();
			}
			return ErrorStrings[4].ToString();
		}
	}

	public string ComputeErf(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string valueFromArg;
		string valueFromArg2;
		if (array.Length == 2)
		{
			valueFromArg = GetValueFromArg(array[0]);
			valueFromArg = valueFromArg.Replace(TIC, "");
			valueFromArg2 = GetValueFromArg(array[1]);
			valueFromArg2 = valueFromArg2.Replace(TIC, "");
		}
		else
		{
			if (array.Length != 1)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return FormulaErrorStrings[10].ToString();
			}
			valueFromArg = "0";
			valueFromArg2 = GetValueFromArg(array[0]);
		}
		if (array[0] == string.Empty || (array.Length == 2 && array[1] == string.Empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[0].ToString();
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		try
		{
			string s = ComputeErfPrecise(valueFromArg);
			return (double.Parse(ComputeErfPrecise(valueFromArg2)) - double.Parse(s)).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(valueFromArg) == TRUEVALUESTR || ComputeIsText(valueFromArg2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (valueFromArg == string.Empty || valueFromArg2 == string.Empty)
			{
				return ErrorStrings[0].ToString();
			}
			if (double.Parse(valueFromArg) < 0.0 || double.Parse(valueFromArg2) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeErfCPrecise(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (string.IsNullOrEmpty(argList) || array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments].ToString();
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		double result2 = 0.0;
		double.TryParse(valueFromArg.Replace(TIC, string.Empty), out result2);
		double num = 0.254829592;
		double num2 = -0.284496736;
		double num3 = 1.421413741;
		double num4 = -1.453152027;
		double num5 = 1.061405429;
		double num6 = 0.3275911;
		if (result2 == 0.0)
		{
			return "1";
		}
		if (result2 < 0.0)
		{
			double num7 = double.Parse(ComputeErfPrecise(valueFromArg));
			return (1.0 - num7).ToString();
		}
		double num8 = 1.0 / (1.0 + num6 * result2);
		return (((((num5 * num8 + num4) * num8 + num3) * num8 + num2) * num8 + num) * num8 * Math.Exp((0.0 - result2) * result2)).ToString();
	}

	public string ComputeErfPrecise(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		double num = 0.254829592;
		double num2 = -0.284496736;
		double num3 = 1.421413741;
		double num4 = -1.453152027;
		double num5 = 1.061405429;
		double num6 = 0.3275911;
		double num7 = double.Parse(valueFromArg.Replace(TIC, string.Empty));
		int num8 = 1;
		if (num7 == 0.0)
		{
			return "0";
		}
		if (num7 < 0.0)
		{
			num8 = -1;
		}
		num7 = Math.Abs(num7);
		double num9 = 1.0 / (1.0 + num6 * num7);
		double num10 = 1.0 - ((((num5 * num9 + num4) * num9 + num3) * num9 + num2) * num9 + num) * num9 * Math.Exp((0.0 - num7) * num7);
		return ((double)num8 * num10).ToString();
	}

	public string ComputeBesselI(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string empty = string.Empty;
		string empty2 = string.Empty;
		if (array.Length > 2 || array.Length <= 1)
		{
			return FormulaErrorStrings[13].ToString();
		}
		empty = GetValueFromArg(array[0]);
		empty = empty.Replace(TIC, "");
		empty2 = GetValueFromArg(array[1]);
		empty2 = empty2.Replace(TIC, "");
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		try
		{
			if (double.Parse(empty) == 0.0)
			{
				return "0.0";
			}
			if (double.Parse(empty2) < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (double.Parse(empty) < 2.0 && double.Parse(empty) > 1.0)
			{
				double num = 2.0 / Math.Abs(double.Parse(empty));
				double num2 = 0.0;
				double num3 = 0.0;
				double num4 = 1.0;
				for (double num5 = Math.Round(2.0 * (double.Parse(empty2) + Math.Sqrt(ACC * double.Parse(empty2)))); num5 > 0.0; num5 -= 1.0)
				{
					double num6 = num3 + num5 * num * num4;
					num3 = num4;
					num4 = num6;
					if (Math.Abs(num4) > BIGNO)
					{
						num2 *= BIGNI;
						num4 *= BIGNI;
						num3 *= BIGNI;
					}
					string s = ComputeRound(num5.ToString());
					string s2 = ComputeRound(empty2);
					if (int.Parse(s) <= int.Parse(s2))
					{
						num2 = num3;
					}
				}
				num2 *= besseli0(double.Parse(empty)) / num4;
				if (double.IsInfinity(num2) || double.IsNaN(num2))
				{
					return ErrorStrings[4].ToString();
				}
				return ((double.Parse(empty) < 0.0 && int.Parse(empty2) % 2 == 0) ? (0.0 - num2) : num2).ToString();
			}
			double num7 = 2.0 / Math.Abs(double.Parse(empty));
			double num8 = 0.0;
			double num9 = 0.0;
			double num10 = 1.0;
			for (double num11 = Math.Round(2.0 * (double.Parse(empty2) + Math.Sqrt(ACC * double.Parse(empty2)))); num11 > 0.0; num11 -= 1.0)
			{
				double num12 = num9 + num11 * num7 * num10;
				num9 = num10;
				num10 = num12;
				if (Math.Abs(num10) > BIGNO)
				{
					num8 *= BIGNI;
					num10 *= BIGNI;
					num9 *= BIGNI;
				}
				string text2 = ComputeRound(num11.ToString());
				string text3 = ComputeRound(empty2);
				if (text2 == text3)
				{
					num8 = num9;
				}
			}
			num8 *= besseli0(double.Parse(empty)) / num10;
			double num13 = num8;
			if (double.Parse(empty) < 0.9 && double.Parse(empty) > 0.0)
			{
				return besseli0(double.Parse(empty)).ToString();
			}
			if (double.Parse(empty) < 0.0)
			{
				double num14 = (num13 *= -1.0);
				return num14.ToString();
			}
			if (double.IsInfinity(num8) || double.IsNaN(num8))
			{
				return ErrorStrings[4].ToString();
			}
			return ((double.Parse(empty) < 0.0 && int.Parse(empty2) % 2 == 0) ? (0.0 - num8) : num8).ToString();
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(empty) == TRUEVALUESTR || ComputeIsText(empty2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (empty == "" || empty2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public static double besseli0(double x)
	{
		double num = 0.0;
		double b = 0.0;
		double b2 = 0.0;
		double b3 = 0.0;
		if (x < 0.0)
		{
			x = 0.0 - x;
		}
		if (x <= 8.0)
		{
			double x2 = x / 2.0 - 2.0;
			besselmfirstcheb(-4.4153416464793395E-18, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 3.3307945188222384E-17, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -2.431279846547955E-16, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 1.715391285555133E-15, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -1.1685332877993451E-14, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 7.676185498604936E-14, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -4.856446783111929E-13, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 2.95505266312964E-12, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -1.726826291441556E-11, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 9.675809035373237E-11, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -5.189795601635263E-10, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 2.6598237246823866E-09, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -1.300025009986248E-08, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 6.046995022541919E-08, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -2.670793853940612E-07, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 1.1173875391201037E-06, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -4.4167383584587505E-06, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 1.6448448070728896E-05, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -5.754195010082104E-05, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.00018850288509584165, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.0005763755745385824, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.0016394756169413357, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.004324309995050576, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.010546460394594998, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.02373741480589947, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.04930528423967071, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.09490109704804764, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.17162090152220877, ref b, ref b2, ref b3);
			besselmnextcheb(x2, -0.3046826723431984, ref b, ref b2, ref b3);
			besselmnextcheb(x2, 0.6767952744094761, ref b, ref b2, ref b3);
			num = 0.5 * (b - b3);
			return Math.Exp(x) * num;
		}
		double x3 = 32.0 / x - 2.0;
		besselmfirstcheb(-7.233180487874754E-18, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -4.830504485944182E-18, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 4.46562142029676E-17, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 3.461222867697461E-17, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -2.8276239805165836E-16, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -3.425485619677219E-16, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.7725601330565263E-15, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 3.8116806693526224E-15, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -9.554846698828307E-15, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -4.150569347287222E-14, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.54008621752141E-14, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 3.8527783827421426E-13, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 7.180124451383666E-13, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.7941785315068062E-12, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -1.3215811840447713E-11, ref b, ref b2, ref b3);
		besselmnextcheb(x3, -3.1499165279632416E-11, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 1.1889147107846439E-11, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 4.94060238822497E-10, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 3.3962320257083865E-09, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 2.266668990498178E-08, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 2.0489185894690638E-07, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 2.8913705208347567E-06, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 6.889758346916825E-05, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 0.0033691164782556943, ref b, ref b2, ref b3);
		besselmnextcheb(x3, 0.8044904110141088, ref b, ref b2, ref b3);
		num = 0.5 * (b - b3);
		return Math.Exp(x) * num / Math.Sqrt(x);
	}

	public string ComputeBesselJ(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string empty = string.Empty;
		string empty2 = string.Empty;
		if (array.Length > 2 || array.Length <= 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = GetValueFromArg(array[0]);
		empty = empty.Replace(TIC, "");
		empty2 = GetValueFromArg(array[1]);
		empty2 = empty2.Replace(TIC, "");
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 40.0;
		double num2 = 10000000000.0;
		double num3 = 1E-10;
		try
		{
			if (double.Parse(empty2) == 0.0)
			{
				return j0(empty).ToString();
			}
			if (double.Parse(empty2) == 1.0)
			{
				return j1(empty).ToString();
			}
			if (double.Parse(empty2) < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			double num4 = Math.Abs(double.Parse(empty));
			if (num4 == 0.0)
			{
				return "0";
			}
			double num7;
			if (double.Parse(empty) < 0.9 && double.Parse(empty2) < 0.9)
			{
				double num5 = 2.0 / num4;
				double num6 = j0(num4.ToString());
				num7 = num6;
			}
			else if (num4 > double.Parse(empty2))
			{
				double num5 = 2.0 / num4;
				double num6 = j0(num4.ToString());
				double num8 = j1(num4.ToString());
				for (double num9 = 1.0; num9 < double.Parse(empty2); num9 += 1.0)
				{
					double num10 = num9 * num5 * num8 - num6;
					num6 = num8;
					num8 = num10;
				}
				num7 = num8;
			}
			else if (double.Parse(empty) < 2.0 && double.Parse(empty2) < 2.0)
			{
				double num5 = 2.0 / num4;
				double num11 = Math.Round(2.0 * (double.Parse(empty2) + (double)((int)Math.Sqrt(num * double.Parse(empty2)) / 2)));
				bool flag = false;
				double num12;
				double num10 = (num7 = (num12 = 0.0));
				double num8 = 1.0;
				for (double num9 = num11; num9 > 0.0; num9 -= 1.0)
				{
					double num6 = num9 * num5 * num8 - num10;
					num10 = num8;
					num8 = num6;
					if (Math.Abs(num8) > num2)
					{
						num8 *= num3;
						num10 *= num3;
						num7 *= num3;
						num12 *= num3;
					}
					if (flag)
					{
						num12 += num8;
					}
					flag = !flag;
					string s = ComputeRound(num9.ToString());
					string s2 = ComputeRound(empty2);
					if (int.Parse(s) <= int.Parse(s2))
					{
						num7 = num10;
					}
				}
				num12 = 2.0 * num12 - num8;
				num7 /= num12;
			}
			else
			{
				double num5 = 2.0 / num4;
				double num13 = 2.0 * (double.Parse(empty2) + (double)((int)Math.Sqrt(num * double.Parse(empty2)) / 2));
				bool flag = false;
				double num12;
				double num10 = (num7 = (num12 = 0.0));
				double num8 = 1.0;
				for (double num9 = num13; num9 > 0.0; num9 -= 1.0)
				{
					double num6 = num9 * num5 * num8 - num10;
					num10 = num8;
					num8 = num6;
					if (Math.Abs(num8) > num2)
					{
						num8 *= num3;
						num10 *= num3;
						num7 *= num3;
						num12 *= num3;
					}
					if (flag)
					{
						num12 += num8;
					}
					flag = !flag;
					string text2 = ComputeRound(num9.ToString());
					string text3 = ComputeRound(empty2);
					if (text2 == text3)
					{
						num7 = num10;
					}
				}
				num12 = 2.0 * num12 - num8;
				num7 /= num12;
			}
			return ((double.Parse(empty) < 0.0 && double.Parse(empty2) % 2.0 == 1.0) ? (0.0 - num7) : num7).ToString();
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(empty) == TRUEVALUESTR || ComputeIsText(empty2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (empty == "" || empty2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public static double j1(string x)
	{
		double num;
		double num2;
		double num3;
		double num4;
		if ((num = Math.Abs(double.Parse(x))) < 8.0)
		{
			num2 = double.Parse(x) * double.Parse(x);
			num3 = double.Parse(x) * (72362614232.0 + num2 * (-7895059235.0 + num2 * (242396853.1 + num2 * (-2972611.439 + num2 * (15704.4826 + num2 * -30.16036606)))));
			num4 = 144725228442.0 + num2 * (2300535178.0 + num2 * (18583304.74 + num2 * (99447.43394 + num2 * (376.9991397 + num2 * 1.0))));
			return num3 / num4;
		}
		double num5 = 8.0 / num;
		double num6 = num - 2.356194491;
		num2 = num5 * num5;
		num3 = 1.0 + num2 * (0.00183105 + num2 * (-3.516396496E-05 + num2 * (2.457520174E-06 + num2 * -2.40337019E-07)));
		num4 = 0.04687499995 + num2 * (-0.0002002690873 + num2 * (8.449199096E-06 + num2 * (-8.8228987E-07 + num2 * 1.05787412E-07)));
		double num7 = Math.Sqrt(0.636619772 / num) * (Math.Cos(num6) * num3 - num5 * Math.Sin(num6) * num4);
		if (double.Parse(x) < 0.0)
		{
			num7 = 0.0 - num7;
		}
		return num7;
	}

	public static double j0(string x)
	{
		double num;
		if ((num = Math.Abs(double.Parse(x))) < 8.0)
		{
			double num2 = double.Parse(x) * double.Parse(x);
			double num3 = 57568490574.0 + num2 * (-13362590354.0 + num2 * (651619640.7 + num2 * (-11214424.18 + num2 * (77392.33017 + num2 * -184.9052456))));
			double num4 = 57568490411.0 + num2 * (1029532985.0 + num2 * (9494680.718 + num2 * (59272.64853 + num2 * (267.8532712 + num2 * 1.0))));
			return num3 / num4;
		}
		double num5 = 8.0 / num;
		double num6 = num5 * num5;
		double num7 = num - 0.785398164;
		double num8 = 1.0 + num6 * (-0.001098628627 + num6 * (2.734510407E-05 + num6 * (-2.073370639E-06 + num6 * 2.093887211E-07)));
		double num9 = -0.01562499995 + num6 * (0.0001430488765 + num6 * (-6.911147651E-06 + num6 * (7.621095161E-07 - num6 * 9.34935152E-08)));
		return Math.Sqrt(0.636619772 / num) * (Math.Cos(num7) * num8 - num5 * Math.Sin(num7) * num9);
	}

	public string ComputeBesselY(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string empty = string.Empty;
		string empty2 = string.Empty;
		if (array.Length == 2)
		{
			array[1].Contains("u");
		}
		if (array.Length > 2 || array.Length <= 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = GetValueFromArg(array[0]);
		empty = empty.Replace(TIC, "");
		empty2 = GetValueFromArg(array[1]);
		empty2 = empty2.Replace(TIC, "");
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (array.Length == 2)
		{
			_ = ComputeIsNumber(array[1]) != TRUEVALUESTR;
		}
		if (empty == string.Empty && empty2 == string.Empty)
		{
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			return ErrorStrings[0].ToString();
		}
		if (array.Length == 2)
		{
			empty = GetValueFromArg(array[0]);
			empty = empty.Replace(TIC, "");
			empty2 = GetValueFromArg(array[1]);
			empty2 = empty2.Replace(TIC, "");
		}
		else
		{
			if (array.Length != 1)
			{
				return FormulaErrorStrings[10].ToString();
			}
			empty = GetValueFromArg(array[0]);
			empty2 = "0";
		}
		try
		{
			if (double.Parse(empty) < 0.0 || double.Parse(empty2) < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (double.Parse(empty) == 0.0)
			{
				return y0(double.Parse(empty)).ToString();
			}
			if (double.Parse(empty2) == 1.0)
			{
				return y1(double.Parse(empty)).ToString();
			}
			double num;
			double num2;
			double num3;
			if (double.Parse(empty) < 2.0 && double.Parse(empty) > 1.0)
			{
				num = 2.0 / double.Parse(empty);
				num2 = y1(double.Parse(empty));
				num3 = y0(double.Parse(empty));
				return num2.ToString();
			}
			num = 2.0 / double.Parse(empty);
			num2 = y1(double.Parse(empty));
			num3 = y0(double.Parse(empty));
			for (int i = 1; (double)i < double.Parse(empty2); i++)
			{
				double num4 = (double)i * num * num2 - num3;
				num3 = num2;
				num2 = num4;
			}
			return num2.ToString("G17");
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(empty) == TRUEVALUESTR || ComputeIsText(empty2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (empty == "" || empty2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public static double y0(double x)
	{
		if (x < 8.0)
		{
			double num = x * x;
			double num2 = -2957821389.0 + num * (7062834065.0 + num * (-512359803.6 + num * (10879881.29 + num * (-86327.92757 + num * 228.4622733))));
			double num3 = 40076544269.0 + num * (745249964.8 + num * (7189466.438 + num * (47447.2647 + num * (226.1030244 + num * 1.0))));
			return num2 / num3 + 0.636619772 * j0(x.ToString()) * Math.Log(x);
		}
		double num4 = 8.0 / x;
		double num5 = num4 * num4;
		double num6 = x - 0.785398164;
		double num7 = 1.0 + num5 * (-0.001098628627 + num5 * (2.734510407E-05 + num5 * (-2.073370639E-06 + num5 * 2.093887211E-07)));
		double num8 = -0.01562499995 + num5 * (0.0001430488765 + num5 * (-6.911147651E-06 + num5 * (7.621095161E-07 + num5 * -9.34945152E-08)));
		return Math.Sqrt(0.636619772 / x) * (Math.Sin(num6) * num7 + num4 * Math.Cos(num6) * num8);
	}

	public static double y1(double x)
	{
		if (x < 8.0)
		{
			double num = x * x;
			double num2 = x * (-4900604943000.0 + num * (1275274390000.0 + num * (-51534381390.0 + num * (734926455.1 + num * (-4237922.726 + num * 8511.937935)))));
			double num3 = 24995805700000.0 + num * (424441966400.0 + num * (3733650367.0 + num * (22459040.02 + num * (102042.605 + num * (354.9632885 + num)))));
			return num2 / num3 + 0.636619772 * (j1(x.ToString()) * Math.Log(x) - 1.0 / x);
		}
		double num4 = 8.0 / x;
		double num5 = num4 * num4;
		double num6 = x - 2.356194491;
		double num7 = 1.0 + num5 * (0.00183105 + num5 * (-3.516396496E-05 + num5 * (2.457520174E-06 + num5 * -2.40337019E-07)));
		double num8 = 0.04687499995 + num5 * (-0.0002002690873 + num5 * (8.449199096E-06 + num5 * (-8.8228987E-07 + num5 * 1.05787412E-07)));
		return Math.Sqrt(0.636619772 / x) * (Math.Sin(num6) * num7 + num4 * Math.Cos(num6) * num8);
	}

	public string ComputebesselK(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string empty = string.Empty;
		string empty2 = string.Empty;
		if (array.Length == 2)
		{
			array[1].Contains("u");
		}
		if (array.Length > 2 || array.Length <= 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = GetValueFromArg(array[0]);
		empty = empty.Replace(TIC, "");
		empty2 = GetValueFromArg(array[1]);
		empty2 = empty2.Replace(TIC, "");
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (array.Length == 2)
		{
			_ = ComputeIsNumber(array[1]) != TRUEVALUESTR;
		}
		if (empty == string.Empty && empty2 == string.Empty)
		{
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			return ErrorStrings[0].ToString();
		}
		if (array.Length == 2)
		{
			empty = GetValueFromArg(array[0]);
			empty = empty.Replace(TIC, "");
			empty2 = GetValueFromArg(array[1]);
			empty2 = empty2.Replace(TIC, "");
		}
		else
		{
			if (array.Length != 1)
			{
				return FormulaErrorStrings[10].ToString();
			}
			empty = GetValueFromArg(array[0]);
			empty2 = "0";
		}
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		double num8 = 0.0;
		double num9 = 0.0;
		double num10 = 0.0;
		double num11 = 0.0;
		double num12 = 0.0;
		double num13 = 0.0;
		double num14 = 0.0;
		double num15 = 0.0;
		double num16 = 0.0;
		double num17 = 0.0;
		int num18 = 0;
		double num19 = 0.0;
		num19 = 0.5772156649015329;
		try
		{
			string s = ((!(double.Parse(empty2) < 0.0)) ? empty2 : ("-" + empty2.ToString()));
			if (double.Parse(empty) < 0.0 || double.Parse(empty2) < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (double.Parse(empty) <= 9.55)
			{
				num11 = 0.0;
				num9 = 0.25 * double.Parse(empty) * double.Parse(empty);
				num12 = 1.0;
				num13 = 0.0;
				num15 = 1.0;
				num17 = 2.0 / double.Parse(empty);
				if (double.Parse(s) > 0.0)
				{
					num13 = 0.0 - num19;
					num2 = 1.0;
					s = ((int)double.Parse(s)).ToString();
					for (num18 = 1; (double)num18 <= double.Parse(s) - 1.0; num18++)
					{
						num13 += 1.0 / num2;
						num2 += 1.0;
						num12 *= num2;
					}
					num15 = num17;
					if (double.Parse(s) == 1.0)
					{
						num11 = 1.0 / double.Parse(empty);
					}
					else
					{
						num4 = num12 / double.Parse(s);
						num3 = 1.0;
						num8 = num4;
						num10 = 0.0 - num9;
						num6 = 1.0;
						for (num18 = 1; (double)num18 <= double.Parse(s) - 1.0; num18++)
						{
							num4 /= double.Parse(s) - (double)num18;
							num3 *= (double)num18;
							num6 *= num10;
							num7 = num4 * num6 / num3;
							num8 += num7;
							num15 *= num17;
						}
						num8 *= 0.5;
						num7 = Math.Abs(num8);
						num11 = num8 * num15;
					}
				}
				num16 = 2.0 * Math.Log(0.5 * double.Parse(empty));
				num14 = 0.0 - num19;
				if (double.Parse(s) == 0.0)
				{
					num13 = num14;
					num7 = 1.0;
				}
				else
				{
					num13 += 1.0 / double.Parse(s);
					num7 = 1.0 / num12;
				}
				num8 = (num14 + num13 - num16) * num7;
				num2 = 1.0;
				do
				{
					num7 *= num9 / (num2 * (num2 + double.Parse(s)));
					num14 += 1.0 / num2;
					num13 += 1.0 / (num2 + double.Parse(s));
					num8 += (num14 + num13 - num16) * num7;
					num2 += 1.0;
				}
				while (Math.Abs(num7 / num8) > 5E-16);
				num8 = 0.5 * num8 / num15;
				if (double.Parse(s) % 2.0 != 0.0)
				{
					num8 = 0.0 - num8;
				}
				num11 += num8;
				num = num11;
				return num.ToString();
			}
			if (double.Parse(empty) > Math.Log(1E+300))
			{
				return 0.0.ToString();
			}
			num2 = double.Parse(s);
			num13 = 4.0 * num2 * num2;
			num14 = 1.0;
			num9 = 8.0 * double.Parse(empty);
			num12 = 1.0;
			num7 = 1.0;
			num8 = num7;
			num18 = 0;
			do
			{
				num10 = num13 - num14 * num14;
				num7 = num7 * num10 / (num12 * num9);
				num4 = Math.Abs(num7);
				if ((double)num18 >= double.Parse(s) && num4 > num5)
				{
					break;
				}
				num5 = num4;
				num8 += num7;
				num12 += 1.0;
				num14 += 2.0;
				num18++;
			}
			while (Math.Abs(num7 / num8) > 5E-16);
			return (Math.Exp(double.Parse("-" + empty)) * Math.Sqrt(Math.PI / (2.0 * double.Parse(empty))) * num8).ToString();
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(empty) == TRUEVALUESTR || ComputeIsText(empty2) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (empty == "" || empty2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeConversion(string argList)
	{
		string text = null;
		string text2 = null;
		string text3 = null;
		string text4 = null;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = valueFromArg.Replace(TIC, "");
		text = GetValueFromArg(array[1]);
		text3 = GetValueFromArg(array[2]);
		text = text.Replace(TIC, "");
		text3 = text3.Replace(TIC, "");
		string[,] array2 = new string[165, 4]
		{
			{ "a.u. of action", "", "action", "1.05457168181818e-34" },
			{ "a.u. of charge", "e", "electric_charge", "1.60217653141414e-19" },
			{ "a.u. of energy", "Eh", "energy", "4.35974417757576e-18" },
			{ "a.u. of length", "a", "length", "5.29177210818182e-11" },
			{ "a.u. of mass", "m", "mass", "9.10938261616162e-31" },
			{ "a.u. of time", "/Eh", "time", "2.41888432650516e-17" },
			{ "admiralty knot", "admkn", "speed", "0.514773333" },
			{ "ampere", "A", "electric_current", "1" },
			{ "ampere per meter", "A/m", "magnetic_field_intensity", "1" },
			{ "ngstrm", "", "length", "1e-10" },
			{ "are", "ar", "area", "100" },
			{ "astronomical unit", "ua", "length", "1.49597870691667e-11" },
			{ "bar", "bar", "pressure", "100000" },
			{ "barn", "b", "area", "1e-28" },
			{ "becquerel", "Bq", "radioactivity", "1" },
			{ "bit", "bit", "information", "1" },
			{ "btu", "BTU", "energy", "1055.05585262" },
			{ "byte", "byte", "information", "8" },
			{ "candela", "cd", "luminous_intensity", "1" },
			{ "candela per square metre", "cd/m", "luminance", "1" },
			{ "coulomb", "C", "electric_charge", "1" },
			{ "cubic ngstrm", "ang3", "volume", "1e-30" },
			{ "cubic foot", "ft3", "volume", "0.028316846592" },
			{ "cubic inch", "in3", "volume", "0.000016387064" },
			{ "cubic light-year", "ly3", "volume", "8.46786664623715e-47" },
			{ "cubic metre", "m", "volume", "1" },
			{ "cubic mile", "mi3", "volume", "4168181825.44058" },
			{ "cubic nautical mile", "Nmi3", "volume", "6352182208" },
			{ "cubic Pica", "Pica3", "volume", "7.58660370370369e-8" },
			{ "cubic yard", "yd3", "volume", "0.764554857984" },
			{ "cup", "cup", "volume", "0.0002365882365" },
			{ "dalton", "Da", "mass", "1.66053886282828e-27" },
			{ "day", "d", "time", "86400" },
			{ "degree", "", "angle", "0.0174532925199433" },
			{ "degrees Rankine", "Rank", "temperature", "0.555555555555556" },
			{ "dyne", "dyn", "force", "0.00001" },
			{ "electronvolt", "eV", "energy", "1.60217656514141" },
			{ "ell", "ell", "length", "1.143" },
			{ "erg", "erg", "energy", "1e-7" },
			{ "farad", "F", "electric_capacitance", "1" },
			{ "fluid ounce", "oz", "volume", "0.0000295735295625" },
			{ "foot", "ft", "length", "0.3048" },
			{ "foot-pound", "flb", "energy", "1.3558179483314" },
			{ "gal", "Gal", "acceleration", "0.01" },
			{ "gallon", "gal", "volume", "0.003785411784" },
			{ "gauss", "G", "magnetic_flux_density", "1" },
			{ "grain", "grain", "mass", "0.0000647989" },
			{ "gram", "g", "mass", "0.001" },
			{ "gray", "Gy", "absorbed_dose", "1" },
			{ "gross registered ton", "GRT", "volume", "2.8316846592" },
			{ "hectare", "ha", "area", "10000" },
			{ "henry", "H", "inductance", "1" },
			{ "hertz", "Hz", "frequency", "1" },
			{ "horsepower", "HP", "power", "745.69987158227" },
			{ "horsepower-hour", "HPh", "energy", "2684519.538" },
			{ "hour", "h", "time", "3600" },
			{ "imperial gallon (U.K.)", "uk_gal", "volume", "0.00454609" },
			{ "imperial hundredweight", "lcwt", "mass", "50.802345" },
			{ "imperial quart (U.K)", "uk_qt", "volume", "0.0011365225" },
			{ "imperial ton", "brton", "mass", "1016.046909" },
			{ "inch", "in", "length", "0.0254" },
			{ "international acre", "uk_acre", "area", "4046.8564224" },
			{ "IT calorie", "cal", "energy", "4.1868" },
			{ "joule", "J", "energy", "1" },
			{ "katal", "kat", "catalytic_activity", "1" },
			{ "kelvin", "K", "temperature", "1" },
			{ "kilogram", "kg", "mass", "1" },
			{ "knot", "kn", "speed", "0.514444444444444" },
			{ "light-year", "ly", "length", "9460730472580800" },
			{ "litre", "L", "volume", "0.001" },
			{ "lumen", "lm", "luminous_flux", "1" },
			{ "lux", "lx", "illuminance", "1" },
			{ "maxwell", "Mx", "magnetic_flux", "1e-18" },
			{ "measurement ton", "MTON", "volume", "1.13267386368" },
			{ "meter per hour", "m/h", "speed", "0.00027777777777778" },
			{ "meter per second", "m/s", "speed", "1" },
			{ "meter per second squared", "ms\u0081", "acceleration", "1" },
			{ "parsec", "pc", "length", "30856775814671900" },
			{ "meter squared per second", "m/s", "kinematic_viscosity", "1" },
			{ "metre", "m", "length", "1" },
			{ "miles per hour", "mph", "speed", "0.44704" },
			{ "millimetre of mercury", "mmHg", "pressure", "133.322" },
			{ "minute", "", "angle", "0.000290888208665722" },
			{ "minute", "min", "time", "60" },
			{ "modern teaspoon", "tspm", "volume", "0.000005" },
			{ "mole", "mol", "amount_of_substance", "1" },
			{ "morgen", "Morgen", "area", "2500" },
			{ "n.u. of action", "", "action", "1.05457168181818e-34" },
			{ "n.u. of mass", "m", "mass", "9.10938261616162e-31" },
			{ "n.u. of speed", "c", "speed", "299792458" },
			{ "n.u. of time", "/(mec)", "time", "1.28808866778687e-21" },
			{ "nautical mile", "M", "length", "1852" },
			{ "newton", "N", "force", "1" },
			{ "rsted", "Oe ", "magnetic_field_intensity", "79.5774715459477" },
			{ "ohm", "", "electric_resistance", "1" },
			{ "ounce mass", "ozm", "mass", "0.028349523125" },
			{ "pascal", "Pa", "pressure", "1" },
			{ "pascal second", "Pas", "dynamic_viscosity", "1" },
			{ "pferdestrke", "PS", "power", "735.49875" },
			{ "phot", "ph", "illuminance", "0.0001" },
			{ "pica (1/6 inch)", "pica", "length", "0.00035277777777778" },
			{ "pica (1/72 inch)", "Pica", "length", "0.00423333333333333" },
			{ "poise", "P", "dynamic_viscosity", "0.1" },
			{ "pond", "pond", "force", "0.00980665" },
			{ "pound force", "lbf", "force", "4.4482216152605" },
			{ "pound mass", "lbm", "mass", "0.45359237" },
			{ "quart", "qt", "volume", "0.000946352946" },
			{ "radian", "rad", "angle", "1" },
			{ "second", "", "angle", "0.00000484813681109536" },
			{ "second", "s", "time", "1" },
			{ "short hundredweight", "cwt", "mass", "45.359237" },
			{ "siemens", "S", "electrical_conductance", "1" },
			{ "sievert", "Sv", "equivalent_dose", "1" },
			{ "slug", "sg", "mass", "14.59390294" },
			{ "square ngstrm", "ang2", "area", "1e-20" },
			{ "square foot", "ft2", "area", "0.09290304" },
			{ "square inch", "in2", "area", "0.00064516" },
			{ "square light-year", "ly2", "area", "8.95054210748189e+31" },
			{ "square meter", "m", "area", "1" },
			{ "square mile", "mi2", "area", "2589988.110336" },
			{ "square nautical mile", "Nmi2", "area", "3429904" },
			{ "square Pica", "Pica2", "area", "0.00001792111111111" },
			{ "square yard", "yd2", "area", "0.83612736" },
			{ "statute mile", "mi", "length", "1609.344" },
			{ "steradian", "sr", "solid_angle", "1" },
			{ "stilb", "sb", "luminance", "0.0001" },
			{ "stokes", "St", "kinematic_viscosity", "0.0001" },
			{ "stone", "stone", "mass", "6.35029318" },
			{ "tablespoon", "tbs", "volume", "0.0000147868" },
			{ "teaspoon", "tsp", "volume", "0.00000492892" },
			{ "tesla", "T", "magnetic_flux_density", "1" },
			{ "thermodynamic calorie", "c", "energy", "4.184" },
			{ "ton", "ton", "mass", "907.18474" },
			{ "tonne", "t", "mass", "1000" },
			{ "U.K. pint", "uk_pt", "volume", "0.00056826125" },
			{ "U.S. bushel", "bushel", "volume", "0.03523907" },
			{ "U.S. oil barrel", "barrel", "volume", "0.158987295" },
			{ "U.S. pint", "pt", "volume", "0.000473176473" },
			{ "U.S. survey mile", "survey_mi", "length", "1609.347219" },
			{ "U.S. survey/statute acre", "us_acre", "area", "4046.87261" },
			{ "volt", "V", "voltage", "1" },
			{ "watt", "W", "power", "1" },
			{ "watt-hour", "Wh", "energy", "3600" },
			{ "weber", "Wb", "magnetic_flux", "1" },
			{ "yard", "yd", "length", "0.9144" },
			{ "year", "yr", "time", "31557600" },
			{ "yotta", "Y", "Measurement", "1e+24" },
			{ "zetta", "Z", "Measurement", "1e+21" },
			{ "exa", "E", "Measurement", "1e+18" },
			{ "peta", "P", "Measurement", "1e+15" },
			{ "tera", "T", "Measurement", "1e+12" },
			{ "giga", "G", "Measurement", "1e+09" },
			{ "mega", "M", "Measurement", "1e+06" },
			{ "kilo", "k", "Measurement", "1e+03" },
			{ "hecto", "h", "Measurement", "1e+02" },
			{ "dekao", "e", "Measurement", "1e+01" },
			{ "deci", "d", "Measurement", "1e-01" },
			{ "centi", "c", "Measurement", "1e-02" },
			{ "micro", "u", "Measurement", "1e-06" },
			{ "nano", "n", "Measurement", "1e-09" },
			{ "pico", "p", "Measurement", "1e-12" },
			{ "femto", "f", "Measurement", "1e-15" },
			{ "atto", "a", "Measurement", "1e-18" },
			{ "zepto", "z", "Measurement", "1e-21" },
			{ "yocto", "y", "Measurement", "1e-24" }
		};
		for (int i = 0; i < 165; i++)
		{
			if (array2[i, 1] == text)
			{
				text2 = array2[i, 3];
			}
		}
		for (int j = 0; j < 165; j++)
		{
			if (array2[j, 1] == text3)
			{
				text4 = array2[j, 3];
			}
		}
		if (text2 == null || text4 == null)
		{
			return ErrorStrings[0].ToString();
		}
		if (text == "F" && text3 == "C")
		{
			return ((double.Parse(valueFromArg) - 32.0) * (5.0 / 9.0)).ToString();
		}
		if (text == "C" && text3 == "F")
		{
			return (double.Parse(valueFromArg) * 1.8 + 32.0).ToString();
		}
		return (double.Parse(valueFromArg) * double.Parse(text2) / double.Parse(text4)).ToString();
	}

	private static void besselmfirstcheb(double c, ref double b0, ref double b1, ref double b2)
	{
		b0 = c;
		b1 = 0.0;
		b2 = 0.0;
	}

	private static void besselmnextcheb(double x, double c, ref double b0, ref double b1, ref double b2)
	{
		b2 = b1;
		b1 = b0;
		b0 = x * b1 - b2 + c;
	}

	private static void besselm1firstcheb(double c, ref double b0, ref double b1, ref double b2)
	{
		b0 = c;
		b1 = 0.0;
		b2 = 0.0;
	}

	private static void besselm1nextcheb(double x, double c, ref double b0, ref double b1, ref double b2)
	{
		b2 = b1;
		b1 = b0;
		b0 = x * b1 - b2 + c;
	}

	private bool IsOptimizedMatchesEnabled()
	{
		return (enableLookupTableCaching & LookupCachingMode.OptimizeForMatches) != 0;
	}

	private bool IsVLookupCachingEnabled()
	{
		if ((enableLookupTableCaching & LookupCachingMode.Both) == 0)
		{
			return (enableLookupTableCaching & LookupCachingMode.VLOOKUP) != 0;
		}
		return true;
	}

	private bool IsHLookupCachingEnabled()
	{
		if ((enableLookupTableCaching & LookupCachingMode.Both) == 0)
		{
			return (enableLookupTableCaching & LookupCachingMode.HLOOKUP) != 0;
		}
		return true;
	}

	private bool IsLookupCachingEnabled()
	{
		if ((enableLookupTableCaching & LookupCachingMode.Both) == 0 && (enableLookupTableCaching & LookupCachingMode.VLOOKUP) == 0)
		{
			return (enableLookupTableCaching & LookupCachingMode.HLOOKUP) != 0;
		}
		return true;
	}

	public void LookupCachingClearAll()
	{
		if (lookupTables == null)
		{
			lookupTables = new Dictionary<string, LookUps>();
		}
		lookupTables.Clear();
	}

	public void LookupCachingClearSheet(ICalcData grd)
	{
		if (lookupTables == null)
		{
			lookupTables = new Dictionary<string, LookUps>();
			return;
		}
		string value = $"_{grd.GetHashCode()}";
		List<string> list = new List<string>();
		foreach (string key in lookupTables.Keys)
		{
			if (key.EndsWith(value))
			{
				list.Add(key);
			}
		}
		foreach (string item in list)
		{
			lookupTables.Remove(item);
		}
	}

	private void MarkParseArgumentSeparatorInQuotes(ref string args)
	{
		if (args.IndexOf(ParseArgumentSeparator) == -1)
		{
			return;
		}
		bool flag = false;
		StringBuilder stringBuilder = new StringBuilder(args.Length);
		for (int i = 0; i < args.Length; i++)
		{
			if (args[i] == TIC[0])
			{
				flag = !flag;
				stringBuilder.Append(args[i]);
			}
			else if (args[i] == ParseArgumentSeparator && flag)
			{
				stringBuilder.Append(MarkerParseChar);
			}
			else
			{
				stringBuilder.Append(args[i]);
			}
		}
		args = stringBuilder.ToString();
	}

	public void ReloadErrorStrings()
	{
		if (formulaErrorStrings == null)
		{
			formulaErrorStrings = new List<object>();
		}
		formulaErrorStrings.Clear();
		formulaErrorStrings.AddRange(FormulaErrorStrings);
	}

	private string GetSheetTokenFromReference(string r)
	{
		string result = string.Empty;
		if (r.Length > 2 && r[0] == '!')
		{
			int i = 1;
			result = '!'.ToString();
			for (; i < r.Length && r[i] != '!'; i++)
			{
				result += r[i];
			}
			result += "!";
		}
		return result;
	}

	public int GetSheetID(ICalcData grd)
	{
		if (modelToSheetID == null || !modelToSheetID.ContainsKey(grid))
		{
			return 0;
		}
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grd);
		if (sheetFamilyItem != null && sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.Count > 0 && double.TryParse((sheetFamilyItem.ParentObjectToToken[grd] as string).Replace("!", string.Empty), NumberStyles.Any, null, out var result))
		{
			return (int)result;
		}
		return -1;
	}

	private double Determinant(double[,] a, int k)
	{
		double num = 1.0;
		double num2 = 0.0;
		int num3 = int.Parse(k.ToString());
		double[,] array = new double[num3, num3];
		if (k == 1)
		{
			return a[0, 0];
		}
		num2 = 0.0;
		for (int i = 0; i < k; i++)
		{
			int num4 = 0;
			int num5 = 0;
			for (int j = 0; j < k; j++)
			{
				for (int l = 0; l < k; l++)
				{
					array[j, l] = 0.0;
					if (j != 0 && l != i)
					{
						array[num4, num5] = a[j, l];
						if (num5 < k - 2)
						{
							num5++;
							continue;
						}
						num5 = 0;
						num4++;
					}
				}
			}
			num2 += num * (a[0, i] * Determinant(array, k - 1));
			num = -1.0 * num;
		}
		return num2;
	}

	private double NormalProbabilityDensity(double x, double mean, double standardDeviation)
	{
		double num = (x - mean) / standardDeviation;
		return 0.398942280401433 * Math.Exp(-0.5 * num * num) / standardDeviation;
	}

	private bool Cofactor(double[,] num, int f, out double[,] inverse)
	{
		int num2 = int.Parse(f.ToString());
		double[,] array = new double[num2, num2];
		double[,] array2 = new double[num2, num2];
		inverse = new double[num2, num2];
		for (int i = 0; i < f; i++)
		{
			for (int j = 0; j < f; j++)
			{
				int num3 = 0;
				int num4 = 0;
				for (int k = 0; k < f; k++)
				{
					for (int l = 0; l < f; l++)
					{
						if (k != i && l != j)
						{
							array[num3, num4] = num[k, l];
							if (num4 < f - 2)
							{
								num4++;
								continue;
							}
							num4 = 0;
							num3++;
						}
					}
				}
				array2[i, j] = double.Parse(Math.Pow(-1.0, i + j).ToString()) * Determinant(array, f - 1);
			}
		}
		return Inverse(num, array2, f, out inverse);
	}

	private bool Inverse(double[,] num, double[,] fac, int r, out double[,] inverse)
	{
		int num2 = int.Parse(r.ToString());
		double[,] array = new double[num2, num2];
		inverse = new double[num2, num2];
		try
		{
			for (int i = 0; i < r; i++)
			{
				for (int j = 0; j < r; j++)
				{
					array[i, j] = fac[j, i];
				}
			}
			double num3 = Determinant(num, r);
			for (int i = 0; i < r; i++)
			{
				for (int j = 0; j < r; j++)
				{
					inverse[i, j] = array[i, j] / num3;
				}
			}
			return true;
		}
		catch
		{
			return false;
		}
	}

	private bool IsDate(object o, out DateTime date)
	{
		date = dateTime1900;
		if (DateTime.TryParse(o.ToString(), CultureInfo.CurrentCulture, DateTimeStyles.None, out date))
		{
			return date >= dateTime1900;
		}
		return false;
	}

	internal bool IsRange(string range)
	{
		bool flag = false;
		int num = range.IndexOf(':');
		double result = 0.0;
		double result2 = 0.0;
		if (num > 1 && num < range.Length - 2)
		{
			int num2 = num - 1;
			if (char.IsDigit(range[num2]))
			{
				bool flag2 = false;
				num2--;
				while (num2 > 0 && char.IsDigit(range[num2]))
				{
					num2--;
				}
				if (char.IsLetter(range[num2]))
				{
					num2--;
					while (num2 >= 0 && char.IsLetter(range[num2]))
					{
						num2--;
					}
					if (num2 > -1 && range[num2] == "$"[0])
					{
						num2--;
					}
					if (num2 < 0 || num2 == 0)
					{
						flag2 = true;
					}
					else if (range[num2] == '!')
					{
						if (num2-- > 1 && range[num2] == CHARTIC)
						{
							flag2 = range.Substring(0, num2 - 1).LastIndexOf(CHARTIC) == 0;
						}
						else if (num2 > 0 && char.IsDigit(range[num2]))
						{
							flag2 = ((!range.Substring(0, num2).Contains("[") || !range.Substring(0, num2).Contains("]")) ? (range.Substring(0, num2).LastIndexOf('!') == 0) : (range.Substring(0, num2).LastIndexOf('!') == 3));
						}
					}
				}
				if (flag2)
				{
					num2 = num + 1;
					if (range[num2] == '!')
					{
						for (num2++; num2 < range.Length && range[num2] != '!'; num2++)
						{
						}
						if (num2 < range.Length)
						{
							num2++;
						}
					}
					if (num2 < range.Length - 6 && range[num2] == CHARTIC)
					{
						num2 = range.IndexOf('!', num2 + 1);
						if (num2 < range.Length - 2)
						{
							num2++;
						}
					}
					if (num2 < range.Length - 2 && range[num2] == "$"[0])
					{
						num2++;
					}
					if (char.IsLetter(range[num2]))
					{
						for (num2++; num2 < range.Length - 1 && char.IsLetter(range[num2]); num2++)
						{
						}
						if (char.IsDigit(range[num2]))
						{
							for (num2++; num2 < range.Length && char.IsDigit(range[num2]); num2++)
							{
							}
							flag = num2 == range.Length;
						}
					}
				}
			}
		}
		if (num >= 1 && num < range.Length - 1 && !flag)
		{
			if (char.IsDigit(range[num - 1]))
			{
				int i = 0;
				if (range[i] == '!')
				{
					for (i++; i < range.Length && range[i] != '!'; i++)
					{
					}
					if (i < range.Length)
					{
						i++;
					}
					num -= i;
				}
				if (double.TryParse(range.Substring(i, num), out result) && double.TryParse(range.Substring(range.IndexOf(":") + 1), out result2))
				{
					return true;
				}
			}
			else if (char.IsLetter(range[num - 1]))
			{
				int num3 = num - 1;
				bool flag3 = false;
				while (num3 >= 0 && char.IsLetter(range[num3]))
				{
					num3--;
				}
				if (num3 < 0)
				{
					flag3 = true;
				}
				else if (range[num3] == '!')
				{
					num3--;
					while (num3 >= 0 && num3 != 33)
					{
						num3--;
					}
					if (num3 <= 0)
					{
						flag3 = true;
					}
				}
				if (flag3)
				{
					for (num3 = num + 1; num3 <= range.Length - 1 && char.IsLetter(range[num3]); num3++)
					{
					}
					flag = num3 == range.Length;
				}
			}
		}
		return flag;
	}

	internal bool ISColumn(string range)
	{
		bool result = false;
		string text = SheetToken(range.Replace(TIC, string.Empty));
		if (!string.IsNullOrEmpty(text))
		{
			range = range.Replace(text, string.Empty).Replace("$", string.Empty);
		}
		int num = range.IndexOf(':');
		if (num > -1)
		{
			int num2 = num - 1;
			bool flag = false;
			while (num2 >= 0 && char.IsLetter(range[num2]))
			{
				num2--;
			}
			if (num2 < 0 || num2 == 0)
			{
				flag = true;
			}
			if (flag)
			{
				num2 = num + 1;
				if (char.IsLetter(range[num2]))
				{
					for (num2++; num2 < range.Length - 1 && char.IsLetter(range[num2]); num2++)
					{
					}
				}
				result = num2 == range.Length;
			}
		}
		return result;
	}

	public double ChiSquaredProbabilityDensityFunction(double x, int k)
	{
		double num = GammaFunction(0.5 * (double)k);
		return 1.0 / (Math.Pow(2.0, 0.5 * (double)k) * num) * Math.Pow(x, 0.5 * (double)k - 1.0) * Math.Exp(-0.5 * x);
	}

	private double StdevdotP(double[] range)
	{
		int length = range.GetLength(0);
		double num = 0.0;
		double num2 = 0.0;
		int num3 = 0;
		for (int i = 0; i < length; i++)
		{
			num += range[i];
		}
		num /= (double)length;
		for (int j = 0; j < length; j++)
		{
			num2 += Math.Pow(range[j] - num, 2.0);
			num3++;
		}
		return Math.Sqrt(num2 / (double)num3);
	}

	private double NormalCumulativeDistributionFunctionInverse(double p, double mean, double standardDeviation)
	{
		double num = StandardNormalCumulativeDistributionInverse(p);
		return standardDeviation * num + mean;
	}

	public double StandardNormalCumulativeDistributionInverse(double p)
	{
		if (p < 0.0 || p > 1.0)
		{
			throw new ArgumentException("Probability must be between 0 and 1");
		}
		if (p == 0.0)
		{
			return double.NegativeInfinity;
		}
		if (p == 1.0)
		{
			return double.PositiveInfinity;
		}
		if (p == 0.5)
		{
			return 0.0;
		}
		double num;
		if (0.0 < p && p < 0.02425)
		{
			num = Math.Sqrt(-2.0 * Math.Log(p));
			return (((((-0.007784894002430293 * num + -0.3223964580411365) * num + -2.400758277161838) * num + -2.549732539343734) * num + 4.374664141464968) * num + 2.938163982698783) / ((((0.007784695709041462 * num + 0.3224671290700398) * num + 2.445134137142996) * num + 3.754408661907416) * num + 1.0);
		}
		if (0.02425 <= p && p <= 0.97575)
		{
			num = p - 0.5;
			double num2 = num * num;
			return (((((-39.69683028665376 * num2 + 220.9460984245205) * num2 + -275.9285104469687) * num2 + 138.357751867269) * num2 + -30.66479806614716) * num2 + 2.506628277459239) * num / (((((-54.47609879822406 * num2 + 161.5858368580409) * num2 + -155.6989798598866) * num2 + 66.80131188771972) * num2 + -13.28068155288572) * num2 + 1.0);
		}
		num = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
		return (0.0 - (((((-0.007784894002430293 * num + -0.3223964580411365) * num + -2.400758277161838) * num + -2.549732539343734) * num + 4.374664141464968) * num + 2.938163982698783)) / ((((0.007784695709041462 * num + 0.3224671290700398) * num + 2.445134137142996) * num + 3.754408661907416) * num + 1.0);
	}

	private double pearson(double[] x, double[] y, int n)
	{
		double num = 0.0;
		double num2 = 0.0;
		int num3 = n;
		for (int i = 0; i < n; i++)
		{
			if (!x[i].Equals(double.NaN) && !y[i].Equals(double.NaN))
			{
				num += x[i];
				num2 += y[i];
			}
			else
			{
				num3--;
			}
		}
		num /= (double)num3;
		num2 /= (double)num3;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		for (int j = 0; j < n; j++)
		{
			if (!x[j].Equals(double.NaN) && !y[j].Equals(double.NaN))
			{
				double num7 = x[j] - num;
				double num8 = y[j] - num2;
				num4 += num7 * num8;
				num5 += num7 * num7;
				num6 += num8 * num8;
			}
		}
		return num4 / Math.Sqrt(num5 * num6);
	}

	public string ComputeNpv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length < 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		array[0] = GetValueFromArg(array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		double.TryParse(array[0], NumberStyles.Any, null, out var result2);
		double num = 0.0;
		double num2 = 1.0;
		for (int i = 1; i < length; i++)
		{
			string text = array[i];
			double result3;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string text2 in cellsFromArgs)
				{
					string text3 = FormulaErrorStringCheck(text2, FormulaArgumentType.Numbers);
					if (ErrorStrings.Contains(text3))
					{
						return text3;
					}
					string valueFromArg = GetValueFromArg(text2);
					valueFromArg = (bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result3))
					{
						num2 *= 1.0 + result2;
						num += result3 / num2;
					}
				}
			}
			else
			{
				string text4 = FormulaErrorStringCheck(text, FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text4))
				{
					return text4;
				}
				string valueFromArg2 = GetValueFromArg(text);
				valueFromArg2 = (bool.TryParse(valueFromArg2, out result) ? Convert.ToInt16(result).ToString() : valueFromArg2);
				if (double.TryParse(valueFromArg2, NumberStyles.Any, null, out result3))
				{
					num2 *= 1.0 + result2;
					num += result3 / num2;
				}
			}
		}
		return num.ToString();
	}

	public string ComputePmt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length < 3 || length > 5 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i].Replace(TIC, string.Empty));
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result5) ? Convert.ToInt16(result5).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result6) && double.TryParse(array[1], NumberStyles.Any, null, out result) && double.TryParse(array[2], NumberStyles.Any, null, out result2) && (length == 3 || double.TryParse(array[3], NumberStyles.Any, null, out result3)) && (length <= 4 || double.TryParse(array[4], NumberStyles.Any, null, out result4)))
		{
			if (result == 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			result4 = ((!(Math.Abs(result4) > 0.5)) ? 0.0 : 1.0);
			if (result6 == 0.0)
			{
				num = 1.0 * (result3 + result2) / ((1.0 + result6 * result4) * (1.0 - (result + 1.0)));
			}
			else
			{
				double num2 = Math.Pow(1.0 + result6, result);
				num = result6 * (result3 + result2 * num2) / ((1.0 + result6 * result4) * (1.0 - num2));
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputePpmt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 6 && length != 5 && length != 4) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result4) ? Convert.ToInt16(result4).ToString() : array[i]);
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out var result5) || !double.TryParse(array[1], NumberStyles.Any, null, out var _) || !double.TryParse(array[2], NumberStyles.Any, null, out var result7) || !double.TryParse(array[3], NumberStyles.Any, null, out result) || (length != 4 && !double.TryParse(array[4], NumberStyles.Any, null, out result2)) || (length > 5 && !double.TryParse(array[5], NumberStyles.Any, null, out result3)))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		result3 = ((!(Math.Abs(result3) > 0.5)) ? 0.0 : 1.0);
		double num2 = Math.Pow(1.0 + result5, result7);
		double num3 = result5 * (result2 + result * num2) / ((1.0 + result5 * result3) * (1.0 - num2));
		double result8 = 0.0;
		double.TryParse(ComputeIpmt(argList), NumberStyles.Any, null, out result8);
		return (num3 - result8).ToString();
	}

	public string ComputePv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 4 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result4) ? Convert.ToInt16(result4).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result5) && double.TryParse(array[1], NumberStyles.Any, null, out var result6) && double.TryParse(array[2], NumberStyles.Any, null, out result) && (length == 3 || double.TryParse(array[3], NumberStyles.Any, null, out result2)) && (length <= 4 || double.TryParse(array[4], NumberStyles.Any, null, out result3)))
		{
			if (array[1] == "0" || array[2] == "0")
			{
				return "0";
			}
			result3 = ((!(Math.Abs(result3) > 0.5)) ? 0.0 : 1.0);
			double num2 = Math.Pow(1.0 + result5, result6);
			return ((result * (1.0 + result5 * result3) * (1.0 - num2) - result5 * result2) / (result5 * num2)).ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeEffect(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 2 && length != 0) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		string text2 = string.Empty;
		if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result) && IsCellReference(array[0]) && array[0].Contains(TIC) && result <= 0.0)
		{
			text2 = ErrorStrings[4].ToString();
		}
		if (double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2) && (!IsCellReference(array[1]) || !array[1].Contains(TIC)) && result2 <= 0.0)
		{
			text2 = ErrorStrings[4].ToString();
		}
		if (!string.IsNullOrEmpty(text2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException("invalid expression");
			}
			return text2;
		}
		return Math.Round(Math.Pow(1.0 + result / result2, result2) - 1.0, 9).ToString();
	}

	public string ComputeRate(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 6 && length != 5 && length != 4 && length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.1;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result4) && double.TryParse(array[1], NumberStyles.Any, null, out var result5) && double.TryParse(array[2], NumberStyles.Any, null, out var result6) && (length == 3 || double.TryParse(array[3], NumberStyles.Any, null, out result)) && (length <= 4 || double.TryParse(array[4], NumberStyles.Any, null, out result2)) && (length <= 5 || double.TryParse(array[5], NumberStyles.Any, null, out result3)))
		{
			result2 = ((!(Math.Abs(result2) > 0.5)) ? 0.0 : 1.0);
			int j;
			for (j = 0; j < 20; j++)
			{
				double x = Math.Abs(result3 + 1.0);
				double num = Math.Pow(x, result4);
				double num2 = Math.Pow(x, result4 - 1.0);
				double num3 = result3 * (result + result6 * num);
				double num4 = (1.0 + result3 * result2) * (1.0 - num);
				double num5 = result + result6 * (num + result3 * result4 * num2);
				double num6 = (1.0 + result3 * result2) * (0.0 - result4) * num2 + (1.0 - num) * result2;
				double num7 = (num5 * num4 - num3 * num6) / (num4 * num4);
				double num8 = (result5 - num3 / num4) / num7;
				if (Math.Abs(num8) < 1E-07)
				{
					result3 += num8;
					break;
				}
				result3 += num8;
			}
			if (j < 20)
			{
				return result3.ToString();
			}
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeSln(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[requires_3_args];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			num = (result2 - result3) / result4;
		}
		if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return num.ToString("C");
	}

	public string ComputeSyd(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result) ? Convert.ToInt16(result).ToString() : array[i]);
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out var result2) || !double.TryParse(array[1], NumberStyles.Any, null, out var result3) || !double.TryParse(array[2], NumberStyles.Any, null, out var result4) || !double.TryParse(array[3], NumberStyles.Any, null, out var result5))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		return ((result2 - result3) * (result4 - result5 + 1.0) * 2.0 / (result4 * (result4 + 1.0))).ToString();
	}

	public string ComputeVdb(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 6 && length != 7) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 2.0;
		double result2 = 0.0;
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result3) ? Convert.ToInt16(result3).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result4) && double.TryParse(array[1], NumberStyles.Any, null, out var result5) && double.TryParse(array[2], NumberStyles.Any, null, out var result6) && double.TryParse(array[3], NumberStyles.Any, null, out var result7) && double.TryParse(array[4], NumberStyles.Any, null, out var result8) && (length == 5 || double.TryParse(array[5], NumberStyles.Any, null, out result)) && (length <= 6 || double.TryParse(array[6], NumberStyles.Any, null, out result2)))
		{
			double num3 = result / result6;
			double num4 = 0.0;
			double num5 = (result4 - result5) / result6;
			bool flag = Math.Abs(result2) > 0.5;
			int num6 = 0;
			while ((double)num6 < result8)
			{
				num6++;
				if ((double)num6 == result6)
				{
					num = result4 - result5 - num4;
				}
				else
				{
					num = (result4 - num4) * num3;
					if (flag && num < num5)
					{
						num = num5;
					}
				}
				num4 += num;
				if ((double)num6 > result7 && (double)num6 <= result8)
				{
					num2 += num;
				}
				else if ((double)num6 - result8 < 0.99 && (double)num6 - result8 > 0.0)
				{
					num2 += num * (result8 - (double)num6 + 1.0);
				}
			}
			return num2.ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeDollarDe(string args)
	{
		string empty = string.Empty;
		NumberFormatInfo numberFormatInfo = (NumberFormatInfo)CultureInfo.CurrentCulture.NumberFormat.Clone();
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length != 2 || string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			if (string.IsNullOrEmpty(array[0]) || string.IsNullOrEmpty(array[1]))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
			string arg = array[0];
			string arg2 = "2";
			if (array.GetLength(0) == 2)
			{
				arg2 = array[1];
			}
			arg = GetValueFromArg(arg);
			arg2 = GetValueFromArg(arg2);
			string[] array2 = arg.Split(parseDecimalSeparator);
			if (arg.Length == 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			if (!IsCellReference(arg) && arg.Contains(TIC))
			{
				arg = arg.Replace(TIC, string.Empty);
			}
			if (!IsCellReference(arg2) && arg2.Contains(TIC))
			{
				arg2 = arg2.Replace(TIC, string.Empty);
			}
			double.TryParse(array2[0], NumberStyles.Any, null, out var _);
			if (!double.TryParse(arg2, NumberStyles.Any, null, out var result2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result2 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[3].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result2 == 0.0 || ComputeRounddown(result2.ToString()) == "0")
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[3].ToString());
				}
				return ErrorStrings[3].ToString();
			}
			if (!(result2 > 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[3].ToString());
				}
				return ErrorStrings[3].ToString();
			}
			string[] array3 = SplitArguments(arg, ParseDecimalSeparator);
			double num = 0.0;
			num = ((!(result2 / 10.0 <= 1.0)) ? ((array3.Length == 2) ? (double.Parse("0" + ParseDecimalSeparator + array3[1]) * 100.0) : 0.0) : ((array3.Length == 2) ? (double.Parse("0" + ParseDecimalSeparator + array3[1]) * 10.0) : 0.0));
			string[] array4 = SplitArguments((num / result2).ToString(), ParseDecimalSeparator);
			int num2 = int.Parse(array3[0], NumberStyles.Any) + int.Parse(array4[0], NumberStyles.Any);
			empty = ((array4.Length <= 1) ? num2.ToString() : (num2.ToString() + ParseDecimalSeparator + ((array4.Length == 2) ? array4[1] : string.Empty)));
			if (!(double.Parse(empty) > 0.0))
			{
				if (double.Parse(empty) < 0.0)
				{
					return string.Format(numberFormatInfo, "{0}", arg);
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			string[] array5 = empty.ToString().Split(parseDecimalSeparator);
			if (array5.Length > 1 && array5[1].Length > 0)
			{
				int length = array5[1].Length;
				numberFormatInfo.CurrencyDecimalDigits = length;
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw;
			}
			return ex.Message;
		}
		return string.Format(numberFormatInfo, "{0}", empty);
	}

	public string ComputeDollarFr(string args)
	{
		double num = 0.0;
		NumberFormatInfo numberFormatInfo = (NumberFormatInfo)CultureInfo.CurrentCulture.NumberFormat.Clone();
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			string text = array[0];
			string arg = "2";
			if (array.GetLength(0) == 2)
			{
				arg = array[1];
			}
			if (array.GetLength(0) >= 1 && string.IsNullOrEmpty(text))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			if (string.IsNullOrEmpty(array[0]) || string.IsNullOrEmpty(array[1]))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
			string text2 = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			text = GetValueFromArg(text);
			arg = GetValueFromArg(arg);
			text.Split(parseDecimalSeparator);
			double.TryParse(StripTics0(text), NumberStyles.Any, null, out var result);
			double.TryParse(StripTics0(arg), NumberStyles.Any, null, out var result2);
			if (double.IsNaN(result) || double.IsNaN(result2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result2 >= 0.0 && result2 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[3].ToString());
				}
				return ErrorStrings[3].ToString();
			}
			if (result2 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result >= 0.0 && result < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[3].ToString());
				}
				return ErrorStrings[3].ToString();
			}
			num = (int)result;
			num += result % 1.0 * Math.Pow(10.0, 0.0 - Math.Ceiling(Math.Log(result2) / Math.Log(10.0))) * result2;
			string[] array2 = num.ToString().Split(parseDecimalSeparator);
			if (array2.Length > 1 && array2[1].Length > 0)
			{
				int length = array2[1].Length;
				numberFormatInfo.CurrencyDecimalDigits = length;
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw;
			}
			return ex.Message;
		}
		return string.Format(numberFormatInfo, "{0}", num);
	}

	public string ComputeDuration(string args)
	{
		string result = string.Empty;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			double num = double.Parse(ComputeDays360(array[0] + ParseArgumentSeparator + array[1])) / 12.0;
			double num2 = num / 60.0;
			double num3 = double.Parse(GetValueFromArg(array[3]));
			double num4 = 100.0;
			double num5 = double.Parse(GetValueFromArg(array[2])) * 100.0;
			int i = 1;
			double num6 = 0.0;
			for (; (double)i <= num2; i++)
			{
				num6 += Math.Pow(num5, i) / Math.Pow(1.0 + num3, i);
			}
			num2 = num / 30.0;
			result = (((num6 + num5 * 100.0 / Math.Pow(1.0 + num3, num2)) / (num5 * (1.0 - 1.0 / Math.Pow(1.0 + num3, num2) / num3 + num4 / Math.Pow(1.0 + num3, num2))) + num5 / 100.0) / 2.0 + num5 / 10.0).ToString();
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw;
			}
		}
		return result;
	}

	public string ComputeACCRINTM(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.Length < 4 || array.Length > 5)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		string valueFromArg3 = GetValueFromArg(array[2]);
		string valueFromArg4 = GetValueFromArg(array[3]);
		string obj = ((array.Length == 5) ? GetValueFromArg(array[4]) : "0");
		DateTime result = dateTime1900;
		DateTime result2 = dateTime1900;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		if (!double.TryParse(obj.Replace(TIC, string.Empty), out var result5))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if ((!double.TryParse(valueFromArg.Replace(TIC, string.Empty), out result3) && !DateTime.TryParse(valueFromArg.Replace(TIC, string.Empty), out result)) || (!double.TryParse(valueFromArg2.Replace(TIC, string.Empty), out result4) && !DateTime.TryParse(valueFromArg2.Replace(TIC, string.Empty), out result2)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (result3 > 0.0)
		{
			result = CalcEngineHelper.FromOADate(result3);
		}
		if (result4 > 0.0)
		{
			result2 = CalcEngineHelper.FromOADate(result4);
		}
		double result6;
		if (valueFromArg4.Equals(string.Empty))
		{
			result6 = 1000.0;
		}
		else
		{
			if (!double.TryParse(valueFromArg4, out result6))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result6 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		if (double.TryParse(valueFromArg3, out var result7))
		{
			if (result7 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			string text = TIC + result.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			string text2 = TIC + result2.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			if (double.TryParse(text.Replace(TIC, string.Empty), out var result8) && double.TryParse(text2.Replace(TIC, string.Empty), out var result9) && result8 >= result9)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			switch ((int)result5)
			{
			case 0:
				num = double.Parse(ComputeDays360(text + ParseArgumentSeparator + text2 + ParseArgumentSeparator + TRUEVALUESTR)) / 360.0;
				break;
			case 1:
				num = double.Parse(ComputeDays360(text + ParseArgumentSeparator + text2)) / 365.0;
				break;
			case 2:
				num = double.Parse(ComputeDays(text2 + ParseArgumentSeparator + text)) / 360.0;
				break;
			case 3:
				num = double.Parse(ComputeDays(text2 + ParseArgumentSeparator + text)) / 365.0;
				break;
			case 4:
				num = double.Parse(ComputeDays360(text + ParseArgumentSeparator + text2)) / 360.0;
				break;
			default:
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			return (result7 * result6 * num).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[4].ToString());
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeRRI(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.Length != 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg2 = (string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2);
		valueFromArg2 = (bool.TryParse(valueFromArg2, out result) ? Convert.ToInt16(result).ToString() : valueFromArg2);
		string valueFromArg3 = GetValueFromArg(array[2]);
		valueFromArg3 = (string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3);
		valueFromArg3 = (bool.TryParse(valueFromArg3, out result) ? Convert.ToInt16(result).ToString() : valueFromArg3);
		if (!double.TryParse(valueFromArg, out var result2) || !double.TryParse(valueFromArg2, out var result3) || !double.TryParse(valueFromArg3, out var result4))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (result2 == 0.0 || result3 == 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new Exception(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		return (Math.Pow(result4 / result3, 1.0 / result2) - 1.0).ToString();
	}

	public string ComputeFvschedule(string args)
	{
		double num = 0.0;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length > 2 || string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			string arg = array[0];
			string arg2 = array[1];
			arg = GetValueFromArg(arg);
			arg2 = GetValueFromArg(arg2);
			if (string.IsNullOrEmpty(arg) || string.IsNullOrEmpty(arg2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
			double result = 0.0;
			double result2 = 0.0;
			double.TryParse(arg, out result);
			num = result;
			arg2 = arg2.Replace(TIC, "");
			string[] array2 = arg2.Split(ParseArgumentSeparator);
			for (int i = 0; i < array2.Length; i++)
			{
				if (string.IsNullOrEmpty(array2[i]))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				if (!double.TryParse(array2[i].ToString(), NumberStyles.Any, null, out result2))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[5].ToString());
					}
					return ErrorStrings[5].ToString();
				}
				result2 = double.Parse(array2[i]);
				num *= 1.0 + result2;
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw;
			}
		}
		return num.ToString();
	}

	public string ComputeIntrate(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		new List<DateTime>();
		if (length > 5)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "");
		string text2 = GetValueFromArg(array[1]).Replace(TIC, "");
		string s = ((length == 5) ? GetValueFromArg(array[4]).Replace(TIC, "") : "0");
		string s2 = GetValueFromArg(array[2]).Replace(TIC, "");
		string s3 = GetValueFromArg(array[3]).Replace(TIC, "");
		if (!DateTime.TryParse(text, out var _) || !DateTime.TryParse(text2, out var _) || !int.TryParse(s, out var result3) || !double.TryParse(s2, out var result4) || !double.TryParse(s3, out var result5))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double num = double.Parse(ComputeDatevalue(text2)) - double.Parse(ComputeDatevalue(text));
		if (result3 > 4 && result3 < 0 && num < 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		double num2 = (result5 - result4) / (result4 * num);
		switch (result3)
		{
		case 0:
			num2 *= 360.0;
			break;
		case 1:
			num2 *= 366.0;
			break;
		case 2:
			num2 *= 360.0;
			break;
		case 3:
			num2 *= 365.0;
			break;
		case 4:
			num2 *= 360.0;
			break;
		default:
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return num2.ToString();
	}

	public string ComputeDisc(string args)
	{
		string result = string.Empty;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length < 3 || array.Length > 5 || string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[invalid_arguments]);
				}
				return FormulaErrorStrings[invalid_arguments];
			}
			string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
			string text2 = GetValueFromArg(array[1]).Replace(TIC, string.Empty);
			string valueFromArg = GetValueFromArg(array[2]);
			string valueFromArg2 = GetValueFromArg(array[3]);
			DateTime result2;
			DateTime result3 = (result2 = dateTime1900);
			double result4 = 0.0;
			double result5 = 0.0;
			string empty = string.Empty;
			empty = ((array.Length <= 4) ? "0" : array[4]);
			for (int i = 0; i <= 1; i++)
			{
				string text3 = FormulaErrorStringCheck(array[i], FormulaArgumentType.Date);
				if (ErrorStrings.Contains(text3))
				{
					return text3;
				}
			}
			for (int j = 2; j < array.Length; j++)
			{
				if (j <= array.Length)
				{
					string text4 = FormulaErrorStringCheck(array[j], FormulaArgumentType.Numbers);
					if (ErrorStrings.Contains(text4))
					{
						return text4;
					}
				}
			}
			if (string.IsNullOrEmpty(valueFromArg) || string.IsNullOrEmpty(valueFromArg2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
			if (!DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out result3) && (!double.TryParse(text, out result4) || (!DateTime.TryParse(text2, CultureInfo.CurrentCulture, DateTimeStyles.None, out result2) && !double.TryParse(text2, out result5))))
			{
				if (text.StartsWith(TIC) || text2.StartsWith(TIC) || text.Equals(string.Empty) || text2.Equals(string.Empty))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result4 > 1.0)
			{
				text = CalcEngineHelper.FromOADate(result4).ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
			}
			if (result5 > 1.0)
			{
				text2 = CalcEngineHelper.FromOADate(result5).ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern);
			}
			valueFromArg = GetValueFromArg(valueFromArg);
			valueFromArg2 = GetValueFromArg(valueFromArg2);
			empty = GetValueFromArg(empty);
			empty = (string.IsNullOrEmpty(empty) ? "0" : empty);
			DateTime result6 = DateTime.Now;
			double result7 = 0.0;
			double result8 = 0.0;
			if (double.TryParse(valueFromArg, out var result9) && double.TryParse(valueFromArg2, out var result10) && double.TryParse(empty, out var result11) && (result9 < 0.0 || result9 == 0.0 || result10 < 0.0 || result10 == 0.0 || result11 < 0.0 || result11 > 4.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if ((DateTime.TryParse(text.Replace(TIC, string.Empty), out var result12) || double.TryParse(text, out result7)) && (DateTime.TryParse(text2.Replace(TIC, string.Empty), out result6) || double.TryParse(text2, out result8)))
			{
				if (result12.Year == 1 || result6.Year == 1)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[4].ToString();
				}
				if (result7 == 0.0)
				{
					result7 = result12.ToOADate();
				}
				if (result8 == 0.0)
				{
					result8 = result6.ToOADate();
				}
				if (result7 > result8 || result7 == result8)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException(ErrorStrings[4].ToString());
					}
					return ErrorStrings[4].ToString();
				}
				if (result8 < 1.0 || result7 < 1.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException(ErrorStrings[4].ToString());
					}
					return ErrorStrings[4].ToString();
				}
				double num = double.Parse(ComputeDays360(result7.ToString() + ParseArgumentSeparator + result8)) + 1.0;
				switch (empty)
				{
				case "0":
					empty = "360";
					break;
				case "1":
					empty = "365";
					break;
				case "2":
					empty = 360.ToString();
					break;
				case "3":
					empty = 365.ToString();
					break;
				case "4":
					empty = "30";
					break;
				}
				result = ((double.Parse(valueFromArg2) - double.Parse(valueFromArg)) / double.Parse(valueFromArg2) * (double.Parse(empty) / num)).ToString();
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		return result;
	}

	public string ComputeFv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 4 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		string valueFromArg3 = GetValueFromArg(array[2]);
		string text2 = ((length >= 4) ? GetValueFromArg(array[3]) : "0");
		string text3 = ((length == 5) ? GetValueFromArg(array[4]) : "0");
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		valueFromArg2 = (string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2);
		valueFromArg3 = (string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3);
		text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
		text3 = (string.IsNullOrEmpty(text3) ? "0" : text3);
		string text4 = string.Empty;
		if (!double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result4))
		{
			text4 = ((IsCellReference(array[0]) || array[0].Contains(TIC)) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString());
		}
		if (!double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result5))
		{
			text4 = ((IsCellReference(array[1]) || array[1].Contains(TIC)) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString());
		}
		if (!double.TryParse(valueFromArg3.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
		{
			text4 = ((IsCellReference(array[2]) || array[2].Contains(TIC)) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString());
		}
		if (!double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
		{
			text4 = ((IsCellReference(array[3]) || array[3].Contains(TIC)) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString());
		}
		if (!double.TryParse(text3.Replace(TIC, string.Empty), NumberStyles.Any, null, out result3))
		{
			text4 = ((IsCellReference(array[4]) || array[4].Contains(TIC)) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString());
		}
		if (!string.IsNullOrEmpty(text4))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException("invalid expression");
			}
			return text4;
		}
		result3 = ((Math.Abs(result3) > 0.5) ? 1 : 0);
		double num2 = Math.Pow(1.0 + result4, result5);
		num = result * (1.0 + result4 * result3) * (1.0 - num2) / result4 - result2 * num2;
		double d = (1.0 - num2) / result4;
		if (double.IsNaN(num) && double.IsNaN(d))
		{
			num = 1.0 * (1.0 + result4 * result3) * (1.0 - num2) / 1.0 - result2 * num2;
		}
		return num.ToString();
	}

	public string ComputeIpmt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 6 && length != 5 && length != 4) || string.IsNullOrEmpty(argList))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result4) ? Convert.ToInt16(result4).ToString() : array[i]);
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out var result5) || !double.TryParse(array[1], NumberStyles.Any, null, out var result6) || !double.TryParse(array[2], NumberStyles.Any, null, out var result7) || !double.TryParse(array[3], NumberStyles.Any, null, out result) || (length != 4 && !double.TryParse(array[4], NumberStyles.Any, null, out result2)) || (length > 5 && !double.TryParse(array[5], NumberStyles.Any, null, out result3)))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		result3 = ((!(Math.Abs(result3) > 0.5)) ? 0.0 : 1.0);
		double num2 = Math.Pow(1.0 + result5, result7);
		double num3 = Math.Pow(1.0 + result5, result6);
		double num4 = result5 * (result2 + result * num2) / ((1.0 + result5 * result3) * (1.0 - num2));
		double num5 = num4 * (1.0 + result5 * result3) * (1.0 - num3) / result5 - result * num3;
		double num6 = Math.Pow(1.0 + result5, result6 - 1.0);
		double num7 = num4 * (1.0 + result5 * result3) * (1.0 - num6) / result5 - result * num6;
		return (num4 - num7 + num5).ToString("G15");
	}

	public string ComputeIrr(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int num = length;
		if ((length != 1 && length != 2) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.None);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (array.Length == 2)
		{
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
		}
		int num2 = 0;
		for (num2 = 0; num2 < length; num2++)
		{
			if (!IsCellReference(array[num2]) && (string.IsNullOrEmpty(GetValueFromArg(array[num2])) || bool.TryParse(GetValueFromArg(array[num2]), out var _)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		double result2 = 0.1;
		string args = array[0];
		double num3 = 0.0;
		if (length == 2)
		{
			double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result2);
		}
		array = ((!array[0].Contains(":")) ? SplitArgsPreservingQuotedCommas(array[0].Replace(TIC, string.Empty)) : GetCellsFromArgs(args));
		length = array.GetLength(0);
		double[] array2 = new double[length];
		num2 = 0;
		bool flag = false;
		bool flag2 = false;
		string[] array3 = array;
		foreach (string arg in array3)
		{
			if (double.TryParse(GetValueFromArg(arg), NumberStyles.Any, null, out var result3))
			{
				if (result3 > 0.0)
				{
					flag = true;
				}
				else if (result3 < 0.0)
				{
					flag2 = true;
				}
				array2[num2] = result3;
				num3 += result3;
			}
			num2++;
		}
		if (!flag && !flag2)
		{
			return ErrorStrings[4].ToString();
		}
		int j = 0;
		result2 = ((num3 < 0.0 && num == 1) ? (-0.9) : result2);
		for (; j < 100; j++)
		{
			double num4 = 0.0;
			double num5 = 0.0;
			double num6 = Math.Abs(result2 + 1.0);
			double num7 = num6;
			num4 += array2[0];
			for (num2 = 1; num2 < length; num2++)
			{
				num4 += array2[num2] / num7;
				num7 *= num6;
				double num8 = (double)(num2 + 1) * array2[num2] / num7;
				num5 = ((array2[num2] != 0.0 || !(num5 < 0.0)) ? (num5 + num8) : num8);
			}
			num4 /= num5;
			if (Math.Abs(num4 / result2) < 1E-05)
			{
				result2 += num4;
				break;
			}
			result2 += num4;
		}
		if (j > 100)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return result2.ToString();
	}

	public string ComputeXirr(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = -1.0;
		string text = array[0];
		if (length == 3)
		{
			double.TryParse(GetValueFromArg(array[2]), NumberStyles.Any, null, out result);
		}
		string[] obj = (text.Contains(ParseArgumentSeparator.ToString()) ? SplitArgsPreservingQuotedCommas(text.Replace(TIC, string.Empty)) : GetCellsFromArgs(text));
		length = obj.GetLength(0);
		double[] array2 = new double[length];
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		string[] array3 = obj;
		foreach (string text2 in array3)
		{
			if (double.TryParse(GetValueFromArg(text2.Replace("u", "-").Replace(TIC, string.Empty)), NumberStyles.Any, null, out var result2))
			{
				array2[num] = result2;
			}
			if (result2 < 0.0)
			{
				num3++;
			}
			else if (result2 > 0.0)
			{
				num2++;
			}
			num++;
		}
		if (num2 == 0 || num3 == 0)
		{
			return ErrorStrings[4].ToString();
		}
		text = array[1];
		array = ((array[1].Contains(ParseArgumentSeparator.ToString()) || !IsCellReference(array[1])) ? array[1].Split(ParseArgumentSeparator) : GetCellsFromArgs(text));
		if (array.GetLength(0) != length)
		{
			return ErrorStrings[4].ToString();
		}
		double[] array4 = new double[length];
		num = 0;
		array3 = array;
		foreach (string arg in array3)
		{
			string valueFromArg = GetValueFromArg(arg);
			double result3;
			bool flag = double.TryParse(valueFromArg, out result3);
			if (!flag && DateTime.TryParse(valueFromArg.Replace(TIC, string.Empty), out var result4))
			{
				array4[num] = (int)GetSerialDateTimeFromDate(result4);
			}
			else
			{
				if (!flag)
				{
					return ErrorStrings[1].ToString();
				}
				array4[num] = result3;
			}
			if (array4[num] < array4[0])
			{
				return ErrorStrings[4].ToString();
			}
			num++;
		}
		return ComputeXirr(array2, array4, result);
	}

	private string ComputeXirr(double[] cashFlows, double[] dates, double lowerBoundRate)
	{
		double num = 1.0;
		double num2 = double.NaN;
		double num3 = double.MaxValue;
		for (double num4 = lowerBoundRate; num4 <= num; num4 += 0.001)
		{
			double num5 = CalculateNPV(cashFlows, dates, num4);
			if (num5 > 0.0 && num5 < num3)
			{
				num2 = num4;
				num3 = num5;
			}
		}
		if (double.IsNaN(num2))
		{
			return "#NUM!";
		}
		return CalculateXirr(cashFlows, dates, num2);
	}

	private string CalculateXirr(double[] cashFlows, double[] dates, double guessRate)
	{
		double num = 0.0001;
		int num2 = 100;
		double num3 = guessRate;
		int i;
		for (i = 0; i < num2; i++)
		{
			double num4 = CalculateNPV(cashFlows, dates, num3);
			if (Math.Abs(num4) < num)
			{
				break;
			}
			double num5 = CalculateNPVDerivative(cashFlows, dates, num3);
			num3 -= num4 / num5;
		}
		if (i >= 100 || double.IsNaN(num3))
		{
			return "#NUM!";
		}
		return num3.ToString();
	}

	private double CalculateNPV(double[] cashFlows, double[] dates, double rate)
	{
		double num = 0.0;
		for (int i = 0; i < cashFlows.Length; i++)
		{
			double y = (dates[i] - dates[0]) / 365.0;
			num += cashFlows[i] / Math.Pow(1.0 + rate, y);
		}
		return num;
	}

	private double CalculateNPVDerivative(double[] cashFlows, double[] dates, double rate)
	{
		double num = 0.0;
		for (int i = 0; i < cashFlows.Length; i++)
		{
			double num2 = (dates[i] - dates[0]) / 365.0;
			num -= num2 * cashFlows[i] / Math.Pow(1.0 + rate, num2 + 1.0);
		}
		return num;
	}

	public string ComputeIspmt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out var result5) && double.TryParse(array[3], NumberStyles.Any, null, out result))
		{
			num = (0.0 - result3) * result * (result5 - result4) / result5;
		}
		if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return num.ToString();
	}

	public string ComputeMirr(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		for (int i = 1; i <= 2; i++)
		{
			string text2 = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
		}
		double num = 0.0;
		double result = 0.1;
		double result2 = 0.1;
		double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result);
		double.TryParse(GetValueFromArg(array[2]), NumberStyles.Any, null, out result2);
		string args = array[0];
		array = ((!array[0].Contains(":")) ? SplitArgsPreservingQuotedCommas(array[0].Replace(TIC, string.Empty)) : GetCellsFromArgs(args));
		length = array.GetLength(0);
		double[] array2 = new double[length];
		int num2 = 0;
		string[] array3 = array;
		foreach (string arg in array3)
		{
			if (double.TryParse(GetValueFromArg(arg), NumberStyles.Any, null, out var result3))
			{
				array2[num2] = result3;
			}
			num2++;
		}
		double num3 = 0.0;
		double num4 = 0.0;
		double num5 = 1.0;
		double num6 = 1.0 + result;
		for (num2 = 0; num2 < length; num2++)
		{
			num5 *= 1.0 + result2;
			if (array2[num2] > 0.0)
			{
				num3 += array2[num2] / num5;
			}
			else
			{
				num4 += array2[num2] / num6;
			}
			num6 *= 1.0 + result;
		}
		num3 = (0.0 - num3) * num5;
		num4 *= 1.0 + result;
		num = Math.Pow(num3 / num4, 1.0 / ((double)length - 1.0)) - 1.0;
		num = Math.Round(100.0 * num);
		return (num / 100.0).ToString("0%");
	}

	public string ComputeNper(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 4 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result5) ? Convert.ToInt16(result5).ToString() : array[i]);
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out var result6) || !double.TryParse(array[1], NumberStyles.Any, null, out result) || !double.TryParse(array[2], NumberStyles.Any, null, out result2) || (length != 3 && !double.TryParse(array[3], NumberStyles.Any, null, out result3)) || (length > 4 && !double.TryParse(array[4], NumberStyles.Any, null, out result4)))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		result4 = ((!(Math.Abs(result4) > 0.5)) ? 0.0 : 1.0);
		return (Math.Log10((result * (1.0 + result6 * result4) - result3 * result6) / (result * (1.0 + result6 * result4) + result2 * result6)) / Math.Log10(1.0 + result6)).ToString();
	}

	public string ComputeDb(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 4) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 12.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = StripTics(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && result3 >= 0.0 && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && result4 > 0.0 && double.TryParse(array[2], NumberStyles.Any, null, out var result5) && result5 > 0.0 && double.TryParse(array[3], NumberStyles.Any, null, out var result6) && result6 > 0.0 && (length == 4 || double.TryParse(array[4], NumberStyles.Any, null, out result)) && result > 0.0)
		{
			if (result5 < result6 && (result < 0.0 || result == 12.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			double num2 = Math.Round(1.0 - Math.Pow(result4 / result3, 1.0 / result5), 3);
			double num3 = 0.0;
			for (int j = 1; (double)j <= result6; j++)
			{
				num = ((j == 1) ? (result3 * num2 * result / 12.0) : ((!((double)j > result5)) ? ((result3 - num3) * num2) : ((result3 - num3) * num2 * (12.0 - result) / 12.0)));
				if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
				{
					return "0";
				}
				num3 += num;
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[4].ToString());
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeDdb(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 5 && length != 4) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 2.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && result3 > 0.0 && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && result4 > 0.0 && double.TryParse(array[2], NumberStyles.Any, null, out var result5) && result5 > 0.0 && double.TryParse(array[3], NumberStyles.Any, null, out var result6) && result6 > 0.0 && (length == 4 || double.TryParse(array[4], NumberStyles.Any, null, out result)) && result5 >= result6)
		{
			double num2 = result / result5;
			double num3 = 0.0;
			for (int j = 1; (double)j <= result6; j++)
			{
				num = (((double)j != result5 / 2.0 && result != 12.0 && result5 != 1.0) ? ((result3 - num3) * num2) : (result3 - result4 - num3));
				num3 += num;
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[bad_formula]);
		}
		return ErrorStrings[4].ToString();
	}

	public string ComputeCUMIPMT(string args)
	{
		double num = 0.0;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length < 5 || string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string arg = array[0];
			string arg2 = array[1];
			string arg3 = array[2];
			string arg4 = array[3];
			string arg5 = array[4];
			string arg6 = array[5];
			arg = GetValueFromArg(arg);
			arg2 = GetValueFromArg(arg2);
			arg3 = GetValueFromArg(arg3);
			arg4 = GetValueFromArg(arg4);
			arg5 = GetValueFromArg(arg5);
			arg6 = GetValueFromArg(arg6);
			double result = 0.0;
			double result2 = 0.0;
			double result3 = 0.0;
			double result4 = 0.0;
			double result5 = 0.0;
			double result6 = 0.0;
			if (!double.TryParse(arg, out result) || !double.TryParse(arg2, out result2) || !double.TryParse(arg3, out result3) || !double.TryParse(arg4, out result4) || !double.TryParse(arg5, out result5) || !double.TryParse(arg6, out result6))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result <= 0.0 || result2 <= 0.0 || result3 <= 0.0 || result4 < 1.0 || result5 < 1.0 || result4 > result5 || (result6 != 0.0 && result6 != 1.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result4 < 1.0 || result5 < 1.0 || result4 > result5)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result6 != 0.0 && result6 != 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			string text2 = parseArgumentSeparator.ToString();
			double num2 = double.Parse(ComputePmt(result + text2 + result2 + text2 + result3 + text2 + "0" + text2 + result6));
			num = 0.0;
			if (result4 == 1.0 && result6 == 0.0)
			{
				num = 0.0 - result3;
				result4 += 1.0;
			}
			for (int i = (int)result4; (double)i <= result5; i++)
			{
				num = ((result6 != 1.0) ? (num + double.Parse(ComputeFv(result + text2 + (i - 1) + text2 + num2 + text2 + result3 + text2 + "0"))) : (num + (double.Parse(ComputeFv(result + text2 + (i - 2) + text2 + num2 + text2 + result3 + text2 + "1")) - num2)));
			}
			num *= result;
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeACCRINT(string args)
	{
		double num = 0.0;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length < 5)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			string arg = array[0];
			string arg2 = array[1];
			string arg3 = array[2];
			string arg4 = array[3];
			string arg5 = array[4];
			string arg6 = array[5];
			string arg7 = ((array.Length < 7) ? "0" : array[6]);
			string arg8 = ((array.Length < 8) ? "0" : array[7]);
			arg = GetValueFromArg(arg);
			arg2 = GetValueFromArg(arg2);
			arg3 = GetValueFromArg(arg3);
			arg4 = GetValueFromArg(arg4);
			arg5 = GetValueFromArg(arg5);
			arg6 = GetValueFromArg(arg6);
			arg7 = GetValueFromArg(arg7);
			arg8 = GetValueFromArg(arg8);
			double result = 0.0;
			double result2 = 0.0;
			double num2 = 0.0;
			double num3 = 0.277777777;
			DateTime result3 = default(DateTime);
			DateTime result4 = default(DateTime);
			DateTime result5 = default(DateTime);
			double result6 = 0.0;
			double result7 = 0.0;
			double result8 = 0.0;
			if ((!DateTime.TryParse(arg.Replace(TIC, string.Empty), out result3) && !double.TryParse(arg.Replace(TIC, string.Empty), out result6)) || (!double.TryParse(arg2.Replace(TIC, string.Empty), out result8) && !DateTime.TryParse(arg2.Replace(TIC, string.Empty), out result5)) || (!double.TryParse(arg3.Replace(TIC, string.Empty), out result7) && !DateTime.TryParse(arg3.Replace(TIC, string.Empty), out result4)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			double result9 = 0.0;
			double.TryParse(arg6, out result9);
			double.TryParse(arg4, out result);
			double.TryParse(arg5, out result2);
			if (result6 > 0.0 || result7 > 0.0)
			{
				result3 = GetDateFromSerialDate((int)result6);
			}
			if (result7 > 0.0)
			{
				result4 = GetDateFromSerialDate((int)result7);
			}
			if (result8 > 0.0)
			{
				result5 = GetDateFromSerialDate((int)result8);
			}
			if (dateTime1900.Year > result3.Year || dateTime1900.Year > result4.Year || dateTime1900.Year > result5.Year)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			string arg9 = TIC + result3.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			string arg10 = TIC + result4.ToString(DateTimeFormatInfo.CurrentInfo.ShortDatePattern) + TIC;
			switch (arg7)
			{
			case "0":
			case "1":
			case "2":
			case "3":
			case "4":
				num2 = double.Parse(ComputeYearFrac($"{arg9},{arg10},{arg7}"));
				num = result2 * (result / (double)(int)result9) * num2 * (double)(int)result9;
				num = (((int)result9 == 4) ? (num + num3) : num);
				break;
			default:
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeCUMPRINC(string args)
	{
		double num = 0.0;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(args);
			if (array.Length < 5 || string.IsNullOrEmpty(args))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string arg = array[0];
			string arg2 = array[1];
			string arg3 = array[2];
			string arg4 = array[3];
			string arg5 = array[4];
			string arg6 = array[5];
			arg = GetValueFromArg(arg);
			arg2 = GetValueFromArg(arg2);
			arg3 = GetValueFromArg(arg3);
			arg4 = GetValueFromArg(arg4);
			arg5 = GetValueFromArg(arg5);
			arg6 = GetValueFromArg(arg6);
			double result = 0.0;
			double result2 = 0.0;
			double result3 = 0.0;
			double result4 = 0.0;
			double result5 = 0.0;
			double result6 = 0.0;
			if (!double.TryParse(arg, out result) || !double.TryParse(arg2, out result2) || !double.TryParse(arg3, out result3) || !double.TryParse(arg4, out result4) || !double.TryParse(arg5, out result5) || !double.TryParse(arg6, out result6))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result <= 0.0 || result2 <= 0.0 || result3 <= 0.0 || result4 < 1.0 || result4 > result2 || result5 < 1.0 || result5 > result2 || result4 > result5 || (result6 != 0.0 && result6 != 1.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (result4 < 1.0 || result5 < 1.0 || result4 > result5)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (result6 != 0.0 && result6 != 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			double num2 = double.Parse(ComputePmt($"{result},{result2},{result3},{0},{result6}"));
			if (result4 == 1.0)
			{
				num = ((result6 != 0.0) ? num2 : (num2 + result3 * result));
				result4 += 1.0;
			}
			for (double num3 = result4; num3 <= result5; num3 += 1.0)
			{
				num = ((!(result6 > 0.0)) ? (num + (num2 - double.Parse(ComputeFv($"{result},{num3 - 1.0},{num2},{result3},{0}")) * result)) : (num + (num2 - (double.Parse(ComputeFv($"{result},{num3 - 2.0},{num2},{result3},{1}")) - num2) * result)));
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw ex;
			}
			return ex.Message;
		}
		return num.ToString();
	}

	public string ComputeAddress(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		string empty = string.Empty;
		string valueFromArg = GetValueFromArg(array[0].Replace(TIC, string.Empty));
		string valueFromArg2 = GetValueFromArg(array[1].Replace(TIC, string.Empty));
		long num = long.Parse(valueFromArg);
		long num2 = long.Parse(valueFromArg2);
		if (num < 1 || num2 < 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		string text = ((length > 2) ? GetValueFromArg(array[2].Replace(TIC, string.Empty)) : "1");
		long num3 = num2;
		long num4 = num3 / 26;
		long num5 = ((num3 % 26 == 0L) ? (num3 / num4) : (num3 % 26));
		num3 = ((num3 % 26 == 0L) ? (num3 / 26 - 1) : (num3 / 26));
		empty += charTable[num5];
		empty += charTable[num3];
		char[] array2 = empty.ToCharArray();
		Array.Reverse(array2);
		string text2 = new string(array2);
		empty = "$" + text2 + "$" + valueFromArg;
		if (length > 2 && (text == null || text.Length != 0))
		{
			switch (text)
			{
			case "2":
				empty = text2 + "$" + valueFromArg;
				break;
			case "3":
				empty = "$" + text2 + valueFromArg;
				break;
			case "4":
				empty = text2 + valueFromArg;
				break;
			}
		}
		if (length > 3 && (GetValueFromArg(array[3].Replace(TIC, string.Empty)) == "FALSE" || GetValueFromArg(array[2].Replace(TIC, string.Empty)) == "0"))
		{
			if (text == null || text.Length != 0)
			{
				switch (text)
				{
				case "1":
					empty = "R" + num + "C" + num2;
					break;
				case "2":
					empty = "R" + num + "C[" + num2 + "]";
					break;
				case "3":
					empty = "R[" + num + "]C" + num2;
					break;
				case "4":
					empty = "R[" + num + "]C[" + num2 + "]";
					break;
				}
			}
			else
			{
				empty = "R" + num + "C" + num2;
			}
		}
		if (length > 4 && GetValueFromArg(array[3].Replace(TIC, string.Empty)) == string.Empty)
		{
			array[4] = GetValueFromArg(array[4]).Replace(TIC, string.Empty);
			empty = array[4] + "!" + empty;
		}
		return empty;
	}

	public string ComputeCell(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (isIndexInteriorFormula)
		{
			isIndexInteriorFormula = false;
		}
		if (array.Length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = "";
		if (array.Length == 2)
		{
			array[1] = array[1].Replace(TIC, string.Empty);
			string scopedRange = string.Empty;
			if (!IsCellReference(array[1]) && !TryGetNamedRange(array[1], out scopedRange))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return FormulaErrorStrings[invalid_arguments];
			}
			text = array[1];
		}
		else
		{
			text = cell;
		}
		string text2 = array[0].Replace(TIC, string.Empty).ToLower();
		string text3 = "";
		switch (text2)
		{
		case "address":
			text3 = RowIndex(text).ToString() + ParseArgumentSeparator + ColIndex(text);
			text3 = ComputeAddress(text3);
			break;
		case "col":
			text3 = ComputeColumn(text);
			break;
		case "contents":
			text3 = GetValueFromArg(text);
			if (text3 == string.Empty)
			{
				text3 = "0";
			}
			break;
		case "filename":
			text3 = "Not Supported";
			break;
		case "row":
			text3 = ComputeRow(text);
			break;
		case "type":
			text3 = ((!(ComputeIsBlank(text) == TRUEVALUESTR)) ? ((!(ComputeIsText(text) == TRUEVALUESTR)) ? "v" : "l") : "b");
			break;
		}
		return text3.ToString();
	}

	public string ComputeInfo(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = StripTics0(GetValueFromArg(array[0])).ToLower();
		string result = string.Empty;
		switch (text)
		{
		case "directory":
			result = "Portable Library does not supports to get Directory";
			break;
		case "numfile":
			result = ((SortedSheetNames == null || sheetFamiliesList.Count != 0) ? "1" : SortedSheetNames.Count.ToString());
			break;
		case "origin":
		{
			string argList2 = RowIndex(cell).ToString() + ParseArgumentSeparator + ColIndex(cell);
			result = "$A: " + ComputeAddress(argList2);
			break;
		}
		case "osversion":
			result = "Portable Library not supprts to get the OS Version.";
			break;
		case "recalc":
			result = ((!alwaysComputeDuringRefresh) ? "Manual" : "Automatic");
			break;
		case "system":
			result = "pcdos";
			break;
		default:
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		case "release":
			break;
		}
		return result;
	}

	public string ComputeType(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int num = 0;
		if (length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string valueFromArg = GetValueFromArg(array[0]);
		if (string.IsNullOrEmpty(valueFromArg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (argList.IndexOf(ParseArgumentSeparator) > -1)
		{
			num = 64;
		}
		else if (ComputeIsNumber(valueFromArg) == TRUEVALUESTR)
		{
			num = 1;
		}
		else if (ComputeIsLogical(valueFromArg) == TRUEVALUESTR)
		{
			num = 4;
		}
		else if (valueFromArg.Equals("invalid expression") || ErrorStrings.Contains(valueFromArg))
		{
			num = 16;
		}
		else if (ComputeIsText(valueFromArg) == TRUEVALUESTR)
		{
			num = 2;
		}
		return num.ToString();
	}

	public string ComputeIsFormula(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		string empty = string.Empty;
		if (length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = array[0];
		if (!IsCellReference(array[0]))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string scopedRange = string.Empty;
		if (TryGetNamedRange(empty, out scopedRange) && scopedRange != string.Empty)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[1].ToString();
		}
		empty = GetValueFromParentObject(empty, calculateFormula: false);
		if (empty == string.Empty || empty[0] != '=')
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	private int matchCompare(object o1, object o2)
	{
		string text = o1.ToString();
		string text2 = o2.ToString();
		if (double.TryParse(text, NumberStyles.Any, null, out var result) && double.TryParse(text2, NumberStyles.Any, null, out var result2))
		{
			return result.CompareTo(result2);
		}
		return text.CompareTo(text2);
	}

	public string ComputeHLookUp(string range)
	{
		bool flag = IsHLookupCachingEnabled();
		bool flag2 = IsOptimizedMatchesEnabled();
		if (flag && lookupTables == null)
		{
			lookupTables = new Dictionary<string, LookUps>();
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = valueFromArg.Replace(TIC, string.Empty).ToUpper();
		string text = array[1].Replace("\"", string.Empty);
		string s = GetValueFromArg(array[2]).Replace("\"", string.Empty);
		double result = 0.0;
		if (!double.TryParse(s, NumberStyles.Any, null, out result))
		{
			return "#N/A";
		}
		int num = (int)result;
		bool flag3 = true;
		if (array.GetLength(0) == 4)
		{
			flag3 = GetValueFromArg(array[3]) == TRUEVALUESTR;
		}
		bool flag4 = flag3 && double.TryParse(valueFromArg, NumberStyles.Any, null, out result);
		int num2 = text.IndexOf(":");
		if (num2 == -1)
		{
			text = text + ":" + text;
			num2 = text.IndexOf(":");
		}
		int num3 = text.Substring(0, num2).LastIndexOf('!');
		ICalcData calcData = grid;
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		if (num3 > -1)
		{
			grid = (ICalcData)sheetFamilyItem.TokenToParentObject[text.Substring(0, num3 + 1)];
		}
		int num4 = RowIndex(text.Substring(0, num2));
		int num5 = RowIndex(text.Substring(num2 + 1));
		int num6 = ColIndex(text.Substring(0, num2));
		int num7 = ColIndex(text.Substring(num2 + 1));
		if (grid is ISheetData)
		{
			if (!(!num4.Equals(-1) || num5.Equals(-1)).Equals(num4.Equals(-1) || !num5.Equals(-1)))
			{
				return ErrorStrings[5].ToString();
			}
			if (num4 == -1)
			{
				num4 = ((ISheetData)grid).GetFirstRow();
			}
			if (num6 == -1)
			{
				num6 = ((ISheetData)grid).GetFirstColumn();
			}
			if (num5 == -1)
			{
				num5 = ((ISheetData)grid).GetLastRow();
			}
			if (num7 == -1)
			{
				num7 = ((ISheetData)grid).GetLastColumn();
			}
		}
		bool flag5 = false;
		string empty = string.Empty;
		List<string> list = null;
		Dictionary<string, int> dictionary = null;
		if (flag)
		{
			empty = $"{num4}_{num6}_{num7}_{grid.GetHashCode()}";
			if (!lookupTables.ContainsKey(empty))
			{
				if (flag2)
				{
					LookUps lookUps = new LookUps();
					lookUps.MatchLookUpList = new Dictionary<string, int>();
					lookUps.LinearLookUpList = new List<string>();
					lookupTables.Add(empty, lookUps);
				}
				else
				{
					LookUps lookUps2 = new LookUps();
					lookUps2.LinearLookUpList = new List<string>();
					lookupTables.Add(empty, lookUps2);
				}
				flag5 = true;
			}
			list = lookupTables[empty].LinearLookUpList;
			if (flag2)
			{
				dictionary = lookupTables[empty].MatchLookUpList;
			}
		}
		string empty2 = string.Empty;
		int col = num6;
		string text2 = string.Empty;
		double result2 = 0.0;
		bool flag6 = true;
		bool flag7 = false;
		if (flag && flag2 && dictionary.ContainsKey(valueFromArg))
		{
			col = dictionary[valueFromArg];
			text2 = valueFromArg;
			flag7 = true;
		}
		else
		{
			int num8 = num6;
			while (num8 <= num7)
			{
				if (!flag || num8 - num6 >= list.Count || flag5)
				{
					text2 = GetValueFromParentObject(grid, num4, num8).ToString().ToUpper().Replace("\"", string.Empty);
					if (flag)
					{
						list.Add(text2);
						if (flag2)
						{
							dictionary.Add(text2, num8);
						}
					}
				}
				else
				{
					text2 = list[num8 - num6];
				}
				if (text2 == valueFromArg)
				{
					goto IL_0446;
				}
				if (flag3)
				{
					bool num9;
					if (!flag4)
					{
						num9 = text2.CompareTo(valueFromArg) > 0;
					}
					else
					{
						if (!double.TryParse(text2, NumberStyles.Any, null, out result2))
						{
							goto IL_0464;
						}
						num9 = result2.CompareTo(result) > 0;
					}
					if (num9)
					{
						goto IL_0446;
					}
				}
				goto IL_0464;
				IL_0464:
				if (valueFromArg.Contains("*") || valueFromArg.Contains("?") || valueFromArg.Contains("~"))
				{
					bool flag8 = false;
					if (valueFromArg.Contains("~"))
					{
						flag8 = text2.ToUpper().Equals(valueFromArg.Replace("~", string.Empty).Replace("**", "*"));
					}
					else if (valueFromArg.Contains("*"))
					{
						string text3 = valueFromArg.Replace("*", string.Empty);
						if (valueFromArg.StartsWith("*") && valueFromArg.EndsWith("*"))
						{
							flag8 = text2.ToUpper().Replace(TIC, string.Empty).Contains(text3.ToUpper());
						}
						else if (valueFromArg.StartsWith("*"))
						{
							flag8 = text2.ToUpper().Replace(TIC, string.Empty).EndsWith(text3.ToUpper());
						}
						else if (valueFromArg.EndsWith("*"))
						{
							flag8 = text2.ToUpper().Replace(TIC, string.Empty).StartsWith(text3.ToUpper());
						}
					}
					else if (valueFromArg.Contains("?"))
					{
						flag8 = text2.ToUpper().Length.Equals(valueFromArg.ToUpper().Length);
					}
					if (flag8)
					{
						col = num8;
						flag3 = true;
						flag7 = true;
					}
					if (!flag5)
					{
						break;
					}
					flag6 = false;
				}
				if (flag6)
				{
					col = num8;
				}
				flag3 = (flag5 = true);
				num8++;
				continue;
				IL_0446:
				if (text2 == valueFromArg)
				{
					col = num8;
					flag3 = true;
					flag7 = true;
				}
				if (!flag5)
				{
					break;
				}
				flag6 = false;
				goto IL_0464;
			}
		}
		if (flag3 || text2.Equals(valueFromArg))
		{
			if (!flag7 && !flag4)
			{
				grid = calcData;
				return "#N/A";
			}
			empty2 = GetValueFromParentObject(grid, num + num4 - 1, col).ToString();
			if (string.IsNullOrEmpty(empty2))
			{
				empty2 = "0";
			}
			if (empty2.Length > 0 && empty2[0] == FormulaCharacter)
			{
				empty2 = Parse(empty2);
			}
			result = 0.0;
			if (empty2.Length > 0 && empty2[0] != TIC[0] && !double.TryParse(empty2, NumberStyles.Any, null, out result))
			{
				empty2 = TIC + empty2 + TIC;
			}
		}
		else
		{
			empty2 = "#N/A";
		}
		grid = calcData;
		return empty2;
	}

	internal void SplitRange(string range, ref string rangeValue, ref string logicalValue)
	{
		int num = 0;
		while (num < range.Length)
		{
			range = range.Replace('\u0092'.ToString(), string.Empty);
			while (num != range.Length && (char.IsDigit(range[num]) | (range[num] == ':') | (range[num] == '!') | IsUpper(range[num])))
			{
				rangeValue += range[num++];
			}
			while (num != range.Length && !IsUpper(range[num]) && ((range[num] == '"') | char.IsLetter(range[num]) | char.IsDigit(range[num]) | (range[num] == ',') | (range[num] == '~')))
			{
				logicalValue += range[num++];
			}
		}
	}

	public string ComputeMatch(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		string text;
		string valueFromArg;
		string text2;
		if (IsArrayFormula && array.Length > 3 && array[1].IndexOfAny(logicalOperators) > -1)
		{
			int num = arg.IndexOf(ParseArgumentSeparator);
			int num2 = arg.LastIndexOf(ParseArgumentSeparator);
			text = array[0];
			if (string.IsNullOrEmpty(text))
			{
				return ErrorStrings[1].ToString();
			}
			valueFromArg = GetValueFromArg(array[^1]);
			text2 = arg.Substring(num + 1, num2 - text.Length - 1);
			if (!string.IsNullOrEmpty(valueFromArg))
			{
				switch (valueFromArg)
				{
				case "0":
				case "1":
				case "-1":
					break;
				default:
					goto IL_0113;
				}
			}
			if (text2.IndexOfAny(logicalOperators) > -1)
			{
				arg = text + parseArgumentSeparator + text2.Replace(parseArgumentSeparator, ';') + "," + valueFromArg;
			}
		}
		goto IL_0142;
		IL_0142:
		array = null;
		string[] array2 = SplitArgsPreservingQuotedCommas(arg);
		int length = array2.GetLength(0);
		if ((length != 3 && length != 2) || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text3 = FormulaErrorStringCheck(array2[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		int num3 = 1;
		string logicalValue = string.Empty;
		string rangeValue = string.Empty;
		new List<string>();
		string[] array3 = null;
		string[] array4 = array2[1].Split(';');
		if ((length == 2 || length == 3) && IsArrayFormula && array4[0].IndexOfAny(logicalOperators) > -1)
		{
			array3 = ((array4 != null && array4.Length != 0) ? new string[array4.Length] : null);
			for (int i = 0; i < array4.Length; i++)
			{
				SplitRange(array4[i], ref rangeValue, ref logicalValue);
				if (logicalValue != string.Empty && array3 != null)
				{
					string text4 = GetValueFromArg(array4[i]).Replace(TIC, string.Empty);
					array3[i] = text4;
				}
			}
		}
		string text5 = array2[1].Replace(TIC, string.Empty);
		int num4 = text5.IndexOf(":");
		if (length == 3)
		{
			string text6 = FormulaErrorStringCheck(array2[2], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text6))
			{
				return text6;
			}
			string valueFromArg2 = GetValueFromArg(array2[2]);
			valueFromArg2 = valueFromArg2.Replace(TIC, string.Empty);
			num3 = ((!double.TryParse(valueFromArg2, NumberStyles.Integer, null, out var result)) ? 1 : ((int)result));
			if (valueFromArg2.Contains(TIC) && (valueFromArg2.Contains(TRUEVALUESTR) || valueFromArg2.Contains(FALSEVALUESTR)))
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException("Passed arguments contains invalid argument");
				}
				return ErrorStrings[1].ToString();
			}
			if (valueFromArg2 == FALSEVALUESTR)
			{
				num3 = 0;
			}
			else if (valueFromArg2 == TRUEVALUESTR)
			{
				num3 = 1;
			}
			else if (valueFromArg2.Contains(TIC) && ComputeIsText(valueFromArg2) == TRUEVALUESTR)
			{
				if (rethrowLibraryComputationExceptions)
				{
					throw new ArgumentException("Passed arguments contains invalid argument");
				}
				return ErrorStrings[1].ToString();
			}
		}
		string text7 = GetValueFromArg(array2[0]).Replace(TIC, string.Empty).ToUpper();
		if (text7 != null && !double.TryParse(text7, out var _) && DateTime.TryParse(text7, null, DateTimeStyles.None, out var result3))
		{
			text7 = GetSerialDateTimeFromDate(result3).ToString();
		}
		if (num4 > -1)
		{
			int num5 = RowIndex(text5.Substring(0, num4));
			int num6 = RowIndex(text5.Substring(num4 + 1));
			int num7 = ColIndex(text5.Substring(0, num4));
			int num8 = ColIndex(text5.Substring(num4 + 1));
			if (grid is ISheetData)
			{
				if (!(!num5.Equals(-1) || num6.Equals(-1)).Equals(num5.Equals(-1) || !num6.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				if (num5 == -1)
				{
					num5 = ((ISheetData)grid).GetFirstRow();
				}
				if (num7 == -1)
				{
					num7 = ((ISheetData)grid).GetFirstColumn();
				}
				if (num6 == -1)
				{
					num6 = ((ISheetData)grid).GetLastRow();
				}
				if (num8 == -1)
				{
					num8 = ((ISheetData)grid).GetLastColumn();
				}
			}
		}
		if ((IsArrayFormula && array3 == null) || (array3 != null && array3.Length == 0))
		{
			string empty = string.Empty;
			string text8 = string.Empty;
			text5 = array2[1].Replace('\u0092'.ToString(), string.Empty);
			string[] array5 = text5.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
			if (array5.Length > 1)
			{
				for (int j = 0; j <= array5.Length - 1; j++)
				{
					string[] array6 = null;
					array6 = ((!(text8 == string.Empty)) ? SplitArguments(text8, ';') : array5[j++].Replace(TIC, string.Empty).Split(';'));
					text8 = string.Empty;
					string[] array7 = array5[j++].Replace(TIC, string.Empty).Split(';');
					int num9 = Math.Max(array6.Length, array7.Length);
					int num10 = Math.Min(array6.Length, array7.Length);
					for (int k = 0; k <= num9 - 1; k++)
					{
						empty = ((k >= num10) ? "#N/A" : GetValueFromArg('\u0092' + "n" + array6[k] + "n" + array7[k] + array5[j] + '\u0092'));
						text8 = text8 + empty + ";";
					}
					text8 = text8.Remove(text8.Length - 1);
				}
				array3 = SplitArguments(text8, ';');
			}
			else if (IsRange(StripTics(text5)))
			{
				array3 = GetCellsFromArgs(StripTics(text5));
			}
		}
		else if (IsRange(StripTics(text5)) && (array3 == null || (array3 != null && array3.Length == 0)))
		{
			array3 = GetCellsFromArgs(StripTics(text5));
		}
		if (array3 == null)
		{
			array3 = SplitArguments(text5.Replace(TIC, string.Empty));
		}
		int num11 = 1;
		int num12 = 0;
		string text9 = string.Empty;
		string text10 = string.Empty;
		string[] array8 = array3;
		foreach (string text11 in array8)
		{
			if (IsCellReference(text11.Replace(TIC, string.Empty)))
			{
				matchType = false;
				text10 = GetValueFromArg(text11).Replace(TIC, string.Empty).ToUpper();
				if (text10 != string.Empty)
				{
					matchType = true;
				}
				if (text10 != null && !double.TryParse(text10, out var _) && DateTime.TryParse(text10.Replace(TIC, string.Empty), null, DateTimeStyles.None, out var result5))
				{
					text10 = GetSerialDateTimeFromDate(result5).ToString();
				}
			}
			else
			{
				text10 = text11.Replace(TIC, string.Empty).ToUpper();
			}
			if (text9 != string.Empty)
			{
				if (num3 == 1)
				{
					if (matchCompare(text10, text9) < 0 && text10 == text7)
					{
						num11--;
						break;
					}
				}
				else if (num3 == -1 && matchCompare(text10, text9) > 0)
				{
					num11 = -1;
					break;
				}
			}
			if ((num3 == 0 || num3 == 1) && text10 == text7 && (matchType || (IsArrayFormula && !IsCellReference(text11.Replace(TIC, string.Empty)))))
			{
				break;
			}
			if (num3 == 1 && matchCompare(text7, text10) < 0)
			{
				num11--;
				break;
			}
			if (num3 == -1 && matchCompare(text7, text10) > 0)
			{
				num11--;
				break;
			}
			if (num3 == 1 && text10 == string.Empty)
			{
				num12++;
			}
			else
			{
				num11++;
			}
			if (text9 == string.Empty && text10 != string.Empty)
			{
				num11 += num12;
				num12 = 0;
			}
			text9 = text10;
		}
		if (num3 != 0 && num11 == array3.Length + 1)
		{
			num11 = array3.Length;
		}
		if (num3 == 1 && text10 != string.Empty && num12 > 0)
		{
			num11 += num12;
		}
		if (num3 == 1 && num11 + num12 == array3.Length + 1)
		{
			num11--;
		}
		if (num11 > 0 && num11 <= array3.Length)
		{
			return num11.ToString();
		}
		return "#N/A";
		IL_0113:
		arg = text + parseArgumentSeparator + text2.Replace(parseArgumentSeparator, ';') + valueFromArg.Replace(parseArgumentSeparator, ';');
		goto IL_0142;
	}

	private string GetResultRange(string lookupRange, string resultRange, ref bool isRangeModified)
	{
		string empty = string.Empty;
		int num = lookupRange.IndexOf(":");
		int num2 = RowIndex(lookupRange.Substring(0, num));
		int num3 = RowIndex(lookupRange.Substring(num + 1));
		int num4 = ColIndex(lookupRange.Substring(0, num));
		int num5 = ColIndex(lookupRange.Substring(num + 1));
		int num6 = 0;
		int num7 = 0;
		if (num2 == num3)
		{
			num6 = RowIndex(resultRange);
			num7 = ColIndex(resultRange) + (num5 - num4);
		}
		else
		{
			if (num4 != num5)
			{
				return resultRange;
			}
			num6 = RowIndex(resultRange);
			num7 = ColIndex(resultRange) + (num3 - num2);
		}
		empty = RangeInfo.GetAlphaLabel(num7);
		if (resultRange.IndexOf(':') > -1)
		{
			int length = resultRange.IndexOf(":");
			num6 = RowIndex(resultRange.Substring(0, length));
			empty = resultRange.Substring(0, length) + ":" + empty + num6;
		}
		else
		{
			empty = resultRange + ":" + empty + num6;
		}
		isRangeModified = true;
		return empty;
	}

	internal string CalculateLookupVector(string lookupRange)
	{
		lookupRange = lookupRange.Replace('\u0092'.ToString(), string.Empty);
		string text = string.Empty;
		string text2 = string.Empty;
		string text3 = string.Empty;
		for (int i = 0; i < lookupRange.Length; i++)
		{
			string text4 = string.Empty;
			string text5 = string.Empty;
			_ = string.Empty;
			string[] array = null;
			if (i + 2 < lookupRange.Length && lookupRange[i + 2] == '!')
			{
				while (i != lookupRange.Length && (char.IsDigit(lookupRange[i]) | (lookupRange[i] == ':') | (lookupRange[i] == '!') | (i != 0 && IsUpper(lookupRange[i]) && !char.IsDigit(lookupRange[i - 1])) | (i == 0 && IsUpper(lookupRange[i]))))
				{
					text4 += lookupRange[i++];
				}
				while (i != lookupRange.Length && ((lookupRange[i] == '"') | char.IsDigit(lookupRange[i]) | char.IsLetter(lookupRange[i])) && lookupRange[i].ToString().IndexOfAny(logicalOperators) == -1)
				{
					text5 += lookupRange[i++];
				}
			}
			else
			{
				while (i != lookupRange.Length && (char.IsDigit(lookupRange[i]) | (lookupRange[i] == ':') | (lookupRange[i] == '!') | (i != 0 && IsUpper(lookupRange[i]) && !char.IsDigit(lookupRange[i - 1])) | (i == 0 && IsUpper(lookupRange[i])) | IsUpper(lookupRange[i])))
				{
					text4 += lookupRange[i++];
				}
				while (i != lookupRange.Length && ((lookupRange[i] == '"') | char.IsDigit(lookupRange[i]) | char.IsLetter(lookupRange[i])) && lookupRange[i].ToString().IndexOfAny(logicalOperators) == -1 && !char.IsUpper(lookupRange[i]))
				{
					text5 += lookupRange[i++];
				}
			}
			if (text4 != string.Empty)
			{
				array = GetCellsFromArgs(text4);
			}
			if (text4 == string.Empty && text5 != string.Empty)
			{
				text = text5;
				i--;
				continue;
			}
			if (text4 != string.Empty && text5 != string.Empty && text2 == string.Empty)
			{
				for (int j = 0; j <= array.Length - 1; j++)
				{
					text2 = text2 + GetValueFromArg('\u0092' + array[j] + text5 + '\u0092') + ";";
				}
				i--;
			}
			else if (text4 != string.Empty && text5 != string.Empty && text2 != string.Empty && lookupRange[i].ToString().IndexOfAny(logicalOperators) > -1)
			{
				for (int k = 0; k <= array.Length - 1; k++)
				{
					text3 = text3 + GetValueFromArg('\u0092' + array[k] + text5 + '\u0092') + ";";
				}
				text3 = text3.Remove(text3.Length - 1);
				if (text2 != string.Empty && text3 != string.Empty && lookupRange[i].ToString().IndexOfAny(logicalOperators) > -1)
				{
					int num = 0;
					text5 = lookupRange[i].ToString();
					string[] array2 = text2.Replace(TIC, string.Empty).Split(';');
					string[] array3 = text3.Split(';');
					if (array2.Length == array3.Length)
					{
						text2 = string.Empty;
						text3 = string.Empty;
						for (num = 0; num <= array2.Length - 1; num++)
						{
							if (num + 1 <= array2.Length)
							{
								text2 = text2 + GetValueFromArg('\u0092' + GetValueFromArg(array2[num]) + array3[num] + text5 + '\u0092') + ";";
							}
						}
					}
				}
			}
			else if (text4 == string.Empty && text5 == string.Empty && text2 != string.Empty && text3 == string.Empty && lookupRange[i].ToString().IndexOfAny(logicalOperators) > -1)
			{
				string[] array4 = text2.Replace(TIC, string.Empty).Split(';');
				for (int l = 0; l <= array4.Length - 1; l++)
				{
					text3 = text3 + GetValueFromArg('\u0092' + text + "n" + array4[l] + lookupRange[i] + '\u0092') + ";";
				}
			}
			if (text3 != string.Empty)
			{
				text3 = text3.Remove(text3.Length - 1);
			}
			else
			{
				text2 = text2.Remove(text2.Length - 1);
			}
		}
		return text3;
	}

	public string ComputeLookUp(string range)
	{
		bool isRangeModified = false;
		string empty = string.Empty;
		bool num = IsLookupCachingEnabled();
		IsOptimizedMatchesEnabled();
		if (num && lookupTables == null)
		{
			lookupTables = new Dictionary<string, LookUps>();
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		int index = 0;
		text = text.Replace(TIC, string.Empty).ToUpper();
		string empty2 = string.Empty;
		if (array[1].IndexOfAny(tokens) > -1 && array[1].Contains(":"))
		{
			empty2 = array[1];
		}
		else
		{
			array[1] = array[1].Replace(TIC, string.Empty);
			if (array.Length == 3)
			{
				array[2] = StripTics0(array[2]);
			}
			empty2 = array[1].Replace("\"", string.Empty);
		}
		if (empty2.IndexOfAny(tokens) > -1 && empty2.Contains(":"))
		{
			empty2 = CalculateLookupVector(empty2);
		}
		GetValueFromArg(array[0]);
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		if (array.Length == 2)
		{
			string text2 = array[1];
			SplitArgsPreservingQuotedCommas(array[1]);
			if (array[1].Contains(";"))
			{
				string[] array2 = SplitArguments(array[1], ';');
				if (array2.Length == 1)
				{
					string[] array3 = SplitArgsPreservingQuotedCommas(array2[0].ToUpper());
					foreach (string arg in array3)
					{
						list.Add(GetValueFromArg(arg).ToUpper());
						list2.Add(GetValueFromArg(arg).ToUpper());
					}
				}
				else if (array2.Length == 2)
				{
					string[] array4 = SplitArgsPreservingQuotedCommas(array2[0].ToUpper());
					string[] array5 = SplitArgsPreservingQuotedCommas(array2[1].ToUpper());
					string[] array3 = array4;
					foreach (string arg2 in array3)
					{
						list.Add(GetValueFromArg(arg2).ToUpper());
					}
					array3 = array5;
					foreach (string arg3 in array3)
					{
						list2.Add(GetValueFromArg(arg3).ToUpper());
					}
				}
				else
				{
					for (int j = 0; j < array2.Length; j++)
					{
						string[] array6 = SplitArgsPreservingQuotedCommas(array2[j].ToUpper());
						list.Add(GetValueFromArg(array6[0]).ToUpper());
						list2.Add(GetValueFromArg(array6[1]).ToUpper());
					}
				}
				text2.IndexOf(ParseArgumentSeparator);
			}
			else if (array[1].IndexOf(':') > -1)
			{
				string[] array3 = GetCellsFromArgs(array[1]);
				foreach (string arg4 in array3)
				{
					list.Add(GetValueFromArg(arg4).ToUpper());
					list2.Add(GetValueFromArg(arg4).ToUpper());
				}
			}
			else
			{
				string[] array3 = SplitArgsPreservingQuotedCommas(array[1].ToUpper());
				foreach (string arg5 in array3)
				{
					list.Add(GetValueFromArg(arg5).ToUpper());
					list2.Add(GetValueFromArg(arg5).ToUpper());
				}
			}
		}
		else if (array.Length == 3)
		{
			if (empty2.IndexOf(':') > -1)
			{
				int num2 = empty2.IndexOf(':');
				int num3 = ColIndex(empty2.Substring(0, num2));
				int num4 = ColIndex(empty2.Substring(num2 + 1, empty2.Length - num2 - 1));
				index = ((num4 > num3) ? (num4 - num3 + 1) : (num3 - num4 + 1));
				string[] array3 = GetCellsFromArgs(empty2);
				foreach (string arg6 in array3)
				{
					try
					{
						list.Add(GetValueFromArg(arg6));
					}
					catch
					{
						ExceptionThrown = true;
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(ErrorStrings[0].ToString());
						}
						return ErrorStrings[0].ToString();
					}
				}
			}
			else
			{
				string[] array7 = null;
				array7 = ((!empty2.Contains(";")) ? SplitArgsPreservingQuotedCommas(array[1]) : SplitArguments(empty2, ';'));
				string[] array3 = array7;
				foreach (string arg7 in array3)
				{
					try
					{
						list.Add(GetValueFromArg(arg7));
					}
					catch
					{
						ExceptionThrown = true;
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(ErrorStrings[0].ToString());
						}
						return ErrorStrings[0].ToString();
					}
				}
			}
		}
		string text3 = string.Empty;
		if (array.Length == 3)
		{
			text3 = array[2];
		}
		if ((empty2.IndexOf(':') > -1 && text3.IndexOf(':') == -1) || (text3.IndexOfAny(tokens) == -1 && IsRange(array[1]) && GetCellsFromArgs(array[1]).Length > GetCellsFromArgs(array[2]).Length))
		{
			text3 = GetResultRange(empty2, text3, ref isRangeModified);
		}
		else
		{
			isRangeModified = true;
		}
		if (!text3.StartsWith(TIC) && !text3.EndsWith(TIC) && text3.Contains(":") && text3.IndexOfAny(tokens) > -1)
		{
			string text4 = string.Empty;
			text3 = text3.Replace('\u0092'.ToString(), string.Empty);
			for (int k = 0; k <= text3.Length; k++)
			{
				string text5 = string.Empty;
				string text6 = string.Empty;
				if (k > 0)
				{
					k--;
				}
				if (text3[k].ToString().Contains("!"))
				{
					while (k != text3.Length && !char.IsLetter(text3[k]))
					{
						text6 += text3[k++];
					}
				}
				while (k != text3.Length && text3[k] != '!' && (!char.IsNumber(text3[k]) || !char.IsLetter(text3[k + 1])))
				{
					text5 += text3[k++];
				}
				if (k != text3.Length && char.IsNumber(text3[k]))
				{
					text5 += text3[k++];
				}
				text4 = ((text5.IndexOf(':') <= -1 || text5.StartsWith('!'.ToString())) ? ComputedValue(text4 + text5) : (text4 + "n" + GetResultVectorValue(text6 + text5, text, ref isRangeModified, index, array, list)));
				if (k != text3.Length && char.IsNumber(text3[k - 1]) && text3[k].ToString().IndexOfAny(tokens) > -1)
				{
					text4 = ComputedValue(text4 + text3[k++]);
				}
			}
			return text4;
		}
		if (array.Length == 2)
		{
			int num5 = array[1].IndexOf(':');
			int num6 = ColIndex(array[1].Substring(0, num5));
			int num7 = RowIndex(array[1].Substring(0, num5));
			int num8 = ColIndex(array[1].Substring(num5 + 1, array[1].Length - num5 - 1));
			index = ((num8 > num6) ? (num8 - num6 + 1) : (num6 - num8 + 1));
			int num9 = RowIndex(array[1].Substring(num5 + 1));
			text3 = ((num8 <= num6 || num9 <= num7 || !list.Contains(text)) ? array[1] : (RangeInfo.GetAlphaLabel(num8) + num7 + ":" + array[1].Substring(num5 + 1, array[1].Length - num5 - 1)));
		}
		return GetResultVectorValue(text3, text, ref isRangeModified, index, array, list);
	}

	private string GetResultVectorValue(string resultVal, string lookUp, ref bool isRangeModified, int index, string[] s, List<string> cellValue)
	{
		List<string> list = new List<string>();
		string empty = string.Empty;
		if (resultVal.IndexOf(':') > -1)
		{
			string[] cellsFromArgs = GetCellsFromArgs(resultVal);
			foreach (string arg in cellsFromArgs)
			{
				try
				{
					list.Add(GetValueFromArg(arg));
				}
				catch
				{
					ExceptionThrown = true;
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[0].ToString());
					}
					return ErrorStrings[0].ToString();
				}
			}
		}
		else
		{
			string[] cellsFromArgs = SplitArgsPreservingQuotedCommas(resultVal);
			foreach (string arg2 in cellsFromArgs)
			{
				try
				{
					list.Add(GetValueFromArg(arg2));
				}
				catch
				{
					ExceptionThrown = true;
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[0].ToString());
					}
					return ErrorStrings[0].ToString();
				}
			}
		}
		if (!cellValue.Contains(lookUp) && !list.Contains(lookUp))
		{
			string text = cellValue[0];
			int num = 0;
			if (!isRangeModified)
			{
				for (int j = 0; j < cellValue.Count; j++)
				{
					double result = 0.0;
					double result2 = 0.0;
					if (double.TryParse(lookUp, out result))
					{
						if (double.TryParse(cellValue[j], out result2) && result >= result2)
						{
							text = cellValue[j];
							num++;
						}
					}
					else if ((cellValue[j].CompareTo(text) == 1 && lookUp.CompareTo(cellValue[j]) == 1 && text.CompareTo(lookUp) == 1) || lookUp.CompareTo(cellValue[j]) == 1)
					{
						if ((cellValue[j].CompareTo(text) == 1 && lookUp.CompareTo(cellValue[j]) == 1 && text.CompareTo(lookUp) == 1) || lookUp.CompareTo(cellValue[j]) == 1)
						{
							text = cellValue[j];
							num++;
						}
					}
					else if (num != 0)
					{
						break;
					}
				}
			}
			else
			{
				for (int k = 0; k < list.Count; k++)
				{
					double result3 = 0.0;
					double result4 = 0.0;
					if (double.TryParse(lookUp, out result3))
					{
						if (double.TryParse(list[k], out result4) && result3 >= result4)
						{
							text = list[k];
							num++;
						}
					}
					else if (num != 0)
					{
						break;
					}
				}
			}
			if (num == 0)
			{
				return ErrorStrings[0].ToString();
			}
			return text;
		}
		int num2 = 0;
		int num3 = 0;
		if ((s.Length == 3 && s[2].IndexOf(':') > -1) || (s.Length == 2 && cellValue.Count > list.Count && cellValue.Contains(lookUp)))
		{
			if (!isRangeModified)
			{
				for (int l = 0; l < cellValue.Count; l++)
				{
					if (cellValue[l] == lookUp)
					{
						num3 = cellValue.IndexOf(lookUp);
						break;
					}
				}
			}
			else
			{
				for (int m = 0; m < list.Count; m++)
				{
					if (list[m] == lookUp)
					{
						num3 = list.IndexOf(lookUp);
						break;
					}
				}
			}
			empty = (isRangeModified ? list[num3] : list[num3 / index]);
		}
		else
		{
			for (int n = 0; n < cellValue.Count; n++)
			{
				if (cellValue[n] == lookUp)
				{
					index = cellValue.IndexOf(lookUp);
					num2++;
				}
				else if (num2 != 0)
				{
					break;
				}
			}
			empty = list[index + num2 - 1];
		}
		isRangeModified = false;
		return empty;
	}

	private bool FindExactMatch(string arg, string lookUp)
	{
		if (IsRange(arg))
		{
			string[] cellsFromArgs = GetCellsFromArgs(arg);
			foreach (string arg2 in cellsFromArgs)
			{
				if (GetValueFromArg(arg2).ToUpper() == lookUp)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string ComputeVLookUp(string range)
	{
		bool flag = IsVLookupCachingEnabled();
		bool flag2 = IsOptimizedMatchesEnabled();
		if (flag && lookupTables == null)
		{
			lookupTables = new Dictionary<string, LookUps>();
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string valueFromArg = GetValueFromArg(array[0]);
		double result = 0.0;
		bool flag3 = double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		valueFromArg = (flag3 ? valueFromArg : valueFromArg.Replace(TIC, string.Empty).ToUpper());
		if (valueFromArg != null && !double.TryParse(valueFromArg.Replace(TIC, string.Empty), out var _) && DateTime.TryParse(valueFromArg, null, DateTimeStyles.None, out var result3))
		{
			valueFromArg = GetSerialDateTimeFromDate(result3).ToString();
		}
		string text = array[1].Replace("\"", string.Empty);
		if (text == "#REF!")
		{
			return text;
		}
		string text2 = GetValueFromArg(array[2]).Replace("\"", string.Empty);
		double result4 = 0.0;
		if (ComputeIsLogical(text2).Equals(TRUEVALUESTR))
		{
			result4 = double.Parse(ComputeN(text2));
		}
		else if (!double.TryParse(text2, NumberStyles.Any, null, out result4) || text2 == "NaN")
		{
			return "#N/A";
		}
		if (result4 < 1.0)
		{
			return ErrorStrings[1].ToString();
		}
		int num = (int)result4;
		bool flag4 = true;
		bool flag5 = true;
		bool flag6 = false;
		if (array.GetLength(0) == 4)
		{
			flag4 = (flag5 = GetValueFromArg(array[3]) == TRUEVALUESTR || GetValueFromArg(array[3].Replace(TIC, string.Empty)) == "1");
		}
		else
		{
			flag6 = FindExactMatch(array[1], valueFromArg);
		}
		bool flag7 = double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result4);
		int num2 = text.IndexOf(":");
		if (num2 == -1)
		{
			text = text + ":" + text;
			num2 = text.IndexOf(":");
		}
		int num3 = text.Substring(0, num2).LastIndexOf('!');
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		ICalcData calcData = null;
		if (num3 > -1 && sheetFamilyItem.TokenToParentObject != null)
		{
			calcData = sheetFamilyItem.TokenToParentObject[text.Substring(0, num3 + 1)] as ICalcData;
		}
		int num4 = RowIndex(text.Substring(0, num2));
		int num5 = RowIndex(text.Substring(num2 + 1));
		int num6 = ColIndex(text.Substring(0, num2));
		int num7 = ColIndex(text.Substring(num2 + 1));
		if (grid is ISheetData || calcData is ISheetData)
		{
			if (!(!num4.Equals(-1) || num5.Equals(-1)).Equals(num4.Equals(-1) || !num5.Equals(-1)))
			{
				return ErrorStrings[5].ToString();
			}
			if (num4 == -1)
			{
				num4 = ((calcData == null) ? ((ISheetData)grid).GetFirstRow() : ((ISheetData)calcData).GetFirstRow());
			}
			if (num6 == -1)
			{
				num6 = ((calcData == null) ? ((ISheetData)grid).GetFirstColumn() : ((ISheetData)calcData).GetFirstColumn());
			}
			if (num5 == -1)
			{
				num5 = ((calcData == null) ? ((ISheetData)grid).GetLastRow() : ((ISheetData)calcData).GetLastRow());
			}
			if (num7 == -1)
			{
				if (calcData != null)
				{
					num7 = ((ISheetData)calcData).GetLastColumn();
				}
				else
				{
					num7 = ((ISheetData)grid).GetLastColumn();
				}
			}
		}
		bool flag8 = true;
		string empty = string.Empty;
		List<string> list = null;
		Dictionary<string, int> dictionary = null;
		if (flag)
		{
			empty = $"{num6}_{num4}_{num5}_{grid.GetHashCode()}";
			if (calcData != null)
			{
				empty = $"{num6}_{num4}_{num5}_{calcData.GetHashCode()}";
			}
			if (!lookupTables.ContainsKey(empty))
			{
				if (flag2)
				{
					LookUps lookUps = new LookUps();
					lookUps.LinearLookUpList = new List<string>();
					lookUps.MatchLookUpList = new Dictionary<string, int>();
					lookupTables.Add(empty, lookUps);
				}
				else
				{
					LookUps lookUps2 = new LookUps();
					lookUps2.LinearLookUpList = new List<string>();
					lookupTables.Add(empty, lookUps2);
				}
				flag8 = true;
			}
			list = lookupTables[empty].LinearLookUpList;
			if (flag2)
			{
				dictionary = lookupTables[empty].MatchLookUpList;
			}
		}
		string empty2 = string.Empty;
		int row = num4;
		int num8 = 0;
		string text3 = string.Empty;
		double result5 = 0.0;
		bool flag9 = true;
		List<string> list2 = new List<string>();
		if (flag && flag2 && dictionary.Count > 0)
		{
			if (dictionary.ContainsKey(valueFromArg))
			{
				row = dictionary[valueFromArg];
				text3 = valueFromArg;
				flag6 = true;
			}
		}
		else
		{
			for (int i = num4; i <= num5; i++)
			{
				if (flag && flag2)
				{
					text3 = ((calcData == null) ? GetValueFromParentObject(grid, i, num6).ToUpper().Replace("\"", string.Empty) : GetValueFromParentObject(calcData, i, num6).ToUpper().Replace("\"", string.Empty));
					if (!list.Contains(text3))
					{
						list.Add(text3);
					}
					if (flag2 && !dictionary.ContainsKey(text3))
					{
						dictionary.Add(text3, i);
					}
					if (i == num5 && dictionary.ContainsKey(valueFromArg))
					{
						goto IL_062b;
					}
					if (flag4)
					{
						bool num9;
						if (!flag7)
						{
							num9 = text3.CompareTo(valueFromArg) > 0;
						}
						else
						{
							if (!double.TryParse(text3, NumberStyles.Any, null, out result5))
							{
								goto IL_064a;
							}
							num9 = result5.CompareTo(result4) > 0;
						}
						if (num9)
						{
							goto IL_062b;
						}
					}
					goto IL_064a;
				}
				if (!flag || i - num4 >= list.Count || flag8)
				{
					text3 = ((calcData == null) ? GetValueFromParentObject(grid, i, num6).ToString().ToUpper() : GetValueFromParentObject(calcData, i, num6).ToString().ToUpper());
					text3 = (flag3 ? text3 : text3.Replace("\"", string.Empty));
					if (text3 != null && !double.TryParse(text3.Replace(TIC, string.Empty), out var _) && DateTime.TryParse(text3, null, DateTimeStyles.None, out var result7))
					{
						text3 = GetSerialDateTimeFromDate(result7).ToString();
					}
					if (!list2.Contains(text3))
					{
						list2.Add(text3);
					}
					if (flag)
					{
						if (!list.Contains(text3))
						{
							list.Add(text3);
						}
						if (flag2 && !dictionary.ContainsKey(text3))
						{
							dictionary.Add(text3, i);
						}
					}
				}
				else
				{
					text3 = list[i - num4];
				}
				if (text3.Replace(TIC, string.Empty).Equals(valueFromArg))
				{
					goto IL_07c2;
				}
				if (flag4)
				{
					bool num10;
					if (!flag7)
					{
						num10 = text3.CompareTo(valueFromArg) > 0;
					}
					else
					{
						if (!double.TryParse(text3, NumberStyles.Any, null, out result5))
						{
							goto IL_0830;
						}
						num10 = result5.CompareTo(result4) > 0;
					}
					if (num10)
					{
						goto IL_07c2;
					}
				}
				goto IL_0830;
				IL_0830:
				if (!flag6 && flag4 && valueFromArg.ToUpper().StartsWith(text3.ToUpper()) && text3 != string.Empty)
				{
					row = i;
					flag4 = true;
					flag6 = true;
					if (!flag8)
					{
						break;
					}
					flag9 = false;
				}
				if (valueFromArg.Contains("*") || valueFromArg.Contains("?") || valueFromArg.Contains("~"))
				{
					bool flag10 = false;
					if (valueFromArg.Contains("~"))
					{
						flag10 = text3.ToUpper().Equals(valueFromArg.Replace("~", string.Empty).Replace("**", "*"));
					}
					else if (valueFromArg.Contains("*"))
					{
						string text4 = valueFromArg.Replace("*", string.Empty);
						flag10 = ((valueFromArg.StartsWith("*") && valueFromArg.EndsWith("*")) ? text3.ToUpper().Replace(TIC, string.Empty).Contains(text4.ToUpper()) : (valueFromArg.StartsWith("*") ? text3.ToUpper().Replace(TIC, string.Empty).EndsWith(text4.ToUpper()) : ((!valueFromArg.EndsWith("*")) ? text3.ToUpper().Replace(TIC, string.Empty).Equals(text4.ToUpper()) : text3.ToUpper().Replace(TIC, string.Empty).StartsWith(text4.ToUpper()))));
					}
					else if (valueFromArg.Contains("?"))
					{
						flag10 = text3.ToUpper().Length.Equals(valueFromArg.ToUpper().Length);
					}
					if (flag10)
					{
						row = i;
						flag4 = true;
						flag6 = true;
						num8++;
					}
					if (!flag8)
					{
						break;
					}
					flag9 = false;
				}
				if (flag9)
				{
					row = i;
				}
				flag8 = num8 == 0;
				flag4 = true;
				continue;
				IL_07c2:
				if (text3.ToUpper().Replace(TIC, string.Empty).Equals(valueFromArg))
				{
					if (valueFromArg == string.Empty && !matchType)
					{
						continue;
					}
					row = i;
					flag4 = true;
					flag6 = true;
					num8++;
					if (array.GetLength(0) == 4 && array[3] == FALSEVALUESTR)
					{
						break;
					}
				}
				if (!flag8)
				{
					break;
				}
				flag9 = false;
				goto IL_0830;
				IL_064a:
				if (flag9 && !dictionary.ContainsKey(valueFromArg))
				{
					row = i;
				}
				continue;
				IL_062b:
				if (dictionary.ContainsKey(valueFromArg))
				{
					row = dictionary[valueFromArg];
					text3 = valueFromArg;
					flag6 = true;
				}
				else
				{
					flag9 = false;
				}
				goto IL_064a;
			}
		}
		if (flag4 || text3.Equals(valueFromArg))
		{
			if (list != null && list.Count > 0)
			{
				if (!flag)
				{
					list.Sort();
				}
				list[0] = ((list[0] == string.Empty) ? "0" : list[0]);
			}
			if (list2 != null && list2.Count > 0 && valueFromArg != string.Empty)
			{
				if (!flag)
				{
					list2.Sort();
				}
				list2[0] = ((list2[0] == string.Empty) ? "0" : list2[0]);
			}
			if ((!flag6 && (!flag7 || (flag7 && list2 != null && list2.Count > 0 && double.Parse(list2[0].ToString()) > double.Parse(valueFromArg)))) || (!flag6 && flag && flag7 && list != null && double.Parse(list[0]) > double.Parse(valueFromArg)) || (!flag5 && !flag6))
			{
				return "#N/A";
			}
			empty2 = ((calcData == null) ? GetValueFromParentObject(grid, row, num + num6 - 1).ToString() : GetValueFromParentObject(calcData, row, num + num6 - 1).ToString());
			if (string.IsNullOrEmpty(empty2) && !GetValueFromParentObject(grid, row, num + num6 - 1, calculateFormula: false).ToUpper().StartsWith("=IF") && !vlookupInsideIFFormula)
			{
				empty2 = "0";
			}
			if (empty2.Length > 0 && empty2[0] == FormulaCharacter)
			{
				empty2 = ParseFormula(empty2);
			}
			result4 = 0.0;
			if (empty2.Length > 0 && empty2[0] != TIC[0] && !double.TryParse(empty2, NumberStyles.Any, null, out result4))
			{
				empty2 = TIC + empty2 + TIC;
			}
		}
		else
		{
			empty2 = "#N/A";
		}
		return empty2;
	}

	public string ComputeLeft(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		double result = 0.0;
		bool flag = double.TryParse(arg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		bool flag2 = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		string text2 = ((length == 2) ? GetValueFromArg(array[1].Replace(TIC, string.Empty)) : "1");
		text2 = ((length == 2 && string.IsNullOrEmpty(text2)) ? "0" : text2);
		text2 = (bool.TryParse(text2, out var result2) ? Convert.ToInt16(result2).ToString() : text2);
		if (double.TryParse(text2, out var result3) && result3 < 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		text2 = ComputedValue(text2);
		if (int.Parse(text2) == 0)
		{
			arg = string.Empty;
		}
		else
		{
			int num = int.Parse(text2) + (flag2 ? 1 : 0);
			arg = arg[..((arg.Length >= num) ? num : arg.Length)];
			if (flag2 && !arg.EndsWith(TIC))
			{
				arg += TIC;
			}
		}
		if (UseNoAmpersandQuotes && arg.Length > 1 && arg[0] == TIC[0] && arg[arg.Length - 1] == TIC[0] && !arg.Contains(TIC + TIC))
		{
			arg = arg.Substring(1, arg.Length - 2);
		}
		if (arg.Contains(TIC + TIC))
		{
			arg = arg.Replace(TIC + TIC, TIC);
		}
		if (flag)
		{
			arg = TIC + arg.Replace(TIC, string.Empty) + TIC;
		}
		return arg;
	}

	public string ComputeLen(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 1 && !IsArrayFormula)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0];
		string text2 = "";
		double num = 0.0;
		string text3 = "";
		if (IsArrayFormula)
		{
			string text4 = ArrayParser.ComputeInteriorFunction(range, "LEN", computeFunctionLevel);
			if (text4 != string.Empty)
			{
				return text4;
			}
			if (text.IndexOf(':') > -1)
			{
				text = GetCellsFromArgs(text)[0];
			}
		}
		if (text.IndexOf(':') > -1 && text.IndexOf(':') > 2)
		{
			string[] cellsFromArgs = GetCellsFromArgs(text);
			foreach (string arg in cellsFromArgs)
			{
				try
				{
					text2 = GetValueFromArg(arg).Replace(TIC, string.Empty);
				}
				catch (Exception ex)
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return ex.Message;
				}
				bool flag = text2.StartsWith(TIC) && text2.EndsWith(TIC);
				text3 = text3 + (flag ? (text2.Length - 2) : text2.Length) + ";";
			}
			return TIC + text3.Substring(0, text3.Length - 1) + TIC;
		}
		if (text.StartsWith(TIC) && text.EndsWith(TIC) && text.IndexOf(";") > -1)
		{
			string[] cellsFromArgs = text.Replace(TIC, string.Empty).Split(';');
			foreach (string text5 in cellsFromArgs)
			{
				bool flag2 = text5.StartsWith(TIC) && text5.EndsWith(TIC);
				text3 = text3 + (flag2 ? (text5.Length - 2) : text5.Length) + ";";
			}
			return TIC + text3.Substring(0, text3.Length - 1) + TIC;
		}
		text = GetValueFromArg(text);
		return ((double)((text.StartsWith(TIC) && text.EndsWith(TIC)) ? (text.Length - 2) : text.Length)).ToString();
	}

	public string ComputeMid(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		if (ErrorStrings.Contains(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return arg;
		}
		double result = 0.0;
		bool flag = double.TryParse(arg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		bool flag2 = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		int num = int.Parse(GetValueFromArg(array[2]));
		if (array[1].IndexOf("#VALUE!") > -1)
		{
			return "#VALUE!";
		}
		string valueFromArg = GetValueFromArg(array[1]);
		int num2 = int.Parse(valueFromArg) + ((!flag2) ? (-1) : 0);
		if (int.Parse(valueFromArg) < 1 || (double)num < 0.0)
		{
			return "#VALUE!";
		}
		if (num2 > arg.Length)
		{
			return "";
		}
		arg = ((num2 + num <= arg.Length) ? arg.Substring(num2, num) : arg.Substring(num2));
		if (flag2 && !arg.StartsWith(TIC))
		{
			arg = TIC + arg;
		}
		if (flag2 && !arg.EndsWith(TIC))
		{
			arg += TIC;
		}
		if (flag2 && arg == TIC)
		{
			arg += TIC;
		}
		if (flag)
		{
			arg = TIC + arg.Replace(TIC, string.Empty) + TIC;
		}
		return arg;
	}

	public string ComputeRight(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		double result = 0.0;
		bool flag = double.TryParse(arg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		bool flag2 = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		string text2 = ((length == 2) ? GetValueFromArg(array[1].Replace(TIC, string.Empty)) : "1");
		text2 = ((length == 2 && string.IsNullOrEmpty(text2)) ? "0" : text2);
		text2 = (bool.TryParse(text2, out var result2) ? Convert.ToInt16(result2).ToString() : text2);
		if (double.TryParse(text2, out var result3) && result3 < 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		text2 = ComputedValue(text2);
		if (int.Parse(text2) == 0)
		{
			arg = string.Empty;
		}
		else
		{
			int num = int.Parse(text2) + (flag2 ? 1 : 0);
			int startIndex = ((arg.Length >= num) ? (arg.Length - num) : 0);
			arg = arg.Substring(startIndex);
			if (flag2 && !arg.StartsWith(TIC))
			{
				arg = TIC + arg;
			}
		}
		if (UseNoAmpersandQuotes && arg.Length > 1 && arg[0] == TIC[0] && arg[arg.Length - 1] == TIC[0] && !arg.Contains(TIC + TIC))
		{
			arg = arg.Substring(1, arg.Length - 2);
		}
		if (flag)
		{
			arg = TIC + arg.Replace(TIC, string.Empty) + TIC;
		}
		return arg;
	}

	public bool IsSeparatorInTIC(string s)
	{
		int i = s.IndexOf(TIC) + 1;
		bool flag = true;
		for (; i > 0 && i < s.Length; i++)
		{
			if (s[i] == ParseArgumentSeparator && flag)
			{
				return true;
			}
			if (s[i] == TIC[0])
			{
				flag = !flag;
			}
		}
		return false;
	}

	public string[] GetStringArray(string s)
	{
		List<string> list = new List<string>();
		int num = 0;
		bool flag = false;
		for (int i = 0; i < s.Length; i++)
		{
			char c = s[i];
			if (c == TIC[0])
			{
				flag = !flag;
			}
			else if (!flag && c == ParseArgumentSeparator)
			{
				list.Add(s.Substring(num, i - num));
				num = i + 1;
			}
		}
		list.Add(s.Substring(num));
		string[] array = new string[list.Count];
		list.CopyTo(array);
		return array;
	}

	public string ComputeConcatenate(string range)
	{
		string empty = string.Empty;
		StringBuilder stringBuilder = new StringBuilder(TIC);
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = (IsSeparatorInTIC(range) ? GetStringArray(range) : SplitArgsPreservingQuotedCommas(range));
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			string text2 = text;
			string valueFromArg = GetValueFromArg(text);
			bool.TryParse(valueFromArg, out var _);
			if (ErrorStrings.Contains(valueFromArg))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return valueFromArg;
			}
			if (text.Contains(":") && IsCellReference(text))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
			if (text == string.Empty || text[0] != TIC[0])
			{
				text2 = GetValueFromArg(text);
			}
			if (stringBuilder.Length > 1 && stringBuilder[stringBuilder.Length - 1] == TIC[0])
			{
				stringBuilder.Length--;
			}
			if (text2.Length > 0 && text2[0] == TIC[0])
			{
				stringBuilder.Append(text2.Substring(1));
			}
			else
			{
				stringBuilder.Append(text2);
			}
		}
		if (stringBuilder[stringBuilder.Length - 1] != TIC[0])
		{
			stringBuilder.Append(TIC);
		}
		empty = stringBuilder.ToString();
		if (empty.IndexOf("#N/A") > -1)
		{
			empty = "#N/A";
		}
		if (excelLikeComputations)
		{
			return empty.Substring(empty.IndexOf(TIC) + 1, empty.LastIndexOf(TIC) - 1);
		}
		return empty;
	}

	public string ComputeIndirect(string args)
	{
		bool flag = false;
		if (args[args.Length - 1] == '\u0092')
		{
			args = GetValueFromArg(args);
			flag = true;
		}
		if (ErrorStrings.Contains(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				libraryComputationException = new Exception(FormulaErrorStrings[bad_formula]);
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return args;
		}
		string scopedRange = string.Empty;
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.Length == 0 || array.Length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (array[0].ToString().IndexOfAny(tokens) > -1 && !IsCellReference(array[0].Replace(TIC, string.Empty).ToUpper()))
		{
			if (args[0].ToString().StartsWith('\u0092'.ToString()))
			{
				flag = true;
			}
			array[0] = ComputedValue(array[0].ToString());
		}
		array[0] = array[0].ToUpper();
		PutTokensForSheets(ref array[0]);
		if ((IsCellReference(array[0].Replace(TIC, string.Empty)) && array[0].Replace(TIC, string.Empty).StartsWith('!'.ToString())) || TryGetNamedRange(array[0].ToUpper().Replace(TIC, string.Empty), out scopedRange))
		{
			array[0] = array[0].Replace(TIC, string.Empty);
		}
		string text = SheetToken(array[0].Replace(TIC, string.Empty));
		if (!string.IsNullOrEmpty(text))
		{
			array[0] = array[0].Replace(text, string.Empty);
		}
		if (array.Length == 2 && array[1] == FALSEVALUESTR)
		{
			bool flag2 = array[0].StartsWith(TIC) && array[0].EndsWith(TIC);
			string[] array2 = array[0].ToUpper().Replace(TIC, string.Empty).Split(new char[1] { ':' }, StringSplitOptions.RemoveEmptyEntries);
			string[] array3 = array2[0].Split(new char[2] { 'R', 'C' }, StringSplitOptions.RemoveEmptyEntries);
			if (array2.Length > 2)
			{
				return ErrorStrings[2].ToString();
			}
			array[0] = RangeInfo.GetAlphaLabel(Convert.ToInt32(array3[1])) + array3[0];
			if (array2.Length == 2)
			{
				string text2 = SheetToken(array2[1]);
				if (!string.IsNullOrEmpty(text2))
				{
					array2[1] = array2[1].Replace(text2, string.Empty);
				}
				array3 = array2[1].Split(new char[2] { 'R', 'C' }, StringSplitOptions.RemoveEmptyEntries);
				ref string reference = ref array[0];
				reference = reference + ":" + RangeInfo.GetAlphaLabel(Convert.ToInt32(array3[1])) + array3[0];
			}
			if (flag2)
			{
				array[0] = TIC + array[0] + TIC;
			}
		}
		string empty = string.Empty;
		if (array[0].StartsWith(TIC))
		{
			empty = text + array[0].Replace(TIC, string.Empty);
		}
		else if (IsCellReference(array[0]))
		{
			empty = ((!TryGetNamedRange(array[0].ToUpper(), out scopedRange)) ? GetValueFromArg(text + array[0]) : array[0]);
			if (string.IsNullOrEmpty(empty))
			{
				empty = "0";
			}
			if (computedValueLevel > 1 && !TryGetNamedRange(empty.ToUpper(), out scopedRange) && array[0].Contains(":"))
			{
				isInteriorFunction = true;
				return text + array[0].Replace("$", string.Empty);
			}
			if (!TryGetNamedRange(empty.ToUpper(), out scopedRange))
			{
				if (IsCellReference(empty))
				{
					return GetValueFromArg(empty);
				}
				if (flag)
				{
					return empty;
				}
				return ErrorStrings[2].ToString();
			}
			empty = Convert.ToString(scopedRange);
			empty = empty.ToUpper();
			empty = empty.Replace("$", "");
			PutTokensForSheets(ref empty);
			if (!empty.StartsWith('!'.ToString()))
			{
				empty = text + empty;
			}
		}
		else
		{
			empty = array[0];
		}
		if (!IsCellReference(empty.Replace("$", "")))
		{
			if (!TryGetNamedRange(empty.ToUpper(), out scopedRange))
			{
				return ErrorStrings[2].ToString();
			}
			empty = Convert.ToString(scopedRange);
			PutTokensForSheets(ref empty);
			if (!empty.StartsWith('!'.ToString()))
			{
				empty = text + empty;
			}
		}
		if ((computedValueLevel > 1 && !empty.StartsWith('!'.ToString())) || (empty.Contains(":") && (IsRange(empty) || ISColumn(empty))))
		{
			isInteriorFunction = true;
			return empty.Replace("$", string.Empty);
		}
		string valueFromArg = GetValueFromArg(empty.Replace("$", string.Empty));
		if (treatStringsAsZero && string.IsNullOrEmpty(valueFromArg))
		{
			return "0";
		}
		return valueFromArg;
	}

	private string SubstituteText(string text, string old_Text, string new_Text, string instance_num)
	{
		if (instance_num.Equals(string.Empty))
		{
			text = text.Replace(old_Text, new_Text);
		}
		else
		{
			double result = 0.0;
			if (double.TryParse(instance_num, NumberStyles.Integer, null, out result))
			{
				int num = (int)result;
				int num2 = -1;
				while (num > 0 && (num2 = text.IndexOf(old_Text, num2 + 1)) > -1)
				{
					num--;
				}
				if (num == 0)
				{
					text = text.Substring(0, num2) + new_Text + text.Substring(num2 + old_Text.Length);
				}
			}
		}
		return text;
	}

	public string ComputeSubstitute(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.Length != 3 && array.Length != 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = string.Empty;
		string old_Text = StripTics0(GetValueFromArg(array[1]));
		string new_Text = StripTics0(GetValueFromArg(array[2]));
		string instance_num = ((array.Length == 4) ? GetValueFromArg(array[3]) : string.Empty);
		if (IsRange(array[0]))
		{
			string[] cellsFromArgs = GetCellsFromArgs(array[0]);
			foreach (string arg in cellsFromArgs)
			{
				string text2 = StripTics0(GetValueFromArg(arg));
				text = text + SubstituteText(text2, old_Text, new_Text, instance_num) + ";";
			}
			text = text.Substring(0, text.Length - 1);
		}
		else
		{
			text = StripTics0(GetValueFromArg(array[0]));
			text = SubstituteText(text, old_Text, new_Text, instance_num);
		}
		return TIC + text + TIC;
	}

	public string ComputeText(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string arg = array[0];
		string text = array[1].Replace(TIC, string.Empty);
		DateTime result = dateTime1900;
		arg = GetValueFromArg(arg);
		if (string.IsNullOrEmpty(arg) && text.Length > 0 && text.ToUpper().IndexOfAny(new char[5] { 'M', 'D', 'Y', 'S', 'T' }) > -1)
		{
			arg = result.ToString();
		}
		if (double.TryParse(arg, NumberStyles.Any, null, out var result2) && text.Length > 0 && !NativeFormats.Contains(text) && text != "0" && text.ToUpper().IndexOfAny(new char[3] { 'H', 'S', 'T' }) < 0 && text.ToUpper().IndexOfAny(new char[3] { 'D', 'Y', 'M' }) > -1)
		{
			arg = GetDateFromSerialDate((int)result2).ToString();
		}
		if (double.TryParse(arg, NumberStyles.Any, null, out result2) || DateTime.TryParse(arg.Replace(TIC, string.Empty), out result))
		{
			if (text[0].Equals('[') && NativeFormats.Contains(text))
			{
				return TIC + arg + TIC;
			}
			if (text.Length > 0 && text.ToUpper().IndexOfAny(new char[5] { 'M', 'D', 'Y', 'S', 'T' }) > -1)
			{
				text = ((text.Equals("HH:MM") || text.Equals("hh:mm")) ? text.Replace('h', 'H') : text.Replace('Y', 'y').Replace('D', 'd').Replace('H', 'h')
					.Replace('S', 's')
					.Replace('m', 'M')
					.Replace("AM/PM", "tt"));
				char[] array2 = text.ToCharArray();
				bool flag = false;
				bool flag2 = false;
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				int num4 = 0;
				char[] array3 = array2;
				foreach (char c in array3)
				{
					if (c == 's' && array2[num3] == 'M')
					{
						array2[num3] = 'm';
						if (array2[num3 - 1] == 'M')
						{
							array2[num3 - 1] = 'm';
						}
					}
					if (char.IsLetter(c))
					{
						num3 = num;
						if (c == 'M')
						{
							num2++;
							num4++;
						}
					}
					else if (num4 > 1)
					{
						num4++;
					}
					if (c == 'M' && flag)
					{
						array2[num] = 'm';
						flag2 = true;
					}
					if (c == 'h' || c == 'H')
					{
						flag = true;
					}
					else if (char.IsLetter(c) && c != 'M' && c != 'h' && !flag2)
					{
						flag = false;
						flag2 = false;
					}
					num++;
				}
				text = new string(array2);
				DateTime dateTime = CalcEngineHelper.FromOADate(result2);
				if (result2 == 0.0)
				{
					dateTime = result;
				}
				arg = dateTime.ToString(text, CultureInfo.CurrentCulture);
			}
			else
			{
				text = $"{{0:{text}}}";
				arg = string.Format(text, result2);
			}
		}
		return TIC + arg + TIC;
	}

	public string ComputeValue(string range)
	{
		string text = string.Empty;
		try
		{
			string[] array = SplitArgsPreservingQuotedCommas(range);
			if (array.GetLength(0) <= 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return FormulaErrorStrings[wrong_number_arguments];
			}
			string text2 = array[0];
			string[] array2 = (IsRange(range) ? null : new string[1]);
			bool flag = false;
			bool flag2 = false;
			if (text2.Contains(TIC))
			{
				flag = true;
			}
			if (!string.IsNullOrEmpty(text2) && !IsCellReference(text2) && flag)
			{
				if (double.TryParse(text2.Replace(TIC, string.Empty), out var _) || DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out var result2) || TryParseExactDateTime(text2.Replace(TIC, string.Empty), out result2))
				{
					text2 = (array2[0] = text2.Replace(TIC, string.Empty));
					flag2 = true;
				}
			}
			else
			{
				if (string.IsNullOrEmpty(text2) && flag)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				if (string.IsNullOrEmpty(text2) && !flag)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
					}
					return FormulaErrorStrings[invalid_arguments];
				}
				if (range.Contains(":"))
				{
					array2 = GetCellsFromArgs(StripTics(text2.ToString()));
				}
				else
				{
					text2 = (array2[0] = GetValueFromArg(text2));
				}
			}
			string[] array3 = array2;
			foreach (string text3 in array3)
			{
				if (array2.Length > 1)
				{
					text2 = GetValueFromArg(text3);
				}
				if (text2.StartsWith("$"))
				{
					text2 = text2.Replace("$", string.Empty);
				}
				if (text2.StartsWith("%") || text2.EndsWith("%"))
				{
					text2 = text2.Replace("%", string.Empty);
					double result3 = 0.0;
					if (double.TryParse(text2, NumberStyles.Number | NumberStyles.AllowExponent, null, out result3))
					{
						text2 = (result3 / 100.0).ToString();
					}
				}
				double result4 = 0.0;
				if (double.TryParse(text2, NumberStyles.Number | NumberStyles.AllowExponent, null, out result4))
				{
					if (computedValueLevel > 1 && exteriorFormula)
					{
						text = ((!(text3 != array2[0])) ? result4.ToString("G15") : (text + ";" + result4.ToString("G15")));
						continue;
					}
					if (range.Contains(":"))
					{
						return ComputedValue(range);
					}
					text = result4.ToString("G15");
					continue;
				}
				if (TimeSpan.TryParse(text2, out var result5))
				{
					if (flag2)
					{
						text = ComputeTimevalue(result5.ToString());
						continue;
					}
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
					}
					return FormulaErrorStrings[invalid_arguments];
				}
				if (IsDate(text2, out var date))
				{
					text = ComputeDatevalue(date.ToString());
					continue;
				}
				if (TryParseExactDateTime(text2.Replace(TIC, string.Empty), out date))
				{
					text = (GetSerialDateTimeFromDate(date) - GetSerialDateTimeFromDate(DateTime.Today)).ToString("G15");
					continue;
				}
				if (string.IsNullOrEmpty(text2))
				{
					text = "0";
					continue;
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
			if (exteriorFormula)
			{
				exteriorFormula = false;
			}
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw;
			}
			return ErrorStrings[1].ToString();
		}
		return text.ToString();
	}

	public string ComputeMod(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (IsArrayFormula && array.Length > 2)
		{
			array[1] = array[^1];
		}
		if ((array.Length != 2 || string.IsNullOrEmpty(range)) && !IsArrayFormula)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string arg = array[0];
		string text2 = array[1];
		arg = GetValueFromArg(arg);
		text2 = ((!string.IsNullOrEmpty(text2)) ? GetValueFromArg(text2) : "0");
		arg = (bool.TryParse(arg, out var result) ? Convert.ToInt16(result).ToString() : arg);
		text2 = (bool.TryParse(text2, out var result2) ? Convert.ToInt16(result2).ToString() : text2);
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		if (double.TryParse(arg.Replace(TIC, string.Empty), out result3) && double.TryParse(text2.Replace(TIC, string.Empty), out result4))
		{
			num = result3 - result4 * Math.Floor(result3 / result4);
			if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[3].ToString();
			}
		}
		return num.ToString();
	}

	public string ComputeTrunc(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		double result = 0.0;
		if (length > 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (length == 2)
		{
			string valueFromArg = GetValueFromArg(array[1]);
			valueFromArg = (bool.TryParse(valueFromArg, out var result2) ? Convert.ToInt16(result2).ToString() : valueFromArg);
			double.TryParse(GetValueFromArg(valueFromArg.Replace(TIC, string.Empty)), NumberStyles.Integer, null, out result);
		}
		range = GetValueFromArg(array[0]);
		range = (bool.TryParse(range, out var result3) ? Convert.ToInt16(result3).ToString() : range);
		if (double.TryParse(range.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result4) && result >= 0.0)
		{
			string text2 = ((result == 0.0) ? "F0" : ("0." + new string('0', (int)result)));
			double num = Math.Pow(10.0, result);
			return ((double)((!(result4 < 0.0)) ? 1 : (-1)) * Math.Floor(num * Math.Abs(result4)) / num).ToString(text2);
		}
		return "0";
	}

	private void PerformLogicalOperation(string tempr, ref bool indexValue, ref int count, ref double[] vector, ref string errorString)
	{
		string text = string.Empty;
		string text2 = string.Empty;
		for (int i = 0; i <= tempr.Length - 1; i++)
		{
			string text3 = string.Empty;
			string text4 = string.Empty;
			_ = string.Empty;
			_ = string.Empty;
			string[] array = null;
			string text5 = string.Empty;
			string text6 = string.Empty;
			while (i != tempr.Length && (char.IsDigit(tempr[i]) | (tempr[i] == ':') | (tempr[i] == '!') | (i != 0 && IsUpper(tempr[i]) && !char.IsDigit(tempr[i - 1])) | (i == 0 && IsUpper(tempr[i]))))
			{
				text3 += tempr[i++];
			}
			if (!text3.Contains(":"))
			{
				while (i != tempr.Length && (char.IsDigit(tempr[i]) | (tempr[i] == ':') | (tempr[i] == '!') | (i != 0 && IsUpper(tempr[i])) | (i == 0 && IsUpper(tempr[i]))))
				{
					text4 += tempr[i++];
				}
			}
			if (exteriorFormula && tempr[i] == '{')
			{
				i++;
				text3 = tempr.Substring(i, tempr.IndexOf("}") - 1);
				i += tempr.IndexOf("}");
				array = text3.Split(';');
				exteriorFormula = false;
			}
			if (i != tempr.Length && tempr[i] == '"')
			{
				text5 += tempr[i++];
				while (i != tempr.Length && tempr[i] != '"')
				{
					text5 += tempr[i++];
				}
				text5 += tempr[i++];
			}
			while (i != tempr.Length && ((IsUpper(tempr[i]) | char.IsDigit(tempr[i]) | (tempr[i] == 'n')) || tempr[i] == parseDecimalSeparator || (tempr[i].ToString().IndexOfAny(logicalOperators) > -1 && char.IsDigit(tempr[i - 1]))))
			{
				text5 += tempr[i++];
			}
			char[] array2 = tokens;
			foreach (char c in array2)
			{
				if (i != tempr.Length && tempr[i] == c)
				{
					text5 += tempr[i];
					break;
				}
			}
			if (array == null && IsRange(text3))
			{
				array = GetCellsFromArgs(text3);
			}
			else if (array == null && IsRange(text4))
			{
				array = GetCellsFromArgs(text4);
			}
			else if (text3 != string.Empty && !IsRange(text3) && text4 != string.Empty && !IsRange(text4))
			{
				text3 += text4;
				text4 = string.Empty;
				if (text4 == string.Empty)
				{
					while (i != tempr.Length && (char.IsDigit(tempr[i]) | (tempr[i] == ':') | (tempr[i] == '!') | (i != 0 && IsUpper(tempr[i])) | (i == 0 && IsUpper(tempr[i]))))
					{
						text4 += tempr[i++];
					}
					if (array == null && IsRange(text4))
					{
						array = GetCellsFromArgs(text4);
					}
				}
				string text7 = string.Empty;
				string text8 = string.Empty;
				string empty = string.Empty;
				string empty2 = string.Empty;
				for (int k = 0; k <= text3.Length - 1; k++)
				{
					while (k != text3.Length && (char.IsDigit(text3[k]) | (k != 0 && IsUpper(text3[k]) && !char.IsDigit(text3[k - 1])) | (k == 0 && IsUpper(text3[k]))))
					{
						text7 += text3[k++];
					}
					while (k != text3.Length && (char.IsDigit(text3[k]) | (k != 0 && IsUpper(text3[k])) | (k == 0 && IsUpper(text3[k]))))
					{
						text8 += text3[k++];
					}
				}
				empty = GetValueFromArg('\u0092' + text7 + text8 + text5 + '\u0092');
				array2 = tokens;
				foreach (char c2 in array2)
				{
					if (i != tempr.Length && tempr[i] == c2)
					{
						text5 = empty2 + tempr[i];
						break;
					}
				}
				text3 = empty;
			}
			int num = 0;
			if (text3 == string.Empty && text != string.Empty)
			{
				string[] array3 = SplitArgsPreservingQuotedCommas(text);
				string[] array4 = array3[0].Replace(TIC, string.Empty).Split(';');
				string[] array5 = array3[1].Replace(TIC, string.Empty).Split(';');
				if (array4.Length == array5.Length)
				{
					for (num = 0; num <= array4.Length - 1; num++)
					{
						if (num + 1 != array3.Length)
						{
							text6 = GetValueFromArg('\u0092' + array4[num] + array5[num] + text5 + '\u0092');
						}
						text2 = text2 + text6 + ";";
					}
				}
				text = string.Empty;
			}
			else if (text3 != string.Empty && text4 != string.Empty)
			{
				for (num = 0; num <= array.Length - 1; num++)
				{
					text6 = GetValueFromArg('\u0092' + text3 + array[num] + text5 + '\u0092');
					text2 = text2 + text6 + ";";
				}
			}
			else if (text3 != string.Empty && text != string.Empty && text5 != string.Empty && text4 != string.Empty)
			{
				string[] array6 = SplitArgsPreservingQuotedCommas(text)[0].Replace(TIC, string.Empty).Split(';');
				if (array6.Length == array.Length)
				{
					for (num = 0; num <= array.Length - 1; num++)
					{
						text6 = GetValueFromArg('\u0092' + array6[num] + array[num] + text5 + '\u0092');
						text2 = text2 + text6 + ";";
					}
				}
				text = string.Empty;
				i--;
			}
			else
			{
				for (num = 0; num <= array.Length - 1; num++)
				{
					text6 = GetValueFromArg('\u0092' + array[num] + text5 + '\u0092');
					text2 = text2 + text6 + ";";
				}
			}
			if (i == tempr.Length - 1)
			{
				text = text2.Remove(text2.Length - 1);
			}
			else
			{
				text2 = text2.Remove(text2.Length - 1);
				text = text + TIC + text2 + TIC + parseArgumentSeparator;
			}
			text2 = string.Empty;
		}
		performMultiplication(text, ref indexValue, ref count, ref vector, ref errorString);
	}

	private void PerformArithmeticCalculation(string range, ref bool indexValue, ref int count, ref double[] vector, ref string errorString)
	{
		List<string> list = new List<string>();
		string text = string.Empty;
		string text2 = string.Empty;
		for (int i = 0; i <= range.Length - 1; i++)
		{
			string empty = string.Empty;
			string text3 = string.Empty;
			string text4 = string.Empty;
			if (range[i] == '!')
			{
				empty = string.Concat(range[i]);
				for (i++; range[i] != '!'; i++)
				{
					empty += range[i];
				}
				empty += range[i];
				i++;
				while (i != range.Length && (char.IsDigit(range[i]) | (range[i] == ':') | (i != 0 && IsUpper(range[i]) && !char.IsDigit(range[i - 1])) | (i == 0 && IsUpper(range[i]))))
				{
					empty += range[i++];
				}
				if ((range.IndexOf(":") != range.LastIndexOf(":") && (range[i] == '!' || range[i].ToString().IndexOfAny(tokens) > -1)) || range[i] == 'n' || range[i].ToString().IndexOfAny(logicalOperators) > -1)
				{
					list.Add(empty);
					i--;
					continue;
				}
			}
			else if (range[i].ToString().IndexOfAny(tokens) > -1 || range[i].ToString().IndexOfAny(logicalOperators) > -1)
			{
				char[] array = tokens;
				foreach (char c in array)
				{
					if (i != range.Length && range[i] == c)
					{
						text4 += range[i];
						break;
					}
				}
			}
			if (list.Count > 2 && text4 != string.Empty)
			{
				int num = 0;
				string[] cellsFromArgs = GetCellsFromArgs(list[list.Count - 1]);
				string[] cellsFromArgs2 = GetCellsFromArgs(list[list.Count - 2]);
				if (cellsFromArgs.Length == cellsFromArgs2.Length)
				{
					for (num = 0; num <= cellsFromArgs.Length - 1; num++)
					{
						if (num + 1 <= cellsFromArgs.Length)
						{
							text3 = GetValueFromArg('\u0092' + cellsFromArgs[num] + cellsFromArgs2[num] + text4 + '\u0092');
						}
						text2 = text2 + text3 + ";";
					}
				}
				list.RemoveAt(list.Count - 2);
				list.RemoveAt(list.Count - 1);
			}
			else if (list.Count > 0 && text4 != string.Empty && text != string.Empty)
			{
				int num2 = 0;
				string[] cellsFromArgs3 = GetCellsFromArgs(list[list.Count - 1]);
				string[] array2 = text.Replace(TIC, string.Empty).Split(';');
				if (cellsFromArgs3.Length == array2.Length)
				{
					for (num2 = 0; num2 <= cellsFromArgs3.Length - 1; num2++)
					{
						bool flag = false;
						if (double.TryParse(array2[num2].ToString(), out var _))
						{
							flag = true;
						}
						if (flag)
						{
							if (num2 + 1 <= cellsFromArgs3.Length && array2[num2].ToString().StartsWith('-'.ToString()))
							{
								text3 = GetValueFromArg('\u0092' + GetValueFromArg(cellsFromArgs3[num2]) + "nu" + array2[num2].Replace("-", string.Empty) + text4 + '\u0092');
							}
							else if (num2 + 1 <= cellsFromArgs3.Length)
							{
								text3 = GetValueFromArg('\u0092' + GetValueFromArg(cellsFromArgs3[num2]) + "n" + Parse(array2[num2]) + text4 + '\u0092');
							}
						}
						else if (num2 + 1 <= cellsFromArgs3.Length)
						{
							text3 = GetValueFromArg('\u0092' + GetValueFromArg(cellsFromArgs3[num2]) + array2[num2] + text4 + '\u0092');
						}
						text2 = text2 + text3 + ";";
					}
				}
				list.RemoveAt(list.Count - 1);
				text = string.Empty;
			}
			if (i == range.Length)
			{
				text = text2.Remove(text2.Length - 1);
			}
			else
			{
				text2 = text2.Remove(text2.Length - 1);
				text = text + TIC + text2 + TIC;
			}
			text2 = string.Empty;
		}
		performMultiplication(text, ref indexValue, ref count, ref vector, ref errorString);
	}

	private string PerformSumproductArithmetic(string range)
	{
		double num = 0.0;
		string[] array = null;
		array = range.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
		string empty = string.Empty;
		int num2 = -1;
		string empty2 = string.Empty;
		string text = string.Empty;
		double result;
		if (array.Length > 1)
		{
			string[] array2 = array;
			foreach (string text2 in array2)
			{
				if (text2.Contains(";"))
				{
					num2++;
				}
				else
				{
					if (text2.IndexOfAny(tokens) <= -1)
					{
						continue;
					}
					string[] array3 = null;
					string[] array4 = null;
					if (text != string.Empty)
					{
						array4 = text.Replace(TIC, string.Empty).Split(';');
						array3 = array[num2].Replace(TIC, string.Empty).Split(';');
					}
					else
					{
						array3 = array[num2].Replace(TIC, string.Empty).Split(';');
						array4 = array[num2 - 1].Replace(TIC, string.Empty).Split(';');
					}
					num2++;
					empty2 = text2;
					if (array4.Length == array3.Length)
					{
						for (int j = 0; j <= array4.Length - 1; j++)
						{
							empty = GetValueFromArg('\u0092' + "n" + array4[j] + "n" + array3[j] + empty2 + '\u0092');
							text = text + empty + ";";
						}
						text = text.Substring(0, text.Length - 1);
					}
					if (num2 != array.Length - 1)
					{
						continue;
					}
					array4 = text.Replace(TIC, string.Empty).Split(';');
					for (int k = 0; k < array4.Length; k++)
					{
						if (double.TryParse(array4[k], out result))
						{
							num += result;
						}
					}
				}
			}
		}
		else if (array.Length == 1 && array[0].Contains(";") && array[0].IndexOfAny(tokens) == -1)
		{
			string[] array2 = array[0].Split(';');
			for (int i = 0; i < array2.Length; i++)
			{
				if (double.TryParse(array2[i], out result))
				{
					num += result;
				}
			}
		}
		return num.ToString();
	}

	public string ComputeSumProduct(string range)
	{
		double num = 0.0;
		int count = 0;
		bool indexValue = false;
		double[] vector = null;
		string[] array = null;
		if (!range.Contains(parseArgumentSeparator.ToString()) && !range.Contains('!'.ToString()) && !range.Contains(":"))
		{
			range = range.Replace('\u0092'.ToString(), string.Empty);
			return PerformSumproductArithmetic(range);
		}
		if (range.Contains(TIC) && (range.StartsWith(TIC) | range.EndsWith(TIC)))
		{
			array = range.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == parseArgumentSeparator.ToString())
				{
					List<string> list = new List<string>(array);
					list.Remove(array[i]);
					array = list.ToArray();
				}
				else if (array[i].StartsWith(parseArgumentSeparator.ToString()) && IsCellReference(array[i].Replace(parseArgumentSeparator.ToString(), string.Empty)))
				{
					array[i] = array[i].Replace(parseArgumentSeparator.ToString(), string.Empty);
				}
			}
		}
		else
		{
			array = SplitArgsPreservingQuotedCommas(range);
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			_ = string.Empty;
			string errorString = string.Empty;
			if (text.IndexOf(':') > -1 && !IsCellReference(text))
			{
				string text2 = text.Replace('\u0092'.ToString(), string.Empty);
				_ = string.Empty;
				string[] array3 = text2.Split(tokens, StringSplitOptions.RemoveEmptyEntries);
				if (text2.Contains(":") && text2.IndexOf(":") != text2.LastIndexOf(":"))
				{
					bool flag = false;
					string[] array4 = array3;
					foreach (string text3 in array4)
					{
						flag = ((text3.Contains(":") && text3.IndexOf(":") != text3.LastIndexOf(":")) ? true : false);
					}
					if (flag)
					{
						PerformArithmeticCalculation(text2, ref indexValue, ref count, ref vector, ref errorString);
						flag = false;
						continue;
					}
					PerformLogicalOperation(text2, ref indexValue, ref count, ref vector, ref errorString);
					if (errorString != string.Empty)
					{
						return errorString;
					}
				}
				else
				{
					PerformLogicalOperation(text2, ref indexValue, ref count, ref vector, ref errorString);
					if (errorString != string.Empty)
					{
						return errorString;
					}
				}
				continue;
			}
			if (!text.StartsWith(TIC) && text.IndexOf(':') > -1)
			{
				int num2 = text.IndexOf(":");
				int num3 = RowIndex(text.Substring(0, num2));
				int num4 = RowIndex(text.Substring(num2 + 1));
				if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				int num5 = ColIndex(text.Substring(0, num2));
				int num6 = ColIndex(text.Substring(num2 + 1));
				if (grid is ISheetData)
				{
					if (num3 == -1 && grid is ISheetData)
					{
						num3 = ((ISheetData)grid).GetFirstRow();
					}
					if (num5 == -1 && grid is ISheetData)
					{
						num5 = ((ISheetData)grid).GetFirstColumn();
					}
					if (num4 == -1 && grid is ISheetData)
					{
						num4 = ((ISheetData)grid).GetLastRow();
					}
					if (num6 == -1 && grid is ISheetData)
					{
						num6 = ((ISheetData)grid).GetLastColumn();
					}
				}
				if (vector != null && count != (num4 - num3 + 1) * (num6 - num5 + 1))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				if (vector == null)
				{
					count = (num4 - num3 + 1) * (num6 - num5 + 1);
					vector = new double[count];
					for (num2 = 0; num2 < count; num2++)
					{
						vector[num2] = 1.0;
					}
				}
				GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
				string sheetTokenFromReference = GetSheetTokenFromReference(text);
				ICalcData grd = ((sheetTokenFromReference == null || sheetTokenFromReference == string.Empty) ? grid : ((ICalcData)sheetFamilyItem.TokenToParentObject[sheetTokenFromReference]));
				num2 = 0;
				for (int l = num3; l <= num4; l++)
				{
					for (int m = num5; m <= num6; m++)
					{
						if (double.TryParse(GetValueFromParentObject(grd, l, m).Replace(TIC, string.Empty), NumberStyles.Any, null, out var result))
						{
							vector[num2] *= result;
						}
						else if (bool.TryParse(GetValueFromParentObject(grd, l, m).Replace(TIC, string.Empty), out indexValue))
						{
							vector[num2] *= Convert.ToDouble(indexValue);
						}
						else
						{
							vector[num2] = 0.0;
						}
						num2++;
					}
				}
				continue;
			}
			if (text.Contains(parseArgumentSeparator.ToString()) || text.Contains(";") || text.Contains("{"))
			{
				string text4 = text.Replace('\u0092'.ToString(), string.Empty);
				if (exteriorFormula)
				{
					text4 = text4.Replace("{", string.Empty).Replace("}", string.Empty);
					exteriorFormula = false;
				}
				performMultiplication(text4, ref indexValue, ref count, ref vector, ref errorString);
				if (errorString != string.Empty)
				{
					return errorString;
				}
				continue;
			}
			string valueFromArg = GetValueFromArg(text);
			if (!double.TryParse(valueFromArg.Replace(TIC, string.Empty), out var result2))
			{
				if (ErrorStrings.Contains(valueFromArg))
				{
					return valueFromArg;
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
			num = ((num != 0.0 || !(result2 > 0.0)) ? (num * result2) : result2);
		}
		for (int n = 0; n < count; n++)
		{
			num += vector[n];
		}
		return num.ToString();
	}

	internal void performMultiplication(string r, ref bool indexValue, ref int count, ref double[] vector, ref string errorString)
	{
		string[] array = null;
		string[] array2 = null;
		int num = 0;
		double result = 0.0;
		if (r.Contains(";"))
		{
			array = SplitArguments(r.Replace(TIC, string.Empty), ';');
			array2 = new string[array.Length * SplitArgsPreservingQuotedCommas(array[0]).Length];
		}
		else if (r.Contains(","))
		{
			array = SplitArguments(r, ',');
			array2 = new string[array.Length * SplitArgsPreservingQuotedCommas(array[0]).Length];
		}
		else
		{
			array = SplitArgsPreservingQuotedCommas(r);
			array2 = new string[array.Length];
		}
		for (int i = 0; i < array.Length; i++)
		{
			int j = 0;
			if (array[i].Contains(","))
			{
				for (string[] array3 = SplitArguments(array[i], ','); j != array3.Length; j++)
				{
					array2[num] = array3[j];
					num++;
				}
			}
			else
			{
				array2[i] = array[i];
			}
		}
		array = array2;
		if (vector != null && count != array.Length)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			errorString = ErrorStrings[1].ToString();
		}
		else if (vector == null)
		{
			count = array.Length;
			vector = new double[count];
			for (int k = 0; k < count; k++)
			{
				vector[k] = 1.0;
			}
		}
		for (int l = 0; l < array.Length; l++)
		{
			if (double.TryParse(array[l], NumberStyles.Any, null, out result))
			{
				vector[l] *= result;
			}
			else if (bool.TryParse(array[l], out indexValue))
			{
				vector[l] *= Convert.ToDouble(indexValue);
			}
			else
			{
				vector[l] = 0.0;
			}
		}
	}

	public string ComputeDollar(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.Length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string arg = array[0];
		string arg2 = "2";
		if (array.GetLength(0) == 2)
		{
			arg2 = array[1];
		}
		arg = GetValueFromArg(arg);
		arg = (string.IsNullOrEmpty(arg) ? "0" : arg);
		arg = (bool.TryParse(arg, out var result) ? Convert.ToInt16(result).ToString() : arg);
		arg2 = GetValueFromArg(arg2);
		arg2 = (string.IsNullOrEmpty(arg2) ? "0" : arg2);
		arg2 = (bool.TryParse(arg2, out result) ? Convert.ToInt16(result).ToString() : arg2);
		if (!double.TryParse(arg, NumberStyles.Any, null, out var result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		if (!double.TryParse(arg2, NumberStyles.Any, null, out var result3))
		{
			result3 = 2.0;
		}
		double num = 0.0;
		NumberFormatInfo numberFormatInfo = (NumberFormatInfo)CultureInfo.CurrentCulture.NumberFormat.Clone();
		if (result3 > 0.0)
		{
			num = Math.Round(result2, (int)result3, MidpointRounding.AwayFromZero);
			numberFormatInfo.CurrencyDecimalDigits = (int)result3;
		}
		else
		{
			double num2 = Math.Pow(10.0, 0.0 - result3);
			num = Math.Round(result2 / num2) * num2;
			numberFormatInfo.CurrencyDecimalDigits = 0;
		}
		return string.Format(numberFormatInfo, "{0:C}", num);
	}

	public string ComputeFixed(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		string arg = array[0];
		string arg2 = "2";
		string arg3 = "FALSE";
		int length = array.GetLength(0);
		if (length > 1)
		{
			arg2 = array[1];
		}
		if (length > 2)
		{
			arg3 = array[2];
		}
		arg = GetValueFromArg(arg);
		arg2 = GetValueFromArg(arg2);
		arg3 = GetValueFromArg(arg3);
		double result = 0.0;
		double.TryParse(arg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2);
		if (array.Length == 1 || (array.Length > 1 && array[1] == string.Empty))
		{
			result = 2.0;
		}
		else if (!double.TryParse(arg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result) && result == 0.0)
		{
			return ErrorStrings[1].ToString();
		}
		bool flag;
		if (double.TryParse(arg3, NumberStyles.Any, null, out var result3))
		{
			flag = result3 != 0.0;
		}
		else if (arg3.ToUpper() == FALSEVALUESTR)
		{
			flag = false;
		}
		else
		{
			if (!(arg3.ToUpper() == TRUEVALUESTR))
			{
				return "#NAME?";
			}
			flag = true;
		}
		NumberFormatInfo numberFormatInfo = (NumberFormatInfo)CultureInfo.CurrentCulture.NumberFormat.Clone();
		if (result > 0.0)
		{
			result2 = Math.Round(result2, (int)result, MidpointRounding.AwayFromZero);
			numberFormatInfo.NumberDecimalDigits = (int)result;
		}
		else
		{
			double num = Math.Pow(10.0, 0.0 - result);
			result2 = Math.Round(result2 / num) * num;
			numberFormatInfo.NumberDecimalDigits = 0;
		}
		if (flag)
		{
			numberFormatInfo.NumberGroupSeparator = string.Empty;
		}
		return string.Format(numberFormatInfo, "{0:N}", result2);
	}

	public string ComputeChoose(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length < 2)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (!int.TryParse(GetValueFromArg(array[0]), out var result) || result > array.Length - 1 || result < 1)
		{
			return "#VALUE!";
		}
		return GetValueFromArg(array[result]);
	}

	public string ComputeLower(string args)
	{
		return GetValueFromArg(args).ToLower();
	}

	public string ComputeUpper(string args)
	{
		return GetValueFromArg(args).ToUpper();
	}

	public string ComputeT(string args)
	{
		int num = 0;
		string[] array = SplitArguments(args, ParseArgumentSeparator);
		if (array.Length != 0)
		{
			string[] array2 = array;
			foreach (string text in array2)
			{
				num++;
				if (text.IndexOf(':') > -1)
				{
					num--;
					string[] cellsFromArgs = GetCellsFromArgs(text);
					for (int j = 0; j < cellsFromArgs.Length; j++)
					{
						_ = cellsFromArgs[j];
						num++;
					}
				}
			}
		}
		if (num > 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string valueFromArg = GetValueFromArg(args);
		string pattern = "[a-zA-Z0-9!#$%&'()*+,/:;<=>?@\\^_`{|}~-]";
		if (ComputeIsNumber(args) == "TRUE" || ComputeIsLogical(args) == "TRUE" || (UseDatesInCalculations && IsDate(valueFromArg, out var _)))
		{
			return string.Empty;
		}
		if (Regex.IsMatch(valueFromArg, pattern))
		{
			return valueFromArg.Replace(TIC, string.Empty);
		}
		return string.Empty;
	}

	public string ComputeColumn(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		int length = array.GetLength(0);
		array[0] = array[0].Replace("\"", "");
		if (length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (string.IsNullOrEmpty(array[0]))
		{
			return ColIndex(cell).ToString();
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(array[0]) && !TryGetNamedRange(array[0], out scopedRange))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		if (arg.IndexOf(':') > -1 && IsArrayFormula)
		{
			string text = ArrayParser.ComputeInteriorFunction(arg, "COLUMN", computeFunctionLevel);
			if (!(text == string.Empty))
			{
				return text;
			}
			arg = GetCellsFromArgs(arg)[0];
		}
		if (arg.IndexOf(':') > -1)
		{
			arg = GetCellsFromArgs(arg)[0];
		}
		return ColIndex(arg).ToString();
	}

	public string ComputeRow(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		int length = array.GetLength(0);
		array[0] = array[0].Replace("\"", "");
		if (array[0].Contains(":") && exteriorFormula)
		{
			string empty = string.Empty;
			empty += "{";
			string[] array2 = null;
			array2 = GetCellsFromArgs(array[0]);
			for (int i = 0; i < array2.Length; i++)
			{
				empty = ((parseArgumentSeparator == ',') ? (empty + ComputeRow(array2[i]) + ";") : (empty + ComputeRow(array2[i]) + ","));
			}
			empty = empty.Remove(empty.Length - 1) + "}";
			return "\u0092" + empty + "\u0092";
		}
		if (length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (string.IsNullOrEmpty(array[0]))
		{
			return RowIndex(cell).ToString();
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(array[0]) && !TryGetNamedRange(array[0], out scopedRange))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		if (arg.IndexOf(':') > -1 && IsArrayFormula)
		{
			string text = ArrayParser.ComputeInteriorFunction(arg, "ROW", computeFunctionLevel);
			if (!(text == string.Empty))
			{
				return text;
			}
			arg = GetCellsFromArgs(arg)[0];
		}
		if (arg.IndexOf(':') > -1)
		{
			arg = GetCellsFromArgs(arg.Replace(TIC, string.Empty))[0];
		}
		return RowIndex(arg).ToString();
	}

	public string ComputeN(string args)
	{
		string empty = string.Empty;
		double result = 0.0;
		if (SplitArguments(args, ParseArgumentSeparator).GetLength(0) != 1)
		{
			return FormulaErrorStrings[requires_a_single_argument];
		}
		empty = GetValueFromArg(args);
		if (double.TryParse(empty, NumberStyles.Any, null, out result))
		{
			return result.ToString();
		}
		if (DateTime.TryParse(empty, out var result2))
		{
			result = GetSerialDateTimeFromDate(result2);
		}
		else if (empty.Equals(TRUEVALUESTR))
		{
			result = 1.0;
		}
		else if (empty.Equals(FALSEVALUESTR))
		{
			result = 0.0;
		}
		else if (ErrorStrings.Contains(empty) || formulaErrorStrings.Contains(empty))
		{
			return empty;
		}
		return result.ToString();
	}

	private string ComputeNA(string args)
	{
		return ComputeNA();
	}

	public string ComputeNA()
	{
		return "#N/A";
	}

	public string ComputeErrorType(string args)
	{
		string empty = string.Empty;
		if (SplitArguments(args, ParseArgumentSeparator).GetLength(0) != 1)
		{
			return FormulaErrorStrings[requires_a_single_argument];
		}
		empty = ((!IsCellReference(args)) ? args : GetValueFromArg(args));
		if (empty.Length > 1 && empty[0] == TIC[0] && empty[empty.Length - 1] == TIC[0])
		{
			return "#N/A";
		}
		if (empty.Equals("#NULL!"))
		{
			return "1";
		}
		if (empty.Equals("#DIV/0!"))
		{
			return "2";
		}
		if (empty.Equals("#VALUE!"))
		{
			return "3";
		}
		if (empty.Equals("#REF!"))
		{
			return "4";
		}
		if (empty.Equals("#NAME?"))
		{
			return "5";
		}
		if (empty.Equals("#NUM!"))
		{
			return "6";
		}
		if (empty.Equals("#N/A"))
		{
			return "7";
		}
		if (empty.Equals("#GETTING_DATA"))
		{
			return "8";
		}
		return "#N/A";
	}

	public string ComputeTrim(string args)
	{
		string text = GetValueFromArg(args).Trim('"', ' ');
		int num = 0;
		while (text.Length != num)
		{
			num = text.Length;
			text = text.Replace("  ", " ");
		}
		return text;
	}

	public string ComputeIsLogical(string args)
	{
		args = GetValueFromArg(args).ToUpper();
		if (args.Equals(FALSEVALUESTR) || args.Equals(TRUEVALUESTR))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsNA(string args)
	{
		if (ErrorStrings.IndexOf(args.ToUpper()) != -1)
		{
			if (args.ToUpper().Equals("#N/A"))
			{
				return TRUEVALUESTR;
			}
			return FALSEVALUESTR;
		}
		try
		{
			args = GetValueFromArg(args).ToUpper();
		}
		catch
		{
			return FALSEVALUESTR;
		}
		if (args.StartsWith("#N/A"))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsErr(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = range.ToUpper();
		range = ((range.Length <= 0 || range.StartsWith("#") || text.StartsWith("NAN") || text.StartsWith("-NAN") || !(range != double.PositiveInfinity.ToString()) || !(range != double.NegativeInfinity.ToString())) ? range.ToUpper() : GetValueFromArg(range).ToUpper().Replace(TIC, string.Empty));
		if (((range.StartsWith("NAN") || range.StartsWith("-NAN") || range.StartsWith("INFINITY") || range.StartsWith("-INFINITY") || range.StartsWith("#") || range.StartsWith("n#")) && !range.StartsWith("#N/A")) || range.Equals(double.PositiveInfinity.ToString()) || range.Equals(double.NegativeInfinity.ToString()))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsBlank(string args)
	{
		if (GetValueFromArg(args).Equals(string.Empty))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsText(string args)
	{
		bool num = IsCellReference(args);
		string text = (num ? GetValueFromArg(args) : args);
		if ((num || text.StartsWith(TIC)) && text.Length > 0 && !double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Any, null, out var _))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsNonText(string args)
	{
		if (ComputeIsText(args) == TRUEVALUESTR)
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	public string ComputeIsError(string range)
	{
		if (SplitArgsPreservingQuotedCommas(range).Length > 1 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (range.Length > 0 && !range.StartsWith("#"))
		{
			range = GetValueFromArg(range);
		}
		range = range.ToUpper().Replace(TIC, string.Empty);
		if (range.StartsWith(double.NaN.ToString().ToUpper()) || range.StartsWith("-" + double.NaN.ToString().ToUpper()) || range.StartsWith(double.PositiveInfinity.ToString().ToUpper()) || range.StartsWith(double.NegativeInfinity.ToString().ToUpper()) || range.StartsWith("#") || range.StartsWith("n#"))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsRef(string args)
	{
		string scopedRange = string.Empty;
		if (SplitArgsPreservingQuotedCommas(args).Length != 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		return ((TryGetNamedRange(args, out scopedRange) || IsCellReference(args)) && !args.StartsWith(TIC) && !args.EndsWith(TIC)).ToString().ToUpper();
	}

	public string ComputeAnd(string range)
	{
		bool flag = true;
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments].ToString();
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string[] source = null;
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result;
			string valueFromArg;
			if (SplitArguments(text, ':').Length > 1 && IsCellReference(text.Replace(TIC, string.Empty)))
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return valueFromArg;
						}
					}
					catch (Exception)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw new ArgumentException(ErrorStrings[4].ToString());
						}
						return ErrorStrings[4].ToString();
					}
					flag &= (valueFromArg.Equals(string.Empty) ? bool.Parse(TRUEVALUESTR) : (valueFromArg == TRUEVALUESTR || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0)));
					if (!flag)
					{
						return FALSEVALUESTR;
					}
				}
				continue;
			}
			if (text.Contains(TIC) && isBracesReplaced)
			{
				if (text.IndexOfAny(tokens) > -1)
				{
					source = ComputeLogicalArrayFormula(text);
				}
				flag = !source.Contains("FALSE");
				if (!flag)
				{
					isBracesReplaced = false;
					return FALSEVALUESTR;
				}
				continue;
			}
			bool result3;
			try
			{
				valueFromArg = GetValueFromArg(text);
				DateTime result2 = dateTime1900;
				if (valueFromArg.StartsWith(TIC) && !bool.TryParse(text.Replace(TIC, string.Empty), out result3))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				if (array.Length == 1 && string.IsNullOrEmpty(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				if (DateTime.TryParse(valueFromArg, out result2))
				{
					return TRUEVALUESTR;
				}
				if (!double.TryParse(valueFromArg, out result) && !valueFromArg.Equals(string.Empty) && !bool.TryParse(valueFromArg.Replace(TIC, string.Empty), out result3))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return IsCellReference(text) ? ErrorStrings[1].ToString() : ErrorStrings[5].ToString();
				}
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			flag &= (bool.TryParse(valueFromArg.Replace(TIC, string.Empty), out result3) && result3) || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
			if (!flag)
			{
				return FALSEVALUESTR;
			}
		}
		isBracesReplaced = false;
		if (!flag)
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	private string[] ComputeLogicalArrayFormula(string range)
	{
		string text = string.Empty;
		string text2 = string.Empty;
		string text3 = string.Empty;
		string text4 = string.Empty;
		bool flag = false;
		string text5 = range.Replace('\u0092'.ToString(), string.Empty);
		int num = Array.IndexOf(FormulaErrorStrings, text5.Replace(TIC, string.Empty));
		if (text5.IndexOfAny(tokens) > -1 && num == -1)
		{
			for (int i = 0; i < text5.Length - 1; i++)
			{
				while (i != text5.Length && ((IsUpper(text5[i]) | char.IsDigit(text5[i]) | (text5[i] == 'n')) || text5[i] == parseDecimalSeparator || text5[i] == 'm'))
				{
					text4 += text5[i++];
				}
				if (text5[i] == TIC[0] && text4 == string.Empty)
				{
					int num2 = text5.Substring(i + 1).IndexOf(TIC);
					text4 = text5.Substring(i, num2 + 2);
					i = num2 + 2;
				}
				if (i != text5.Length && text5[i] == '"' && text5[i + 1] == '"')
				{
					string value = TIC + TIC;
					int num3 = text5.Substring(i + 1).IndexOf(value);
					text = text5.Substring(i + 1, num3 + 1);
					i = num3 + i + 3;
					flag = true;
				}
				else if (i != text5.Length && text5[i] == '"')
				{
					text += text5[i++];
					while (i != range.Length && text5[i] != '"')
					{
						text += text5[i++];
					}
					text = (text + text5[i++]).Replace(TIC, string.Empty) + ";";
				}
				char[] array = tokens;
				foreach (char c in array)
				{
					if (i != text5.Length && text5[i] == c)
					{
						text3 += text5[i++];
						break;
					}
				}
				if ((!text.Equals(string.Empty) && !text3.Equals(string.Empty) && !text4.Equals(string.Empty)) || i == text5.Length)
				{
					i--;
					string text6 = string.Empty;
					string[] array2 = text.Split(';')[0].Split(',');
					for (int k = 0; k <= array2.Length - 1; k++)
					{
						text6 = ((!flag) ? (text6 + GetValueFromArg('\u0092' + text4 + "n" + array2[k] + text3 + '\u0092') + ",") : (text6 + GetValueFromArg('\u0092' + text4 + array2[k] + text3 + '\u0092') + ","));
					}
					text = text6.Substring(0, text6.Length - 1) + ";";
					text4 = (text3 = string.Empty);
				}
			}
			text2 = text2 + text.Replace(";", string.Empty) + ",";
		}
		return text2.Split(',');
	}

	public string ComputeOr(string range)
	{
		bool flag = false;
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string[] source = null;
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1 && IsCellReference(text))
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return valueFromArg;
						}
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					flag |= valueFromArg.Equals(TRUEVALUESTR) || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
					if (flag)
					{
						return TRUEVALUESTR;
					}
				}
				continue;
			}
			if (IsArrayFormula && text.StartsWith(TIC) && text.EndsWith(TIC))
			{
				string[] cellsFromArgs = text.Replace(TIC, string.Empty).Split(new string[1] { ";" }, StringSplitOptions.RemoveEmptyEntries);
				foreach (string arg2 in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg2);
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return valueFromArg;
						}
					}
					catch (Exception ex2)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex2.Message;
					}
					flag |= valueFromArg.Equals(TRUEVALUESTR) || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
					if (flag)
					{
						return TRUEVALUESTR;
					}
				}
				continue;
			}
			if (text.Contains(TIC) && isBracesReplaced)
			{
				if (text.IndexOfAny(tokens) > -1)
				{
					source = ComputeLogicalArrayFormula(text);
				}
				flag = (source.Contains("TRUE") ? true : false);
				if (flag)
				{
					isBracesReplaced = false;
					return TRUEVALUESTR;
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				if (array.Length == 1 && string.IsNullOrEmpty(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				if (DateTime.TryParse(valueFromArg, out var _))
				{
					return TRUEVALUESTR;
				}
			}
			catch (Exception ex3)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex3.Message;
			}
			flag |= valueFromArg.Replace(TIC, string.Empty).ToUpper().Equals(TRUEVALUESTR) || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
			if (flag)
			{
				return TRUEVALUESTR;
			}
		}
		isBracesReplaced = false;
		if (!flag)
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	public string ComputeNot(string args)
	{
		string arg = args;
		if (args.Length > 0 && !char.IsLetter(args[0]) && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) > -1)
		{
			return FormulaErrorStrings[requires_a_single_argument];
		}
		try
		{
			arg = GetValueFromArg(arg);
			double result;
			if (arg.Equals(TRUEVALUESTR))
			{
				arg = FALSEVALUESTR;
			}
			else if (arg.Equals(FALSEVALUESTR))
			{
				arg = TRUEVALUESTR;
			}
			else if (double.TryParse(arg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
			{
				arg = ((!(Math.Abs(result) > 1E-10)) ? TRUEVALUESTR : FALSEVALUESTR);
			}
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
			{
				throw LibraryComputationException;
			}
			return ex.Message;
		}
		return arg;
	}

	public string ComputeOffSet(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		int length = array.GetLength(0);
		if (length < 3 || length > 5 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (isIndexInteriorFormula && hitCount - 1 == computedValueLevel)
		{
			isIndexInteriorFormula = false;
		}
		for (int i = 1; i < length; i++)
		{
			if (i <= length)
			{
				string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text))
				{
					return text;
				}
			}
		}
		string text2 = array[0];
		string empty = string.Empty;
		int num = 0;
		int num2 = 0;
		double result;
		if (!string.IsNullOrEmpty(array[1]))
		{
			num = (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out result) ? ((int)result) : (-1));
		}
		if (!string.IsNullOrEmpty(array[2]))
		{
			num2 = (double.TryParse(GetValueFromArg(array[2]), NumberStyles.Integer, null, out result) ? ((int)result) : (-1));
		}
		int num3 = -1;
		int num4 = -1;
		num4 = ((length < 4) ? (-1) : (double.TryParse(GetValueFromArg(array[3]), NumberStyles.Integer, null, out result) ? ((int)result) : 2));
		num3 = ((length != 5) ? (-1) : (double.TryParse(GetValueFromArg(array[4]), NumberStyles.Integer, null, out result) ? ((int)result) : 2));
		num4 = ((num4 > 0) ? (num4 - 1) : num4);
		num3 = ((num3 > 0) ? (num3 - 1) : num3);
		if (text2.StartsWith(TIC) && IsCellReference(text2.Replace(TIC, string.Empty)))
		{
			text2 = text2.Replace(TIC, string.Empty);
		}
		int num5 = text2.IndexOf(":");
		bool flag = num5 == -1;
		if (flag)
		{
			text2 = text2 + ":" + text2;
			num5 = text2.IndexOf(":");
		}
		flag = flag && num3 <= 0 && num4 <= 0;
		if (num3 == -1 && computedValueLevel == 1)
		{
			flag = true;
		}
		else if (num3 == -1 && num4 >= 0 && computedValueLevel > 1)
		{
			num3++;
		}
		else if (num4 == -1 && num3 >= 0 && computedValueLevel > 1)
		{
			num4++;
		}
		string sheetTokenFromReference = GetSheetTokenFromReference(text2);
		int num6 = RowIndex(text2.Substring(0, num5)) + num;
		int num7 = RowIndex(text2.Substring(num5 + 1)) + num;
		if (!(!RowIndex(text2.Substring(0, num5)).Equals(-1) || RowIndex(text2.Substring(num5 + 1)).Equals(-1)).Equals(RowIndex(text2.Substring(0, num5)).Equals(-1) || !RowIndex(text2.Substring(num5 + 1)).Equals(-1)) || !IsCellReference(text2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[5].ToString();
		}
		int num8 = ColIndex(text2.Substring(0, num5)) + num2;
		int num9 = ColIndex(text2.Substring(num5 + 1)) + num2;
		if (grid is ISheetData)
		{
			if (num6 == num - 1)
			{
				num6 = ((ISheetData)grid).GetFirstRow() + num;
			}
			if (num8 == num2 - 1)
			{
				num8 = ((ISheetData)grid).GetFirstColumn() + num2;
			}
			if (num7 == num - 1)
			{
				num7 = ((ISheetData)grid).GetLastRow() + num;
			}
			if (num9 == num2 - 1)
			{
				num9 = ((ISheetData)grid).GetLastColumn() + num2;
			}
		}
		if (num6 <= 0 || num8 <= 0)
		{
			return ErrorStrings[2].ToString();
		}
		if (((num4 > 0 && num3 < 0) || (num4 < 0 && num3 > 0)) && !string.IsNullOrEmpty(cell))
		{
			num6 = RowIndex(cell);
		}
		if (num9 == int.Parse(ComputeColumn(text2)) - 1)
		{
			flag = true;
		}
		empty = (flag ? ComputedValue(string.Format("{2}{0}{1}", RangeInfo.GetAlphaLabel(num8), num6, sheetTokenFromReference)) : string.Format("{4}{0}{1}:{2}{3}", RangeInfo.GetAlphaLabel(num8), num6, RangeInfo.GetAlphaLabel(num8 + num3), num6 + num4, sheetTokenFromReference));
		if (empty != null && !double.TryParse(empty.Replace(TIC, string.Empty), out var _) && DateTime.TryParse(empty, out var result3))
		{
			return GetSerialDateTimeFromDate(result3).ToString();
		}
		if (string.IsNullOrEmpty(empty) && TreatStringsAsZero)
		{
			return "0";
		}
		return empty;
	}

	public string ComputeTrue(string empty)
	{
		return TRUEVALUESTR;
	}

	public string ComputeFalse(string empty)
	{
		return FALSEVALUESTR;
	}

	public string ComputeXor(string range)
	{
		bool flag = false;
		string[] array = SplitArgsPreservingQuotedCommas(range);
		foreach (string text in array)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1 && IsCellReference(text))
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					flag ^= (valueFromArg == TRUEVALUESTR) ^ (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				if (!valueFromArg.Replace(TIC, string.Empty).ToUpper().Equals(TRUEVALUESTR) && !valueFromArg.Replace(TIC, string.Empty).ToUpper().Equals(FALSEVALUESTR) && !double.TryParse(valueFromArg, NumberStyles.Any, null, out var _))
				{
					return ErrorStrings[1].ToString();
				}
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			flag ^= valueFromArg.Replace(TIC, string.Empty).ToUpper().Equals(TRUEVALUESTR) ^ (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0);
		}
		if (!flag)
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	public string ComputeIfNA(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		string empty = string.Empty;
		string scopedRange = string.Empty;
		if (length != 2)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result;
		if (ComputeIsNA(array[0]).Equals(bool.TrueString.ToUpper()))
		{
			if (array[1].Equals(TRUEVALUESTR) || array[1].Equals(FALSEVALUESTR))
			{
				return array[1];
			}
			if (!array[1].Contains(TIC) && !IsCellReference(array[1]) && !double.TryParse(array[1], out result) && !TryGetNamedRange(array[1], out scopedRange))
			{
				return ErrorStrings[5].ToString();
			}
			empty = GetValueFromArg(array[1]);
		}
		else if (IsRange(array[0]))
		{
			empty = ErrorStrings[1].ToString();
		}
		else
		{
			if (!array[0].Contains(TIC) && !IsCellReference(array[0]) && !double.TryParse(array[0], out result) && !TryGetNamedRange(array[0], out scopedRange))
			{
				return ErrorStrings[5].ToString();
			}
			empty = GetValueFromArg(array[0]);
		}
		if (empty.StartsWith(TIC) && empty.EndsWith(TIC))
		{
			empty = empty.Substring(1, empty.Length - 2);
		}
		return empty;
	}

	public string ComputeAcos(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Acos).ToString();
	}

	public string ComputeArabic(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, "").ToUpper();
		if ((!GetValueFromArg(array[0]).Contains(TIC) && string.IsNullOrEmpty(text)) || (!IsCellReference(array[0]) && !array[0].Contains(TIC)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[5].ToString();
		}
		int num = 0;
		string text2 = null;
		long num2 = 0L;
		long num3 = 0L;
		long num4 = 0L;
		num4 = 1000L;
		for (num = 1; num <= text.Length; num++)
		{
			switch (text.Substring(num - 1, 1))
			{
			case "I":
				num3 = 1L;
				break;
			case "V":
				num3 = 5L;
				break;
			case "X":
				num3 = 10L;
				break;
			case "L":
				num3 = 50L;
				break;
			case "C":
				num3 = 100L;
				break;
			case "D":
				num3 = 500L;
				break;
			case "M":
				num3 = 1000L;
				break;
			default:
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
			num2 = ((num3 <= num4) ? (num2 + num3) : (num2 + num3 - 2 * num4));
			num4 = num3;
		}
		return num2.ToString();
	}

	public string ComputeAreas(string arg)
	{
		string scopedRange = string.Empty;
		if (arg.Contains(" "))
		{
			arg = arg.Substring(0, arg.IndexOf(" "));
		}
		if (!IsCellReference(arg) && !arg.Contains(")") && !TryGetNamedRange(arg, out scopedRange))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string[] array = SplitArguments(arg, ')');
		if (array.Length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0].Replace("(", string.Empty);
		text = text.Replace(")", string.Empty);
		string[] array2 = SplitArgsPreservingQuotedCommas(text);
		for (int i = 0; i < array2.Length; i++)
		{
			if (!IsCellReference(array2[i]) && !TryGetNamedRange(array2[i], out scopedRange))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return FormulaErrorStrings[invalid_arguments];
			}
		}
		return array2.Length.ToString();
	}

	public string ComputeAsin(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Asin);
	}

	public string ComputeAsinh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = GetValueFromArg(args);
		args = (bool.TryParse(args, out var result) ? Convert.ToInt16(result).ToString() : args);
		if (!double.TryParse(StripTics0(args), NumberStyles.Any, null, out var result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[1].ToString();
		}
		return ((double)Math.Sign(result2) * Math.Log(Math.Abs(result2) + Math.Sqrt(result2 * result2 + 1.0))).ToString();
	}

	public string ComputeAtan(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Atan).ToString();
	}

	public string ComputeAtan2(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			return FormulaErrorStrings[requires_2_args];
		}
		double result = 0.0;
		double num = 0.0;
		string text = GetValueFromArg(array[0]);
		string text2 = GetValueFromArg(array[1]);
		if (bool.TryParse(text, out var result2))
		{
			text = Convert.ToInt32(result2).ToString();
		}
		else if (text.Equals(string.Empty))
		{
			text = "0";
		}
		if (bool.TryParse(text2, out var result3))
		{
			text2 = Convert.ToInt32(result3).ToString();
		}
		else if (text2.Equals(string.Empty))
		{
			text2 = "0";
		}
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (!double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result4) || !double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[1].ToString();
		}
		if (result == 0.0 && result4 == 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[3].ToString();
		}
		return Math.Atan2(result, result4).ToString();
	}

	public string ComputeAtanh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = GetValueFromArg(args);
		args = (bool.TryParse(args, out var result) ? Convert.ToInt16(result).ToString() : args);
		double num;
		if (!double.TryParse(StripTics0(args), NumberStyles.Any, null, out var result2) || !((num = Math.Abs(result2)) < 1.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		return (0.5 * (double)Math.Sign(result2) * Math.Log((1.0 + num) / (1.0 - num))).ToString();
	}

	public string ComputeCeiling(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		array[0] = GetValueFromArg(array[0]);
		string text = ((length > 1) ? array[0] : "1");
		text = (string.IsNullOrEmpty(array[0]) ? "0" : text);
		array[1] = GetValueFromArg(array[1]);
		string text2 = ((length > 1 && array[1].Length != 0) ? array[1] : "0");
		text2 = (string.IsNullOrEmpty(array[1]) ? "0" : text2);
		bool result = false;
		bool result2 = false;
		text = (bool.TryParse(array[0].Replace(TIC, string.Empty), out result) ? Convert.ToInt32(result).ToString() : text);
		text2 = (bool.TryParse(array[1].Replace(TIC, string.Empty), out result2) ? Convert.ToInt32(result2).ToString() : text2);
		double result3 = -1.0;
		double num = -1.0;
		if (double.TryParse(GetValueFromArg(text), NumberStyles.Any, null, out var result4) && double.TryParse(GetValueFromArg(text2), NumberStyles.Any, null, out result3))
		{
			if (result4 == 0.0 || result3 == 0.0)
			{
				return "0";
			}
			if (result4 < 0.0 && ComputeRounddown(result4.ToString()) == "0" && result3 > 0.0)
			{
				return "0";
			}
			if (result4 > 0.0 && result3 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return ErrorStrings[4].ToString();
			}
			num = Math.Floor(result4 / result3) * result3;
			if (result3 > 0.0)
			{
				for (; num < result4; num += result3)
				{
				}
			}
			else
			{
				for (; num > result4; num += result3)
				{
				}
			}
		}
		return num.ToString();
	}

	public string ComputeCeilingMath(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(args) || length > 3 || length < 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string text2 = ((length > 1 && GetValueFromArg(array[1]).Length != 0) ? GetValueFromArg(array[1]).Replace(TIC, "") : "1");
		string text3 = ((length == 3 && GetValueFromArg(array[2]).Length != 0) ? GetValueFromArg(array[2]).Replace(TIC, "") : "0");
		double result = -1.0;
		double result2 = -1.0;
		double num = 0.0;
		bool result3 = false;
		bool result4 = false;
		bool result5 = false;
		valueFromArg = (bool.TryParse(valueFromArg.Replace(TIC, string.Empty), out result3) ? Convert.ToInt32(result3).ToString() : valueFromArg);
		text2 = (bool.TryParse(text2.Replace(TIC, string.Empty), out result4) ? Convert.ToInt32(result4).ToString() : text2);
		text3 = (bool.TryParse(text3.Replace(TIC, string.Empty), out result5) ? Convert.ToInt32(result5).ToString() : text3);
		_ = string.Empty;
		if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result6) && double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result) && double.TryParse(text3.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
		{
			if (result6 < 0.0 && result2 < 0.0)
			{
				result = -1.0;
			}
			if (array.Length < 2)
			{
				if (result6 > 0.0)
				{
					return ComputeRoundup(result6.ToString());
				}
				return ComputeRounddown(result6.ToString());
			}
			if (result6 == 0.0 || result == 0.0)
			{
				return "0";
			}
			if (array.Length < 3)
			{
				return double.Parse(ComputeCeiling(result6.ToString() + ParseArgumentSeparator + result)).ToString();
			}
			result6 = double.Parse(ComputeRoundup(result6.ToString()));
			num = double.Parse(ComputeRoundup((result6 / result).ToString())) * result;
			if (result6 < 0.0 && result6 % 2.0 != 0.0 && result2 == 0.0)
			{
				num += result;
			}
		}
		return num.ToString();
	}

	public string ComputeColumns(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 1 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = -1.0;
		string scopedRange = string.Empty;
		if (double.TryParse(array[0], out result))
		{
			return "1";
		}
		if ((array[0].Contains(TIC) && !array[0].Contains(";") && !array[0].Contains(ParseArgumentSeparator.ToString())) || (!IsCellReference(array[0]) && !TryGetNamedRange(array[0], out scopedRange) && !arg.Contains(";") && !arg.Contains(ParseArgumentSeparator.ToString())))
		{
			array[0] = GetValueFromArg(arg);
			if (ErrorStrings.Contains(array[0]))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return array[0];
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		int num = 1;
		if (arg.IndexOf(':') > -1)
		{
			string[] cellsFromArgs = GetCellsFromArgs(arg);
			int num2 = ColIndex(cellsFromArgs[0].ToString());
			num = ColIndex(cellsFromArgs[^1].ToString()) - num2 + 1;
			num = ((num <= 0) ? 1 : num);
		}
		else if (arg.IndexOf(';') > -1)
		{
			string[] array2 = SplitArguments(arg.Replace(TIC, ""), ';');
			for (int i = 1; i < array2.Length; i++)
			{
				if (SplitArgsPreservingQuotedCommas(array2[i - 1]).Length != SplitArgsPreservingQuotedCommas(array2[1]).Length)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
					}
					return FormulaErrorStrings[wrong_number_arguments];
				}
				num = SplitArgsPreservingQuotedCommas(array2[0]).Length;
			}
		}
		else
		{
			num = SplitArgsPreservingQuotedCommas(array[0].Replace(TIC, string.Empty)).Length;
		}
		return num.ToString();
	}

	public string ComputeCombin(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
			}
			return FormulaErrorStrings[requires_2_args];
		}
		array[0] = (string.IsNullOrEmpty(GetValueFromArg(array[0])) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(GetValueFromArg(array[1])) ? "0" : array[1]);
		double num = 0.0;
		if (array[0].Replace(TIC, string.Empty).Equals(string.Empty) || array[1].Replace(TIC, string.Empty).Equals(string.Empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (double.TryParse(GetValueFromArg(array[0]).Replace(TIC, string.Empty), NumberStyles.Any, null, out var result) && double.TryParse(GetValueFromArg(array[1]).Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2))
		{
			int num2 = (int)(result2 + 0.1);
			int num3 = (int)(result + 0.1);
			if (num3 < num2 || num2 < 0 || num3 < 0 || result2 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			return comb(num2, num3).ToString();
		}
		if ((array[0].StartsWith(TIC) || array[1].StartsWith(TIC)) && (!IsCellReference(array[0]) || !IsCellReference(array[1])))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[5].ToString());
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeCombinA(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (argList.Contains("u"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(errorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (argList.Length > 15)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		array[0] = (string.IsNullOrEmpty(GetValueFromArg(array[0])) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(GetValueFromArg(array[1])) ? "0" : array[1]);
		int num = Convert.ToInt32(GetValueFromArg(array[0]));
		int num2 = Convert.ToInt32(GetValueFromArg(array[1]));
		if (Convert.ToInt32(num) == 0 && Convert.ToInt32(num2) == 0)
		{
			return "1";
		}
		string argList2 = num + num2 - 1 + "," + (num - 1);
		return ComputeCombin(argList2);
	}

	public string ComputeLog(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		double result2 = 10.0;
		double result3 = 10.0;
		if (length == 2)
		{
			string valueFromArg2 = GetValueFromArg(array[1]);
			if (string.IsNullOrEmpty(valueFromArg) || string.IsNullOrEmpty(valueFromArg2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_index]);
				}
				return ErrorStrings[4].ToString();
			}
			valueFromArg2 = (bool.TryParse(valueFromArg2, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2);
			if (double.TryParse(GetValueFromArg(array[0]), NumberStyles.Any, null, out result2) && result2 > 0.0 && (length == 1 || double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result3)))
			{
				return Math.Log(result2, result3).ToString();
			}
			if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2) && double.TryParse(valueFromArg2, NumberStyles.Any, null, out result3))
			{
				double num = Math.Log10(result2);
				double num2 = Math.Log10(result3);
				if (ComputeIsErr(num.ToString()) == TRUEVALUESTR || ComputeIsErr(num2.ToString()) == TRUEVALUESTR)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[4].ToString();
				}
				if (ComputeIsErr((num / num2).ToString()) == TRUEVALUESTR)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[3].ToString();
				}
				return (num / num2).ToString();
			}
		}
		else if (double.TryParse(GetValueFromArg(array[0]), NumberStyles.Any, null, out result2) && result2 > 0.0 && (length == 1 || double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out result3)))
		{
			return Math.Log(result2, result3).ToString();
		}
		return ComputeMath(argList, Math.Log10).ToString();
	}

	public string ComputeLog10(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Log10).ToString();
	}

	public string ComputeExp(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		args = ((string.IsNullOrEmpty(GetValueFromArg(args)) && TreatStringsAsZero) ? "0" : args);
		return ComputeMath(args, Math.Exp).ToString();
	}

	public string ComputeSqrtpi(string args)
	{
		string empty = string.Empty;
		string result = string.Empty;
		if (SplitArgsPreservingQuotedCommas(args).GetLength(0) > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result2;
		if (args.Length > 0 && !char.IsLetter(args[0]) && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) == -1)
		{
			if (!double.TryParse(GetValueFromArg(args), NumberStyles.Any, null, out result2))
			{
				return ErrorStrings[1].ToString();
			}
			if (result2 < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			result = ComputeSqrt((result2 * Math.PI).ToString());
		}
		else if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(tokens) > -1))
		{
			args = args.Replace('{', '(');
			args = args.Replace('}', ')');
			try
			{
				empty = GetValueFromArg(args).Replace(TIC, string.Empty);
			}
			catch
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return FormulaErrorStrings[26];
			}
			if (!double.TryParse(empty, NumberStyles.Any, null, out result2) || !(result2 >= 0.0))
			{
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
				return ErrorStrings[4].ToString();
			}
			result = ComputeSqrt((result2 * Math.PI).ToString());
		}
		else
		{
			string[] cellsFromArgs = GetCellsFromArgs(args);
			foreach (string arg in cellsFromArgs)
			{
				try
				{
					empty = GetValueFromArg(arg).Replace(TIC, string.Empty);
				}
				catch
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return FormulaErrorStrings[26];
				}
				if (empty.Length > 0)
				{
					if (double.TryParse(empty, NumberStyles.Any, null, out result2) && result2 >= 0.0)
					{
						result = ComputeSqrt((result2 * Math.PI).ToString());
						break;
					}
					if (ErrorStrings.Contains(empty))
					{
						return empty;
					}
					return ErrorStrings[4].ToString();
				}
			}
		}
		return result;
	}

	public string ComputeSqrt(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Sqrt).ToString();
	}

	public string ComputeAbs(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Abs).ToString();
	}

	public string ComputeCos(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Cos).ToString();
	}

	public string ComputeAcosh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = GetValueFromArg(args);
		args = (bool.TryParse(args, out var result) ? Convert.ToInt16(result).ToString() : args);
		double.TryParse(StripTics0(args), NumberStyles.Any, null, out var result2);
		if (!(result2 >= 1.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		return Math.Log(result2 + Math.Sqrt(result2 * result2 - 1.0)).ToString();
	}

	public string ComputeRand(string args)
	{
		SplitArgsPreservingQuotedCommas(args);
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.None);
		if (FormulaErrorStrings[invalid_arguments] == text)
		{
			return text;
		}
		if (rand == null)
		{
			rand = new Random();
		}
		return rand.NextDouble().ToString("0.0#############");
	}

	public string ComputeTan(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Tan).ToString();
	}

	public string ComputeTanh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Tanh).ToString();
	}

	private bool CheckCriteria(char op, string s, string criteria)
	{
		s = GetValueFromArg(s);
		if (s.ToUpper().Replace(TIC, "") == criteria.ToUpper())
		{
			return true;
		}
		return false;
	}

	private bool CheckCriteria(char op, string s, double compare)
	{
		DateTime result2;
		double result;
		switch (op)
		{
		case 'e':
			s = GetValueFromArg(s);
			if (double.TryParse(s, out result))
			{
				if (result == compare)
				{
					return true;
				}
			}
			else if (DateTime.TryParse(s, out result2))
			{
				result = GetSerialDateTimeFromDate(result2);
				if (result == compare)
				{
					return true;
				}
			}
			break;
		case 'j':
			s = GetValueFromArg(s);
			if (double.TryParse(s, out result))
			{
				if (result >= compare)
				{
					return true;
				}
			}
			else if (DateTime.TryParse(s, out result2))
			{
				result = GetSerialDateTimeFromDate(result2);
				if (result >= compare)
				{
					return true;
				}
			}
			break;
		case 'g':
			s = GetValueFromArg(s);
			if (double.TryParse(s, out result))
			{
				if (result > compare)
				{
					return true;
				}
			}
			else if (DateTime.TryParse(s, out result2))
			{
				result = GetSerialDateTimeFromDate(result2);
				if (result > compare)
				{
					return true;
				}
			}
			break;
		case 'l':
			s = GetValueFromArg(s);
			if (double.TryParse(s, out result))
			{
				if (result < compare)
				{
					return true;
				}
			}
			else if (DateTime.TryParse(s, out result2))
			{
				result = GetSerialDateTimeFromDate(result2);
				if (result < compare)
				{
					return true;
				}
			}
			break;
		case 'k':
			s = GetValueFromArg(s);
			if (double.TryParse(s, out result))
			{
				if (result <= compare)
				{
					return true;
				}
			}
			else if (DateTime.TryParse(s, out result2))
			{
				result = GetSerialDateTimeFromDate(result2);
				if (result <= compare)
				{
					return true;
				}
			}
			break;
		default:
			return false;
		}
		return false;
	}

	public string ComputeSumif(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0];
		string text2 = array[1];
		if (text2.Length < 1)
		{
			return "0";
		}
		char op = 'e';
		if (text2[0] != TIC[0] && "=><".IndexOf(text2[0]) == -1)
		{
			text2 = GetValueFromArg(text2);
		}
		text2 = findCriteria(text2, ref op);
		string text3 = ((length == 2) ? text : array[2]);
		string[] cellsFromArgs = GetCellsFromArgs(text);
		string[] cellsFromArgs2 = GetCellsFromArgs(text3);
		if (cellsFromArgs[0].Equals(ErrorStrings[5]) || cellsFromArgs2[0].Equals(ErrorStrings[5]))
		{
			return ErrorStrings[5].ToString();
		}
		int length2 = cellsFromArgs.GetLength(0);
		if (length2 > cellsFromArgs2.GetLength(0))
		{
			string text4 = SheetToken(text3.Replace(TIC, string.Empty));
			if (!string.IsNullOrEmpty(text4))
			{
				text3 = text3.Replace(text4, string.Empty);
			}
			int num = text3.IndexOf(':');
			int num2 = text.IndexOf(':');
			int startRow = RowIndex(text.Substring(0, num2));
			int endRow = RowIndex(text.Substring(num2 + 1));
			int startCol = ColIndex(text.Substring(0, num2));
			int endCol = ColIndex(text.Substring(num2 + 1));
			if (!(!startRow.Equals(-1) || endRow.Equals(-1)).Equals(startRow.Equals(-1) || !endRow.Equals(-1)))
			{
				return ErrorStrings[5].ToString();
			}
			FindRowColIndex(ref startRow, ref endRow, ref startCol, ref endCol);
			int num3 = endRow - startRow;
			int num4 = endCol - startCol;
			if (num > -1)
			{
				int startRow2 = RowIndex(text3.Substring(0, num));
				int endRow2 = RowIndex(text3.Substring(num + 1));
				if (!(!startRow2.Equals(-1) || endRow2.Equals(-1)).Equals(startRow2.Equals(-1) || !endRow2.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				int startCol2 = ColIndex(text3.Substring(0, num));
				int endCol2 = ColIndex(text3.Substring(num + 1));
				FindRowColIndex(ref startRow2, ref endRow2, ref startCol2, ref endCol2);
				int num5 = endCol2 - startCol2;
				int num6 = endRow2 - startRow2;
				if (num5 != num4)
				{
					endCol2 = startCol2 + num4;
				}
				if (num6 != num3)
				{
					endRow2 = startRow2 + num3;
				}
				text3 = text4 + RangeInfo.GetAlphaLabel(startCol2) + text3.Substring(1, num) + RangeInfo.GetAlphaLabel(endCol2) + endRow2;
			}
			else
			{
				int num7 = 0;
				string empty = string.Empty;
				num7 = RowIndex(text3);
				int num8 = ColIndex(text3);
				num7 += num3;
				empty = RangeInfo.GetAlphaLabel(num8 + num4);
				text3 = text3 + ":" + empty + num7;
			}
			cellsFromArgs2 = GetCellsFromArgs(text3);
		}
		double num9 = 0.0;
		double result = 0.0;
		string empty2 = string.Empty;
		double result2 = double.MinValue;
		bool isNumber = double.TryParse(text2, NumberStyles.Any, CultureInfo.CurrentCulture, out result2);
		for (int i = 0; i < length2; i++)
		{
			empty2 = GetValueFromArg(cellsFromArgs[i]);
			if (ErrorStrings.Contains(empty2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[invalid_arguments]);
				}
				return empty2;
			}
			if (CheckForCriteriaMatch(empty2.ToUpper(), op, text2.ToUpper(), isNumber, result2))
			{
				empty2 = cellsFromArgs2[i];
				empty2 = GetValueFromArg(empty2);
				if (double.TryParse(empty2, NumberStyles.Any, null, out result))
				{
					num9 += result;
				}
			}
		}
		return num9.ToString();
	}

	private void FindRowColIndex(ref int startRow, ref int endRow, ref int startCol, ref int endCol)
	{
		if (startRow == -1)
		{
			startRow = ((ISheetData)grid).GetFirstRow();
		}
		if (startCol == -1)
		{
			startCol = ((ISheetData)grid).GetFirstColumn();
		}
		if (endRow == -1)
		{
			endRow = ((ISheetData)grid).GetLastRow();
		}
		if (endCol == -1)
		{
			endCol = ((ISheetData)grid).GetLastColumn();
		}
	}

	public string ComputeAsc(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		char[] array2 = StripTics0(GetValueFromArg(array[0])).ToCharArray();
		for (int i = 0; i < array2.Length; i++)
		{
			if (array2[i] == '\u3000')
			{
				array2[i] = ' ';
			}
			else if (array2[i] > '\uff00' && array2[i] < '')
			{
				array2[i] = (char)(array2[i] - 65248);
			}
		}
		return new string(array2);
	}

	public string ComputeAcot(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		argList = (bool.TryParse(argList, out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (double.TryParse(StripTics0(argList), out var _))
		{
			double result3 = 0.0;
			double num = 0.0;
			if (double.TryParse(StripTics0(argList), out result3))
			{
				num = ((!(result3 <= 0.0)) ? Math.Atan(1.0 / result3) : (Math.PI / 2.0 - Math.Atan(result3)));
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeAcoth(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).GetLength(0) > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		if (double.TryParse(StripTics0(argList), out var result))
		{
			string text2 = (Math.Log((result + 1.0) / (result - 1.0)) / 2.0).ToString();
			if (ComputeIsErr(text2) == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			return text2;
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeAsech(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.StartsWith(TIC) && argList.EndsWith(TIC))
		{
			argList = argList.Replace(TIC, string.Empty);
		}
		if (argList == string.Empty)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text = argList;
			text = (text.Contains("u") ? text.Replace("u", string.Empty) : text);
			if (Convert.ToDouble(text) > 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			if (double.TryParse(argList, out var result))
			{
				return Math.Log((Math.Sqrt((0.0 - result) * result + 1.0) + 1.0) / result).ToString();
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[5].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeBase(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length < 2 || length > 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 1;
		try
		{
			array[0] = GetValueFromArg(array[0]);
			array[1] = GetValueFromArg(array[1]);
			array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
			array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
			array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
			array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
			if (length == 3)
			{
				array[2] = GetValueFromArg(array[2]);
				array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
				array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
			}
			num = int.Parse(GetValueFromArg(array[0]).Replace(TIC, ""));
			num2 = int.Parse(GetValueFromArg(array[1]).Replace(TIC, ""));
			num3 = ((length != 3) ? 1 : int.Parse(array[2].Replace(TIC, "")));
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument] + ex.Message);
			}
			return ErrorStrings[5].ToString();
		}
		if (num < 0 || num2 < 2 || num2 > "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".Length || num3 < 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
			}
			return ErrorStrings[4].ToString();
		}
		if (num == 0)
		{
			return "0";
		}
		int num4 = 63;
		long num5 = Math.Abs(num);
		char[] array2 = new char[64];
		while (num5 != 0L)
		{
			int index = (int)(num5 % num2);
			array2[num4--] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[index];
			num5 /= num2;
		}
		string text2 = new string(array2, num4 + 1, 64 - num4 - 1);
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < num3 - text2.Length; i++)
		{
			stringBuilder.Append("0");
		}
		text2 = stringBuilder.ToString() + text2;
		if (num < 0)
		{
			text2 = "-" + text2;
		}
		return text2.ToString();
	}

	public string ComputeCosh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Cosh).ToString();
	}

	public string ComputeCot(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		if (argList == "0")
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		string text3 = ComputeMath(argList, Math.Tan);
		if (text3 != "#NUM!" || text3 != "#VALUE!")
		{
			text3 = (1m / Convert.ToDecimal(text3)).ToString();
		}
		return text3;
	}

	public string ComputeCoth(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		int length = array.GetLength(0);
		bool flag = false;
		if (length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			if (text2.Contains("-"))
			{
				flag = true;
			}
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		if (argList == "0")
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		argList = (argList.Contains("-") ? argList.Replace("-", string.Empty) : argList);
		string text3 = ComputeMath(argList, Math.Tanh);
		if (text3 != "#NUM!" || text3 != "#VALUE!")
		{
			text3 = (1m / Convert.ToDecimal(text3)).ToString();
		}
		if (flag)
		{
			text3 = "-" + text3;
		}
		return text3;
	}

	public string ComputeCsc(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		if (argList == "0")
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		string text3 = ComputeMath(argList, Math.Sin);
		if (text3 != "#NUM!" || text3 != "#VALUE!")
		{
			text3 = (1m / Convert.ToDecimal(text3)).ToString();
		}
		return text3;
	}

	public string ComputeCsch(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		if (argList == "0")
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		argList = (argList.Contains("-") ? argList.Replace("-", string.Empty) : argList);
		if (double.TryParse(argList, out var result2))
		{
			return (2.0 / (Math.Exp(result2) - Math.Exp(0.0 - result2))).ToString();
		}
		return ErrorStrings[5].ToString();
	}

	public string ComputeDecimal(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) > 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int num = 0;
		string text;
		try
		{
			text = GetValueFromArg(array[0]).Replace(TIC, "");
			num = int.Parse(GetValueFromArg(array[1]).Replace(TIC, ""));
		}
		catch (Exception ex)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument] + ex.Message);
			}
			return ErrorStrings[1].ToString();
		}
		if (num < 2 || num > "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/".Length)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
			}
			return ErrorStrings[4].ToString();
		}
		text = text.Trim();
		if (num <= 36)
		{
			text = text.ToUpper();
		}
		int i = 0;
		long num2 = 0L;
		if ((text.Contains("e") || text.Contains("E")) && double.TryParse(text, out var _))
		{
			text = decimal.Parse(text, NumberStyles.Any).ToString();
		}
		for (; i < text.Length && !char.IsWhiteSpace(text[i]); i++)
		{
			string value = text.Substring(i, 1);
			int num3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/".IndexOf(value);
			if (num3 >= 0 && num3 < num)
			{
				num2 *= num;
				num2 += num3;
				continue;
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
			}
			return ErrorStrings[4].ToString();
		}
		return num2.ToString();
	}

	public string ComputeDegrees(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		if (!double.TryParse(GetValueFromArg(args), NumberStyles.Any, null, out var result2))
		{
			if (ComputeIsText(args).ToString() == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[5].ToString());
				}
				return ErrorStrings[5].ToString();
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		return (180.0 * result2 / Math.PI).ToString();
	}

	public string ComputeEven(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		if (double.TryParse(GetValueFromArg(args.Replace(TIC, string.Empty)), NumberStyles.Any, null, out var result2))
		{
			int num2 = Math.Sign(result2);
			result2 = Math.Abs(result2);
			if ((double)(int)result2 != result2)
			{
				result2 = (int)(result2 + 1.0);
			}
			num = ((result2 % 2.0 != 1.0) ? ((double)num2 * result2) : ((double)num2 * (result2 + 1.0)));
		}
		return num.ToString();
	}

	public string ComputeFact(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		double.TryParse(GetValueFromArg(args).Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2);
		if (result2 < 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[4].ToString();
		}
		int num2 = (int)result2;
		if (num2 > 12)
		{
			num = factorialTable[12];
			for (int i = 13; i <= num2; i++)
			{
				num *= (double)i;
			}
		}
		else
		{
			num = factorialTable[num2];
		}
		return num.ToString();
	}

	public string ComputeFactdouble(string args)
	{
		double num = 1.0;
		if (SplitArgsPreservingQuotedCommas(args).GetLength(0) > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (!double.TryParse(GetValueFromArg(args).Replace(TIC, string.Empty), NumberStyles.Any, null, out var result))
		{
			if (!args.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		else
		{
			if (result < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			int num2 = (int)result;
			int num3 = num2;
			if (num2 <= 3)
			{
				num = ((num2 != 0) ? ((double)num2) : 1.0);
			}
			else
			{
				while (num3 > 0)
				{
					num *= (double)num3;
					num3 -= 2;
				}
			}
		}
		return num.ToString();
	}

	public string ComputeFloor(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Date);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double num = 0.0;
		string text2 = GetValueFromArg(array[0]).ToString();
		string text3 = GetValueFromArg(array[1]).ToString();
		if (TryParseExactDateTime(text2.Replace(TIC, string.Empty), out var result3))
		{
			result = GetSerialDateTimeFromDate(result3) - GetSerialDateTimeFromDate(DateTime.Today);
		}
		else if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
		{
			result = result;
		}
		if (TryParseExactDateTime(text3.Replace(TIC, string.Empty), out result3))
		{
			result2 = GetSerialDateTimeFromDate(result3) - GetSerialDateTimeFromDate(DateTime.Today);
		}
		else if (double.TryParse(text3.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
		{
			result2 = result2;
		}
		if (result == 0.0)
		{
			return num.ToString();
		}
		if (result * result2 <= 0.0 && !(result < 0.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return CalculateFloorValue(result, result2).ToString();
	}

	private double CalculateFloorValue(double d1, double d2)
	{
		double num = 0.0;
		num = Math.Ceiling(d1 / d2) * d2;
		if (d2 > 0.0)
		{
			while (num > d1)
			{
				num -= d2;
			}
		}
		else
		{
			while (num < d1)
			{
				num -= d2;
			}
		}
		if (d2 == 0.1)
		{
			num = d1;
		}
		return num;
	}

	public string ComputeFormulaText(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		string empty = string.Empty;
		if (length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = array[0];
		if (NamedRanges.ContainsValue(empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_index]);
			}
			return ErrorStrings[1].ToString();
		}
		empty = GetValueFromParentObject(empty, calculateFormula: false);
		if (string.IsNullOrEmpty(empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		if (empty[0] != '=')
		{
			return ErrorStrings[0].ToString();
		}
		return empty;
	}

	public string ComputeGcd(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		List<int> list = new List<int>();
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException("Wrong number of arguments");
			}
			FormulaErrorStrings[25].ToString();
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result;
			if (text.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				int num = 0;
				if (num >= cellsFromArgs.Length)
				{
					continue;
				}
				string text2 = cellsFromArgs[num];
				string valueFromArg = GetValueFromArg(text2);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException("Passed arguments contains invalid argument");
					}
					return valueFromArg;
				}
				if ((double.TryParse(GetValueFromArg(text2).Replace(TIC, string.Empty), NumberStyles.Any, null, out result) || text2.Length > 0) && (int)result > 0)
				{
					list.Add((int)result);
				}
				else if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException("Passed arguments contains invalid argument");
				}
				return ErrorStrings[4].ToString();
			}
			string valueFromArg2 = GetValueFromArg(text);
			if (ErrorStrings.Contains(valueFromArg2))
			{
				return valueFromArg2;
			}
			if (!IsCellReference(text) && string.IsNullOrEmpty(valueFromArg2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException("Passed arguments contains invalid argument");
				}
				return ErrorStrings[0].ToString();
			}
			if (!double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
			{
				if (!IsCellReference(text) && !text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentNullException("Passed arguments contains invalid argument");
					}
					return ErrorStrings[5].ToString();
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException("Passed arguments contains invalid argument");
				}
				return ErrorStrings[1].ToString();
			}
			if (result >= 0.0)
			{
				list.Add((int)result);
				continue;
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException("Passed arguments contains invalid argument");
			}
			return ErrorStrings[4].ToString();
		}
		if (list.Count == 1)
		{
			return list[0].ToString();
		}
		for (int j = 0; j < list.Count - 1; j++)
		{
			while (list[1] != 0)
			{
				int value = list[0] % list[1];
				list[0] = list[1];
				list[1] = value;
			}
			if (list.Count > 2 && j < list.Count - 2)
			{
				list[1] = list[j + 2];
			}
		}
		return list[0].ToString();
	}

	public string ComputeHyperlink(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length > 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string result = StripTics0(GetValueFromArg(array[0]));
		if (length == 2)
		{
			string text = StripTics0(GetValueFromArg(array[1]));
			if (text == null)
			{
				return "0";
			}
			if (text == string.Empty)
			{
				return string.Empty;
			}
			return text;
		}
		return result;
	}

	public string ComputeInt(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (range.Contains(":") && exteriorFormula)
		{
			string empty = string.Empty;
			empty += "{";
			string[] array2 = null;
			array2 = GetCellsFromArgs(range);
			for (int i = 0; i < array2.Length; i++)
			{
				empty = empty + ComputeInt(array2[i]) + ";";
			}
			empty = empty.Remove(empty.Length - 1) + "}";
			return "\u0092" + empty + "\u0092";
		}
		if (array.Length > 1 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		range = GetValueFromArg(range);
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		range = (bool.TryParse(range, out var result) ? Convert.ToInt16(result).ToString() : range);
		if (double.TryParse(range, NumberStyles.Any, null, out var result2))
		{
			return Math.Floor(result2).ToString("F0");
		}
		return "0";
	}

	public string ComputeIsEven(string args)
	{
		_ = string.Empty;
		double result = 0.0;
		if (SplitArguments(args, ParseArgumentSeparator).GetLength(0) != 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (!args.Equals(string.Empty))
		{
			if (args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) != -1)
			{
				return "#VALUE!";
			}
			PutTokensForSheets(ref args);
			if (double.TryParse(GetValueFromArg(args).Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
			{
				if ((int)result % 2 == 0)
				{
					return TRUEVALUESTR;
				}
				return FALSEVALUESTR;
			}
			return ErrorStrings[1].ToString();
		}
		return TRUEVALUESTR;
	}

	public string ComputeIsNumber(string range)
	{
		range = GetValueFromArg(range);
		if (double.TryParse(range, NumberStyles.Any, null, out var result) && !double.IsNaN(result))
		{
			return TRUEVALUESTR;
		}
		return FALSEVALUESTR;
	}

	public string ComputeIsOdd(string args)
	{
		_ = string.Empty;
		double result = 0.0;
		if (SplitArguments(args, ParseArgumentSeparator).GetLength(0) != 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (!args.Equals(string.Empty))
		{
			if (args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) != -1)
			{
				return "#VALUE!";
			}
			if (double.TryParse(GetValueFromArg(args).Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
			{
				if ((int)result % 2 != 0)
				{
					return TRUEVALUESTR;
				}
				return FALSEVALUESTR;
			}
			return ErrorStrings[1].ToString();
		}
		return TRUEVALUESTR;
	}

	public string ComputeLcm(string range)
	{
		int num = 0;
		int num2 = 0;
		string empty = string.Empty;
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string[] array2;
		if (array.Length != 0)
		{
			array2 = array;
			foreach (string text in array2)
			{
				num2++;
				if (text.IndexOf(':') > -1)
				{
					num2--;
					string[] cellsFromArgs = GetCellsFromArgs(text);
					for (int j = 0; j < cellsFromArgs.Length; j++)
					{
						_ = cellsFromArgs[j];
						num2++;
					}
				}
			}
		}
		int[] array3 = new int[num2];
		array2 = array;
		foreach (string text2 in array2)
		{
			double result;
			if (text2.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text2);
				foreach (string text3 in cellsFromArgs)
				{
					if (!double.TryParse(GetValueFromArg(text3).Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
					{
						return ErrorStrings[1].ToString();
					}
					if (text3.Length > 0 && (int)result >= 0)
					{
						array3[num] = (int)result;
						num++;
						continue;
					}
					return ErrorStrings[4].ToString();
				}
			}
			else
			{
				if (!double.TryParse(GetValueFromArg(text2).Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
				{
					return ErrorStrings[1].ToString();
				}
				if (text2.Length <= 0)
				{
					return ErrorStrings[4].ToString();
				}
				array3[num] = (int)result;
				num++;
			}
		}
		if (array3.Length == 1)
		{
			return array3[0].ToString();
		}
		int num3 = array3[0] * array3[1];
		empty = array3[0].ToString() + ParseArgumentSeparator + array3[1];
		string s = ComputeGcd(empty);
		int num4 = num3 / int.Parse(s);
		for (int k = 2; k < array3.Length; k++)
		{
			int num5 = num4 * array3[k];
			empty = num4.ToString() + ParseArgumentSeparator + array3[k];
			s = ComputeGcd(empty);
			num4 = num5 / int.Parse(s);
		}
		return num4.ToString();
	}

	public string ComputeLn(string argList)
	{
		string empty = string.Empty;
		string text = string.Empty;
		if (SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (argList.Contains(":"))
		{
			string[] cellsFromArgs = GetCellsFromArgs(argList);
			for (int i = 0; i < cellsFromArgs.Length; i++)
			{
				empty = GetValueFromArg(cellsFromArgs[i]);
				if (empty.Length > 0)
				{
					if (!double.TryParse(empty, NumberStyles.Number | NumberStyles.AllowExponent, null, out var _))
					{
						return ErrorStrings[1].ToString();
					}
					empty = ((i != cellsFromArgs.Length - 1) ? (ComputeMath(empty, Math.Log).ToString() + parseArgumentSeparator) : ComputeMath(empty, Math.Log).ToString());
					text += empty;
				}
			}
			if (!text.StartsWith(TIC) && !text.EndsWith(TIC))
			{
				text = TIC + text + TIC;
			}
			return text;
		}
		if (!argList.StartsWith(TIC))
		{
			return ComputeMath(argList, Math.Log).ToString();
		}
		return ErrorStrings[1].ToString();
	}

	private string ComputeMath(string args, MathFunc func)
	{
		double num = 0.0;
		bool flag = false;
		if (args.Length > 0)
		{
			args = SplitArgsPreservingQuotedCommas(args)[0];
		}
		double result;
		if (args.Length > 0 && ((!char.IsLetter(args[0]) && args[0] != '!' && args[0] != '\u0092') || (args[0] == 'u' && char.IsDigit(args[1]))) && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) == -1)
		{
			args = args.Replace('u', '-').Replace("n", string.Empty);
			if (double.TryParse(args.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
			{
				num = func(result);
			}
		}
		else if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(tokens) > -1))
		{
			args = args.Replace('{', '(');
			args = args.Replace('}', ')');
			string text = string.Empty;
			string value = Math.PI.ToString("R");
			string text2;
			try
			{
				if (args.Contains(value) && !ComputedValue(args).Equals(value))
				{
					text2 = args.Substring(1, args.IndexOf(value) - 2);
					text2 = (string.IsNullOrEmpty(text2) ? "1" : text2);
					text = ((args.IndexOfAny(tokens) > -1) ? args.Substring(args.IndexOf(value) - 1) : "1");
					flag = true;
				}
				else
				{
					text2 = ComputedValue(args);
				}
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex.Message;
			}
			if (flag)
			{
				string text3 = text2;
				string text4 = ComputedValue(text3 + text);
				if (text4 == Math.PI.ToString())
				{
					num = func(Math.PI);
				}
				else
				{
					if (!double.TryParse(text4, out var result2))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return ErrorStrings[1].ToString();
					}
					num = func(result2);
				}
			}
			else
			{
				if (!double.TryParse(text2, out result))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				num = func(result);
			}
		}
		else
		{
			args = args.Replace('u', '-');
			string[] cellsFromArgs = GetCellsFromArgs(args);
			int num2 = 0;
			if (num2 < cellsFromArgs.Length)
			{
				string arg = cellsFromArgs[num2];
				string text2;
				try
				{
					text2 = GetValueFromArg(arg);
				}
				catch (Exception ex2)
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return ex2.Message;
				}
				if (text2.Length > 0 && double.TryParse(text2, NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
				{
					num = func(result);
				}
			}
		}
		if (!ExcelLikeComputations && num.ToString() == Convert.ToString(double.NaN))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return num.ToString();
		}
		if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			if (!ExcelLikeComputations)
			{
				return num.ToString();
			}
			return ErrorStrings[4].ToString();
		}
		return num.ToString();
	}

	public string ComputeMdeterm(string arg)
	{
		if (SplitArgsPreservingQuotedCommas(arg).Length != 1 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(arg, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(arg) && !TryGetNamedRange(arg, out scopedRange) && !arg.Contains(";"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		double num = 0.0;
		if (arg.IndexOf(':') > -1)
		{
			string[] cellsFromArgs = GetCellsFromArgs(arg);
			int num2 = 0;
			int num3 = int.Parse(ComputeRows(arg));
			int num4 = int.Parse(ComputeColumns(arg));
			if (num3 != num4)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			int num5 = num3;
			double[,] array = new double[num3, num4];
			for (int i = 0; i < num5; i++)
			{
				for (int j = 0; j < num5; j++)
				{
					array[i, j] = double.Parse(GetValueFromArg(cellsFromArgs[num2]));
					num2++;
				}
			}
			num = Determinant(array, num5);
		}
		else if (arg.IndexOf(';') > -1)
		{
			string[] array2 = SplitArguments(arg.Replace(TIC, ""), ';');
			int num6 = SplitArgsPreservingQuotedCommas(array2[0]).Length;
			if (array2.Length != num6)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			double[,] array3 = new double[array2.Length, num6];
			int num7 = num6;
			int num8 = 0;
			for (int k = 0; k < array2.Length; k++)
			{
				string[] array4 = SplitArgsPreservingQuotedCommas(array2[k]);
				num8 = array4.Length;
				if (num7 != num8)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
					}
					return FormulaErrorStrings[wrong_number_arguments];
				}
				for (int l = 0; l < num7; l++)
				{
					array3[k, l] = double.Parse(GetValueFromArg(array4[l]));
				}
			}
			num = Determinant(array3, array2.Length);
		}
		return num.ToString();
	}

	internal void GetCofactor(double[,] matrix, out double[,] iMatrix)
	{
		int length = matrix.GetLength(0);
		iMatrix = new double[matrix.GetLength(0), matrix.GetLength(1)];
		Cofactor(matrix, length, out iMatrix);
	}

	public string ComputeMInverse(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (string.IsNullOrEmpty(array[0].Replace(TIC, string.Empty)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(array[0]) && !TryGetNamedRange(array[0], out scopedRange) && !array[0].Contains(";") && !double.TryParse(array[0].Replace(TIC, ""), out var _))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			if (!array[0].StartsWith(TIC))
			{
				return ErrorStrings[5].ToString();
			}
			return ErrorStrings[1].ToString();
		}
		double num = 0.0;
		if (arg.IndexOf(':') > -1)
		{
			string[] cellsFromArgs = GetCellsFromArgs(array[0]);
			int num2 = 0;
			int num3 = int.Parse(ComputeRows(array[0]));
			int num4 = int.Parse(ComputeColumns(array[0]));
			if (num3 != num4)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			int num5 = num3;
			double[,] array2 = new double[num3, num4];
			for (int i = 0; i < num5; i++)
			{
				for (int j = 0; j < num5; j++)
				{
					if (double.TryParse(GetValueFromArg(cellsFromArgs[num2]), out var result2))
					{
						array2[i, j] = result2;
						num2++;
						continue;
					}
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[1].ToString();
				}
			}
			double[,] inverse = array2;
			if (Determinant(array2, num5) == 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			Cofactor(array2, num5, out inverse);
			if (computedValueLevel > 1)
			{
				string empty = string.Empty;
				string text = string.Empty;
				int num6 = 0;
				double[,] array3 = inverse;
				int upperBound = array3.GetUpperBound(0);
				int upperBound2 = array3.GetUpperBound(1);
				for (int k = array3.GetLowerBound(0); k <= upperBound; k++)
				{
					for (int l = array3.GetLowerBound(1); l <= upperBound2; l++)
					{
						double num7 = array3[k, l];
						num6++;
						empty = num7.ToString();
						if (num6 == inverse.Length / 2)
						{
							empty += ";";
						}
						else if (num6 != inverse.Length)
						{
							empty += parseArgumentSeparator;
						}
						text += empty;
					}
				}
				if (!text.StartsWith(TIC) && !text.EndsWith(TIC))
				{
					text = TIC + text + TIC;
				}
				return text;
			}
			if (string.IsNullOrEmpty(cell))
			{
				return inverse[0, 0].ToString();
			}
			int num8 = ColIndex(cell);
			int num9 = RowIndex(cell);
			GetFormulaArrayBounds(cell, num3, num4, out var firstRowIndex, out var firstColIndex, out var _, out var _);
			int num10 = num9 - firstRowIndex;
			int num11 = num8 - firstColIndex;
			num = inverse[num10, num11];
		}
		else
		{
			if (arg.IndexOf(';') <= -1)
			{
				if (!double.TryParse(GetValueFromArg(array[0]).Replace(TIC, ""), out var result3))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[1].ToString();
				}
				if (result3 == 0.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_index]);
					}
					return ErrorStrings[4].ToString();
				}
				return (1.0 / result3).ToString();
			}
			string[] array4 = SplitArguments(arg.Replace(TIC, ""), ';');
			int num12 = SplitArgsPreservingQuotedCommas(array4[0]).Length;
			if (array4.Length != num12)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			double[,] array5 = new double[array4.Length, num12];
			int num13 = num12;
			int num14 = 0;
			for (int m = 0; m < array4.Length; m++)
			{
				string[] array6 = SplitArgsPreservingQuotedCommas(array4[m]);
				num14 = array6.Length;
				if (num13 != num14)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
					}
					return FormulaErrorStrings[wrong_number_arguments];
				}
				for (int n = 0; n < num13; n++)
				{
					array5[m, n] = double.Parse(GetValueFromArg(array6[n]));
				}
			}
			double[,] inverse2 = array5;
			if (Determinant(array5, array4.Length) == 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			Cofactor(array5, array4.Length, out inverse2);
			if (string.IsNullOrEmpty(cell))
			{
				return inverse2[0, 0].ToString();
			}
			int num15 = ColIndex(cell);
			int num16 = RowIndex(cell);
			GetFormulaArrayBounds(cell, inverse2.Length - num13, num13, out var firstRowIndex2, out var firstColIndex2, out var _, out var _);
			int num17 = num16 - firstRowIndex2;
			int num18 = num15 - firstColIndex2;
			num = inverse2[num17, num18];
		}
		return num.ToString();
	}

	public string ComputeMmult(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 2 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		double[,] array2 = null;
		double[,] array3 = null;
		double[,] array4 = null;
		int num8 = 0;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IndexOf(":") > -1)
			{
				string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
				if (ErrorStrings.Contains(text))
				{
					return text;
				}
				double result = 0.0;
				if (!IsCellReference(array[i]) && !double.TryParse(StripTics0(array[i]), out result))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
					}
					return ErrorStrings[1].ToString();
				}
				array[i] = StripTics0(array[i]);
				if (i == 0)
				{
					string[] cellsFromArgs = GetCellsFromArgs(array[i]);
					num4 = int.Parse(ComputeRows(array[0]));
					num5 = int.Parse(ComputeColumns(array[0]));
					array2 = new double[num4, num5];
					for (num = 0; num <= num4 - 1; num++)
					{
						for (num2 = 0; num2 <= num5 - 1; num2++)
						{
							array2[num, num2] = double.Parse(GetValueFromArg(cellsFromArgs[num8]));
							num8++;
						}
					}
					continue;
				}
				string[] cellsFromArgs2 = GetCellsFromArgs(array[1]);
				num6 = int.Parse(ComputeRows(array[1]));
				num7 = int.Parse(ComputeColumns(array[1]));
				array3 = new double[num6, num7];
				num8 = 0;
				for (num = 0; num <= num6 - 1; num++)
				{
					for (num2 = 0; num2 <= num7 - 1; num2++)
					{
						array3[num, num2] = double.Parse(GetValueFromArg(cellsFromArgs2[num8]));
						num8++;
					}
				}
			}
			else if (array[i].IndexOf(";") > -1)
			{
				string[] array5 = SplitArguments(array[i].ToString().Replace(TIC, ""), ';');
				if (i == 0)
				{
					num5 = SplitArgsPreservingQuotedCommas(array5[0]).Length;
					num4 = array5.Length;
					if (array5.Length != num5)
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
						}
						return ErrorStrings[1].ToString();
					}
					array2 = new double[array5.Length, num5];
					int num9 = num5;
					int num10 = 0;
					for (num = 0; num < array5.Length; num++)
					{
						string[] array6 = SplitArgsPreservingQuotedCommas(array5[num]);
						num10 = array6.Length;
						if (num9 != num10)
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
							}
							return FormulaErrorStrings[wrong_number_arguments];
						}
						for (num2 = 0; num2 < num9; num2++)
						{
							array2[num, num2] = double.Parse(GetValueFromArg(array6[num2]));
						}
					}
					continue;
				}
				num7 = SplitArgsPreservingQuotedCommas(array5[0]).Length;
				num6 = array5.Length;
				if (array5.Length != num7)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
					}
					return ErrorStrings[1].ToString();
				}
				array3 = new double[array5.Length, num7];
				int num11 = num7;
				int num12 = 0;
				for (num = 0; num < array5.Length; num++)
				{
					string[] array7 = SplitArgsPreservingQuotedCommas(array5[num]);
					num12 = array7.Length;
					if (num11 != num12)
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
						}
						return FormulaErrorStrings[wrong_number_arguments];
					}
					for (num2 = 0; num2 < num11; num2++)
					{
						array3[num, num2] = double.Parse(GetValueFromArg(array7[num2]));
					}
				}
			}
			else
			{
				string text2 = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
			}
		}
		array4 = new double[num4, num7];
		for (num = 0; num <= num4 - 1; num++)
		{
			for (num2 = 0; num2 <= num7 - 1; num2++)
			{
				for (num3 = 0; num3 <= num6 - 1; num3++)
				{
					array4[num, num2] += array2[num, num3] * array3[num3, num2];
				}
			}
		}
		if (string.IsNullOrEmpty(cell))
		{
			return array4[0, 0].ToString();
		}
		int num13 = ColIndex(cell);
		int num14 = RowIndex(cell);
		GetFormulaArrayBounds(cell, num4, num5, out var firstRowIndex, out var firstColIndex, out var _, out var _);
		int num15 = num14 - firstRowIndex;
		int num16 = num13 - firstColIndex;
		return array4[num15, num16].ToString();
	}

	public string ComputeMround(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (string.IsNullOrEmpty(GetValueFromArg(array[0])) || string.IsNullOrEmpty(GetValueFromArg(array[1])))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		if (bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double result2 = 0.0;
		double result3 = 0.0;
		string text2 = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text3 = GetValueFromArg(array[1]).Replace(TIC, string.Empty);
		if (!double.TryParse(text2, NumberStyles.Any, null, out result2) || !double.TryParse(text3, NumberStyles.Any, null, out result3))
		{
			return ErrorStrings[1].ToString();
		}
		if (result3 == 0.0)
		{
			return text3;
		}
		if (ComputeSign(text2) != ComputeSign(text3) && text2 != "0" && text3 != "0")
		{
			return ErrorStrings[4].ToString();
		}
		double num = result2 / result3;
		string s = ((!(ComputeSign(result3.ToString()) == "1") || !(Math.Round(result2 % result3, 2) >= result3 / 2.0)) ? ComputeRound(num.ToString()) : ComputeRoundup(num.ToString()));
		return (double.Parse(s) * result3).ToString();
	}

	public string ComputeMultinomial(string range)
	{
		string empty = string.Empty;
		int num = 0;
		int num2 = 0;
		string args = ComputeSum(range);
		string text = ComputeFact(args);
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string[] array2;
		if (array.Length != 0)
		{
			array2 = array;
			foreach (string text2 in array2)
			{
				num2++;
				if (text2.IndexOf(':') > -1)
				{
					num2--;
					string[] cellsFromArgs = GetCellsFromArgs(text2);
					for (int j = 0; j < cellsFromArgs.Length; j++)
					{
						_ = cellsFromArgs[j];
						num2++;
					}
				}
			}
		}
		string[] array3 = new string[num2];
		array2 = array;
		foreach (string text3 in array2)
		{
			double result;
			string text4;
			if (text3.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text3);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text4 = GetValueFromArg(arg).Replace(TIC, string.Empty);
					}
					catch
					{
						ExceptionThrown = true;
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[26]);
						}
						return FormulaErrorStrings[26];
					}
					if (text4.Length > 0)
					{
						if (double.TryParse(text4, NumberStyles.Any, null, out result))
						{
							string text5 = ComputeFact(result.ToString());
							array3[num] = text5;
							num++;
						}
						else if (ErrorStrings.Contains(text4))
						{
							return text4;
						}
					}
				}
				continue;
			}
			try
			{
				text4 = GetValueFromArg(text3).Replace(TIC, string.Empty);
			}
			catch
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[26]);
				}
				return FormulaErrorStrings[26];
			}
			if (text4.Length > 0)
			{
				if (!double.TryParse(text4, NumberStyles.Any, null, out result))
				{
					return ErrorStrings[1].ToString();
				}
				string text6 = ComputeFact(result.ToString());
				array3[num] = text6;
				num++;
			}
		}
		empty = array3[0];
		for (int k = 1; k < array3.Length; k++)
		{
			empty = empty + "," + array3[k];
		}
		string text7 = ComputeProduct(empty);
		if (double.TryParse(text, out var result2) && double.TryParse(text7, out var result3))
		{
			return (result2 / result3).ToString();
		}
		string args2 = text7 + "," + text;
		return FormulaErrorStringCheck(args2, FormulaArgumentType.Numbers);
	}

	public string ComputeMUnit(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 1 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(arg, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		array[0] = (bool.TryParse(GetValueFromArg(array[0]), out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		int num = int.Parse(GetValueFromArg(array[0].Replace(TIC, "")));
		if (num == 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[,] array2 = new double[num, num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				if (i == j)
				{
					array2[i, j] = 1.0;
				}
				else
				{
					array2[i, j] = 0.0;
				}
			}
		}
		return array2[0, 0].ToString();
	}

	public string ComputeOdd(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		if (double.TryParse(GetValueFromArg(args), NumberStyles.Any, null, out var result2))
		{
			int num2 = ((result2 == 0.0) ? 1 : Math.Sign(result2));
			result2 = Math.Abs(result2);
			if ((double)(int)result2 != result2 || result2 == 0.0)
			{
				result2 = (int)(result2 + 1.0);
			}
			num = ((result2 % 2.0 != 0.0) ? ((double)num2 * result2) : ((double)num2 * (result2 + 1.0)));
		}
		return num.ToString();
	}

	public string ComputePI(string args)
	{
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.None);
		if (FormulaErrorStrings[invalid_arguments] == text)
		{
			return text;
		}
		return Math.PI.ToString("R");
	}

	public string ComputePow(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length != 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (args.Length > 0 && !char.IsLetter(args[0]) && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) == -1)
		{
			return FormulaErrorStrings[requires_2_args];
		}
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.GetLength(0) == 2 && !string.IsNullOrEmpty(args))
		{
			string valueFromArg;
			string valueFromArg2;
			try
			{
				valueFromArg = GetValueFromArg(array[0]);
				valueFromArg2 = GetValueFromArg(array[1]);
				if (string.IsNullOrEmpty(valueFromArg) && string.IsNullOrEmpty(valueFromArg2))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[4].ToString();
				}
				valueFromArg = ((string.IsNullOrEmpty(valueFromArg) && TreatStringsAsZero) ? "0" : valueFromArg);
				valueFromArg2 = ((string.IsNullOrEmpty(valueFromArg2) && TreatStringsAsZero) ? "0" : valueFromArg2);
				valueFromArg = (bool.TryParse(GetValueFromArg(valueFromArg), out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
				valueFromArg2 = (bool.TryParse(GetValueFromArg(valueFromArg2), out result) ? Convert.ToInt16(result).ToString() : valueFromArg2);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex.Message;
			}
			if (double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out var result2) && double.TryParse(valueFromArg2, NumberStyles.Number | NumberStyles.AllowExponent, null, out var result3))
			{
				if (result2 == 0.0 && result3 < 0.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[3].ToString();
				}
				num = Math.Pow(result2, result3);
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[requires_2_args]);
		}
		return FormulaErrorStrings[requires_2_args];
	}

	private string GetValueForBool(string arg)
	{
		if (arg == TRUEVALUESTR || arg == "n" + TRUEVALUESTR)
		{
			return "1";
		}
		if (arg == FALSEVALUESTR || arg == "n" + FALSEVALUESTR)
		{
			return "0";
		}
		return arg;
	}

	public string ComputeProduct(string range)
	{
		double num = 1.0;
		bool flag = true;
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range.Replace(TIC, string.Empty));
		foreach (string text in array)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						valueFromArg = GetValueForBool(valueFromArg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (RethrowLibraryComputationExceptions)
						{
							throw ex;
						}
						return ex.Message;
					}
					if (valueFromArg.Length > 0)
					{
						if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
						{
							num *= result;
							flag = false;
						}
						else if (ErrorStrings.Contains(valueFromArg))
						{
							return valueFromArg;
						}
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
				valueFromArg = GetValueForBool(valueFromArg);
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw ex2;
				}
				return ex2.Message;
			}
			if (valueFromArg.Length > 0)
			{
				if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result))
				{
					num *= result;
					flag = false;
				}
				else if (ErrorStrings.Contains(valueFromArg))
				{
					return valueFromArg;
				}
			}
		}
		if (!flag)
		{
			return num.ToString();
		}
		return "0";
	}

	public string ComputeQuotient(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.Length > 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string arg = array[0];
		string arg2 = array[1];
		_ = string.Empty;
		arg = GetValueFromArg(arg).Replace(TIC, string.Empty);
		arg2 = GetValueFromArg(arg2).Replace(TIC, string.Empty);
		if (string.IsNullOrEmpty(GetValueFromArg(array[0])) || string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		if (!double.TryParse(arg, NumberStyles.Any, null, out var result2) || !double.TryParse(arg2, NumberStyles.Any, null, out var result3))
		{
			return ErrorStrings[1].ToString();
		}
		return ComputeInt((result2 / result3).ToString());
	}

	public string ComputeRadians(string args)
	{
		double num = 0.0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		string valueFromArg = GetValueFromArg(args);
		if (string.IsNullOrEmpty(valueFromArg))
		{
			return num.ToString();
		}
		if (!double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		return (Math.PI * result2 / 180.0).ToString();
	}

	public string ComputeRoman(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string empty = string.Empty;
		string text2 = string.Empty;
		string text3 = string.Empty;
		string text4 = string.Empty;
		string text5 = string.Empty;
		int num = 0;
		if (array.Length > 2)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		int[] array2 = new int[2];
		string[] array3 = array;
		foreach (string text6 in array3)
		{
			if (IsRange(text6))
			{
				return ErrorStrings[1].ToString();
			}
			if ((double.TryParse(GetValueFromArg(text6), NumberStyles.Any, null, out var result) || text6.Length > 0) && (int)result >= 0)
			{
				array2[num] = (int)result;
				num++;
				continue;
			}
			return ErrorStrings[1].ToString();
		}
		if (array2[0] < 0 || array2[0] > 3999)
		{
			return ErrorStrings[1].ToString();
		}
		if (array2[1] < 0 || array2[1] > 4)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int[] array4 = new int[13]
		{
			1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,
			5, 4, 1
		};
		string[] array5 = new string[13]
		{
			"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX",
			"V", "IV", "I"
		};
		StringBuilder stringBuilder = new StringBuilder();
		int num2 = array2[0];
		string text7 = num2.ToString();
		bool flag = true;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		for (int j = 0; j < 13; j++)
		{
			while (num2 >= array4[j])
			{
				num2 -= array4[j];
				stringBuilder.Append(array5[j]);
			}
		}
		empty = stringBuilder.ToString();
		if (text7.Contains("45") || text7.Contains("46") || text7.Contains("47") || text7.Contains("48") || text7.Contains("49"))
		{
			flag2 = true;
		}
		if (text7.Contains("95") || text7.Contains("96") || text7.Contains("97") || text7.Contains("98") || text7.Contains("99"))
		{
			flag3 = true;
		}
		if (text7.EndsWith("45") || text7.EndsWith("46") || text7.EndsWith("47") || text7.EndsWith("48") || text7.EndsWith("49"))
		{
			flag4 = true;
		}
		if (text7.EndsWith("95") || text7.EndsWith("96") || text7.EndsWith("97") || text7.EndsWith("98") || text7.EndsWith("99"))
		{
			flag5 = true;
		}
		if (!(flag2 || flag3))
		{
			return stringBuilder.ToString();
		}
		if (text7.EndsWith("499") || text7.EndsWith("999"))
		{
			string text8 = empty;
			text2 = text8.Replace('C', 'L');
			text2 = text2.Replace('X', 'V');
			text3 = text2.Replace('L', 'X');
			string[] array6 = text3.Split('V');
			char[] array7 = array6[1].ToCharArray();
			char[] value = array6[0].ToCharArray();
			Array.Reverse(array7);
			text8 = new string(array7);
			text3 = new string(value);
			text3 += text8;
			text4 = text3.Replace('X', 'V');
			string[] array8 = text4.Split('V');
			char[] array9 = array8[1].ToCharArray();
			Array.Reverse(array9);
			text8 = new string(array9);
			for (int k = 0; k < array6.Length - 1; k++)
			{
				text5 = ((k != 1) ? (text5 + array8[k]) : (text5 + text8));
			}
			flag = false;
		}
		if (text7.Contains("95") || text7.Contains("96") || text7.Contains("97") || text7.Contains("98"))
		{
			int num3 = int.Parse("4".Replace('4', text7[text7.IndexOf('9')]));
			if (num3 == 4 || num3 == 9)
			{
				text2 = empty.Replace('C', 'L');
				int num4 = text2.IndexOf('X');
				string[] array10 = text2.Split('X');
				int num5 = 0;
				int num6 = 0;
				num6 = 0;
				while (num5 < num4 + 1)
				{
					num5 += array10[num6].Length;
					num6++;
				}
				char[] array11 = array10[1].ToCharArray();
				Array.Reverse(array11);
				text2 = new string(array11);
				int num7 = text2.Length;
				int num8 = num7;
				int num9 = 0;
				for (num9 = 0; num9 < num8 - 2; num9++)
				{
					text2 += text2[num7 - 3];
					num7--;
				}
				text2 = text2.Substring(num9);
				text2 = array10[0] + text2;
				string[] array12 = text2.Split('L');
				text3 = array12[0] + "X";
				for (int l = 1; l < array12.Length; l++)
				{
					text3 += array12[l];
				}
				string[] array13 = text3.Split('X');
				char[] array14 = array13[1].ToCharArray();
				Array.Reverse(array14);
				text4 = new string(array14);
				int num10 = text4.Length;
				int num11 = num10;
				int num12 = 0;
				for (num12 = 0; num12 < num11 - 2; num12++)
				{
					text4 += text4[num10 - 3];
					num10--;
				}
				text4 = text4.Substring(num9);
				text4 = array13[0] + text4;
				text5 = text4;
				flag = false;
			}
		}
		if (flag && (flag4 || flag5))
		{
			int num13 = empty.IndexOf('X');
			string[] array15 = empty.Split('X');
			if (array15.Length == 2)
			{
				int num14 = 0;
				int num15 = 0;
				num15 = 0;
				while (num14 < num13 + 1)
				{
					num14 += array15[num15].Length;
					num15++;
				}
				char[] array16 = array15[num15 - 1].ToCharArray();
				Array.Reverse(array16);
				text2 = new string(array16);
				int num16 = text2.Length;
				int num17 = num16;
				int num18 = 0;
				for (num18 = 0; num18 < num17 - 2; num18++)
				{
					text2 += text2[num16 - 3];
					num16--;
				}
				text2 = text2.Substring(num18);
				text3 = (text4 = (text5 = (text2 = array15[0] + text2)));
			}
			if (array15.Length == 3)
			{
				text2 = empty.Replace("X", "V");
				string[] array17 = text2.Split('V');
				text3 = string.Empty;
				char[] array18 = array17[1].ToCharArray();
				Array.Reverse(array18);
				string text9 = new string(array18);
				for (int m = 0; m < array17.Length; m++)
				{
					text3 = ((m == 1) ? (text3 + text9) : (text3 + array17[m]));
				}
				text4 = (text5 = text3);
			}
		}
		else if (flag && !(flag4 || flag5))
		{
			int num19 = empty.IndexOf('C');
			string[] array19 = empty.Split('C');
			if (array19.Length == 2)
			{
				int num20 = 0;
				int num21 = 0;
				num21 = 0;
				while (num20 < num19 + 1)
				{
					num20 += array19[num21].Length;
					num21++;
				}
				char[] array20 = array19[num21 - 1].ToCharArray();
				Array.Reverse(array20);
				text2 = new string(array20);
				int num22 = text2.Length;
				int num23 = num22;
				int num24 = 0;
				for (num24 = 0; num24 < num23 - 2; num24++)
				{
					text2 += text2[num22 - 3];
					num22--;
				}
				text2 = text2.Substring(num24);
				text2 = array19[0] + text2;
				text3 = (text4 = (text5 = text2));
			}
			if (array19.Length == 3)
			{
				text2 = empty.Replace("C", "L");
				string[] array21 = text2.Split('L');
				text3 = string.Empty;
				char[] array22 = array21[1].ToCharArray();
				Array.Reverse(array22);
				string text10 = new string(array22);
				for (int n = 0; n < array21.Length; n++)
				{
					text3 = ((n == 1) ? (text3 + text10) : (text3 + array21[n]));
				}
				text4 = (text5 = text3);
			}
		}
		else if (flag)
		{
			return empty;
		}
		switch (array2[1])
		{
		case 1:
			empty = text2;
			break;
		case 2:
			empty = text3;
			break;
		case 3:
			empty = text4;
			break;
		case 4:
			empty = text5;
			break;
		}
		return empty;
	}

	public string ComputeRound(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (length == 1)
		{
			argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
			return ComputeMath(argList, Math.Round).ToString();
		}
		double result2 = 0.0;
		double result3 = 0.0;
		string text2 = "0";
		string valueFromArg = GetValueFromArg(array[0]);
		string text3 = (string.IsNullOrEmpty(array[1]) ? "0" : GetValueFromArg(array[1]));
		valueFromArg = (bool.TryParse(valueFromArg, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg);
		text3 = (bool.TryParse(text3, out var result5) ? Convert.ToInt16(result5).ToString() : text3);
		if ((valueFromArg == string.Empty || double.TryParse(valueFromArg, NumberStyles.Any, null, out result2)) && (text3 == string.Empty || double.TryParse(text3, NumberStyles.Any, null, out result3)))
		{
			if (result3 > 0.0)
			{
				text2 = Math.Round((decimal)result2, (int)result3, MidpointRounding.AwayFromZero).ToString();
			}
			else
			{
				double num = Math.Pow(10.0, 0.0 - result3);
				text2 = (Math.Round(result2 / num, MidpointRounding.AwayFromZero) * num).ToString();
			}
		}
		return text2.ToString();
	}

	public string ComputeRounddown(string argList)
	{
		double result = 0.0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		switch (length)
		{
		case 1:
		{
			argList = (bool.TryParse(GetValueFromArg(argList), out var result2) ? Convert.ToInt16(result2).ToString() : argList);
			if (double.TryParse(GetValueFromArg(argList.Replace(TIC, string.Empty)), NumberStyles.Any, null, out result))
			{
				result -= 0.4999999999 * (double)Math.Sign(result);
				return ComputeRound($"{result}");
			}
			break;
		}
		default:
			return FormulaErrorStrings[invalid_arguments];
		case 2:
			break;
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg = (bool.TryParse(valueFromArg, out var result3) ? Convert.ToInt16(result3).ToString() : valueFromArg);
		valueFromArg2 = (bool.TryParse(valueFromArg2, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2);
		double result5 = 0.0;
		double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result5);
		if (!result.Equals(double.NaN))
		{
			result -= 0.4999999999 * Math.Pow(10.0, 0.0 - result5) * (double)Math.Sign(result);
			return ComputeRound($"{result}{ParseArgumentSeparator}{result5}");
		}
		return "#VALUE!";
	}

	public string ComputeRoundup(string argList)
	{
		double result = 0.0;
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		switch (length)
		{
		case 1:
		{
			argList = (bool.TryParse(GetValueFromArg(argList), out var result5) ? Convert.ToInt16(result5).ToString() : argList);
			double.TryParse(GetValueFromArg(argList), NumberStyles.Any, null, out result);
			if (result > 0.0)
			{
				result += 0.4999999999;
			}
			else if (result < 0.0)
			{
				result -= 0.4999999999;
			}
			result = Math.Round(result, 0, MidpointRounding.AwayFromZero);
			return $"{result}";
		}
		default:
			return FormulaErrorStrings[invalid_arguments];
		case 2:
		{
			double result2 = 0.0;
			string valueFromArg = GetValueFromArg(array[0]);
			string valueFromArg2 = GetValueFromArg(array[1]);
			valueFromArg = (bool.TryParse(valueFromArg, out var result3) ? Convert.ToInt16(result3).ToString() : valueFromArg);
			valueFromArg2 = (bool.TryParse(valueFromArg2, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2);
			double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
			double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2);
			result2 = Math.Ceiling(result2);
			if (result2 >= 0.0)
			{
				if (result > 0.0)
				{
					result += 0.4999999999 / Math.Pow(10.0, result2);
				}
				else if (result < 0.0)
				{
					result -= 0.4999999999 / Math.Pow(10.0, result2);
				}
				result = Math.Round(result, (int)result2, MidpointRounding.AwayFromZero);
			}
			else
			{
				if (result > 0.0)
				{
					result = result / Math.Pow(10.0, 0.0 - result2) + 0.49999;
				}
				else if (result < 0.0)
				{
					result = result / Math.Pow(10.0, 0.0 - result2) - 0.49999;
				}
				result = Math.Round(result, 0, MidpointRounding.AwayFromZero) * Math.Pow(10.0, 0.0 - result2);
			}
			return $"{result}";
		}
		}
	}

	public string ComputeRows(string arg)
	{
		string scopedRange = string.Empty;
		if (!IsCellReference(arg) && !TryGetNamedRange(arg, out scopedRange) && !arg.Contains(";"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		if (SplitArgsPreservingQuotedCommas(arg).Length != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int num = 1;
		if (arg.IndexOf(':') > -1)
		{
			string[] cellsFromArgs = GetCellsFromArgs(arg);
			int num2 = RowIndex(cellsFromArgs[0].ToString());
			num = RowIndex(cellsFromArgs[^1].ToString()) - num2 + 1;
			num = ((num <= 0) ? 1 : num);
		}
		else if (arg.IndexOf(';') > -1)
		{
			string[] array = SplitArguments(arg.Replace(TIC, ""), ';');
			for (int i = 1; i < array.Length; i++)
			{
				if (SplitArgsPreservingQuotedCommas(array[i - 1]).Length != SplitArgsPreservingQuotedCommas(array[1]).Length)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
					}
					return FormulaErrorStrings[wrong_number_arguments];
				}
				num = array.Length;
			}
		}
		return num.ToString();
	}

	public string ComputeSecant(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		string text3 = ComputeMath(argList, Math.Cos);
		if (text3 != "#NUM!" || text3 != "#VALUE!")
		{
			text3 = (1.0 / Convert.ToDouble(text3)).ToString();
		}
		return text3;
	}

	public string ComputeSecanth(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		argList = GetValueFromArg(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		if (ComputeIsNumber(argList) == TRUEVALUESTR)
		{
			string text2 = argList;
			text2 = (text2.Contains("u") ? text2.Replace("u", string.Empty) : text2);
			if (Convert.ToDouble(text2) >= 134217728.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
		}
		argList = (argList.Contains("-") ? argList.Replace("-", string.Empty) : argList);
		string text3 = ComputeMath(argList, Math.Cosh);
		if (text3 != "#NUM!" || text3 != "#VALUE!")
		{
			text3 = (1.0 / Convert.ToDouble(text3)).ToString();
		}
		return text3;
	}

	public string ComputeSheet(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		_ = string.Empty;
		if (length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0].Replace(TIC, "").ToUpper();
		text = (string.IsNullOrEmpty(text) ? cell : text);
		if (string.IsNullOrEmpty(text))
		{
			return "1";
		}
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(text) && !TryGetNamedRange(text, out scopedRange) && !SortedSheetNames.Contains(text))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
			}
			return ErrorStrings[0].ToString();
		}
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		string sheetTokenFromReference = GetSheetTokenFromReference(text);
		int num = 0;
		if (string.IsNullOrEmpty(sheetTokenFromReference) && !SortedSheetNames.Contains(text) && !text.Contains('!'.ToString()))
		{
			num = GetSheetID(grid) + 1;
		}
		else if (sheetTokenFromReference.Length > 0)
		{
			num = int.Parse(sheetTokenFromReference.Replace('!'.ToString(), string.Empty)) + 1;
		}
		else
		{
			try
			{
				foreach (KeyValuePair<object, object> item in sheetFamilyItem.TokenToParentObject)
				{
					if (sheetFamilyItem.SheetNameToParentObject[text].Equals(item.Value))
					{
						ICalcData grd = item.Value as ICalcData;
						num = GetSheetID(grd) + 1;
						break;
					}
				}
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw;
				}
				return ErrorStrings[2].ToString();
			}
		}
		return num.ToString();
	}

	public string ComputeSheets(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		_ = string.Empty;
		if (length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int num = 0;
		string text = array[0].Replace(TIC, "").ToUpper();
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string scopedRange = string.Empty;
		if (string.IsNullOrEmpty(text))
		{
			return SortedSheetNames.Count.ToString();
		}
		if (!IsCellReference(text) && !TryGetNamedRange(text, out scopedRange) && !SortedSheetNames.Contains(text))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[cannot_parse]);
			}
			return ErrorStrings[0].ToString();
		}
		try
		{
			num = (SplitArguments(text, '!').Length - 1) / 2;
		}
		catch (Exception)
		{
			ExceptionThrown = true;
			if (RethrowLibraryComputationExceptions)
			{
				throw;
			}
			return ErrorStrings[2].ToString();
		}
		return num.ToString();
	}

	public string ComputeSign(string args)
	{
		int num = 0;
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		double result2;
		if (args.Length > 0 && !char.IsLetter(args[0]) && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) == -1)
		{
			if (double.TryParse(args, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num = Math.Sign(result2);
			}
		}
		else if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(tokens) > -1))
		{
			args = args.Replace('{', '(');
			args = args.Replace('}', ')');
			string s;
			try
			{
				s = ComputedValue(args);
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex.Message;
			}
			if (!double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				return FormulaErrorStrings[invalid_Math_argument];
			}
			num = Math.Sign(result2);
		}
		else
		{
			string[] cellsFromArgs = GetCellsFromArgs(args);
			foreach (string arg in cellsFromArgs)
			{
				string s;
				try
				{
					s = GetValueFromArg(arg);
				}
				catch (Exception ex2)
				{
					ExceptionThrown = true;
					if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					return ex2.Message;
				}
				if (s.Length <= 0)
				{
					continue;
				}
				if (double.TryParse(s.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
				{
					num = Math.Sign(result2);
					break;
				}
				if (!s.StartsWith(TIC) && !IsCellReference(s))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[5].ToString();
				}
				if (s.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
			}
		}
		return num.ToString();
	}

	public string ComputeSin(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Sin).ToString();
	}

	public string ComputeSinh(string args)
	{
		if (SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		args = (bool.TryParse(GetValueFromArg(args), out var result) ? Convert.ToInt16(result).ToString() : args);
		return ComputeMath(args, Math.Sinh).ToString();
	}

	internal string[] ComputeSumArray(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string text = string.Empty;
		string text2 = string.Empty;
		string text3 = string.Empty;
		string text4 = string.Empty;
		string[] array2 = array;
		foreach (string text5 in array2)
		{
			string text6 = text5.Replace('\u0092'.ToString(), string.Empty);
			int num = Array.IndexOf(FormulaErrorStrings, text6.Replace(TIC, string.Empty));
			if (text6.IndexOfAny(tokens) > -1 && num == -1)
			{
				int num2;
				for (num2 = 0; num2 < text6.Length - 1; num2++)
				{
					string text7 = string.Empty;
					if (num2 != text6.Length && text6[num2] == '"')
					{
						text7 += text6[num2++];
						while (num2 != range.Length && text6[num2] != '"')
						{
							text7 += text6[num2++];
						}
						text7 += text6[num2++];
						text = text + text7 + ";";
					}
					while (num2 != text6.Length && ((IsUpper(text6[num2]) | char.IsDigit(text6[num2]) | (text6[num2] == 'n')) || text6[num2] == parseDecimalSeparator || text6[num2] == 'm'))
					{
						text4 += text6[num2++];
					}
					char[] array3 = logicalOperators;
					foreach (char c in array3)
					{
						if (num2 != text6.Length && text6[num2] == c)
						{
							text4 += text6[num2++];
							break;
						}
					}
					if ((!text7.Equals(string.Empty) && !text4.Equals(string.Empty)) || num2 == text6.Length)
					{
						num2--;
						string[] array4 = null;
						string text8 = string.Empty;
						array4 = text.Split(';');
						string[] array5 = array4[0].Replace(TIC, string.Empty).Split(',');
						if (array4.Length > 2)
						{
							string[] array6 = array4[1].Replace(TIC, string.Empty).Split(',');
							for (int k = 0; k <= array5.Length - 1; k++)
							{
								text8 = text8 + GetValueFromArg('\u0092' + text2 + "n" + array5[k] + "n" + array6[k] + text4 + '\u0092') + ",";
							}
							text = text8.Substring(0, text8.Length - 1) + ";";
							text2 = (text4 = string.Empty);
						}
						else if (array4.Length > 1)
						{
							for (int l = 0; l <= array5.Length - 1; l++)
							{
								text8 = text8 + GetValueFromArg('\u0092' + text2 + "n" + array5[l] + text4 + '\u0092') + ",";
							}
							text = text8.Substring(0, text8.Length - 1) + ";";
							text2 = (text4 = string.Empty);
						}
					}
					else
					{
						num2--;
						text2 += text4;
						text4 = string.Empty;
					}
				}
				text3 = text3 + text.Replace(";", string.Empty) + ",";
			}
			else if (num == -1 && !string.IsNullOrEmpty(text6.Replace(TIC, string.Empty)))
			{
				text3 = text3 + text5.Replace(TIC, string.Empty).Replace(";", ",") + ",";
			}
		}
		return text3.Split(',');
	}

	public string ComputeSum(string range)
	{
		double num = 0.0;
		string[] array = null;
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		if (range.Contains(TIC))
		{
			array = range.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array.Length; i++)
			{
				if (char.IsLetter(array[i][0]) && char.IsLetter(array[i][array[i].Length - 1]))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
			}
			array = ((range.IndexOfAny(tokens) <= -1) ? range.Replace('\u0092'.ToString(), string.Empty).Replace(";", ",").Split(new string[2]
			{
				TIC,
				parseArgumentSeparator.ToString()
			}, StringSplitOptions.RemoveEmptyEntries) : ComputeSumArray(range));
		}
		else
		{
			array = SplitArgsPreservingQuotedCommas(range);
		}
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			string text2 = text;
			double result;
			string valueFromArg;
			if (text2.IndexOf(':') > -1 && IsRange(text))
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text2);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return valueFromArg;
						}
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg != string.Empty)
					{
						if (double.TryParse(valueFromArg, NumberStyles.Number, null, out result))
						{
							num = ((!valueFromArg.StartsWith("+") && !valueFromArg.StartsWith("-")) ? ((!valueFromArg.Contains("+") && !valueFromArg.Contains("-")) ? (num + result) : (num + 0.0)) : (num + result));
						}
						else if (double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
						{
							num += result;
						}
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text2);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				valueFromArg = ((bool.TryParse(valueFromArg, out var result2) && !IsCellReference(text)) ? Convert.ToInt16(result2).ToString() : valueFromArg);
				if (ExcelLikeComputations && useDatesInCalcs && !double.TryParse(valueFromArg.Replace(TIC, string.Empty), out var _))
				{
					if (TryParseExactDateTime(text.Replace(TIC, string.Empty), out var result4))
					{
						valueFromArg = (GetSerialDateTimeFromDate(result4) - GetSerialDateTimeFromDate(DateTime.Today)).ToString();
					}
					else if (IsDate(text.Replace(TIC, string.Empty), out result4))
					{
						valueFromArg = GetSerialDateTimeFromDate(result4).ToString();
					}
				}
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ErrorStrings[5].ToString();
			}
			if (valueFromArg.Length > 0 && ((IsCellReference(text2) && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result) && !double.IsNaN(result)) || (!IsCellReference(text2) && double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result) && !double.IsNaN(result))))
			{
				num = ((!valueFromArg.StartsWith("+") && !valueFromArg.StartsWith("-")) ? ((!valueFromArg.Contains("+") && !valueFromArg.Contains("-")) ? (num + result) : (num + 0.0)) : (num + result));
			}
		}
		return num.ToString("G15");
	}

	public string ComputeSumIFS(string argList)
	{
		return CalculateIFSFormula(argList, "SUMIFS");
	}

	private string CalculateIFSFormula(string argList, string condition)
	{
		string[] array = null;
		bool flag = false;
		if (argList.Contains(TIC + TIC))
		{
			flag = true;
			int num = argList.IndexOf(TIC + TIC);
			int num2 = argList.Substring(num + 1).IndexOf(TIC + TIC);
			string text = argList.Substring(num, num2 + 3);
			text = text.Replace(parseArgumentSeparator, '!');
			argList = argList.Substring(0, num) + text;
		}
		array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		List<string> list3 = new List<string>();
		int num3;
		for (num3 = 1; num3 < length; num3++)
		{
			list.Add(array[num3]);
			num3++;
			list2.Add(array[num3]);
		}
		if (length < 3 && list.Count == list2.Count)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text2 = array[0];
		double num4 = 0.0;
		double num5 = double.MinValue;
		double num6 = double.MaxValue;
		string result = string.Empty;
		GetCellsFromArgs(array[0]);
		string[] cellsFromArgs = GetCellsFromArgs(text2);
		for (int i = 0; i < list2.Count; i++)
		{
			char op = 'e';
			string text3 = list2[i];
			if (flag && text3.Contains("!"))
			{
				text3 = text3.Replace('!', parseArgumentSeparator);
				flag = false;
			}
			if (text3[0] != TIC[0] && "=><".IndexOf(text3[0]) == -1)
			{
				text3 = GetValueFromArg(text3);
			}
			text3 = findCriteria(text3, ref op);
			string[] cellsFromArgs2 = GetCellsFromArgs(list[i]);
			if ((cellsFromArgs2[0] != null && cellsFromArgs2[0].Equals(ErrorStrings[5])) || (cellsFromArgs[0] != null && cellsFromArgs[0].Equals(ErrorStrings[5])))
			{
				return ErrorStrings[5].ToString();
			}
			if (cellsFromArgs2.GetLength(0) != cellsFromArgs.GetLength(0))
			{
				return ErrorStrings[1].ToString();
			}
			int length2 = cellsFromArgs2.GetLength(0);
			if (length2 > cellsFromArgs.GetLength(0))
			{
				int num7 = text2.IndexOf(':');
				if (num7 > -1)
				{
					int num8 = RowIndex(text2.Substring(0, num7));
					int num9 = RowIndex(text2.Substring(num7 + 1));
					if (!(!num8.Equals(-1) || num9.Equals(-1)).Equals(num8.Equals(-1) || !num9.Equals(-1)))
					{
						return ErrorStrings[5].ToString();
					}
					int num10 = ColIndex(text2.Substring(0, num7));
					int num11 = ColIndex(text2.Substring(num7 + 1));
					if (grid is ISheetData)
					{
						if (num8 == -1)
						{
							num8 = ((ISheetData)grid).GetFirstRow();
						}
						if (num10 == -1)
						{
							num10 = ((ISheetData)grid).GetFirstColumn();
						}
						if (num9 == -1)
						{
							num9 = ((ISheetData)grid).GetLastRow();
						}
						if (num11 == -1)
						{
							num11 = ((ISheetData)grid).GetLastColumn();
						}
					}
					if (num8 != num9)
					{
						num9 += length2 - cellsFromArgs.GetLength(0);
					}
					else if (num10 != num11)
					{
						num11 += length2 - cellsFromArgs.GetLength(0);
					}
					text2 = text2.Substring(0, num7 + 1) + RangeInfo.GetAlphaLabel(num11) + num9;
					cellsFromArgs = GetCellsFromArgs(text2);
				}
			}
			string[] array2 = null;
			List<string> list4 = new List<string>();
			if (text3.Contains(parseArgumentSeparator.ToString()))
			{
				array2 = text3.Split(new char[1] { ParseArgumentSeparator });
			}
			else
			{
				list4.Add(text3);
				array2 = list4.ToArray();
			}
			List<string> list5 = new List<string>();
			string[] array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				text3 = array3[j];
				text3.IndexOf("*");
				double result2 = double.MinValue;
				bool isNumber = double.TryParse(text3, out result2);
				for (int k = 0; k < length2; k++)
				{
					string valueFromArg = GetValueFromArg(cellsFromArgs2[k]);
					if (!CheckForCriteriaMatch(valueFromArg.ToUpper(), op, text3.ToUpper(), isNumber, result2))
					{
						continue;
					}
					if (list3.Count > 0 && i != 0)
					{
						int count = list3.Count;
						bool flag2 = list[i] == list[i - 1];
						for (int l = 0; l < count; l++)
						{
							if (flag2)
							{
								if (list3[l] != null && list3[l].Equals(cellsFromArgs2[k]))
								{
									list5.Add(cellsFromArgs[k]);
								}
							}
							else if (list3[l] != null && RowIndex(list3[l].ToString()).Equals(RowIndex(cellsFromArgs2[k])))
							{
								list5.Add(cellsFromArgs[k]);
							}
						}
					}
					else if (cellsFromArgs[k] != null)
					{
						list5.Add(cellsFromArgs[k]);
					}
				}
			}
			if (list5.Count == 0)
			{
				list3.Clear();
				break;
			}
			list3 = list5;
		}
		switch (condition)
		{
		case "SUMIFS":
		{
			for (int n = 0; n < list3.Count; n++)
			{
				double.TryParse(GetValueFromArg(list3[n]), out var result4);
				num4 += result4;
			}
			break;
		}
		case "MAXIFS":
		{
			for (int num12 = 0; num12 < list3.Count; num12++)
			{
				double.TryParse(GetValueFromArg(list3[num12]), out var result5);
				if (result5 > num5)
				{
					num5 = result5;
				}
			}
			break;
		}
		case "MINIFS":
		{
			for (int m = 0; m < list3.Count; m++)
			{
				double.TryParse(GetValueFromArg(list3[m]), out var result3);
				if (result3 < num6)
				{
					num6 = result3;
				}
			}
			break;
		}
		}
		if (condition == "SUMIFS")
		{
			result = num4.ToString();
		}
		if (condition == "MAXIFS")
		{
			result = num5.ToString();
		}
		if (condition == "MINIFS")
		{
			result = num6.ToString();
		}
		return result;
	}

	public string ComputeSumsq(string range)
	{
		double num = 0.0;
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
					{
						num += result * result;
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				valueFromArg = (bool.TryParse(valueFromArg, out var result2) ? Convert.ToInt16(result2).ToString() : valueFromArg);
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (valueFromArg.Length <= 0)
			{
				continue;
			}
			if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
			{
				num += result * result;
			}
			else if (valueFromArg.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		return num.ToString();
	}

	public string ComputeSumx2my2(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string range2 = array[0];
		string range3 = array[1];
		double[] doubleArray = GetDoubleArray(range2);
		double[] doubleArray2 = GetDoubleArray(range3);
		int length = doubleArray.GetLength(0);
		if (length != doubleArray2.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num2 = doubleArray[i];
			num3 = doubleArray2[i];
			if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
			{
				num += num2 * num2 - num3 * num3;
			}
		}
		return num.ToString();
	}

	public string ComputeSumx2py2(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string range2 = array[0];
		string range3 = array[1];
		double[] doubleArray = GetDoubleArray(range2);
		double[] doubleArray2 = GetDoubleArray(range3);
		int length = doubleArray.GetLength(0);
		if (length != doubleArray2.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num2 = doubleArray[i];
			num3 = doubleArray2[i];
			if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
			{
				num += num2 * num2 + num3 * num3;
			}
		}
		return num.ToString();
	}

	public string ComputeSumxmy2(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[requires_2_args];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string range2 = array[0];
		string range3 = array[1];
		double[] doubleArray = GetDoubleArray(range2);
		double[] doubleArray2 = GetDoubleArray(range3);
		int length = doubleArray.GetLength(0);
		if (length != doubleArray2.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num2 = doubleArray[i];
			num3 = doubleArray2[i];
			if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
			{
				num += Math.Pow(num2 - num3, 2.0);
			}
		}
		return num.ToString();
	}

	public string ComputeTranspose(string arg)
	{
		string text = FormulaErrorStringCheck(arg, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 1 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (array.Length == 1 && !IsCellReference(arg))
		{
			return SplitArgsPreservingQuotedCommas(StripTics0(array[0]))[0];
		}
		string empty = string.Empty;
		if (arg.IndexOf(';') > -1)
		{
			string[] array2 = SplitArguments(arg.Replace(TIC, ""), ';');
			for (int i = 1; i < array2.Length; i++)
			{
				if (SplitArgsPreservingQuotedCommas(array2[i - 1]).Length != SplitArgsPreservingQuotedCommas(array2[1]).Length)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
					}
					return FormulaErrorStrings[wrong_number_arguments];
				}
			}
			empty = SplitArgsPreservingQuotedCommas(array2[0])[0];
		}
		else
		{
			string[] cellsFromArgs = GetCellsFromArgs(arg);
			int num = RowIndex(cellsFromArgs[0].ToString());
			int num2 = RowIndex(cellsFromArgs[^1].ToString());
			int num3 = ColIndex(cellsFromArgs[0].ToString());
			int num4 = ColIndex(cellsFromArgs[^1].ToString());
			string s = cell;
			int num5 = ColIndex(s);
			int num6 = RowIndex(s);
			int arrayHeight = num2 - num + 1;
			int arrayWidth = num4 - num3 + 1;
			GetFormulaArrayBounds(cell, arrayHeight, arrayWidth, out var firstRowIndex, out var firstColIndex, out var _, out var _);
			int num7 = num6 - firstRowIndex;
			int num8 = num5 - firstColIndex;
			int num9 = arg.IndexOf(":");
			if (num9 == -1)
			{
				arg = arg + ":" + arg;
				num9 = arg.IndexOf(":");
			}
			int num10 = arg.Substring(0, num9).LastIndexOf('!');
			ICalcData calcData = grid;
			GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
			if (num10 > -1)
			{
				grid = (ICalcData)sheetFamilyItem.TokenToParentObject[arg.Substring(0, num10 + 1)];
			}
			empty = GetValueComputeFormulaIfNecessary(num + num8, num3 + num7, grid);
			grid = calcData;
		}
		if (string.IsNullOrEmpty(empty))
		{
			empty = "0";
		}
		return empty;
	}

	public string ComputeTruncate(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (argList.Length > 15)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		string text = string.Empty;
		string valueFromArg = GetValueFromArg(array[0]);
		decimal result2;
		if (double.TryParse(valueFromArg, out var result))
		{
			text = result.ToString();
		}
		else if (decimal.TryParse(valueFromArg, out result2))
		{
			text = result2.ToString();
		}
		return text.ToString();
	}

	public string ComputeRandbetween(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (string.IsNullOrEmpty(GetValueFromArg(array[0])) || string.IsNullOrEmpty(GetValueFromArg(array[1])))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text3 = GetValueFromArg(array[1]).Replace(TIC, string.Empty);
		if (!double.TryParse(text2, NumberStyles.Any, null, out var result) || !double.TryParse(text3, NumberStyles.Any, null, out var result2))
		{
			return ErrorStrings[1].ToString();
		}
		string s = ComputeRound(text2);
		string s2 = ComputeRound(text3);
		if (!double.TryParse(text2, NumberStyles.Any, null, out result) || !double.TryParse(text3, NumberStyles.Any, null, out result2))
		{
			return "#NAME?";
		}
		if (result > result2)
		{
			return ErrorStrings[4].ToString();
		}
		if (rand == null)
		{
			rand = new Random();
		}
		return rand.Next(int.Parse(s), int.Parse(s2)).ToString();
	}

	public string ComputeSeriessum(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 4 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i <= 2; i++)
		{
			string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		string text2 = FormulaErrorStringCheck(array[3], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		string[] array2 = ((array[3].IndexOf(';') <= -1) ? GetCellsFromArgs(array[3].Replace(TIC, "")) : SplitArguments(array[3].Replace(TIC, ""), ';'));
		double.TryParse(GetValueFromArg(array[0].Replace(TIC, "")), out result);
		double.TryParse(GetValueFromArg(array[1].Replace(TIC, "")), out result2);
		double.TryParse(GetValueFromArg(array[2].Replace(TIC, "")), out result3);
		for (int j = 0; j < array2.Length; j++)
		{
			if (double.TryParse(GetValueFromArg(array2[j].Replace(TIC, "")), out result4))
			{
				num += result4 * Math.Pow(result, result2 + (double)j * result3);
				continue;
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		return num.ToString();
	}

	public string ComputeXLookUp(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (array.Length > 6 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = ValidateArgumentType(array[0], FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(text).Replace(TIC, string.Empty);
		string text2 = array[1];
		if (ComputeIsText(text2) == TRUEVALUESTR && !text2.Contains(":"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		string text3 = ValidateArgumentType(array[2], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text3))
		{
			return text3;
		}
		text3 = array[2];
		string empty = string.Empty;
		string notFound = string.Empty;
		string text4;
		if (length > 3)
		{
			notFound = ValidateArgumentType(array[3], FormulaArgumentType.Text);
			notFound = GetValueFromArg(notFound);
			if (length > 4)
			{
				text4 = FindMatchMode(array[4]);
				if (ErrorStrings.Contains(text4))
				{
					return text4;
				}
			}
			else
			{
				text4 = "0";
			}
			if (length > 5)
			{
				empty = FindSearchMode(array[5]);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
			}
			else
			{
				empty = "1";
			}
		}
		else
		{
			empty = "1";
			text4 = "0";
		}
		string text5 = GetMatchedValue(text, text2, text3, notFound, text4, empty);
		if (computeFunctionLevel > 0)
		{
			text5 = TIC + text5 + TIC;
		}
		return text5;
	}

	private string GetMatchedValue(string lookupValue, string lookupRange, string returnArray, string notFound, string matchMode, string searchMode)
	{
		string empty = string.Empty;
		string[] array = null;
		string[] array2 = null;
		int num = 0;
		bool flag = false;
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		int num2 = 0;
		int num3 = 0;
		if (IsRange(lookupRange))
		{
			int num4 = lookupRange.IndexOf(':');
			RowIndex(lookupRange.Substring(0, num4));
			RowIndex(lookupRange.Substring(num4 + 1));
			num2 = ColIndex(lookupRange.Substring(0, num4));
			num3 = ColIndex(lookupRange.Substring(num4 + 1));
		}
		if (lookupRange.IndexOf(":") > -1)
		{
			array = ((lookupRange.IndexOfAny(logicalOperators) <= -1) ? GetCellsFromArgs(lookupRange) : CalculateLookupRange(lookupRange).Replace(TIC, string.Empty).Split(new char[1] { ';' }));
		}
		else if (lookupRange.StartsWith(TIC) && lookupRange.EndsWith(TIC))
		{
			array = lookupRange.Replace(TIC, string.Empty).Split(new char[1] { ParseArgumentSeparator });
		}
		string[] array3 = array;
		foreach (string arg in array3)
		{
			string valueFromArg = GetValueFromArg(arg);
			list.Add(valueFromArg);
		}
		if (returnArray.IndexOf(":") > -1)
		{
			array2 = GetCellsFromArgs(returnArray);
		}
		else if (returnArray.StartsWith(TIC) && returnArray.EndsWith(TIC))
		{
			array2 = returnArray.Replace(TIC, string.Empty).Split(new char[1] { ParseArgumentSeparator });
		}
		if (list.Count != array2.Length && num2 == num3)
		{
			array2 = ReorderCellsColumnWise(array2);
		}
		array3 = array2;
		foreach (string arg2 in array3)
		{
			string valueFromArg2 = GetValueFromArg(arg2);
			list2.Add(valueFromArg2);
		}
		double result;
		switch (searchMode)
		{
		case "1":
			num = FindMatchFromRange(lookupValue, list.ToArray(), matchMode);
			break;
		case "-1":
			if (!list.Contains(lookupValue))
			{
				List<string> list3 = new List<string>();
				for (int num5 = list.Count - 1; num5 >= 0; num5--)
				{
					list3.Add(list[num5]);
				}
				num = FindMatchFromRange(lookupValue, list3.ToArray(), matchMode);
			}
			else
			{
				num = FindMatchFromRange(lookupValue, list.ToArray(), matchMode);
			}
			break;
		case "2":
			if (!list.Contains(lookupValue) && double.TryParse(lookupValue, out result))
			{
				string[] tempArray2 = GetsortedArray(list.ToArray());
				num = FindMatchFromRange(lookupValue, tempArray2, matchMode);
			}
			else
			{
				num = FindMatchFromRange(lookupValue, list.ToArray(), matchMode);
			}
			break;
		case "-2":
			if (double.TryParse(lookupValue, out result))
			{
				string[] tempArray = SortDescendingOrder(list.ToArray());
				num = FindMatchFromRange(lookupValue, tempArray, matchMode);
			}
			else
			{
				num = FindMatchFromRange(lookupValue, list.ToArray(), matchMode);
			}
			break;
		}
		if (num != -1)
		{
			if (list.Count == list2.Count)
			{
				return empty = list2[num];
			}
			int num6 = returnArray.IndexOf(':');
			int num7 = RowIndex(returnArray.Substring(0, num6));
			int num8 = RowIndex(returnArray.Substring(num6 + 1));
			int num9 = ColIndex(returnArray.Substring(0, num6));
			int num10 = ColIndex(returnArray.Substring(num6 + 1));
			int num11 = num8 - num7 + 1;
			int num12 = num10 - num9 + 1;
			List<string> list4 = new List<string>();
			if (num2 == num3)
			{
				for (int j = 0; j < num12; j++)
				{
					int index = j * num11 + num;
					string text = list2[index];
					if (string.IsNullOrEmpty(text))
					{
						text = "0";
					}
					list4.Add(text);
				}
			}
			else
			{
				for (int k = 0; k < num11; k++)
				{
					int index2 = k * num12 + num;
					string text2 = list2[index2];
					if (string.IsNullOrEmpty(text2))
					{
						text2 = "0";
					}
					list4.Add(text2);
				}
			}
			if (computeFunctionLevel > 0)
			{
				return string.Join(parseArgumentSeparator.ToString(), list4);
			}
			return empty = list4[0];
		}
		if (true && notFound != string.Empty)
		{
			return notFound;
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[0].ToString());
		}
		return ErrorStrings[0].ToString();
	}

	internal string[] ReorderCellsColumnWise(string[] cells)
	{
		if (cells.Length == 0)
		{
			return cells;
		}
		SortedDictionary<int, List<string>> sortedDictionary = new SortedDictionary<int, List<string>>();
		foreach (string text in cells)
		{
			int key = ColIndex(text);
			if (!sortedDictionary.ContainsKey(key))
			{
				sortedDictionary[key] = new List<string>();
			}
			sortedDictionary[key].Add(text);
		}
		List<string> list = new List<string>();
		foreach (List<string> value in sortedDictionary.Values)
		{
			list.AddRange(value);
		}
		return list.ToArray();
	}

	private string CalculateLookupRange(string lookupRange)
	{
		string[] array = null;
		string[] array2 = null;
		string text = string.Empty;
		lookupRange = lookupRange.Replace('\u0092'.ToString(), string.Empty);
		for (int i = 0; i < lookupRange.Length; i++)
		{
			string text2 = string.Empty;
			string text3 = string.Empty;
			string text4 = string.Empty;
			while (i != lookupRange.Length && (char.IsDigit(lookupRange[i]) | (lookupRange[i] == ':') | (i != 0 && IsUpper(lookupRange[i]) && !char.IsDigit(lookupRange[i - 1])) | (i == 0 && IsUpper(lookupRange[i]))))
			{
				text2 += lookupRange[i++];
			}
			while (i != lookupRange.Length && ((IsUpper(lookupRange[i]) | char.IsDigit(lookupRange[i]) | (lookupRange[i] == 'n')) || (lookupRange[i].ToString().IndexOfAny(logicalOperators) > -1 && char.IsDigit(lookupRange[i - 1]))))
			{
				text3 += lookupRange[i++];
			}
			char[] array3 = tokens;
			foreach (char c in array3)
			{
				if (i != lookupRange.Length && lookupRange[i] == c)
				{
					text3 += lookupRange[i];
					break;
				}
			}
			array = GetCellsFromArgs(text2);
			if (array2 != null && text == string.Empty)
			{
				string[] array4 = array2[0].Replace(TIC, string.Empty).Split(';');
				string[] array5 = array2[1].Replace(TIC, string.Empty).Split(';');
				if (array4.Length == array5.Length)
				{
					for (int k = 0; k <= array4.Length - 1; k++)
					{
						text4 = text4 + GetValueFromArg('\u0092' + array4[k] + array5[k] + text3 + '\u0092') + ";";
					}
					text4 = text4.Substring(0, text4.Length - 1);
					text = TIC + text4 + TIC + parseArgumentSeparator;
					array2 = null;
				}
			}
			else if (text != string.Empty && lookupRange[i].ToString().IndexOfAny(tokens) > -1)
			{
				for (int l = 0; l <= array.Length - 1; l++)
				{
					text4 = text4 + GetValueFromArg('\u0092' + array[l] + text3 + '\u0092') + ";";
				}
				text4 = text4.Substring(0, text4.Length - 1);
				text4 = TIC + text4 + TIC;
				text += text4;
				array2 = text.Split(parseArgumentSeparator);
				text = string.Empty;
			}
			else
			{
				for (int m = 0; m <= array.Length - 1; m++)
				{
					text4 = GetValueFromArg('\u0092' + array[m] + text3 + '\u0092');
					text = text + text4 + ";";
				}
				text = text.Substring(0, text.Length - 1);
				text = TIC + text + TIC + parseArgumentSeparator;
			}
			if (i == lookupRange.Length - 1 && !text.StartsWith(TIC) && !text.EndsWith(TIC))
			{
				text = TIC + text + TIC;
			}
		}
		return text.Substring(0, text.Length - 1);
	}

	private int FindMatchFromRange(string lookupValue, string[] tempArray, string matchMode)
	{
		int num = -1;
		switch (matchMode)
		{
		case "0":
		{
			for (int l = 0; l < tempArray.Length; l++)
			{
				if (string.Equals(lookupValue, tempArray[l]))
				{
					num = l;
				}
			}
			break;
		}
		case "-1":
		{
			string[] array = GetsortedArray(tempArray);
			for (int j = 0; j < tempArray.Length; j++)
			{
				if (string.Compare(lookupValue, array[j]) <= 0)
				{
					string empty = string.Empty;
					empty = ((!string.Equals(lookupValue, array[j])) ? array[j - 1] : array[j]);
					return num = Array.IndexOf(tempArray, empty);
				}
			}
			break;
		}
		case "1":
		{
			string[] array2 = GetsortedArray(tempArray);
			for (int k = 0; k < tempArray.Length; k++)
			{
				if (string.Compare(lookupValue, array2[k], StringComparison.Ordinal) <= 0)
				{
					string value = array2[k];
					return num = Array.IndexOf(tempArray, value);
				}
			}
			break;
		}
		case "2":
		{
			for (int i = 0; i < tempArray.Length; i++)
			{
				if (lookupValue.Contains("*") && tempArray[i].ToUpper().Contains(lookupValue.Replace("*", string.Empty).ToUpper()))
				{
					num = i;
				}
				if (lookupValue.Contains("?") && CheckForMatch(tempArray[i], lookupValue))
				{
					num = i;
				}
				if (lookupValue.Contains("~"))
				{
					if (tempArray[i].ToUpper() == lookupValue.Replace("~", string.Empty).ToUpper())
					{
						num = i;
					}
				}
				else if (tempArray[i].ToUpper().Contains(lookupValue.ToUpper()))
				{
					num = i;
				}
			}
			break;
		}
		}
		if (num != -1)
		{
			return num;
		}
		return -1;
	}

	private string FindMatchMode(string arg)
	{
		double result = 0.0;
		string text = ValidateArgumentType(arg, FormulaArgumentType.Numbers);
		if (!ErrorStrings.Contains(text))
		{
			text = GetValueFromArg(arg);
			if (text == string.Empty)
			{
				text = "0";
			}
			else if (text == FALSEVALUESTR)
			{
				text = "0";
			}
			else if (text == TRUEVALUESTR)
			{
				text = "1";
			}
			if (double.TryParse(text, out result) && result != 0.0 && result != -1.0 && result != 1.0 && result != 2.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		return text;
	}

	private string FindSearchMode(string arg)
	{
		double result = 0.0;
		string text = ValidateArgumentType(arg, FormulaArgumentType.Numbers);
		if (!ErrorStrings.Contains(text))
		{
			text = GetValueFromArg(arg);
			if (text == string.Empty)
			{
				text = "1";
			}
			else if (text == FALSEVALUESTR)
			{
				text = "0";
			}
			else if (text == TRUEVALUESTR)
			{
				text = "1";
			}
			if (double.TryParse(text, out result) && result != 1.0 && result != -1.0 && result != -2.0 && result != 2.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		return text;
	}

	private string ValidateArgumentType(string arg, FormulaArgumentType type)
	{
		string text = FormulaErrorStringCheck(arg, type);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		return arg;
	}

	public string ComputeXMatch(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 4 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = ValidateArgumentType(array[0], FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(text).Replace(TIC, string.Empty);
		string text2 = ValidateArgumentType(array[1], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		text2 = array[1];
		string empty = string.Empty;
		if (length > 2)
		{
			empty = FindMatchMode(array[2]);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = "0";
		}
		string empty2 = string.Empty;
		if (length > 3)
		{
			empty2 = FindSearchMode(array[3]);
			if (ErrorStrings.Contains(empty2))
			{
				return empty2;
			}
		}
		else
		{
			empty2 = "1";
		}
		int num = FindMatchIndex(text, text2, empty, empty2);
		if (num == -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		return num.ToString();
	}

	private int FindMatchIndex(string lookupValue, string lookupRange, string matchMode, string searchMode)
	{
		string[] array = null;
		List<string> list = new List<string>();
		if (lookupRange.IndexOf(":") > -1)
		{
			array = GetCellsFromArgs(lookupRange);
		}
		else if (lookupRange.StartsWith(TIC) && lookupRange.EndsWith(TIC))
		{
			array = lookupRange.Replace(TIC, string.Empty).Split(new char[1] { ParseArgumentSeparator });
		}
		string[] array2 = array;
		foreach (string arg in array2)
		{
			string valueFromArg = GetValueFromArg(arg);
			list.Add(valueFromArg);
		}
		double result;
		switch (searchMode)
		{
		case "1":
			return FindMatch(lookupValue, list.ToArray(), matchMode);
		case "-1":
		{
			List<string> list2 = new List<string>();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				list2.Add(list[num]);
			}
			return FindMatch(lookupValue, list2.ToArray(), matchMode);
		}
		case "2":
			if (double.TryParse(lookupValue, out result))
			{
				string[] tempArray2 = GetsortedArray(list.ToArray());
				return FindMatch(lookupValue, tempArray2, matchMode);
			}
			return FindMatch(lookupValue, list.ToArray(), matchMode);
		case "-2":
			if (double.TryParse(lookupValue, out result))
			{
				string[] tempArray = SortDescendingOrder(list.ToArray());
				return FindMatch(lookupValue, tempArray, matchMode);
			}
			return FindMatch(lookupValue, list.ToArray(), matchMode);
		default:
			return -1;
		}
	}

	private string[] SortDescendingOrder(string[] cells)
	{
		string[] array = (string[])cells.Clone();
		double[] array2 = new double[cells.Length];
		for (int i = 0; i < cells.Length; i++)
		{
			array2[i] = double.Parse(cells[i]);
		}
		Array.Sort(array2);
		Array.Reverse(array2);
		for (int j = 0; j < array2.Length; j++)
		{
			array[j] = array2[j].ToString();
		}
		return array;
	}

	private string[] GetsortedArray(string[] array)
	{
		string[] array2 = (string[])array.Clone();
		double[] array3 = new double[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array3[i] = double.Parse(array[i]);
		}
		Array.Sort(array3);
		for (int j = 0; j < array3.Length; j++)
		{
			array2[j] = array3[j].ToString();
		}
		return array2;
	}

	private int FindMatch(string lookupValue, string[] tempArray, string matchMode)
	{
		int num = -1;
		switch (matchMode)
		{
		case "0":
		{
			for (int l = 0; l < tempArray.Length; l++)
			{
				if (string.Equals(lookupValue, tempArray[l]))
				{
					num = l;
				}
			}
			break;
		}
		case "-1":
		{
			string[] array = GetsortedArray(tempArray);
			for (int j = 0; j < tempArray.Length; j++)
			{
				if (string.Compare(lookupValue, array[j]) <= 0)
				{
					string empty = string.Empty;
					empty = ((!string.Equals(lookupValue, tempArray[j])) ? array[j - 1] : array[j]);
					return num = Array.IndexOf(tempArray, empty) + 1;
				}
			}
			break;
		}
		case "1":
		{
			string[] array = GetsortedArray(tempArray);
			for (int k = 0; k < tempArray.Length; k++)
			{
				if (string.Compare(lookupValue, array[k]) <= 0)
				{
					string value = array[k];
					return num = Array.IndexOf(tempArray, value) + 1;
				}
			}
			break;
		}
		case "2":
		{
			for (int i = 0; i < tempArray.Length; i++)
			{
				if (lookupValue.Contains("*"))
				{
					lookupValue = lookupValue.Replace("*", string.Empty);
					if (tempArray[i].ToUpper().Contains(lookupValue.ToUpper()))
					{
						num = i;
					}
				}
				if (lookupValue.Contains("?") && CheckForMatch(tempArray[i], lookupValue))
				{
					num = i;
				}
				if (lookupValue.Contains("~"))
				{
					if (tempArray[i].ToUpper() == lookupValue.Replace("~", string.Empty).ToUpper())
					{
						num = i;
					}
				}
				else if (tempArray[i].ToUpper().Contains(lookupValue.ToUpper()))
				{
					num = i;
				}
			}
			break;
		}
		}
		if (num != -1)
		{
			return num + 1;
		}
		return -1;
	}

	private bool CheckForMatch(string tempValue, string lookupValue)
	{
		if (lookupValue.Length != tempValue.Length)
		{
			return false;
		}
		for (int i = 0; i < lookupValue.Length; i++)
		{
			if (lookupValue[i] == '?' && i + 1 < lookupValue.Length && lookupValue[i + 1] == tempValue[i + 1])
			{
				return true;
			}
		}
		return false;
	}

	public string ComputeFloorMath(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			string text = FormulaErrorStringCheck(array[i].ToString(), FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if (IsArrayFormula || args[0].ToString().StartsWith(TIC))
		{
			return FloorMathArrayCalculation(array);
		}
		double num = validateArg(array[0]);
		if (num == 0.0)
		{
			return "0";
		}
		double num2 = 0.0;
		double num3 = 0.0;
		double num4 = 0.0;
		if (length > 1)
		{
			num2 = validateArg(array[1]);
			if (num2 == 0.0)
			{
				return "0";
			}
		}
		else
		{
			num2 = 1.0;
		}
		num3 = ((length <= 2) ? 0.0 : validateArg(array[2]));
		return ((length <= 2) ? CalculateFloorValue(num, num2) : CalculateFloorMathValue(num, num2, num3)).ToString();
	}

	private double validateArg(string arg)
	{
		bool result = false;
		double result2 = 0.0;
		string valueFromArg = GetValueFromArg(arg.ToString().Replace(TIC, string.Empty));
		valueFromArg = (bool.TryParse(valueFromArg.Replace(TIC, string.Empty), out result) ? Convert.ToInt32(result).ToString() : valueFromArg);
		if (TryParseExactDateTime(valueFromArg.Replace(TIC, string.Empty), out var result3))
		{
			result2 = GetSerialDateTimeFromDate(result3) - GetSerialDateTimeFromDate(DateTime.Today);
		}
		else if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
		{
			result2 = result2;
		}
		return result2;
	}

	internal string FloorMathArrayCalculation(string[] range)
	{
		string[] array = null;
		string[] array2 = null;
		string[] array3 = null;
		string text = string.Empty;
		double d = 0.0;
		double d2 = 0.0;
		double d3 = 0.0;
		if (range[0].StartsWith(TIC) && range[0].EndsWith(TIC))
		{
			array = range[0].Replace(TIC, string.Empty).Split(',');
		}
		if (range.Length > 1 && range[1].StartsWith(TIC) && range[1].EndsWith(TIC))
		{
			array2 = range[1].Replace(TIC, string.Empty).Split(',');
		}
		if (range.Length > 2 && range[2].StartsWith(TIC) && range[2].EndsWith(TIC))
		{
			array3 = range[2].Replace(TIC, string.Empty).Split(',');
		}
		if (array2 != null && array3 != null && array.Length == array2.Length && array.Length == array3.Length)
		{
			if (computedValueLevel > 1)
			{
				for (int i = 0; i < array.Length; i++)
				{
					ParseArgAsDouble(array[i], array2[i], array3[i], ref d, ref d2, ref d3);
					text = text + CalculateFloorMathValue(d, d2, d3) + ";";
				}
				return TIC + text.Remove(text.Length - 1) + TIC;
			}
			ParseArgAsDouble(array[0], array2[0], array3[0], ref d, ref d2, ref d3);
			return CalculateFloorMathValue(d, d2, d3).ToString();
		}
		string sign = ((range.Length > 1) ? range[1] : string.Empty);
		string mode = ((range.Length > 2) ? range[2] : string.Empty);
		if (computedValueLevel > 1)
		{
			for (int j = 0; j < array.Length; j++)
			{
				ParseArgAsDouble(array[j], sign, mode, ref d, ref d2, ref d3);
				text = text + CalculateFloorMathValue(d, d2, d3) + ";";
			}
			return TIC + text.Remove(text.Length - 1) + TIC;
		}
		ParseArgAsDouble(array[0], sign, mode, ref d, ref d2, ref d3);
		return CalculateFloorMathValue(d, d2, d3).ToString();
	}

	private void ParseArgAsDouble(string number, string sign, string mode, ref double d1, ref double d2, ref double d3)
	{
		double.TryParse(GetValueFromArg(number.Replace(TIC, string.Empty)), NumberStyles.Any, null, out d1);
		double.TryParse(GetValueFromArg(sign.Replace(TIC, string.Empty)), NumberStyles.Any, null, out d2);
		double.TryParse(GetValueFromArg(mode.Replace(TIC, string.Empty)), NumberStyles.Any, null, out d3);
	}

	private void ParseArgAsDouble(string number, string sign, ref double d1, ref double d2)
	{
		double.TryParse(GetValueFromArg(number.Replace(TIC, string.Empty)), NumberStyles.Any, null, out d1);
		double.TryParse(GetValueFromArg(sign.Replace(TIC, string.Empty)), NumberStyles.Any, null, out d2);
	}

	private double CalculateFloorMathValue(double d1, double d2, double d3)
	{
		if (d3 < 0.0 && d1 > 0.0)
		{
			return CalculateFloorValue(d1, d2);
		}
		if (d3 == 0.0 && d1 < 0.0)
		{
			return double.Parse(ComputeRoundup((d1 / d2).ToString())) * d2;
		}
		return double.Parse(ComputeRounddown((d1 / d2).ToString())) * d2;
	}

	public string ComputeFloorPrecise(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			string text = FormulaErrorStringCheck(array[i].ToString(), FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if (IsArrayFormula || args[0].ToString().StartsWith(TIC))
		{
			return FloorPreciseArrayCalculation(array);
		}
		double num = validateArg(array[0]);
		if (num == 0.0)
		{
			return "0";
		}
		double num2 = 0.0;
		if (length > 1)
		{
			num2 = validateArg(array[1]);
			if (num2 == 0.0)
			{
				return "0";
			}
		}
		else
		{
			num2 = 1.0;
		}
		return CalculateFloorPrecise(num, num2).ToString();
	}

	private double CalculateFloorPrecise(double d1, double d2)
	{
		if (!(d1 < 0.0))
		{
			return double.Parse(ComputeRounddown((d1 / d2).ToString())) * d2;
		}
		return double.Parse(ComputeRoundup((d1 / d2).ToString())) * d2;
	}

	private double CalculateCeilingValue(double d1, double d2)
	{
		if (!(d1 < 0.0))
		{
			return double.Parse(ComputeRoundup((d1 / d2).ToString())) * d2;
		}
		return double.Parse(ComputeRounddown((d1 / d2).ToString())) * d2;
	}

	internal string FloorPreciseArrayCalculation(string[] range)
	{
		string[] array = null;
		string[] array2 = null;
		string text = string.Empty;
		double d = 0.0;
		double d2 = 0.0;
		if (range[0].StartsWith(TIC) && range[0].EndsWith(TIC))
		{
			array = range[0].Replace(TIC, string.Empty).Split(',');
		}
		if (range.Length > 1 && range[1].StartsWith(TIC) && range[1].EndsWith(TIC))
		{
			array2 = range[1].Replace(TIC, string.Empty).Split(',');
		}
		if (array2 != null && array.Length == array2.Length)
		{
			if (computedValueLevel > 1)
			{
				for (int i = 0; i < array.Length; i++)
				{
					ParseArgAsDouble(array[i], array2[i], ref d, ref d2);
					text = text + CalculateFloorPrecise(d, d2) + ";";
				}
				return TIC + text.Remove(text.Length - 1) + TIC;
			}
			ParseArgAsDouble(array[0], array2[0], ref d, ref d2);
			return CalculateFloorPrecise(d, d2).ToString();
		}
		string sign = ((range.Length > 1) ? range[1] : string.Empty);
		if (computedValueLevel > 1)
		{
			for (int j = 0; j < array.Length; j++)
			{
				ParseArgAsDouble(array[j], sign, ref d, ref d2);
				text = text + CalculateFloorPrecise(d, d2) + ";";
			}
			return TIC + text.Remove(text.Length - 1) + TIC;
		}
		ParseArgAsDouble(array[0], sign, ref d, ref d2);
		return CalculateFloorPrecise(d, d2).ToString();
	}

	internal string IsoCeilingArrayCalculation(string[] range)
	{
		string[] array = null;
		string[] array2 = null;
		string text = string.Empty;
		double d = 0.0;
		double d2 = 0.0;
		if (range[0].StartsWith(TIC) && range[0].EndsWith(TIC))
		{
			array = range[0].Replace(TIC, string.Empty).Split(',');
		}
		if (range.Length > 1 && range[1].StartsWith(TIC) && range[1].EndsWith(TIC))
		{
			array2 = range[1].Replace(TIC, string.Empty).Split(',');
		}
		if (array2 != null && array.Length == array2.Length)
		{
			if (computedValueLevel > 1)
			{
				for (int i = 0; i < array.Length; i++)
				{
					ParseArgAsDouble(array[i], array2[i], ref d, ref d2);
					text = text + CalculateCeilingValue(d, d2) + ";";
				}
				return TIC + text.Remove(text.Length - 1) + TIC;
			}
			ParseArgAsDouble(array[0], array2[0], ref d, ref d2);
			return CalculateCeilingValue(d, d2).ToString();
		}
		string sign = ((range.Length > 1) ? range[1] : string.Empty);
		if (computedValueLevel > 1)
		{
			for (int j = 0; j < array.Length; j++)
			{
				ParseArgAsDouble(array[j], sign, ref d, ref d2);
				text = text + CalculateCeilingValue(d, d2) + ";";
			}
			return TIC + text.Remove(text.Length - 1) + TIC;
		}
		ParseArgAsDouble(array[0], sign, ref d, ref d2);
		return CalculateCeilingValue(d, d2).ToString();
	}

	internal string CeilingPreciseArrayCalculation(string[] range)
	{
		string[] array = null;
		string[] array2 = null;
		string text = string.Empty;
		double d = 0.0;
		double d2 = 0.0;
		if (range[0].StartsWith(TIC) && range[0].EndsWith(TIC))
		{
			array = range[0].Replace(TIC, string.Empty).Split(',');
		}
		if (range.Length > 1 && range[1].StartsWith(TIC) && range[1].EndsWith(TIC))
		{
			array2 = range[1].Replace(TIC, string.Empty).Split(',');
		}
		if (array2 != null && array.Length == array2.Length)
		{
			if (computedValueLevel > 1)
			{
				for (int i = 0; i < array.Length; i++)
				{
					ParseArgAsDouble(array[i], array2[i], ref d, ref d2);
					text = text + CalculateCeilingValue(d, d2) + ";";
				}
				return TIC + text.Remove(text.Length - 1) + TIC;
			}
			ParseArgAsDouble(array[0], array2[0], ref d, ref d2);
			return CalculateCeilingValue(d, d2).ToString();
		}
		string sign = ((range.Length > 1) ? range[1] : string.Empty);
		if (computedValueLevel > 1)
		{
			for (int j = 0; j < array.Length; j++)
			{
				ParseArgAsDouble(array[j], sign, ref d, ref d2);
				text = text + CalculateCeilingValue(d, d2) + ";";
			}
			return TIC + text.Remove(text.Length - 1) + TIC;
		}
		ParseArgAsDouble(array[0], sign, ref d, ref d2);
		return CalculateCeilingValue(d, d2).ToString();
	}

	public string ComputeIsoCeiling(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			string text = FormulaErrorStringCheck(array[i].ToString(), FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if (IsArrayFormula || args[0].ToString().StartsWith(TIC))
		{
			return IsoCeilingArrayCalculation(array);
		}
		double num = validateArg(array[0]);
		if (num == 0.0)
		{
			return "0";
		}
		double num2 = 0.0;
		if (length > 1)
		{
			num2 = validateArg(array[1]);
			if (num2 == 0.0)
			{
				return "0";
			}
		}
		else
		{
			num2 = 1.0;
		}
		return CalculateCeilingValue(num, num2).ToString();
	}

	public string ComputeCeilingPrecise(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			string text = FormulaErrorStringCheck(array[i].ToString(), FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if (IsArrayFormula || args[0].ToString().StartsWith(TIC))
		{
			return CeilingPreciseArrayCalculation(array);
		}
		double num = validateArg(array[0]);
		if (num == 0.0)
		{
			return "0";
		}
		double num2 = 0.0;
		if (length > 1)
		{
			num2 = validateArg(array[1]);
			if (num2 == 0.0)
			{
				return "0";
			}
		}
		else
		{
			num2 = 1.0;
		}
		return CalculateCeilingValue(num, num2).ToString();
	}

	public string ComputeVStack(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		List<string> list = new List<string>();
		string errorCheck = string.Empty;
		list = ValidateStackArgs(args, ref errorCheck);
		if (ErrorStrings.Contains(errorCheck))
		{
			return errorCheck;
		}
		return VerticalStackValue(list);
	}

	public string ComputeHStack(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		List<string> list = new List<string>();
		string errorCheck = string.Empty;
		list = ValidateStackArgs(args, ref errorCheck);
		if (ErrorStrings.Contains(errorCheck))
		{
			return errorCheck;
		}
		return HorizontalStackValue(list);
	}

	private List<string> ValidateStackArgs(string args, ref string errorCheck)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		List<string> list = new List<string>();
		for (int i = 0; i < length; i++)
		{
			if (!array[i].StartsWith(TIC) && !array[i].EndsWith(TIC))
			{
				errorCheck = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
			}
			else
			{
				errorCheck = FormulaErrorStringCheck(array[i], FormulaArgumentType.Text);
			}
			list.Add(array[i]);
		}
		return list;
	}

	private string ConvertArrayToString(string[,] result, int rows, int col)
	{
		if (computeFunctionLevel > 0)
		{
			string text = string.Empty;
			for (int i = 0; i < rows; i++)
			{
				for (int j = 0; j < col; j++)
				{
					text = text + result[i, j].ToString() + parseArgumentSeparator;
				}
				text = text.Remove(text.Length - 1) + ";";
			}
			return TIC + text.Remove(text.Length - 1) + TIC;
		}
		return result[0, 0].ToString();
	}

	private string VerticalStackValue(List<string> arrayList)
	{
		string[] array = null;
		int num = 0;
		int num2 = 0;
		foreach (string array4 in arrayList)
		{
			if (array4.IndexOf(":") > -1)
			{
				int num3 = array4.IndexOf(':');
				int num4 = RowIndex(array4.Substring(0, num3));
				int num5 = RowIndex(array4.Substring(num3 + 1));
				int num6 = ColIndex(array4.Substring(0, num3));
				int num7 = ColIndex(array4.Substring(num3 + 1));
				num += num5 - num4 + 1;
				num2 = Math.Max(num2, num7 - num6 + 1);
			}
			else if (array4.StartsWith(TIC) && array4.EndsWith(TIC))
			{
				if (array4.Contains(";"))
				{
					array = SplitArguments(array4.Replace(TIC, ""), ';');
					num += array.Length;
					num2 = Math.Max(num2, SplitArgsPreservingQuotedCommas(array[0]).Length);
				}
				else if (array4.Contains(parseArgumentSeparator.ToString()))
				{
					array = SplitArguments(array4.Replace(TIC, ""), parseArgumentSeparator);
					num += SplitArgsPreservingQuotedCommas(array[0]).Length;
					num2 = Math.Max(num2, array.Length);
				}
			}
		}
		string[,] array2 = new string[num, num2];
		int num8 = 0;
		foreach (string array5 in arrayList)
		{
			int num9 = 0;
			int num10 = 0;
			if (array5.IndexOf(":") > -1)
			{
				int num11 = array5.IndexOf(':');
				int num12 = RowIndex(array5.Substring(0, num11));
				int num13 = RowIndex(array5.Substring(num11 + 1));
				int num14 = ColIndex(array5.Substring(0, num11));
				int num15 = ColIndex(array5.Substring(num11 + 1));
				int num16 = 0;
				array = GetCellsFromArgs(array5);
				num9 = num13 - num12 + 1;
				num10 = num15 - num14 + 1;
				for (int i = 0; i < num9; i++)
				{
					for (int j = 0; j < num2; j++)
					{
						if (j < num10)
						{
							string valueFromArg = GetValueFromArg(array[num16]);
							valueFromArg = ((valueFromArg == string.Empty) ? (array2[num8, j] = "0") : (array2[num8, j] = valueFromArg));
							num16++;
						}
						else
						{
							array2[num8, j] = ErrorStrings[0].ToString();
						}
					}
					num8++;
				}
			}
			else
			{
				if (!array5.StartsWith(TIC) || !array5.EndsWith(TIC))
				{
					continue;
				}
				string args = string.Empty;
				if (array5.StartsWith(TIC) && array5.EndsWith(TIC))
				{
					args = array5.Substring(1, array5.Length - 2);
				}
				if (array5.Contains(";"))
				{
					array = SplitArguments(args, ';');
					num10 = SplitArgsPreservingQuotedCommas(array[0]).Length;
					num9 = array.Length - 1;
					for (int k = 0; k < array.Length; k++)
					{
						string[] array3 = SplitArgsPreservingQuotedCommas(array[k]);
						for (int l = 0; l < num2; l++)
						{
							if (l < num10)
							{
								array2[num8, l] = GetValueFromArg(array3[l]);
							}
							else
							{
								array2[num8, l] = ErrorStrings[0].ToString();
							}
						}
						num8++;
					}
				}
				else
				{
					if (!array5.Contains(parseArgumentSeparator.ToString()))
					{
						continue;
					}
					array = SplitArguments(args, parseArgumentSeparator);
					num9 = SplitArgsPreservingQuotedCommas(array[0]).Length;
					num10 = array.Length;
					for (int m = 0; m < num9; m++)
					{
						for (int n = 0; n < num2; n++)
						{
							if (n < num10)
							{
								array2[num8 + m, n] = GetValueFromArg(array[n]);
							}
							else
							{
								array2[num8 + m, n] = ErrorStrings[0].ToString();
							}
						}
						num8++;
					}
				}
			}
		}
		return ConvertArrayToString(array2, num, num2);
	}

	private string HorizontalStackValue(List<string> arrayList)
	{
		string[] array = null;
		int num = 0;
		int num2 = 0;
		foreach (string array4 in arrayList)
		{
			if (array4.IndexOf(":") > -1)
			{
				int num3 = array4.IndexOf(':');
				int num4 = RowIndex(array4.Substring(0, num3));
				int num5 = RowIndex(array4.Substring(num3 + 1));
				int num6 = ColIndex(array4.Substring(0, num3));
				int num7 = ColIndex(array4.Substring(num3 + 1));
				num = Math.Max(num, num5 - num4 + 1);
				num2 += num7 - num6 + 1;
			}
			else if (array4.StartsWith(TIC) && array4.EndsWith(TIC))
			{
				if (array4.Contains(";"))
				{
					array = SplitArguments(array4.Replace(TIC, ""), ';');
					num = Math.Max(num, array.Length);
					num2 += SplitArgsPreservingQuotedCommas(array[0]).Length;
				}
				else if (array4.Contains(parseArgumentSeparator.ToString()))
				{
					array = SplitArguments(array4.Replace(TIC, ""), parseArgumentSeparator);
					num = Math.Max(num, SplitArgsPreservingQuotedCommas(array[0]).Length);
					num2 += array.Length;
				}
			}
		}
		string[,] array2 = new string[num, num2];
		int num8 = 0;
		foreach (string array5 in arrayList)
		{
			int num9 = 0;
			int num10 = 0;
			if (array5.IndexOf(":") > -1)
			{
				int num11 = array5.IndexOf(':');
				int num12 = RowIndex(array5.Substring(0, num11));
				int num13 = RowIndex(array5.Substring(num11 + 1));
				int num14 = ColIndex(array5.Substring(0, num11));
				int num15 = ColIndex(array5.Substring(num11 + 1));
				int num16 = 0;
				array = GetCellsFromArgs(array5);
				num9 = num13 - num12 + 1;
				num10 = num15 - num14 + 1;
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num10; j++)
					{
						if (i < num9)
						{
							string valueFromArg = GetValueFromArg(array[num16]);
							valueFromArg = ((valueFromArg == string.Empty) ? (array2[i, num8 + j] = "0") : (array2[i, num8 + j] = valueFromArg));
							num16++;
						}
						else
						{
							array2[i, num8 + j] = ErrorStrings[0].ToString();
						}
					}
				}
				num8 += num10;
			}
			else
			{
				if (!array5.StartsWith(TIC) || !array5.EndsWith(TIC))
				{
					continue;
				}
				string args = string.Empty;
				if (array5.StartsWith(TIC) && array5.EndsWith(TIC))
				{
					args = array5.Substring(1, array5.Length - 2);
				}
				if (array5.Contains(";"))
				{
					array = SplitArguments(args, ';');
					num10 = SplitArgsPreservingQuotedCommas(array[0]).Length;
					num9 = array.Length;
					for (int k = 0; k < num; k++)
					{
						string[] array3 = null;
						if (k < num9)
						{
							array3 = SplitArgsPreservingQuotedCommas(array[k]);
						}
						for (int l = 0; l < num10; l++)
						{
							if (k < num9)
							{
								array2[k, num8 + l] = GetValueFromArg(array3[l]);
							}
							else
							{
								array2[k, num8 + l] = ErrorStrings[0].ToString();
							}
						}
					}
					num8 += num10;
				}
				else
				{
					if (!array5.Contains(parseArgumentSeparator.ToString()))
					{
						continue;
					}
					array = SplitArguments(args, parseArgumentSeparator);
					num9 = SplitArgsPreservingQuotedCommas(array[0]).Length;
					num10 = array.Length;
					for (int m = 0; m < num; m++)
					{
						for (int n = 0; n < num10; n++)
						{
							if (m < num9)
							{
								array2[m, num8 + n] = GetValueFromArg(array[n]);
							}
							else
							{
								array2[m, num8 + n] = ErrorStrings[0].ToString();
							}
						}
					}
					num8 += num10;
				}
			}
		}
		return ConvertArrayToString(array2, num, num2);
	}

	internal double[] GetDoubleArray(string range)
	{
		string text = string.Empty;
		List<object> list = new List<object>();
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range.Replace(TIC, string.Empty));
		foreach (string text2 in array)
		{
			double result2;
			if (text2.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text2);
				foreach (string text3 in cellsFromArgs)
				{
					try
					{
						text = GetValueFromArg(text3);
						text = (bool.TryParse(text, out var result) ? Convert.ToInt16(result).ToString() : text);
					}
					catch
					{
					}
					if (text.Length > 0)
					{
						if (double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
						{
							list.Add(result2);
						}
						else if (ComputeIsText(text3) == TRUEVALUESTR)
						{
							list.Add(double.NaN);
						}
						else
						{
							list.Add(0.0);
						}
					}
					else
					{
						list.Add(double.NaN);
					}
				}
				continue;
			}
			try
			{
				text = GetValueFromArg(text2);
				text = (bool.TryParse(text, out var result3) ? Convert.ToInt16(result3).ToString() : text);
			}
			catch
			{
			}
			if (text.Length > 0)
			{
				if (double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
				{
					list.Add(result2);
				}
				else if (ComputeIsText(text) == TRUEVALUESTR)
				{
					list.Add(double.NaN);
				}
				else
				{
					list.Add(0.0);
				}
			}
			else
			{
				list.Add(double.NaN);
			}
		}
		return ListToDouble(list);
	}

	private double Covariance(double[] array1, double[] array2)
	{
		if (array1.Length != array2.Length)
		{
			throw new ArgumentException(FormulaErrorStrings[incorrect_array_length]);
		}
		int num = array1.Length;
		if (num == 1)
		{
			return double.NaN;
		}
		double num2 = Mean(array1);
		double num3 = Mean(array2);
		double num4 = 0.0;
		for (int i = 0; i < num; i++)
		{
			num4 += (array1[i] - num2) * (array2[i] - num3);
		}
		return num4 / (double)(num - 1);
	}

	public double Mean(double[] array)
	{
		return Mean(array, 1.0);
	}

	public static double Mean(double[] array, double decayFactor)
	{
		int num = array.Length;
		double num2 = 0.0;
		double num3 = 1.0;
		for (int i = 0; i < num; i++)
		{
			num2 += num3 * array[num - 1 - i];
			num3 *= decayFactor;
		}
		return num2 * InverseSumOfGeometricSeries(decayFactor, num);
	}

	public static double InverseSumOfGeometricSeries(double decayFactor, int length)
	{
		if (length < 1)
		{
			return double.NaN;
		}
		if (decayFactor == 1.0)
		{
			return 1.0 / (double)length;
		}
		return (1.0 - decayFactor) / (1.0 - Math.Pow(decayFactor, length));
	}

	private double GammaLn(double x)
	{
		if (x <= 0.0)
		{
			return 0.0;
		}
		double num = x;
		double num2 = 0.0;
		if (num <= 7.0)
		{
			num2 = num;
			for (num += 1.0; num <= 7.0; num += 1.0)
			{
				num2 *= num;
			}
			num2 = 0.0 - Math.Log(num2);
		}
		double num3 = 1.0 / (num * num);
		return num2 + (num - 0.5) * Math.Log(num) - num + gammaAs[0] + ((((0.0 - gammaAs[1]) * num3 + gammaAs[2]) * num3 - gammaAs[3]) * num3 + gammaAs[4]) / num;
	}

	public string ComputeAvedev(string range)
	{
		double num = 0.0;
		List<object> list = new List<object>();
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		foreach (string text in array)
		{
			double result2;
			string text2;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text2 = GetValueFromArg(arg);
						if (bool.TryParse(text2, out var result))
						{
							text2 = Convert.ToInt32(result).ToString();
						}
						if (ErrorStrings.Contains(text2))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return text2;
						}
					}
					catch
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ErrorStrings[4].ToString();
					}
					if (double.TryParse(text2, NumberStyles.Any, null, out result2))
					{
						num += result2;
						list.Add(result2);
						continue;
					}
					if (ErrorStrings.Contains(text2))
					{
						return text2;
					}
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[5].ToString());
					}
					return ErrorStrings[5].ToString();
				}
				continue;
			}
			try
			{
				text2 = GetValueFromArg(text);
				if (bool.TryParse(text2, out var result3))
				{
					text2 = Convert.ToInt32(result3).ToString();
				}
				string text3 = FormulaErrorStringCheck(text2, FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text3))
				{
					return text3;
				}
			}
			catch
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ErrorStrings[4].ToString();
			}
			if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2))
			{
				num += result2;
				list.Add(result2);
				continue;
			}
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		if (list.Count > 0)
		{
			double num2 = num / (double)list.Count;
			num = 0.0;
			for (int k = 0; k < list.Count; k++)
			{
				num += Math.Abs((double)list[k] - num2);
			}
			num /= (double)list.Count;
		}
		return num.ToString("G17");
	}

	public string ComputeAveragea(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.Length < 1 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string text = string.Empty;
		double num = 0.0;
		int num2 = 0;
		double result = 0.0;
		string[] array3;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].Contains(ParseArgumentSeparator.ToString()))
			{
				string[] array2 = SplitArgsPreservingQuotedCommas(array[i].Replace(TIC, string.Empty));
				int num3 = 0;
				array3 = array2;
				foreach (string text2 in array3)
				{
					text = text + text2 + ParseArgumentSeparator;
					array[num3] = text2;
				}
			}
			else
			{
				text = ((!array[i].Equals(string.Empty)) ? ((!IsCellReference(array[i])) ? (text + array[i] + ParseArgumentSeparator) : (text + array[i] + ParseArgumentSeparator)) : (text + "0" + ParseArgumentSeparator));
			}
		}
		if (text.EndsWith(ParseArgumentSeparator.ToString()))
		{
			text = text.Substring(0, text.Length - 1);
		}
		array3 = SplitArgsPreservingQuotedCommas(text);
		foreach (string text3 in array3)
		{
			double result3;
			string valueFromArg;
			if (text3.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text3);
				foreach (string arg in cellsFromArgs)
				{
					valueFromArg = GetValueFromArg(arg);
					valueFromArg = (bool.TryParse(valueFromArg, out var result2) ? Convert.ToInt16(result2).ToString() : valueFromArg);
					valueFromArg = ((!double.TryParse(valueFromArg, out result3) && TreatStringsAsZero) ? "0" : valueFromArg);
					if (ErrorStrings.Contains(valueFromArg))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return valueFromArg;
					}
					if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
					{
						num += result;
						num2++;
					}
				}
				continue;
			}
			valueFromArg = GetValueFromArg(text3);
			if (ErrorStrings.Contains(valueFromArg))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return valueFromArg;
			}
			if (array.Length == 1 && IsCellReference(text3) && string.IsNullOrEmpty(valueFromArg))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[3].ToString();
			}
			if (string.IsNullOrEmpty(text3) && TreatStringsAsZero)
			{
				valueFromArg = "0";
			}
			valueFromArg = (bool.TryParse(valueFromArg, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg);
			valueFromArg = ((!double.TryParse(valueFromArg, out result3) && IsCellReference(text3) && TreatStringsAsZero) ? "0" : valueFromArg);
			if (valueFromArg.Length <= 0)
			{
				continue;
			}
			if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result))
			{
				num += result;
				num2++;
			}
			else if (valueFromArg.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num2 > 0)
		{
			num /= (double)num2;
		}
		return num.ToString();
	}

	public string ComputeAverageIFS(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		double num = 0.0;
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		List<string> list3 = new List<string>();
		List<string> list4 = new List<string>();
		int num2;
		for (num2 = 1; num2 < length; num2++)
		{
			list.Add(array[num2]);
			num2++;
			list2.Add(array[num2]);
		}
		if (length < 3 && list.Count == list2.Count)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0];
		double num3 = 0.0;
		GetCellsFromArgs(array[0]);
		string[] cellsFromArgs = GetCellsFromArgs(text);
		bool flag = false;
		for (int i = 0; i < list2.Count; i++)
		{
			char op = 'e';
			string text2 = list2[i];
			if (text2[0] != TIC[0] && "=><".IndexOf(text2[0]) == -1)
			{
				text2 = GetValueFromArg(text2);
			}
			if (i == list.Count - 1)
			{
				flag = true;
			}
			text2 = findCriteria(text2, ref op);
			string[] cellsFromArgs2 = GetCellsFromArgs(list[i]);
			if (cellsFromArgs2[0].Equals(ErrorStrings[5]) || cellsFromArgs[0].Equals(ErrorStrings[5]))
			{
				return ErrorStrings[5].ToString();
			}
			int length2 = cellsFromArgs2.GetLength(0);
			if (length2 > cellsFromArgs.GetLength(0))
			{
				int num4 = text.IndexOf(':');
				if (num4 > -1)
				{
					int num5 = RowIndex(text.Substring(0, num4));
					int num6 = RowIndex(text.Substring(num4 + 1));
					if (!(!num5.Equals(-1) || num6.Equals(-1)).Equals(num5.Equals(-1) || !num6.Equals(-1)))
					{
						return ErrorStrings[5].ToString();
					}
					if (num5 == -1 && grid is ISheetData)
					{
						num5 = ((ISheetData)grid).GetFirstRow();
					}
					int num7 = ColIndex(text.Substring(0, num4));
					if (num7 == -1 && grid is ISheetData)
					{
						num7 = ((ISheetData)grid).GetFirstColumn();
					}
					if (num6 == -1 && grid is ISheetData)
					{
						num6 = ((ISheetData)grid).GetLastRow();
					}
					int num8 = ColIndex(text.Substring(num4 + 1));
					if (num8 == -1 && grid is ISheetData)
					{
						num8 = ((ISheetData)grid).GetLastColumn();
					}
					if (num5 != num6)
					{
						num6 += length2 - cellsFromArgs.GetLength(0);
					}
					else if (num7 != num8)
					{
						num8 += length2 - cellsFromArgs.GetLength(0);
					}
					text = text.Substring(0, num4 + 1) + RangeInfo.GetAlphaLabel(num8) + num6;
					cellsFromArgs = GetCellsFromArgs(text);
				}
			}
			double result = 0.0;
			string empty = string.Empty;
			double result2 = double.MinValue;
			bool isNumber = double.TryParse(text2, out result2);
			for (int j = 0; j < length2; j++)
			{
				empty = GetValueFromArg(cellsFromArgs2[j]);
				if (!CheckForCriteriaMatch(empty.ToUpper(), op, text2.ToUpper(), isNumber, result2))
				{
					continue;
				}
				if (flag && list2.Count == 1)
				{
					num += 1.0;
					num3 += result;
				}
				else if (list3.Count > 0 && i != 0)
				{
					int count = list3.Count;
					if (count.Equals(cellsFromArgs2.Length) && RowIndex(list3[j].ToString()).Equals(RowIndex(cellsFromArgs2[j])))
					{
						list4.Add(cellsFromArgs2[j]);
						if (flag && cellsFromArgs[j] != null)
						{
							empty = GetValueFromArg(cellsFromArgs[j]);
							if (double.TryParse(empty, NumberStyles.Any, null, out result) && flag)
							{
								num3 += result;
								num += 1.0;
							}
						}
						continue;
					}
					for (int k = 0; k < count; k++)
					{
						if (list3[k] == null || !RowIndex(list3[k].ToString()).Equals(RowIndex(cellsFromArgs2[j])))
						{
							continue;
						}
						list4.Add(cellsFromArgs2[j]);
						if (flag && cellsFromArgs[j] != null)
						{
							empty = GetValueFromArg(cellsFromArgs[j]);
							if (double.TryParse(empty, NumberStyles.Any, null, out result) && flag)
							{
								num3 += result;
								num += 1.0;
							}
						}
					}
				}
				else
				{
					list4.Add(cellsFromArgs2[j]);
				}
			}
			list3 = list4;
			list4 = new List<string>();
		}
		double num9 = num3 / num;
		if (ComputeIsErr(num9.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return num9.ToString();
	}

	private string findCriteria(string criteria, ref char op)
	{
		int num = ((criteria.Length > 0 && criteria[0] == TIC[0]) ? 1 : 0);
		if (criteria.Substring(num).StartsWith(">="))
		{
			criteria = criteria.Substring(num + 2, criteria.Length - 2 - 2 * num);
			op = 'j';
		}
		else if (criteria.Substring(num).StartsWith("<="))
		{
			criteria = criteria.Substring(num + 2, criteria.Length - 2 - 2 * num);
			op = 'k';
		}
		else if (criteria.Substring(num).StartsWith("<>"))
		{
			criteria = criteria.Substring(num + 2, criteria.Length - 2 - 2 * num);
			op = 'o';
		}
		else if (criteria.Substring(num).StartsWith("<"))
		{
			criteria = criteria.Substring(num + 1, criteria.Length - 1 - 2 * num);
			op = 'l';
		}
		else if (criteria.Substring(num).StartsWith(">"))
		{
			criteria = criteria.Substring(num + 1, criteria.Length - 1 - 2 * num);
			op = 'g';
		}
		else if (criteria.Substring(num).StartsWith("="))
		{
			criteria = criteria.Substring(num + 1, criteria.Length - 1 - 2 * num);
		}
		criteria = criteria.Replace(TIC, string.Empty);
		return criteria;
	}

	internal bool CheckForCriteriaMatch(string s, char op, string criteria, bool isNumber, double compare)
	{
		string text = criteria;
		double result = 0.0;
		s = s.Replace(TIC, string.Empty);
		switch (op)
		{
		case 'e':
		{
			if (isNumber)
			{
				if (double.TryParse(s, NumberStyles.Any, null, out result))
				{
					return result == compare;
				}
				return false;
			}
			int num6 = text.IndexOf("*");
			if (num6 != -1 && !string.IsNullOrEmpty(s))
			{
				bool flag4 = num6 == 0;
				bool flag5 = text.EndsWith("*");
				string[] array3 = criteria.Split('*');
				if (array3.Length > 2)
				{
					bool flag6 = false;
					for (int j = 0; j < array3.Length; j++)
					{
						flag6 = ((j != 0 || flag4) ? s.Contains(array3[j]) : s.StartsWith(array3[0]));
						if (!flag6)
						{
							return flag6;
						}
					}
					return flag6;
				}
				if (!flag4 && !flag5)
				{
					string[] array4 = criteria.Split('*');
					if (s.StartsWith(array4[0]))
					{
						return s.EndsWith(array4[1]);
					}
					return false;
				}
				if (flag4 && flag5)
				{
					criteria = criteria.Replace("*", string.Empty);
					return s.Contains(criteria);
				}
				if (flag4)
				{
					criteria = criteria.Replace("*", string.Empty);
					return s.EndsWith(criteria);
				}
				if (flag5)
				{
					criteria = criteria.Replace("*", string.Empty);
					return s.StartsWith(criteria);
				}
			}
			if (!string.IsNullOrEmpty(s))
			{
				return s == criteria;
			}
			return false;
		}
		case 'o':
		{
			if (isNumber)
			{
				if (double.TryParse(s, NumberStyles.Any, null, out result))
				{
					return result != compare;
				}
				return false;
			}
			int num3 = text.IndexOf("*");
			if (num3 != -1 && !string.IsNullOrEmpty(s))
			{
				bool flag = num3 == 0;
				bool flag2 = text.EndsWith("*");
				string[] array = criteria.Split('*');
				if (array.Length > 2)
				{
					array = array.Where((string s1) => !string.IsNullOrEmpty(s1)).ToArray();
					bool flag3 = false;
					for (int i = 0; i < array.Length; i++)
					{
						flag3 = ((i != 0 || array.Length < 2) ? (!s.Contains(array[i])) : (!s.StartsWith(array[0]) || !s.EndsWith(array[1])));
						if (flag3)
						{
							return flag3;
						}
					}
					return flag3;
				}
				if (!flag && !flag2)
				{
					string[] array2 = criteria.Split('*');
					if (s.StartsWith(array2[0]))
					{
						return !s.EndsWith(array2[1]);
					}
					return true;
				}
				if (flag && flag2)
				{
					criteria = criteria.Replace("*", string.Empty);
					return !s.Contains(criteria);
				}
				if (flag)
				{
					criteria = criteria.Replace("*", string.Empty);
					return !s.EndsWith(criteria);
				}
				if (flag2)
				{
					criteria = criteria.Replace("*", string.Empty);
					return !s.StartsWith(criteria);
				}
			}
			if (!string.IsNullOrEmpty(s))
			{
				return s != criteria;
			}
			return false;
		}
		case 'j':
		{
			int num2 = string.Compare(s.ToUpper(), criteria.ToUpper());
			if (!isNumber)
			{
				if (!string.IsNullOrEmpty(s))
				{
					return num2 >= 0;
				}
				return false;
			}
			if (double.TryParse(s, out result))
			{
				return result >= compare;
			}
			return false;
		}
		case 'g':
		{
			int num4 = string.Compare(s.ToUpper(), criteria.ToUpper());
			if (!isNumber)
			{
				if (!string.IsNullOrEmpty(s))
				{
					return num4 > 0;
				}
				return false;
			}
			if (double.TryParse(s, out result))
			{
				return result > compare;
			}
			return false;
		}
		case 'l':
		{
			int num5 = string.Compare(s.ToUpper(), criteria.ToUpper());
			if (!isNumber)
			{
				if (!string.IsNullOrEmpty(s))
				{
					return num5 < 0;
				}
				return false;
			}
			if (double.TryParse(s, out result))
			{
				return result < compare;
			}
			return false;
		}
		case 'k':
		{
			int num = string.Compare(s.ToUpper(), criteria.ToUpper());
			if (!isNumber)
			{
				if (!string.IsNullOrEmpty(s))
				{
					return num <= 0;
				}
				return false;
			}
			if (double.TryParse(s, out result))
			{
				return result <= compare;
			}
			return false;
		}
		default:
			return false;
		}
	}

	public string ComputeChidist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = StripTics(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2))
		{
			if (result < 0.0 || result2 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result == 0.0)
			{
				return "1";
			}
			if ((result2 != 1.0 || !excelLikeComputations) && result2 < 1.0)
			{
				if (excelLikeComputations)
				{
					return "#NUM!";
				}
				return FormulaErrorStrings[invalid_arguments];
			}
			num = 1.0 - chidist(result, result2);
		}
		return num.ToString();
	}

	public string ComputeGrowth(string range)
	{
		string[] array = null;
		if (range.Contains(TIC))
		{
			array = range.Split(new string[1] { TIC }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == ",")
				{
					List<string> list = new List<string>(array);
					list.Remove(array[i]);
					array = list.ToArray();
				}
			}
		}
		else
		{
			array = range.Split(new char[1] { ParseArgumentSeparator });
		}
		int length = array.GetLength(0);
		string[] cellsFromArgs = GetCellsFromArgs(array[0]);
		foreach (string arg in cellsFromArgs)
		{
			if (!double.TryParse(GetValueFromArg(arg).Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out var _))
			{
				return ErrorStrings[1].ToString();
			}
		}
		if (length >= 2)
		{
			cellsFromArgs = GetCellsFromArgs(array[1]);
			foreach (string arg2 in cellsFromArgs)
			{
				if (!double.TryParse(GetValueFromArg(arg2).Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out var _))
				{
					return ErrorStrings[1].ToString();
				}
			}
		}
		bool flag = length == 1;
		if (length == 0 || length > 4)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		for (int k = 0; k < doubleArray.GetLength(0); k++)
		{
			if (doubleArray[k] <= 0.0)
			{
				return ErrorStrings[4].ToString();
			}
		}
		double[] array2 = null;
		array2 = ((length <= 1 || !(array[1] == string.Empty)) ? (flag ? new double[doubleArray.GetLength(0)] : GetDoubleArray(array[1])) : doubleArray);
		double[] array3 = ((length < 3) ? new double[array2.GetLength(0)] : GetDoubleArray(array[2]));
		if (doubleArray.GetLength(0) != array2.GetLength(0))
		{
			return ErrorStrings[2].ToString();
		}
		int length2 = array2.GetLength(0);
		if (length2 <= 2 || length2 != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		if (flag)
		{
			for (int l = 0; l < length2; l++)
			{
				array2[l] = l + 1;
			}
		}
		for (int m = 0; m < length2; m++)
		{
			doubleArray[m] = Math.Log10(doubleArray[m]);
		}
		double m2 = 0.0;
		double b = 1.0;
		ComputeLogestMB(doubleArray, array2, out m2, out b);
		int length3 = array3.GetLength(0);
		if (length < 3)
		{
			for (int n = 0; n < length3; n++)
			{
				array3[n] = array2[n];
			}
		}
		for (int num = 0; num < length3; num++)
		{
			if (length > 3 && array[3].Contains(FALSEVALUESTR))
			{
				b = 1.0;
			}
			array3[num] = b * Math.Pow(m2, array3[num]);
		}
		if (length3 > 1 && length > 2)
		{
			string[] cellsFromArgs2 = GetCellsFromArgs(array[2]);
			cellsFromArgs = cellsFromArgs2;
			foreach (string arg3 in cellsFromArgs)
			{
				if (!double.TryParse(GetValueFromArg(arg3).Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out var _))
				{
					return ErrorStrings[1].ToString();
				}
			}
			RowIndex(cellsFromArgs2[0]);
			RowIndex(cellsFromArgs2[1]);
			for (int num2 = 1; num2 < length3; num2++)
			{
				if (!string.IsNullOrEmpty(cell))
				{
					grid.SetValueRowCol(array3[num2], RowIndex(cell), ColIndex(cell));
				}
			}
		}
		return array3[0].ToString();
	}

	internal void ComputeLogestMB(double[] y, double[] x, out double m, out double b)
	{
		m = 0.0;
		b = 1.0;
		int length = x.GetLength(0);
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += x[i];
			num2 += y[i];
		}
		num /= (double)length;
		num2 /= (double)length;
		double num3 = 0.0;
		double num4 = 0.0;
		for (int j = 0; j < length; j++)
		{
			double num5 = x[j] - num;
			num3 += num5 * (y[j] - num2);
			num4 += num5 * num5;
		}
		b = Math.Pow(10.0, num2 - num3 / num4 * num);
		m = Math.Pow(10.0, num3 / num4);
	}

	public string ComputeGammaln(string argList)
	{
		return ComputeGammaln0Precise(argList);
	}

	private double chidist(double x, double v)
	{
		double num = v / 2.0;
		double num2 = 1.0 / (Math.Pow(2.0, num) * Math.Exp(GammaLn(num)));
		num -= 1.0;
		double num3 = 0.0;
		double num4 = (num3 + x) / 2.0;
		double num5 = (x - num3) / 2.0;
		double num6 = 0.0;
		for (int i = 0; i < gauss_n; i++)
		{
			double num7 = gauss_x[i] * num5;
			num6 += gauss_w[i] * (Math.Pow(num4 + num7, num) * Math.Exp((0.0 - (num4 + num7)) / 2.0) + Math.Pow(num4 - num7, num) * Math.Exp((0.0 - (num4 - num7)) / 2.0));
		}
		return num2 * num6 * num5;
	}

	private double chiinv(double p, double v)
	{
		double num = p;
		double num2 = num / 2.0;
		double num3 = 0.0;
		double num4 = 1E-07;
		int i = 100;
		int num5 = 3;
		while (i == 100 && num5 > 0)
		{
			num5--;
			num /= 2.0;
			num2 = num / 2.0;
			for (i = 0; i < 100; i++)
			{
				num3 = 1.0 - chidist(num, v);
				if (Math.Abs((num3 - p) / p) < num4)
				{
					break;
				}
				if (num3 > p)
				{
					num += num2;
					continue;
				}
				num2 /= 2.0;
				if (num - num2 < 0.0)
				{
					num2 = num / 2.0;
				}
				num -= num2;
			}
		}
		if (i == 100)
		{
			num = -1.0;
		}
		return num;
	}

	public string ComputeLinest(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int num = array.Length;
		bool flag = num == 1;
		double m = 0.0;
		double b = 1.0;
		string errorValue = string.Empty;
		if (num == 0 || num > 4)
		{
			string[] array2 = range.Split(new char[1] { TIC[0] });
			List<string> list = new List<string>();
			for (int i = 0; i < array2.Length; i++)
			{
				if (i % 2 != 0)
				{
					list.Add(array2[i]);
				}
			}
			array = list.ToArray();
			num = array.GetLength(0);
			flag = num == 1;
			if (num == 0 || num > 4)
			{
				return FormulaErrorStrings[wrong_number_arguments];
			}
		}
		else if (num > 2)
		{
			if (array[2] == string.Empty)
			{
				array[2] = TRUEVALUESTR;
			}
			else if (!ComputeIsLogical(array[2]).Equals(TRUEVALUESTR) && ComputeIsNumber(array[2]) != TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num == 4)
		{
			if (array[3] == string.Empty)
			{
				array[3] = FALSEVALUESTR;
			}
			else if (!ComputeIsLogical(array[3]).Equals(TRUEVALUESTR) && ComputeIsNumber(array[2]) != TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] array3 = null;
		double[] coefficients;
		if (array[1].Contains(TIC))
		{
			if (computedValueLevel <= 1)
			{
				return LinearRegression.ComputeXArithmetic(doubleArray, array3, array[1], b, m, flag, errorValue, out coefficients);
			}
			string empty = string.Empty;
			empty = LinearRegression.ComputeXArithmetic(doubleArray, array3, array[1], b, m, flag, errorValue, out coefficients);
			empty = TIC;
			if (coefficients != null && coefficients.Length != 0)
			{
				for (int num2 = coefficients.Length - 1; num2 >= 0; num2--)
				{
					empty = empty + coefficients[num2] + ";";
				}
				return empty.Substring(0, empty.Length - 1) + TIC;
			}
		}
		else
		{
			array3 = ((flag || (num > 1 && array[1] == string.Empty)) ? new double[doubleArray.GetLength(0)] : GetDoubleArray(array[1]));
		}
		int length = array3.GetLength(0);
		if (length != doubleArray.Length)
		{
			if (computedValueLevel <= 1)
			{
				return LinearRegression.ComputeXArg(doubleArray, array3, array[1], b, m, flag, errorValue, out coefficients);
			}
			string empty2 = string.Empty;
			empty2 = LinearRegression.ComputeXArg(doubleArray, array3, array[1], b, m, flag, errorValue, out coefficients);
			empty2 = TIC;
			if (coefficients != null && coefficients.Length != 0)
			{
				for (int num3 = coefficients.Length - 1; num3 >= 0; num3--)
				{
					empty2 = empty2 + coefficients[num3] + ";";
				}
				return empty2.Substring(0, empty2.Length - 1) + TIC;
			}
		}
		if (length <= 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (flag || (num > 1 && array[1] == string.Empty))
		{
			for (int j = 0; j < length; j++)
			{
				array3[j] = j + 1;
			}
		}
		LinearRegression.ComputeLinest(doubleArray, array3, out m, out b, out errorValue);
		if (errorValue != string.Empty)
		{
			return errorValue;
		}
		return b.ToString();
	}

	public string ComputeChiinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = StripTics(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3))
		{
			if (result2 < 0.0 || result2 > 1.0 || result3 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result2 == 1.0)
			{
				return "0";
			}
			num = chiinv(result2, result3);
		}
		return num.ToString();
	}

	public string ComputeChitest(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string text2 = array[0];
		double num = 0.0;
		double num2 = 0.0;
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray.GetLength(0);
		if (text2.IndexOf(':') > -1)
		{
			string s = text2.Substring(0, text2.IndexOf(':'));
			int num3 = ColIndex(s);
			int num4 = RowIndex(s);
			s = text2.Substring(text2.IndexOf(':') + 1);
			int num5 = ColIndex(s);
			int num6 = RowIndex(s);
			if (grid is ISheetData)
			{
				if (!(!num4.Equals(-1) || num6.Equals(-1)).Equals(num4.Equals(-1) || !num6.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				if (num4 == -1)
				{
					num4 = ((ISheetData)grid).GetFirstRow();
				}
				if (num3 == -1)
				{
					num3 = ((ISheetData)grid).GetFirstColumn();
				}
				if (num5 == -1)
				{
					num5 = ((ISheetData)grid).GetLastColumn();
				}
				if (num6 == -1)
				{
					num6 = ((ISheetData)grid).GetLastRow();
				}
			}
			num2 = Math.Abs(num3 - num5) * Math.Abs(num4 - num6);
			num2 = 1.0001;
			if (num2 < 1.0)
			{
				return FormulaErrorStrings[invalid_Math_argument];
			}
		}
		else if (excelLikeComputations && doubleArray.Length < 1 && doubleArray2.Length < 1)
		{
			return "#N/A";
		}
		num2 = 0.99555;
		if (length <= 0 || length != doubleArray2.GetLength(0))
		{
			return ErrorStrings[0].ToString();
		}
		double num7 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num = doubleArray2[i] - doubleArray[i];
			num7 += num * num / doubleArray[i];
		}
		return (1.0 - chidist(num7, num2)).ToString();
	}

	private double normaldensity(double x, double u, double s)
	{
		return 1.0 / (Math.Sqrt(Math.PI * 2.0) * s) * Math.Exp((0.0 - (x - u)) * (x - u) / (2.0 * s * s));
	}

	private double normaldist(double x, double u, double s)
	{
		int num = 32;
		double num2;
		double num3;
		if (x > u)
		{
			num2 = u - (x - u);
			num3 = x;
		}
		else
		{
			num2 = x;
			num3 = u + (u - x);
		}
		double num4 = (num3 - num2) / (double)num;
		double num5 = num4 / 3.0;
		double num6 = normaldensity(num2, u, s) + normaldensity(num3, u, s);
		double num7 = 0.0;
		for (int i = 1; i < num; i += 2)
		{
			num7 += 4.0 * normaldensity(num2 + (double)i * num4, u, s);
		}
		double num8 = 0.0;
		for (int j = 2; j < num; j += 2)
		{
			num8 += 2.0 * normaldensity(num2 + (double)j * num4, u, s);
		}
		double num9 = num5 * (num6 + num8 + num7);
		double num10 = num9;
		double num11 = 1E-07;
		int num12 = 0;
		for (num12 = 0; num12 < 10; num12++)
		{
			num *= 2;
			num8 += num7 / 2.0;
			num7 = 0.0;
			num4 = (num4 = (num3 - num2) / (double)num);
			for (int k = 0; k < num; k++)
			{
				if (k % 2 == 1)
				{
					double num13 = normaldensity(num2 + num4 * (double)k, u, s);
					num7 += num13;
				}
			}
			num7 = 4.0 * num7;
			num5 = num4 / 3.0;
			num9 = num5 * (num6 + num8 + num7);
			if (Math.Abs((num9 - num10) / num10) < num11)
			{
				break;
			}
			num10 = num9;
		}
		if (x > u)
		{
			return num9 + (1.0 - num9) / 2.0;
		}
		return (1.0 - num9) / 2.0;
	}

	public string ComputeNormdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		string text2 = array[0];
		string text3 = array[1];
		string text4 = array[2];
		string text5 = array[3];
		text2 = ((string.IsNullOrEmpty(text2) && treatStringsAsZero) ? "0" : text2);
		text3 = ((string.IsNullOrEmpty(text3) && treatStringsAsZero) ? "0" : text3);
		text2 = (bool.TryParse(text2, out var result4) ? Convert.ToInt16(result4).ToString() : text2);
		text3 = (bool.TryParse(text3, out var result5) ? Convert.ToInt16(result5).ToString() : text3);
		text4 = (bool.TryParse(text4, out var result6) ? Convert.ToInt16(result6).ToString() : text4);
		text5 = (bool.TryParse(text5, out var result7) ? Convert.ToInt16(result7).ToString() : text5);
		if (string.IsNullOrEmpty(text4) || string.IsNullOrEmpty(text5))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result) && double.TryParse(text3.Replace(TIC, string.Empty), NumberStyles.Any, null, out result2) && double.TryParse(text4.Replace(TIC, string.Empty), NumberStyles.Any, null, out result3))
		{
			if (length != 3)
			{
				double result8 = 0.0;
				num = ((!double.TryParse(array[3], out result8)) ? ((double)((array[3].Replace(TIC, string.Empty).ToUpper() == TRUEVALUESTR) ? 1 : ((!(array[3].Replace(TIC, string.Empty).ToUpper() == FALSEVALUESTR)) ? (-1) : 0))) : ((double)((result8 != 0.0) ? 1 : 0)));
			}
			if (num == -1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
			num2 = ((num != 0.0) ? normaldist(result, result2, result3) : normaldensity(result, result2, result3));
		}
		return num2.ToString();
	}

	public string ComputeNormsDist(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = (bool.TryParse(GetValueFromArg(argList), out var result) ? Convert.ToInt16(result).ToString() : argList);
		string argList2 = argList + ", 0, 1, " + TRUEVALUESTR;
		return ComputeNormdist(argList2);
	}

	public string ComputeNorminv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && result2 > 0.0 && result2 < 1.0 && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result2 >= 1.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = normalinv(result2, result3, result4);
		}
		if (num <= 0.0)
		{
			return FormulaErrorStrings[iterations_dont_converge];
		}
		return num.ToString();
	}

	private double normalinv(double p, double u, double s)
	{
		double num = u;
		num = ((p < 0.05) ? (u - 2.0 * s) : ((p < 0.5) ? u : ((!(p < 0.95)) ? (u + 5.0 * s) : (u + 2.0 * s))));
		double num2 = num / 2.0;
		double num3 = 0.0;
		double num4 = 1E-07;
		int i = 100;
		int num5 = 3;
		int num6 = 0;
		while (i == 100 && num5 > 0)
		{
			num5--;
			num /= 2.0;
			num2 = num / 2.0;
			for (i = 0; i < 100; i++)
			{
				num6++;
				num3 = normaldist(num, u, s);
				if (Math.Abs((num3 - p) / p) < num4)
				{
					break;
				}
				if (num3 < p)
				{
					num += num2;
					continue;
				}
				num2 /= 2.0;
				if (num - num2 < 0.0)
				{
					num2 = num / 2.0;
				}
				num -= num2;
			}
		}
		if (i == 100)
		{
			num = -1.0;
		}
		return num;
	}

	private double newnormalinv(double p)
	{
		double[] array = new double[6] { -39.69683028665376, 220.9460984245205, -275.9285104469687, 138.357751867269, -30.66479806614716, 2.506628277459239 };
		double[] array2 = new double[5] { -54.47609879822406, 161.5858368580409, -155.6989798598866, 66.80131188771972, -13.28068155288572 };
		double[] array3 = new double[6] { -0.007784894002430293, -0.3223964580411365, -2.400758277161838, -2.549732539343734, 4.374664141464968, 2.938163982698783 };
		double[] array4 = new double[4] { 0.007784695709041462, 0.3224671290700398, 2.445134137142996, 3.754408661907416 };
		double num = 0.02425;
		double num2 = 1.0 - num;
		double num3 = 0.0;
		double num4 = 0.0;
		if (p < num)
		{
			num3 = Math.Sqrt(-2.0 * Math.Log(p));
			return (((((array3[0] * num3 + array3[1]) * num3 + array3[2]) * num3 + array3[3]) * num3 + array3[4]) * num3 + array3[5]) / ((((array4[0] * num3 + array4[1]) * num3 + array4[2]) * num3 + array4[3]) * num3 + 1.0);
		}
		if (num2 < p)
		{
			num3 = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
			return (0.0 - (((((array3[0] * num3 + array3[1]) * num3 + array3[2]) * num3 + array3[3]) * num3 + array3[4]) * num3 + array3[5])) / ((((array4[0] * num3 + array4[1]) * num3 + array4[2]) * num3 + array4[3]) * num3 + 1.0);
		}
		num3 = p - 0.5;
		num4 = num3 * num3;
		return (((((array[0] * num4 + array[1]) * num4 + array[2]) * num4 + array[3]) * num4 + array[4]) * num4 + array[5]) * num3 / (((((array2[0] * num4 + array2[1]) * num4 + array2[2]) * num4 + array2[3]) * num4 + array2[4]) * num4 + 1.0);
	}

	public string ComputeNormsInv(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		argList = GetValueFromArg(argList);
		argList = (bool.TryParse(argList, out var result2) ? Convert.ToInt16(result2).ToString() : argList);
		double.TryParse(StripTics0(argList), out result);
		if (result <= 0.0 || result >= 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		bool flag = false;
		if (!ExcelLikeComputations)
		{
			if (!char.IsLetter(argList, 0))
			{
				double num = double.Parse(argList);
				if (num <= 0.0 || num >= 1.0)
				{
					return "#NUM!";
				}
				if (num < 0.5)
				{
					argList = (1.0 - num).ToString();
					flag = true;
				}
				else if (num == 0.5)
				{
					return "0";
				}
			}
			string argList2 = argList + ", 0, 1";
			if (flag)
			{
				return $"-{ComputeNorminv(argList2)}";
			}
			return ComputeNorminv(argList2);
		}
		return newnormalinv(double.Parse(argList)).ToString();
	}

	public string ComputeConfidence(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = StripTics(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[min_value]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result4 == 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[3].ToString();
			}
			num = (ExcelLikeComputations ? newnormalinv(1.0 - result2 + result2 / 2.0) : normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0));
			num = num * result3 / Math.Sqrt(result4);
		}
		return num.ToString();
	}

	public string ComputeCorrel(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray2[i];
			num2 += doubleArray[i];
		}
		num /= (double)length;
		num2 /= (double)length;
		double num3 = 0.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num6 = doubleArray2[j] - num;
			num7 = doubleArray[j] - num2;
			num3 += num6 * num7;
			num4 += num6 * num6;
			num5 += num7 * num7;
		}
		string text2 = (num3 / Math.Sqrt(num4 * num5)).ToString();
		if (ComputeIsErr(text2) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text2;
	}

	public string ComputeCount(string range)
	{
		int num = 0;
		string text = string.Empty;
		if (isIndexInteriorFormula)
		{
			isIndexInteriorFormula = false;
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		foreach (string text2 in array)
		{
			double result;
			DateTime result2;
			if (text2.IndexOf(':') > -1 && IsRange(text2))
			{
				string[] cellsFromArgs = GetCellsFromArgs(text2.Replace(TIC, string.Empty));
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text = GetValueFromArg(arg);
					}
					catch (Exception)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions)
						{
							if (LibraryComputationException != null)
							{
								throw LibraryComputationException;
							}
							throw new ArgumentException(ErrorStrings[4].ToString());
						}
						return ErrorStrings[4].ToString();
					}
					if (text.Length <= 0)
					{
						continue;
					}
					if (text.Equals(FormulaErrorStrings[19]))
					{
						if (rethrowLibraryComputationExceptions)
						{
							if (LibraryComputationException != null)
							{
								throw LibraryComputationException;
							}
							throw new Exception(FormulaErrorStrings[19]);
						}
						return FormulaErrorStrings[19];
					}
					if (double.TryParse(text, NumberStyles.Any, null, out result) || DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
					{
						num++;
					}
				}
				continue;
			}
			try
			{
				if (text2.Equals(string.Empty) && !text2.StartsWith(TIC))
				{
					num++;
				}
				if (text2.Contains(ParseArgumentSeparator.ToString()))
				{
					string[] cellsFromArgs = SplitArgsPreservingQuotedCommas(StripTics0(text2));
					foreach (string s in cellsFromArgs)
					{
						if (double.TryParse(s, NumberStyles.Any, null, out result) || DateTime.TryParse(s, CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
						{
							num++;
						}
					}
				}
				else
				{
					text = GetValueFromArg(text2);
				}
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions)
				{
					if (LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (text.Length <= 0)
			{
				continue;
			}
			if (text.Equals(FormulaErrorStrings[19]))
			{
				if (rethrowLibraryComputationExceptions)
				{
					if (LibraryComputationException != null)
					{
						throw LibraryComputationException;
					}
					throw new Exception(FormulaErrorStrings[19]);
				}
				return FormulaErrorStrings[19];
			}
			if (double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Any, null, out result) || DateTime.TryParse(text.Replace(TIC, string.Empty), CultureInfo.CurrentCulture, DateTimeStyles.None, out result2) || text.Equals(TRUEVALUESTR) || text.Equals(FALSEVALUESTR))
			{
				num++;
			}
		}
		return num.ToString();
	}

	public string ComputeCounta(string range)
	{
		int num = 0;
		string empty = string.Empty;
		if (isIndexInteriorFormula)
		{
			isIndexInteriorFormula = false;
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (text.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string text2 in cellsFromArgs)
				{
					try
					{
						empty = GetValueFromArg(text2);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (empty.Length > 0)
					{
						num++;
					}
					else if (GetValueFromParentObject(text2, calculateFormula: false) != string.Empty)
					{
						num++;
					}
				}
			}
			else if (text.Equals(string.Empty))
			{
				num++;
			}
			else if (char.IsLetter(text, 0))
			{
				empty = GetValueFromArg(text);
				if (empty.Length > 0)
				{
					num++;
				}
			}
			else if (text.Contains(ParseArgumentSeparator.ToString()))
			{
				string[] cellsFromArgs = SplitArgsPreservingQuotedCommas(text.Replace(TIC, string.Empty));
				foreach (string text3 in cellsFromArgs)
				{
					if (!text3.StartsWith(TIC) && IsCellReference(text3))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
						}
						return FormulaErrorStrings[invalid_arguments];
					}
					if (text3.Length > 0 || text3.Equals(string.Empty))
					{
						num++;
					}
				}
			}
			else if (text.Length > 0)
			{
				num++;
			}
		}
		return num.ToString();
	}

	public string ComputeCountblank(string range)
	{
		int num = 0;
		string text = TIC + TIC;
		if (isIndexInteriorFormula)
		{
			isIndexInteriorFormula = false;
		}
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (string.IsNullOrEmpty(range) || array.Length > 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string[] array2 = array;
		foreach (string text2 in array2)
		{
			string valueFromArg;
			if (text2.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text2);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
					}
					catch (Exception)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ErrorStrings[4].ToString();
					}
					if (valueFromArg == string.Empty || valueFromArg == text)
					{
						num++;
					}
				}
				continue;
			}
			try
			{
				if (!double.TryParse(text2, out var _) && !IsCellReference(text2))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[5].ToString());
					}
					return ErrorStrings[5].ToString();
				}
				valueFromArg = GetValueFromArg(text2);
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ErrorStrings[4].ToString();
			}
			if (!IsCellReference(text2))
			{
				if (double.TryParse(valueFromArg, out var _) || ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_arguments].ToString());
					}
					return FormulaErrorStrings[invalid_arguments].ToString();
				}
				if (!valueFromArg.Replace(TIC, string.Empty).Equals(string.Empty))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[5].ToString());
					}
					return ErrorStrings[5].ToString();
				}
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arguments].ToString());
				}
				return FormulaErrorStrings[invalid_arguments].ToString();
			}
			if (valueFromArg == string.Empty || valueFromArg == text)
			{
				num++;
			}
		}
		return num.ToString();
	}

	public string ComputeCountif(string argList)
	{
		return ComputeCountIFFunctions(argList, isCountif: true);
	}

	private string ComputeCountIFFunctions(string argList, bool isCountif)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		double num = 0.0;
		_ = string.Empty;
		if (isIndexInteriorFormula)
		{
			isIndexInteriorFormula = false;
		}
		bool flag = false;
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		List<string> list3 = new List<string>();
		List<string> list4 = new List<string>();
		int num2;
		for (num2 = 0; num2 < length; num2++)
		{
			list.Add(array[num2]);
			num2++;
			list2.Add(array[num2]);
		}
		string[] cellsFromArgs = GetCellsFromArgs(list[0]);
		if (length < 2 && list.Count == list2.Count && !isCountif)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (list.Count != list2.Count)
		{
			return ErrorStrings[1].ToString();
		}
		if (length != 2 && length != 3 && isCountif)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < list2.Count; i++)
		{
			char op = 'e';
			string text = list2[i];
			if (text[0] != TIC[0] && "=><".IndexOf(text[0]) == -1)
			{
				text = GetValueFromArg(text);
			}
			if (i == list.Count - 1 && !isCountif)
			{
				flag = true;
			}
			if (isCountif)
			{
				flag = true;
			}
			if (text.Length < 1 && isCountif)
			{
				return "0";
			}
			text = ((!(IsArrayFormula && isCountif)) ? findCriteria(text, ref op) : findCriteria(list2[0].Replace('\u0092'.ToString(), string.Empty), ref op));
			string[] cellsFromArgs2 = GetCellsFromArgs(list[i]);
			if (cellsFromArgs2.GetLength(0) != cellsFromArgs.GetLength(0))
			{
				return ErrorStrings[1].ToString();
			}
			if (cellsFromArgs2[0].Equals(ErrorStrings[5]))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_index]);
				}
				return ErrorStrings[5].ToString();
			}
			int length2 = cellsFromArgs2.GetLength(0);
			double result = double.MinValue;
			bool isNumber = double.TryParse(text, out result);
			if (IsArrayFormula && text.Contains(":"))
			{
				return ArrayParser.ComputeCountIF(cellsFromArgs2, op, text, isNumber, result, computeFunctionLevel, length2);
			}
			string[] array2 = null;
			List<string> list5 = new List<string>();
			if (text.Contains(parseArgumentSeparator.ToString()))
			{
				array2 = text.Split(new char[1] { ParseArgumentSeparator });
			}
			else
			{
				list5.Add(text);
				array2 = list5.ToArray();
			}
			string[] array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				text = array3[j];
				for (int k = 0; k < length2; k++)
				{
					string valueFromArg = GetValueFromArg(cellsFromArgs2[k]);
					if (!CheckForCriteriaMatch(valueFromArg.ToUpper(), op, text.ToUpper(), isNumber, result))
					{
						continue;
					}
					if ((isCountif && flag) || (flag && list2.Count == 1))
					{
						num += 1.0;
					}
					else if (list3.Count > 0 && i != 0)
					{
						int count = list3.Count;
						for (int l = 0; l < count; l++)
						{
							if (list3[l] != null && RowIndex(list3[l].ToString()).Equals(RowIndex(cellsFromArgs2[k])))
							{
								list4.Add(cellsFromArgs2[k]);
								if (flag)
								{
									num += 1.0;
								}
							}
						}
					}
					else
					{
						list4.Add(cellsFromArgs2[k]);
					}
				}
			}
			list3 = list4;
			list4 = new List<string>();
		}
		return num.ToString();
	}

	public string ComputeCovar(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray2[i];
			num2 += doubleArray[i];
		}
		num /= (double)length;
		num2 /= (double)length;
		double num3 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num3 += (doubleArray2[j] - num) * (doubleArray[j] - num2);
		}
		return (num3 / (double)length).ToString();
	}

	public string ComputeCritbinom(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		int num = 0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = StripTics(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result2) ? Convert.ToInt16(result2).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result2) ? Convert.ToInt16(result2).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result2) ? Convert.ToInt16(result2).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (!(result4 > 0.0) || !(result4 < 1.0) || !(result > 0.0) || !(result < 1.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			num = critbinom((int)result3, result4, result);
			if (num == int.MaxValue)
			{
				return FormulaErrorStrings[calculation_overflow];
			}
		}
		return num.ToString();
	}

	private int critbinom(int nTrials, double p, double alpha)
	{
		int num = nTrials;
		int num2 = nTrials;
		double num3 = 1.0;
		double num4 = 1.0;
		do
		{
			num2 = num2 / 2 + 1;
			if (num3 >= alpha)
			{
				num4 = binomdist(nTrials, num - 1, p);
				if (double.IsNaN(num4))
				{
					return int.MaxValue;
				}
				if (num4 < alpha && num4 > 0.0)
				{
					break;
				}
				num -= num2;
			}
			else
			{
				num4 = binomdist(nTrials, num + 1, p);
				if (num4 >= alpha)
				{
					num++;
					break;
				}
				num += num2;
			}
			num3 = binomdist(nTrials, num, p);
		}
		while (num < nTrials && num > 0);
		return num;
	}

	public string ComputeExpondist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (result3 < 0.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			num = ((result != 0.0) ? (1.0 - Math.Exp((0.0 - result4) * result3)) : (result4 * Math.Exp((0.0 - result4) * result3)));
		}
		return num.ToString();
	}

	public string ComputeFdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double num = 0.0;
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		valueFromArg = (bool.TryParse(valueFromArg, out var result3) ? Convert.ToInt16(result3).ToString() : valueFromArg);
		string valueFromArg2 = GetValueFromArg(array[1]);
		valueFromArg2 = (string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2);
		valueFromArg2 = (bool.TryParse(valueFromArg2, out result3) ? Convert.ToInt16(result3).ToString() : valueFromArg2);
		string valueFromArg3 = GetValueFromArg(array[2]);
		valueFromArg3 = (string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3);
		valueFromArg3 = (bool.TryParse(valueFromArg3, out result3) ? Convert.ToInt16(result3).ToString() : valueFromArg3);
		double.TryParse(valueFromArg, NumberStyles.Any, null, out var result4);
		double.TryParse(valueFromArg2, NumberStyles.Any, null, out result);
		double.TryParse(valueFromArg3, NumberStyles.Any, null, out result2);
		if (result4 < 0.0 || result < 1.0 || result >= Math.Pow(10.0, 10.0) || result2 < 1.0 || result2 >= Math.Pow(10.0, 10.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		double num2 = Math.Exp(GammaLn((result + result2) / 2.0) - GammaLn(result / 2.0) - GammaLn(result2 / 2.0) + result / 2.0 * Math.Log(result / result2));
		num = 1.0 - num2 * fdist(result4, (int)result, (int)result2);
		if (result4 == 1.0 && result == 1.0 && result2 == 1.0)
		{
			num = Math.Round(Math.Exp(GammaLn((result + result2) / 2.0)) / 2.0, 2);
		}
		return num.ToString();
	}

	private double fdensity(double x, int df1, int df2)
	{
		return Math.Pow(x, (double)(df1 - 2) / 2.0) / Math.Pow(1.0 + (double)df1 * x / (double)df2, (double)(df1 + df2) / 2.0);
	}

	private double fdist(double x, int df1, int df2)
	{
		int num = 32;
		double num2 = 0.0;
		double num3 = (x - num2) / (double)num;
		double num4 = num3 / 3.0;
		double num5 = fdensity(num2, df1, df2) + fdensity(x, df1, df2);
		double num6 = 0.0;
		for (int i = 1; i < num; i += 2)
		{
			num6 += 4.0 * fdensity(num2 + (double)i * num3, df1, df2);
		}
		double num7 = 0.0;
		for (int j = 2; j < num; j += 2)
		{
			num7 += 2.0 * fdensity(num2 + (double)j * num3, df1, df2);
		}
		double num8 = num4 * (num5 + num7 + num6);
		double num9 = num8;
		double num10 = 1E-07;
		int num11 = 0;
		for (num11 = 0; num11 < 10; num11++)
		{
			num *= 2;
			num7 += num6 / 2.0;
			num6 = 0.0;
			num3 = (x - num2) / (double)num;
			for (int k = 0; k < num; k++)
			{
				if (k % 2 == 1)
				{
					double num12 = fdensity(num2 + num3 * (double)k, df1, df2);
					num6 += num12;
				}
			}
			num6 = 4.0 * num6;
			num4 = num3 / 3.0;
			num8 = num4 * (num5 + num7 + num6);
			if (Math.Abs((num8 - num9) / num9) < num10)
			{
				break;
			}
			num9 = num8;
		}
		return num8;
	}

	private double finv(double p, int df1, int df2)
	{
		double num = Math.Exp(GammaLn((double)(df1 + df2) / 2.0) - GammaLn((double)df1 / 2.0) - GammaLn((double)df2 / 2.0) + (double)df1 / 2.0 * Math.Log((double)df1 / (double)df2));
		double num2 = num;
		double num3 = num2 / 2.0;
		double num4 = 0.0;
		double num5 = 1E-07;
		double num6 = 1000.0;
		int i = 100;
		int num7 = 3;
		int num8 = 0;
		double num9 = num / 2.0;
		while (num2 > num6)
		{
			double y = 2.0;
			if (Regex.IsMatch(num2.ToString(), "[0-9.]+E[-+][0-9]+"))
			{
				y = double.Parse(num2.ToString().Split('+', '-')[^1]);
			}
			num2 /= Math.Pow(2.0, y);
			num2 /= 2.0;
			num9 = num2 / 2.0;
		}
		while (i == 100 && num7 > 0)
		{
			num7--;
			num2 /= 2.0;
			num3 = num2 / 2.0;
			for (i = 0; i < 100; i++)
			{
				num8++;
				num4 = 1.0 - num * fdist(num2, df1, df2);
				if (Math.Abs((num4 - p) / p) < num5)
				{
					break;
				}
				if (num4 > p)
				{
					num2 += num3;
					if (num2 > num9)
					{
						num2 = num3 * 2.0;
						num2 /= 2.0;
						num3 = num2 / 2.0;
					}
					continue;
				}
				num3 /= 2.0;
				if (num2 - num3 < 0.0)
				{
					num3 = num2 / 2.0;
				}
				num2 -= num3;
				if (num3 < num5)
				{
					num2 /= 2.0;
					num3 = num2 / 2.0;
				}
			}
		}
		if (i == 100)
		{
			num2 = -1.0;
		}
		return num2;
	}

	public string ComputeFinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = finv(result2, (int)result3, (int)result4);
		}
		if (num <= 0.0)
		{
			return "0";
		}
		return num.ToString();
	}

	public string ComputeFisher(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		if (!double.TryParse(GetValueFromArg(array[0]), NumberStyles.Any, null, out var result) || !(result > -1.0) || !(result < 1.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return (0.5 * Math.Log((1.0 + result) / (1.0 - result))).ToString();
	}

	public string ComputeFisherinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		if (double.TryParse(GetValueFromArg(array[0]), NumberStyles.Any, null, out var result))
		{
			double num2 = Math.Exp(2.0 * result);
			num = (num2 - 1.0) / (num2 + 1.0);
		}
		return num.ToString();
	}

	public string ComputeForecast(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 3 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		for (int i = 1; i <= 2; i++)
		{
			string text2 = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
		}
		if ((!IsRange(array[1]) && (string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(array[1], out var result))) || (!IsRange(array[2]) && string.IsNullOrEmpty(GetValueFromArg(array[2]))) || (!IsRange(array[0]) && bool.TryParse(array[0], out result)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string valueFromArg = GetValueFromArg(array[0]);
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		double.TryParse(valueFromArg, NumberStyles.Any, null, out var result2);
		double[] doubleArray = GetDoubleArray(array[1]);
		double[] doubleArray2 = GetDoubleArray(array[2]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		int num3 = length;
		for (int j = 0; j < length; j++)
		{
			if (doubleArray2[j].Equals(double.NaN) || doubleArray[j].Equals(double.NaN))
			{
				num3--;
				continue;
			}
			num += doubleArray2[j];
			num2 += doubleArray[j];
		}
		num /= (double)num3;
		num2 /= (double)num3;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int k = 0; k < length; k++)
		{
			if (!doubleArray2[k].Equals(double.NaN) && !doubleArray[k].Equals(double.NaN))
			{
				double num6 = doubleArray2[k] - num;
				num4 += num6 * (doubleArray[k] - num2);
				num5 += num6 * num6;
			}
		}
		double num7 = num4 / num5;
		if (ComputeIsErr(num7.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return (num2 - num7 * num + num7 * result2).ToString();
	}

	private double var(double[] x)
	{
		double num = 0.0;
		int length = x.GetLength(0);
		for (int i = 0; i < length; i++)
		{
			num += x[i];
		}
		num /= (double)length;
		double num2 = 0.0;
		for (int j = 0; j < length; j++)
		{
			double num3 = x[j] - num;
			num2 += num3 * num3;
		}
		return num2 / (double)(length - 1);
	}

	public string ComputeKurt(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		if (length < 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray[i];
		}
		num /= (double)length;
		double num2 = 0.0;
		double num3 = num;
		int num4 = length;
		double num5 = 0.0;
		double num6 = num4;
		for (int j = 1; j <= num4; j++)
		{
			num5 += Math.Pow(doubleArray[j - 1] - num3, 2.0);
		}
		double num7 = 0.0;
		double num8 = Math.Sqrt(num5 / (num6 - 1.0));
		double[] array = doubleArray;
		for (int k = 0; k < array.Length; k++)
		{
			double x = (array[k] - num3) / num8;
			num7 += Math.Pow(x, 4.0);
		}
		double num9 = num6 * (num6 + 1.0) / ((num6 - 1.0) * (num6 - 2.0) * (num6 - 3.0));
		double num10 = 3.0 * Math.Pow(num6 - 1.0, 2.0) / ((num6 - 2.0) * (num6 - 3.0));
		return (num9 * num7 - num10).ToString();
	}

	public string ComputeLarge(string range)
	{
		string[] array = null;
		string[] array2 = new string[2];
		bool flag = false;
		double result;
		if (!range.Contains(":") && !range.StartsWith(TIC))
		{
			array = SplitArgsPreservingQuotedCommas(range);
			for (int i = 0; i < array.Length; i++)
			{
				if (IsCellReference(array[i]))
				{
					if (i == array.Length - 2)
					{
						array2[0] += array[i];
					}
					else
					{
						ref string reference = ref array2[0];
						reference = reference + array[i] + parseArgumentSeparator;
					}
				}
				if (double.TryParse(array[i], out result))
				{
					array2[1] = array[i];
				}
			}
			array = array2;
			flag = true;
		}
		else
		{
			array = SplitArgsPreservingQuotedCommas(range);
		}
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (array[1].Contains("n"))
		{
			array[1] = GetValueFromArg(array[1]);
		}
		if (!double.TryParse(array[1], out result) && !flag && (string.IsNullOrEmpty(GetValueFromArg(array[0])) || string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(GetValueFromArg(array[0]), out var result2) || bool.TryParse(GetValueFromArg(array[1]), out result2)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (!double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out var result3))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = (int)result3;
		double[] doubleArray = GetDoubleArray(array[0]);
		int length = doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		if (num < 1 || num > length || doubleArray[length - num].Equals(double.NaN))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return doubleArray[length - num].ToString();
	}

	public string ComputeLognormdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (array[0].Contains(ParseArgumentSeparator.ToString()))
		{
			string[] array2 = SplitArgsPreservingQuotedCommas(array[0].Replace(TIC, string.Empty));
			array[0] = GetValueFromArg(array2[0]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = normaldist(Math.Log(result2), result3, result4);
		}
		return num.ToString();
	}

	public string ComputeLoginv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result2 >= 1.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return ErrorStrings[4].ToString();
			}
			return Math.Exp(normalinv(result2, result3, result4)).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[bad_formula]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeMaxa(string range)
	{
		double num = double.MinValue;
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.Length == 1 && !range.StartsWith(TIC) && string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			string valueFromArg;
			double result2;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg.Length > 0)
					{
						result2 = 0.0;
						if (ErrorStrings.Contains(valueFromArg))
						{
							return valueFromArg;
						}
						double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2);
						num = Math.Max(num, result2);
					}
				}
				continue;
			}
			try
			{
				if (!text.StartsWith(TIC) && string.IsNullOrEmpty(text))
				{
					valueFromArg = "0";
				}
				else
				{
					valueFromArg = GetValueFromArg(text);
					valueFromArg = (bool.TryParse(valueFromArg, out var result3) ? Convert.ToInt16(result3).ToString() : valueFromArg);
					if (ErrorStrings.Contains(valueFromArg))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return valueFromArg;
					}
					if (valueFromArg == string.Empty)
					{
						valueFromArg = "0";
					}
				}
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (valueFromArg.Length <= 0)
			{
				continue;
			}
			result2 = 0.0;
			if (double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num = Math.Max(num, result2);
			}
			else if (valueFromArg.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num != double.MinValue)
		{
			return num.ToString();
		}
		return "0";
	}

	public string ComputeMedian(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		SplitArgsPreservingQuotedCommas(range);
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		_ = string.Empty;
		double[] doubleArray = GetDoubleArray(range);
		Array.Sort(doubleArray);
		int num = doubleArray.GetLength(0) / 2;
		string empty = string.Empty;
		if (doubleArray.GetLength(0) % 2 == 1)
		{
			return doubleArray[num].ToString();
		}
		return ((doubleArray[num] + doubleArray[num - 1]) / 2.0).ToString();
	}

	public string ComputeMina(string range)
	{
		double num = double.MaxValue;
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		string[] array2 = SplitArguments(range, ';');
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array3;
		if (array2.Length > 1)
		{
			array3 = array2;
			foreach (string args in array3)
			{
				string[] array4 = SplitArgsPreservingQuotedCommas(args);
				foreach (string arg in array4)
				{
					string valueFromArg = GetValueFromArg(arg);
					if (valueFromArg.Length > 0)
					{
						if (ErrorStrings.Contains(valueFromArg))
						{
							return valueFromArg;
						}
						valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
						double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out var result2);
						num = Math.Min(num, result2);
					}
				}
			}
			if (num != double.MaxValue)
			{
				return num.ToString();
			}
		}
		array3 = array;
		foreach (string text in array3)
		{
			string valueFromArg2;
			double result2;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] array4 = GetCellsFromArgs(text);
				foreach (string arg2 in array4)
				{
					try
					{
						valueFromArg2 = GetValueFromArg(arg2);
						valueFromArg2 = (bool.TryParse(valueFromArg2, out var result3) ? Convert.ToInt16(result3).ToString() : valueFromArg2);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg2.Length > 0)
					{
						result2 = 0.0;
						if (ErrorStrings.Contains(valueFromArg2))
						{
							return valueFromArg2;
						}
						double.TryParse(valueFromArg2, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2);
						num = Math.Min(num, result2);
					}
				}
				continue;
			}
			try
			{
				if (!text.StartsWith(TIC) && string.IsNullOrEmpty(text))
				{
					valueFromArg2 = "0";
				}
				else
				{
					valueFromArg2 = GetValueFromArg(text);
					valueFromArg2 = (bool.TryParse(valueFromArg2, out var result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2);
					if (valueFromArg2 == string.Empty)
					{
						valueFromArg2 = "0";
					}
				}
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (valueFromArg2.Length <= 0)
			{
				continue;
			}
			result2 = 0.0;
			if (ErrorStrings.Contains(valueFromArg2))
			{
				return valueFromArg2;
			}
			if (double.TryParse(valueFromArg2, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num = Math.Min(num, result2);
			}
			else if (valueFromArg2.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num != double.MaxValue)
		{
			return num.ToString();
		}
		return "0";
	}

	public string ComputeMode(string range)
	{
		double[] doubleArray = GetDoubleArray(range);
		double[] array = doubleArray.Clone() as double[];
		int length = doubleArray.GetLength(0);
		if (length <= 1)
		{
			return "#N/A";
		}
		Array.Sort(doubleArray);
		List<object> list = new List<object>();
		double num = double.NaN;
		int num2 = 0;
		int num3 = 0;
		for (int i = 1; i < length; i++)
		{
			if (doubleArray[i] == doubleArray[i - 1])
			{
				num2++;
				continue;
			}
			if (num2 > num3)
			{
				num3 = num2;
				num = doubleArray[i - 1];
				list.Clear();
				list.Add(num);
			}
			else if (num2 == num3)
			{
				list.Add(doubleArray[i - 1]);
			}
			num2 = 0;
		}
		if (num2 > num3)
		{
			num3 = num2;
			num = doubleArray[length - 1];
			list.Clear();
			list.Add(num);
		}
		if (num3 > 0)
		{
			if (num2 == num3)
			{
				list.Add(doubleArray[length - 1]);
			}
			if (list.Count > 1)
			{
				double[] array2 = array;
				foreach (double num4 in array2)
				{
					if (list.IndexOf(num4) > -1)
					{
						num = num4;
						break;
					}
				}
			}
			return num.ToString();
		}
		return "#N/A";
	}

	public string ComputeNegbinomdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2) && double.TryParse(array[2], NumberStyles.Any, null, out var result3))
		{
			num = negbinomdensity((int)result, (int)result2, result3);
		}
		return num.ToString();
	}

	private double negbinomdensity(int failures, int successes, double p)
	{
		return comb(successes - 1, failures + successes - 1) * Math.Pow(p, successes) * Math.Pow(1.0 - p, failures);
	}

	public string ComputePearson(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		string text2 = pearson(doubleArray2, doubleArray, length).ToString();
		if (ComputeIsErr(text2) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text2;
	}

	public string ComputePercentile(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		List<double> list = new List<double>();
		if (length != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (array[0].Contains(":"))
		{
			int num = 0;
			string[] cellsFromArgs = GetCellsFromArgs(array[0]);
			foreach (string arg in cellsFromArgs)
			{
				double result = 0.0;
				if (double.TryParse(GetValueFromArg(arg).Replace(TIC, ""), NumberStyles.Number, null, out result))
				{
					list.Add(result);
				}
				num++;
			}
		}
		else
		{
			string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (string.IsNullOrEmpty(GetValueFromArg(array[0])) || string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(GetValueFromArg(array[0]), out var result2) || bool.TryParse(GetValueFromArg(array[1]), out result2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			list = new List<double>(GetDoubleArray(array[0]));
		}
		if (!double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out var result3) && (result3 < 0.0 || result3 > 1.0))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		list.Sort();
		int count = list.Count;
		double num2 = 1.0 / (double)(count - 1);
		double num3 = list[count - 1];
		for (int j = 0; j < count - 1; j++)
		{
			if ((double)(j + 1) * num2 > result3)
			{
				result3 = (result3 - (double)j * num2) / num2;
				num3 = list[j] + result3 * (list[j + 1] - list[j]);
				break;
			}
		}
		return num3.ToString("G15");
	}

	internal string ComputeContionalFomattingPercentile(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		List<double> list = new List<double>();
		double result = 0.0;
		for (int i = 0; i < length; i++)
		{
			if (array[i].Contains(":"))
			{
				string[] cellsFromArgs = GetCellsFromArgs(array[i]);
				foreach (string arg in cellsFromArgs)
				{
					double result2 = 0.0;
					if (double.TryParse(GetValueFromArg(arg).Replace(TIC, ""), NumberStyles.None, null, out result2))
					{
						list.Add(result2);
					}
				}
			}
			else if (!double.TryParse(GetValueFromArg(array[i]), NumberStyles.Any, null, out result) && (result < 0.0 || result > 1.0))
			{
				return FormulaErrorStrings[invalid_arguments];
			}
		}
		int count = list.Count;
		list.Sort();
		double num = 1.0 / (double)(count - 1);
		double num2 = list[count - 1];
		for (int k = 0; k < count - 1; k++)
		{
			if ((double)(k + 1) * num > result)
			{
				result = (result - (double)k * num) / num;
				num2 = list[k] + result * (list[k + 1] - list[k]);
				break;
			}
		}
		return num2.ToString();
	}

	public string ComputePercentrank(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		double result = 3.0;
		string valueFromArg = GetValueFromArg(array[1]);
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		double.TryParse(valueFromArg, NumberStyles.Any, null, out var result2);
		if (length == 3)
		{
			string text3 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			valueFromArg = GetValueFromArg(array[2]);
			valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
			double.TryParse(valueFromArg, NumberStyles.Integer, null, out result);
			if (result < 1.0 && result2 > 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		int length2 = doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		double num = 1.0;
		for (int i = 0; i < length2; i++)
		{
			if (doubleArray[i] > result2)
			{
				int j;
				for (j = 0; j + i < length2 && doubleArray[j + i] == result2; j++)
				{
				}
				num = (double)(i - 1) / (double)(i + length2 - i - j - 1);
				if (i > 0 && doubleArray[i - 1] < result2)
				{
					double num2 = (double)i / (double)(length2 - 1);
					num = num2 + (num - num2) * (1.0 - (result2 - doubleArray[i - 1]) / (doubleArray[i] - doubleArray[i - 1]));
				}
				break;
			}
		}
		if (num < 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		string text4 = "0." + new string('#', (int)result);
		return num.ToString(text4);
	}

	public string ComputePermut(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		array[0] = GetValueFromArg(array[0]);
		array[1] = GetValueFromArg(array[1]);
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3))
		{
			if ((result2 <= 0.0 && result3 != 0.0) || result3 < 0.0 || (result2 < result3 && result2 != 0.0 && result3 != 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			int num2 = (int)(result3 + 0.1);
			int num3 = (int)(result2 + 0.1);
			double num4 = 1.0;
			for (int i = num3 - num2 + 1; i <= num3; i++)
			{
				num4 *= (double)i;
			}
			num = num4;
			return num.ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputePoisson(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (result3 < 0.0 || result4 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			int num2 = (int)result3;
			if (result == 0.0)
			{
				double num3 = 1.0;
				for (int j = 2; j <= num2; j++)
				{
					num3 *= (double)j;
				}
				num = Math.Exp(0.0 - result4) * Math.Pow(result4, num2) / num3;
			}
			else
			{
				double num4 = 1.0;
				num = 0.0;
				double num5 = 1.0;
				for (int k = 0; k <= num2; k++)
				{
					num += num5 / num4;
					num4 *= (double)(k + 1);
					num5 *= result4;
				}
				num = Math.Exp(0.0 - result4) * num;
			}
		}
		return num.ToString();
	}

	public string ComputeProb(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 3 && length != 4) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < 2; i++)
		{
			string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		for (int j = 2; j <= 3; j++)
		{
			if (j <= length - 1)
			{
				string text2 = FormulaErrorStringCheck(array[j], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
			}
		}
		string valueFromArg = GetValueFromArg(array[2]);
		valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		double result2 = 0.0;
		double.TryParse(valueFromArg, NumberStyles.Any, null, out result2);
		double result3 = result2;
		if (length == 4)
		{
			valueFromArg = GetValueFromArg(array[3]);
			valueFromArg = (string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg);
			valueFromArg = (bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg);
			double.TryParse(valueFromArg, NumberStyles.Any, null, out result3);
		}
		double[] doubleArray = GetDoubleArray(array[1]);
		double[] doubleArray2 = GetDoubleArray(array[0]);
		int length2 = doubleArray2.GetLength(0);
		if (length2 != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		for (int k = 0; k < length2; k++)
		{
			double num2 = doubleArray2[k];
			if (num2 >= result2 && num2 <= result3)
			{
				num += doubleArray[k];
			}
		}
		return num.ToString();
	}

	public string ComputeQuartile(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if ((!IsRange(array[0]) && (string.IsNullOrEmpty(GetValueFromArg(array[0])) || bool.TryParse(GetValueFromArg(array[0]), out var result))) || (!IsRange(array[1]) && (string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(GetValueFromArg(array[1]), out result))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out var result2) && result2 >= 0.0 && result2 <= 4.0)
		{
			return ComputePercentile(array[0] + ParseArgumentSeparator + result2 * 0.25);
		}
		if (result2 < 0.0 || result2 > 4.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeRank(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		int num = 0;
		string valueFromArg = GetValueFromArg(array[0]);
		if (double.TryParse(valueFromArg, NumberStyles.Any, null, out var result))
		{
			double result2 = 0.0;
			if (length == 3)
			{
				string text3 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text3))
				{
					return text3;
				}
				valueFromArg = GetValueFromArg(array[2]);
				double.TryParse(valueFromArg, NumberStyles.Integer, null, out result2);
			}
			double result3 = 0.0;
			bool flag = false;
			_ = array[1];
			double[] doubleArray = GetDoubleArray(array[1]);
			double.TryParse(valueFromArg, NumberStyles.Any, null, out result3);
			if (result2 == 0.0)
			{
				Array.Sort(doubleArray, (double a, double b) => -a.CompareTo(b));
			}
			else
			{
				Array.Sort(doubleArray);
			}
			double[] array2 = doubleArray;
			foreach (double num2 in array2)
			{
				if (!double.IsNaN(num2))
				{
					num++;
					if (num2 == result)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
		}
		return num.ToString();
	}

	public string ComputeRsq(string range)
	{
		string text = ComputePearson(range);
		double result = 0.0;
		if (double.TryParse(text, NumberStyles.Any, null, out result))
		{
			result *= result;
		}
		else if (ErrorStrings.Contains(text))
		{
			return text;
		}
		return result.ToString();
	}

	public string ComputeSkew(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		if (length < 3)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		double num = sd(doubleArray, out xbar);
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num2 += Math.Pow((doubleArray[i] - xbar) / num, 3.0);
		}
		return ((double)length * num2 / (double)(length - 1) / (double)(length - 2)).ToString();
	}

	private double sd(double[] x, out double xbar)
	{
		int length = x.GetLength(0);
		xbar = 0.0;
		for (int i = 0; i < length; i++)
		{
			xbar += x[i];
		}
		xbar /= length;
		double num = 0.0;
		double num2 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num2 = x[j] - xbar;
			num += num2 * num2;
		}
		if (length == 1)
		{
			return 0.0;
		}
		return Math.Sqrt(num / (double)(length - 1));
	}

	public string ComputeSlope(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		if (!IsCellReference(array[0]))
		{
			string text = FormulaErrorStringCheck(range, FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if ((!IsCellReference(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsCellReference(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		double num = doubleArray2.Length;
		if (num != (double)doubleArray.Length)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num2 = 0.0;
		double num3 = 0.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < doubleArray2.Length; i++)
		{
			if (doubleArray2[i].ToString() != double.NaN.ToString() && doubleArray[i].ToString() != double.NaN.ToString())
			{
				num2 += doubleArray2[i] * doubleArray[i];
				num3 += doubleArray2[i];
				num4 += doubleArray[i];
				num5 += doubleArray2[i] * doubleArray2[i];
			}
		}
		string text2 = ((num2 - num3 * num4 / num) / (num5 - num3 * num3 / num)).ToString();
		if (ComputeIsErr(text2) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text2;
	}

	public string ComputeSmall(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int num = 0;
		double result;
		double[] doubleArray;
		if (length == 2)
		{
			string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			if (!double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out result))
			{
				return FormulaErrorStrings[invalid_arguments];
			}
			num = (int)result;
			doubleArray = GetDoubleArray(array[0]);
			List<double> list = new List<double>();
			for (int i = 0; i < doubleArray.GetLength(0); i++)
			{
				if (doubleArray[i].ToString() != double.NaN.ToString())
				{
					list.Add(doubleArray[i]);
				}
			}
			doubleArray = list.ToArray();
		}
		else
		{
			List<double> list2 = new List<double>();
			for (int j = 0; j < length; j++)
			{
				if (array[j].Contains(":"))
				{
					string text3 = FormulaErrorStringCheck(array[j], FormulaArgumentType.Range);
					if (ErrorStrings.Contains(text3))
					{
						return text3;
					}
					doubleArray = GetDoubleArray(array[j]);
					for (int k = 0; k < doubleArray.GetLength(0); k++)
					{
						if (doubleArray[k].ToString() != double.NaN.ToString())
						{
							list2.Add(doubleArray[k]);
						}
					}
				}
				else
				{
					string text4 = FormulaErrorStringCheck(array[j], FormulaArgumentType.Numbers);
					if (ErrorStrings.Contains(text4))
					{
						return text4;
					}
					if (!double.TryParse(GetValueFromArg(array[j]), NumberStyles.Integer, null, out result))
					{
						return FormulaErrorStrings[invalid_arguments];
					}
					num = (int)result;
				}
			}
			doubleArray = list2.ToArray();
		}
		if (num < 1 || num > doubleArray.GetLength(0))
		{
			return ErrorStrings[4].ToString();
		}
		Array.Sort(doubleArray);
		return doubleArray[num - 1].ToString();
	}

	public string ComputeStandardize(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (result <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			num = (result3 - result4) / result;
		}
		return num.ToString();
	}

	public string ComputeStdev(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		List<double> list = new List<double>(doubleArray);
		double[] array = doubleArray;
		for (int i = 0; i < array.Length; i++)
		{
			double item = array[i];
			if (item.ToString() == double.NaN.ToString())
			{
				list.Remove(item);
			}
		}
		doubleArray = list.ToArray();
		if (length < 2)
		{
			return ErrorStrings[3].ToString();
		}
		double xbar = 0.0;
		return sd(doubleArray, out xbar).ToString();
	}

	public string ComputeStdeva(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArrayA = GetDoubleArrayA(range);
		if (doubleArrayA.GetLength(0) < 2)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		return sd(doubleArrayA, out xbar).ToString();
	}

	public string ComputeStdevaP(string range)
	{
		double[] doubleArrayA = GetDoubleArrayA(range);
		if (doubleArrayA.GetLength(0) < 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		return StdevdotP(doubleArrayA).ToString();
	}

	public string ComputeStdevp(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		if (length < 2)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		return (sd(doubleArray, out xbar) * Math.Sqrt(length - 1) / Math.Sqrt(length)).ToString();
	}

	public string ComputeStdevpa(string range)
	{
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArrayA = GetDoubleArrayA(range);
		int length = doubleArrayA.GetLength(0);
		if (length < 2)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		return (sd(doubleArrayA, out xbar) * Math.Sqrt(length - 1) / Math.Sqrt(length)).ToString();
	}

	public string ComputeSteyx(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray2[i];
			num2 += doubleArray[i];
		}
		num /= (double)length;
		num2 /= (double)length;
		double num3 = 0.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num7 = doubleArray2[j] - num;
			num6 = doubleArray[j] - num2;
			num3 += num7 * num6;
			num4 += num7 * num7;
			num5 += num6 * num6;
		}
		string text2 = Math.Sqrt((num5 - num3 * num3 / num4) / (double)(length - 2)).ToString();
		if (ComputeIsErr(text2) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text2;
	}

	public string ComputeTrimmean(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out var result);
		double[] doubleArray = GetDoubleArray(array[0]);
		int length = doubleArray.GetLength(0);
		int num = (int)(result * (double)length);
		num /= 2;
		if (result < 0.0 || result > 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		Array.Sort(doubleArray);
		double num2 = 0.0;
		length -= num;
		for (int i = num; i < length; i++)
		{
			num2 += doubleArray[i];
		}
		return (num2 / (double)(length - num)).ToString();
	}

	public string ComputeVar(string range)
	{
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		return var(doubleArray).ToString();
	}

	private double[] GetDoubleArrayA(string range)
	{
		string text = string.Empty;
		List<object> list = new List<object>();
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range.Replace(TIC, string.Empty));
		foreach (string text2 in array)
		{
			if (text2.IndexOf(':') > -1)
			{
				string[] cellsFromArgs = GetCellsFromArgs(text2);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text = GetValueFromArg(arg);
					}
					catch
					{
					}
					if (text.Length > 0)
					{
						double result = 0.0;
						if (text.ToUpper() == TRUEVALUESTR)
						{
							result = 1.0;
						}
						else
						{
							double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result);
						}
						list.Add(result);
					}
				}
				continue;
			}
			try
			{
				text = GetValueFromArg(text2);
			}
			catch
			{
			}
			if (text.Length > 0)
			{
				double result = 0.0;
				if (text.ToUpper() == TRUEVALUESTR)
				{
					result = 1.0;
				}
				else
				{
					double.TryParse(text.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result);
				}
				list.Add(result);
			}
		}
		return ListToDouble(list);
	}

	public string ComputeVara(string range)
	{
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArrayA = GetDoubleArrayA(range);
		return var(doubleArrayA).ToString();
	}

	public string ComputeVarp(string range)
	{
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		return ((double)(length - 1) * var(doubleArray) / (double)length).ToString();
	}

	public string ComputeVarpa(string range)
	{
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArrayA = GetDoubleArrayA(range);
		int length = doubleArrayA.GetLength(0);
		return ((double)(length - 1) * var(doubleArrayA) / (double)length).ToString();
	}

	public string ComputeWeibull(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result) ? Convert.ToInt16(result).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result3 <= 0.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (length != 3)
			{
				double result5 = 0.0;
				double.TryParse(array[3], NumberStyles.Any, null, out result5);
				num = ((array[3] == TRUEVALUESTR || result5 != 0.0) ? 1 : 0);
			}
			num2 = ((num != 0.0) ? (1.0 - Math.Exp(0.0 - Math.Pow(result2 / result4, result3))) : (result3 / Math.Pow(result4, result3) * Math.Pow(result2, result3 - 1.0) * Math.Exp(0.0 - Math.Pow(result2 / result4, result3))));
		}
		return num2.ToString();
	}

	public string ComputeZtest(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		for (int i = 1; i < length; i++)
		{
			if (i <= length - 1)
			{
				string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
			}
		}
		string valueFromArg = GetValueFromArg(array[1]);
		if (!double.TryParse(valueFromArg, NumberStyles.Any, null, out var result))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double xbar;
		double result2 = sd(doubleArray, out xbar);
		if (length == 3)
		{
			double.TryParse(valueFromArg, NumberStyles.Any, null, out result2);
		}
		return (1.0 - normaldist((xbar - result) / (result2 / Math.Sqrt(doubleArray.GetLength(0))), 0.0, 1.0)).ToString();
	}

	private void CalculateMultiRange(ref string range)
	{
		string[] array = null;
		string text = string.Empty;
		string text2 = string.Empty;
		string text3 = string.Empty;
		range = range.Replace('\u0092'.ToString(), string.Empty);
		for (int i = 0; i < range.Length; i++)
		{
			string text4 = string.Empty;
			string text5 = string.Empty;
			while (i != range.Length && (char.IsDigit(range[i]) | (range[i] == ':') | (i != 0 && IsUpper(range[i]) && !char.IsDigit(range[i - 1])) | (i == 0 && IsUpper(range[i]))))
			{
				text4 += range[i++];
			}
			if (!text4.Contains(":"))
			{
				while (i != range.Length && (char.IsDigit(range[i]) | (range[i] == ':') | (range[i] == '!') | (i != 0 && IsUpper(range[i])) | (i == 0 && IsUpper(range[i]))))
				{
					text4 += range[i++];
				}
			}
			while (i != range.Length - 1 && !IsUpper(range[i]) && ((char.IsLetter(range[i]) && range[i - 1].ToString().IndexOfAny(tokens) <= -1) | char.IsDigit(range[i])))
			{
				text5 += range[i++];
			}
			if (text5 == string.Empty && i == range.Length - 1 && range[i - 1].ToString().IndexOfAny(tokens) > -1)
			{
				text5 = range[i].ToString();
			}
			array = GetCellsFromArgs(text4);
			if (text4 != string.Empty && text5 == string.Empty)
			{
				for (int j = 0; j <= array.Length - 1; j++)
				{
					text = text + GetValueFromArg(array[j]) + ";";
				}
				text = text.Remove(text.Length - 1);
				i--;
			}
			else if (text4 != string.Empty && text5 != string.Empty)
			{
				for (int k = 0; k <= array.Length - 1; k++)
				{
					text2 = text2 + GetValueFromArg('\u0092' + array[k] + text5 + '\u0092') + ";";
				}
				text2 = text2.Remove(text2.Length - 1);
				i--;
			}
			else
			{
				if (!(text4 == string.Empty) || !(text5 != string.Empty) || !(text2 != string.Empty) || !(text != string.Empty))
				{
					continue;
				}
				int num = 0;
				string[] array2 = text.Replace(TIC, string.Empty).Split(';');
				string[] array3 = text2.Replace(TIC, string.Empty).Split(';');
				if (array2.Length == array3.Length)
				{
					for (num = 0; num <= array2.Length - 1; num++)
					{
						text3 = ((num + 1 > array2.Length || !(ComputeIsNumber(array2[num]) == "TRUE") || !(ComputeIsNumber(array2[num]) == "TRUE")) ? (text3 + GetValueFromArg('\u0092' + array2[num] + array3[num] + text5 + '\u0092') + ";") : (text3 + GetValueFromArg('\u0092' + "n" + array2[num] + "n" + array3[num] + text5 + '\u0092') + ";"));
					}
					text3 = text3.Remove(text3.Length - 1);
				}
			}
		}
		range = TIC + text3 + TIC;
	}

	public string ComputeMax(string range)
	{
		double num = double.MinValue;
		if (!range.Contains(parseArgumentSeparator.ToString()) && range.Contains(":") && range.IndexOf(":") != range.LastIndexOf(":"))
		{
			CalculateMultiRange(ref range);
		}
		if (!range.Contains(parseArgumentSeparator.ToString()) && !range.Contains(";"))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = ((!range.StartsWith(TIC) || !range.EndsWith(TIC) || !range.Contains(";")) ? SplitArgsPreservingQuotedCommas(range) : range.Replace(TIC, string.Empty).Split(new string[1] { ";" }, StringSplitOptions.RemoveEmptyEntries));
		if (array.Length == 1 && !range.StartsWith(TIC) && string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result2;
			string text2;
			if (text.IndexOf(':') > -1 && IsRange(text))
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text2 = GetValueFromArg(arg);
						if (text2 != null && DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out var result) && !double.TryParse(text2, NumberStyles.Any, null, out result2))
						{
							text2 = GetSerialDateTimeFromDate(result).ToString();
						}
						if (ErrorStrings.Contains(text2))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return text2;
						}
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (text2.Length > 0)
					{
						if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
						{
							num = Math.Max(num, result2);
						}
						else if (ErrorStrings.Contains(text2))
						{
							return text2;
						}
					}
				}
				continue;
			}
			try
			{
				if (!text.StartsWith(TIC) && string.IsNullOrEmpty(text))
				{
					text2 = "0";
				}
				else
				{
					text2 = GetValueFromArg(text);
					text2 = ((bool.TryParse(text2, out var result3) && !IsCellReference(text)) ? Convert.ToInt16(result3).ToString() : text2);
					if (text2 != null && TryParseExactDateTime(text2.Replace(TIC, string.Empty), out var result4))
					{
						text2 = (GetSerialDateTimeFromDate(result4) - GetSerialDateTimeFromDate(DateTime.Today)).ToString();
					}
					if (text2 != null && DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out result4) && !double.TryParse(text2, NumberStyles.Any, null, out result2))
					{
						text2 = GetSerialDateTimeFromDate(result4).ToString();
					}
					if (ErrorStrings.Contains(text2))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return text2;
					}
					if (text2 == string.Empty && treatStringsAsZero && !IsCellReference(text))
					{
						text2 = "0";
					}
				}
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (text2.Length <= 0)
			{
				continue;
			}
			if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num = Math.Max(num, result2);
			}
			else if (text2.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num != double.MinValue)
		{
			return num.ToString();
		}
		return "0";
	}

	public string ComputeSubTotal(string args)
	{
		string empty = string.Empty;
		int num = 0;
		string[] array = SplitArguments(args, ParseArgumentSeparator);
		if (array.GetLength(0) < 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		empty = ((!IsCellReference(array[0])) ? array[0] : GetValueFromArg(array[0]));
		if (double.TryParse(empty, out var result))
		{
			num = (int)result;
			if ((num < 1 || num > 11) && (num < 101 || num > 111))
			{
				return ErrorStrings[1].ToString();
			}
		}
		if (IgnoreSubtotal)
		{
			return string.Empty;
		}
		empty = args.Remove(0, array[0].Length + 1);
		IgnoreSubtotal = true;
		string empty2 = string.Empty;
		switch (num)
		{
		case 1:
		case 101:
			empty2 = ComputeAvg(empty);
			break;
		case 2:
		case 102:
			empty2 = ComputeCount(empty);
			break;
		case 3:
		case 103:
			empty2 = ComputeCounta(empty);
			break;
		case 4:
		case 104:
			empty2 = ComputeMax(empty);
			break;
		case 5:
		case 105:
			empty2 = ComputeMin(empty);
			break;
		case 6:
		case 106:
			empty2 = ComputeProduct(empty);
			break;
		case 7:
		case 107:
			empty2 = ComputeStdev(empty);
			break;
		case 8:
		case 108:
			empty2 = ComputeStdevp(empty);
			break;
		case 9:
		case 109:
			empty2 = ComputeSum(empty);
			break;
		case 10:
		case 110:
			empty2 = ComputeVar(empty);
			break;
		case 11:
		case 111:
			empty2 = ComputeVarp(empty);
			break;
		default:
			empty2 = ErrorStrings[1].ToString();
			break;
		}
		IgnoreSubtotal = false;
		return empty2;
	}

	public string ComputeMin(string range)
	{
		double num = double.MaxValue;
		if (!range.Contains(parseArgumentSeparator.ToString()) && !range.Contains(";"))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = ((!range.StartsWith(TIC) || !range.EndsWith(TIC) || !range.Contains(";")) ? SplitArgsPreservingQuotedCommas(range) : range.Replace(TIC, string.Empty).Split(new string[1] { ";" }, StringSplitOptions.RemoveEmptyEntries));
		if (string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result2;
			string text2;
			if (text.IndexOf(':') > -1 && IsRange(text))
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						text2 = GetValueFromArg(arg);
						if (text2 != null && DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out var result) && !double.TryParse(text2, NumberStyles.Any, null, out result2))
						{
							text2 = GetSerialDateTimeFromDate(result).ToString();
						}
						if (ErrorStrings.Contains(text2))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return text2;
						}
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (text2.Length > 0 && double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
					{
						num = Math.Min(num, result2);
					}
				}
				continue;
			}
			try
			{
				if (!text.StartsWith(TIC) && string.IsNullOrEmpty(text))
				{
					text2 = "0";
				}
				else
				{
					text2 = GetValueFromArg(text);
					text2 = ((bool.TryParse(text2, out var result3) && !IsCellReference(text)) ? Convert.ToInt16(result3).ToString() : text2);
					if (TryParseExactDateTime(text2.Replace(TIC, string.Empty), out var result4))
					{
						text2 = (GetSerialDateTimeFromDate(result4) - GetSerialDateTimeFromDate(DateTime.Today)).ToString();
					}
					else if (text2 != null && DateTime.TryParse(text2.Replace(TIC, string.Empty), null, DateTimeStyles.None, out result4) && !double.TryParse(text2, NumberStyles.Any, null, out result2))
					{
						text2 = GetSerialDateTimeFromDate(result4).ToString();
					}
					if (ErrorStrings.Contains(text2))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return text2;
					}
					if (text2 == string.Empty && !IsCellReference(text))
					{
						text2 = "0";
					}
				}
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (text2.Length <= 0)
			{
				continue;
			}
			if (double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num = Math.Min(num, result2);
			}
			else if (text2.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num != double.MaxValue)
		{
			return num.ToString();
		}
		return "0";
	}

	public string ComputeAvg(string range)
	{
		double num = 0.0;
		int num2 = 0;
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.Length < 1 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string[] array2 = array;
		foreach (string text in array2)
		{
			double result2;
			string valueFromArg;
			if (text.IndexOf(':') > -1 && !TryParseExactDateTime(text.Replace(TIC, string.Empty), out var _))
			{
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
						if (ErrorStrings.Contains(valueFromArg))
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[bad_formula]);
							}
							return valueFromArg;
						}
					}
					catch
					{
						ExceptionThrown = true;
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(ErrorStrings[4].ToString());
						}
						return ErrorStrings[4].ToString();
					}
					if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
					{
						num += result2;
						num2++;
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
				if (ErrorStrings.Contains(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return valueFromArg;
				}
				if (ExcelLikeComputations && useDatesInCalcs && !double.TryParse(valueFromArg.Replace(TIC, string.Empty), out var _))
				{
					if (TryParseExactDateTime(valueFromArg.Replace(TIC, string.Empty), out var result4))
					{
						valueFromArg = (GetSerialDateTimeFromDate(result4) - GetSerialDateTimeFromDate(DateTime.Today)).ToString();
					}
					else if (IsDate(valueFromArg.Replace(TIC, string.Empty), out result4))
					{
						valueFromArg = GetSerialDateTimeFromDate(result4).ToString();
					}
				}
				if (string.IsNullOrEmpty(text))
				{
					valueFromArg = "0";
				}
				if (array.Length == 1 && IsCellReference(text) && string.IsNullOrEmpty(valueFromArg))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[3].ToString();
				}
			}
			catch
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			if (valueFromArg.Length <= 0)
			{
				continue;
			}
			if (double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, null, out result2))
			{
				num += result2;
				num2++;
			}
			else if (valueFromArg.StartsWith(TIC))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num2 > 0)
		{
			num /= (double)num2;
		}
		else if (num2 == 0 && num == 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		return num.ToString();
	}

	public string ComputeHarmean(string range)
	{
		double num = 0.0;
		int num2 = 0;
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		foreach (string text in array)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg.Length <= 0)
					{
						continue;
					}
					if (ErrorStrings.Contains(valueFromArg))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return valueFromArg;
					}
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0)
					{
						num2++;
						num += 1.0 / result;
					}
					else if (ErrorStrings.Contains(valueFromArg))
					{
						return valueFromArg;
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (valueFromArg.Length > 0)
			{
				string text2 = FormulaErrorStringCheck(valueFromArg, FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
				if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result) && result != 0.0)
				{
					num2++;
					num += 1.0 / result;
				}
				else if (ErrorStrings.Contains(valueFromArg))
				{
					return valueFromArg;
				}
			}
		}
		if (num2 > 0)
		{
			num = (double)num2 / num;
		}
		return num.ToString();
	}

	public string ComputeHypgeomdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result5) ? Convert.ToInt16(result5).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Integer, null, out result) && double.TryParse(array[1], NumberStyles.Integer, null, out result2) && double.TryParse(array[2], NumberStyles.Integer, null, out result3) && double.TryParse(array[3], NumberStyles.Integer, null, out result4))
		{
			int num2 = (int)result;
			int num3 = (int)result2;
			int num4 = (int)result3;
			int num5 = (int)result4;
			if (num2 < 0 || num3 < num2 || num4 <= 0 || num5 < num4 || num2 > num4 || num3 > num5 || num3 <= 0 || num5 <= 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			num = comb(num2, num4) * comb(num3 - num2, num5 - num4) / comb(num3, num5);
		}
		return num.ToString();
	}

	public string ComputeHypgeomOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 5)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double result4 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out result) && double.TryParse(array[1], NumberStyles.Any, null, out result2) && double.TryParse(array[2], NumberStyles.Any, null, out result3) && double.TryParse(array[3], NumberStyles.Any, null, out result4))
		{
			int num2 = (int)result;
			int num3 = (int)result2;
			int num4 = (int)result3;
			int num5 = (int)result4;
			if (num2 < 0 || num3 < num2 || num4 <= 0 || num5 < num4 || num2 > num4 || num3 > num5 || num3 <= 0 || num5 <= 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (array[4] == TRUEVALUESTR)
			{
				num2 = (int)result;
				for (int j = 0; j <= num2; j++)
				{
					num += comb(j, num4) * comb(num3 - j, num5 - num4) / comb(num3, num5);
				}
			}
			else
			{
				num = comb(num2, num4) * comb(num3 - num2, num5 - num4) / comb(num3, num5);
			}
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out result) || !double.TryParse(array[1], NumberStyles.Any, null, out result2) || !double.TryParse(array[2], NumberStyles.Any, null, out result3) || !double.TryParse(array[3], NumberStyles.Any, null, out result4))
		{
			return ErrorStrings[1].ToString();
		}
		return num.ToString();
	}

	private string CalculateArea(string s)
	{
		string empty = string.Empty;
		string text = string.Empty;
		if (IsRange(s))
		{
			string[] cellsFromArgs = GetCellsFromArgs(s);
			for (int i = 0; i < cellsFromArgs.Length; i++)
			{
				empty = GetValueFromArg(cellsFromArgs[i]);
				empty = ((i != cellsFromArgs.Length - 1) ? (empty + parseArgumentSeparator) : empty);
				text += empty;
			}
		}
		if (!text.StartsWith(TIC) && !text.EndsWith(TIC))
		{
			text = TIC + text + TIC;
		}
		return text;
	}

	public string ComputeIf(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (args.Length > 0 && args.IndexOfAny(new char[2] { ParseArgumentSeparator, ':' }) == -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[requires_3_args]);
			}
			return FormulaErrorStrings[requires_3_args];
		}
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.GetLength(0) <= 3)
		{
			try
			{
				double result = 0.0;
				if ((IsArrayFormula && array[0].IndexOf(':') > -1 && IsRange(array[0])) || (computedValueLevel > 1 && array[0].IndexOf(':') > -1))
				{
					string text = ArrayParser.ComputeInteriorFunction(args, "IF", computeFunctionLevel);
					if (text != string.Empty)
					{
						return text;
					}
				}
				string text2 = (string.IsNullOrEmpty(array[0]) ? "0" : GetValueFromArg(array[0]));
				if (!double.TryParse(text2, out result))
				{
					if (ErrorStrings.Contains(text2))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return text2;
					}
					if ((!IsCellReference(array[0]) && !bool.TryParse(text2.Replace(TIC, string.Empty), out var _) && text2.StartsWith(TIC)) || (IsCellReference(array[0]) && text2.StartsWith(TIC)))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return ErrorStrings[1].ToString();
					}
				}
				empty = GetValueFromArg(array[0]);
				double result3 = 0.0;
				if (empty.Replace(TIC, string.Empty).ToUpper().Equals(TRUEVALUESTR) || (double.TryParse(empty, NumberStyles.Any, null, out result3) && result3 != 0.0))
				{
					empty = ((computedValueLevel > 1 && IsRange(array[1]) && !array[1].Contains(TIC)) ? array[1] : ((!string.IsNullOrEmpty(array[1]) || !TreatStringsAsZero) ? GetValueFromArg(array[1]) : "0"));
					if (string.IsNullOrEmpty(empty) && TreatStringsAsZero)
					{
						empty = GetExactResultsFromCellReference(array[1], empty);
					}
					else if (!string.IsNullOrEmpty(empty) && empty[0] == TIC[0] && !IsCellReference(array[1]) && UseNoAmpersandQuotes)
					{
						empty = Regex.Replace(empty, "^\"|\"$", "");
					}
				}
				else if (array.Length < 3 && (empty.Replace(TIC, string.Empty).ToUpper().Equals(FALSEVALUESTR) || (double.TryParse(empty, NumberStyles.Any, null, out result3) && result3 == 0.0)))
				{
					empty = FALSEVALUESTR;
				}
				else if (empty.Replace(TIC, string.Empty).ToUpper().Equals(FALSEVALUESTR) || empty == string.Empty || (double.TryParse(empty, NumberStyles.Any, null, out result3) && result3 == 0.0))
				{
					empty = ((computedValueLevel > 1 && IsRange(array[2]) && !array[2].Contains(TIC)) ? array[2] : ((!string.IsNullOrEmpty(array[2]) || !TreatStringsAsZero) ? GetValueFromArg(array[2]) : "0"));
					if (string.IsNullOrEmpty(empty) && TreatStringsAsZero)
					{
						empty = GetExactResultsFromCellReference(array[2], empty);
					}
					else if (!string.IsNullOrEmpty(empty) && empty[0] == TIC[0] && !IsCellReference(array[2]) && UseNoAmpersandQuotes)
					{
						empty = ((array.GetLength(0) == 3) ? empty : FALSEVALUESTR);
						empty = Regex.Replace(empty, "^\"|\"$", "");
					}
				}
				else if (array[0].Contains(TIC))
				{
					int num = array[0].IndexOf(TIC) + 1;
					int num2 = array[0].LastIndexOf(TIC) - 1;
					string text3 = array[0].Substring(num, num2 - num + 1);
					string[] array2 = FormulaErrorStrings;
					foreach (string text4 in array2)
					{
						if (text3.Equals(text4))
						{
							return text4;
						}
					}
				}
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex.Message;
			}
			return empty;
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[requires_3_args]);
		}
		return FormulaErrorStrings[requires_3_args];
	}

	public string ComputeIfError(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		if (array.Length != 2)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0];
		text = ((array[0].IndexOf(":") == array[0].LastIndexOf(":")) ? array[0] : ErrorStrings[1].ToString());
		if (text.StartsWith(TIC.ToString()))
		{
			return GetValueFromArg(array[0]);
		}
		try
		{
			if (text[0] == '\u0092')
			{
				text = text.Replace('\u0092', ' ');
				text = text.Trim();
				if (text.StartsWith(double.NaN.ToString().ToUpper()) || text.StartsWith("INFINITY") || text.StartsWith("-INFINITY") || text.StartsWith("#") || text.StartsWith("n#") || text.StartsWith(double.PositiveInfinity.ToString()) || text.StartsWith(double.NegativeInfinity.ToString()))
				{
					return GetValueFromArg(array[1]);
				}
			}
			if (!text.StartsWith("#"))
			{
				text = array[0];
			}
			text = GetValueFromArg(text).ToUpper().Replace(TIC, string.Empty);
		}
		catch
		{
			text = text.ToUpper();
		}
		if (text.StartsWith(double.NaN.ToString().ToUpper()) || text.StartsWith("INFINITY") || text.StartsWith("-INFINITY") || text.StartsWith("#") || text.StartsWith("n#") || text.StartsWith(double.PositiveInfinity.ToString()) || text.StartsWith(double.NegativeInfinity.ToString()))
		{
			return GetValueFromArg(array[1]);
		}
		return GetValueFromArg(array[0]);
	}

	public string ComputeIntercept(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && (string.IsNullOrEmpty(GetValueFromArg(array[0])) || bool.TryParse(GetValueFromArg(array[0]), out var result))) || (!IsRange(array[1]) && (string.IsNullOrEmpty(GetValueFromArg(array[1])) || bool.TryParse(GetValueFromArg(array[1]), out result))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		int num3 = 0;
		for (int i = 0; i < length; i++)
		{
			if (doubleArray2[i].ToString() != double.NaN.ToString() && doubleArray[i].ToString() != double.NaN.ToString())
			{
				num3++;
				num += doubleArray2[i];
				num2 += doubleArray[i];
			}
		}
		num /= (double)num3;
		num2 /= (double)num3;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int j = 0; j < length; j++)
		{
			if (doubleArray2[j].ToString() != double.NaN.ToString() && doubleArray[j].ToString() != double.NaN.ToString())
			{
				double num6 = doubleArray2[j] - num;
				num4 += num6 * (doubleArray[j] - num2);
				num5 += num6 * num6;
			}
		}
		string text2 = (num2 - num4 / num5 * num).ToString();
		if (ComputeIsErr(text2) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text2;
	}

	public string ComputeBinomdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length - 1; i++)
		{
			string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		double result = 0.0;
		double num = 0.0;
		for (int j = 0; j < length; j++)
		{
			array[j] = GetValueFromArg(array[j]);
			if (j != 3)
			{
				array[j] = StripTics(array[j]);
				array[j] = (string.IsNullOrEmpty(array[j]) ? "0" : array[j]);
			}
		}
		if (array[3].StartsWith(TIC))
		{
			array[3] = StripTics(array[3]);
			if (array[3].ToUpper() != TRUEVALUESTR && array[3].ToUpper() != FALSEVALUESTR)
			{
				return ErrorStrings[1].ToString();
			}
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result2 > result3 || result4 < 0.0 || result4 > 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			double.TryParse(array[3], NumberStyles.Any, null, out result);
			num = ((result != 0.0 || !(array[3].ToUpper() != TRUEVALUESTR)) ? binomdist((int)result3, (int)result2, result4) : (comb((int)result2, (int)result3) * Math.Pow(result4, result2) * Math.Pow(1.0 - result4, result3 - result2)));
		}
		return num.ToString();
	}

	private double binomdist(int trials, int successes, double p)
	{
		double num = 1.0 - p;
		Math.Pow(num, trials);
		double num2 = 0.0;
		double num3 = 1.0 * Math.Pow(num, trials);
		if (num3 == 0.0)
		{
			return double.NaN;
		}
		for (int i = 0; i <= successes; i++)
		{
			num2 += num3;
			num3 = num3 * p / num * (double)(trials - i) / (double)(i + 1);
			if (double.IsInfinity(num3) || double.IsNaN(num3))
			{
				num2 = double.NaN;
				break;
			}
		}
		return num2;
	}

	public string ComputeSkewP(string range)
	{
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		if (length < 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		double num = sd(doubleArray, out xbar);
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num2 += Math.Pow((doubleArray[i] - xbar) / num, 3.0);
		}
		return ((double)length * num2 / (double)(length - 1) / (double)(length - 2)).ToString();
	}

	public string ComputeCovarianceP(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		if (doubleArray.GetLength(0) == 1 && doubleArray2.GetLength(0) == 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = Mean(doubleArray);
		double num2 = Mean(doubleArray2);
		double num3 = 0.0;
		int num4 = doubleArray.Length;
		for (int i = 0; i < length; i++)
		{
			num3 += (doubleArray[i] - num) * (doubleArray2[i] - num2);
		}
		return (num3 / (double)num4).ToString();
	}

	public string ComputeCovarianceS(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (doubleArray.GetLength(0) == 1 && doubleArray2.GetLength(0) == 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[3].ToString());
			}
			return ErrorStrings[3].ToString();
		}
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[0].ToString();
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray2[i];
			num2 += doubleArray[i];
		}
		num /= (double)length;
		num2 /= (double)length;
		double num3 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num3 += (doubleArray2[j] - num) * (doubleArray[j] - num2);
		}
		return Covariance(doubleArray, doubleArray2).ToString();
	}

	public string ComputePercentileInc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		string valueFromArg = GetValueFromArg(array[1]);
		if (!double.TryParse(valueFromArg, NumberStyles.Any, null, out var result2) && (result2 < 0.0 || result2 > 1.0))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double num = Convert.ToDouble(valueFromArg);
		if (num == 0.0 || num <= 0.0 || num > 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		int length = doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		double num2 = 1.0 / (double)(length - 1);
		double num3 = doubleArray[length - 1];
		for (int i = 0; i < length - 1; i++)
		{
			if ((double)(i + 1) * num2 > result2)
			{
				result2 = (result2 - (double)i * num2) / num2;
				num3 = doubleArray[i] + result2 * (doubleArray[i + 1] - doubleArray[i]);
				break;
			}
		}
		return num3.ToString();
	}

	public string ComputePercentrankExc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 3.0;
		if (!double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out var result2))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		if (result2 == 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (length == 3 && !double.TryParse(GetValueFromArg(array[2]), NumberStyles.Integer, null, out result) && result < 1.0)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		int length2 = doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		double num = 1.0;
		for (int i = 0; i < length2; i++)
		{
			if (doubleArray[i] == result2)
			{
				int j;
				for (j = 0; j + i < length2 && doubleArray[j + i] == result2; j++)
				{
				}
				num = (double)(i - 1) / (double)(i + length2 - i - j - 1);
				if (i > 0 && doubleArray[i - 1] < result2)
				{
					double num2 = (double)i / (double)(length2 - 1);
					num = num2 + (num - num2) * (1.0 - (result2 - doubleArray[i - 1]) / (doubleArray[i] - doubleArray[i - 1]));
				}
				break;
			}
		}
		string text = "0." + new string('#', (int)result);
		return num.ToString(text);
	}

	public string ComputePercentileExc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		string valueFromArg = GetValueFromArg(array[1]);
		if (!double.TryParse(valueFromArg, NumberStyles.Any, null, out var result2) && (result2 <= 0.0 || result2 >= 1.0))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double num = Convert.ToDouble(valueFromArg);
		if (num == 0.0 || num <= 0.0 || num >= 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		int length = doubleArray.GetLength(0);
		if (result2 <= (double)(1 / (length + 1)) && result2 >= (double)(length / (length + 1)))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		return (result2 * (double)(length + 1)).ToString();
	}

	public string ComputePercentrankInc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 3.0;
		if (!double.TryParse(GetValueFromArg(array[1]), NumberStyles.Any, null, out var result2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		_ = 0.0;
		if (length == 3 && !double.TryParse(GetValueFromArg(array[2]), NumberStyles.Integer, null, out result) && result < 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string s = ComputeMin(array[0].Replace(TIC, string.Empty));
		string s2 = ComputeMax(array[0].Replace(TIC, string.Empty));
		if (double.TryParse(s, out var result3) && double.TryParse(s2, out var result4) && (result3 > result2 || result4 < result2))
		{
			return ErrorStrings[0].ToString();
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		int length2 = doubleArray.GetLength(0);
		Array.Sort(doubleArray);
		double num = 1.0;
		for (int i = 0; i < length2; i++)
		{
			if (doubleArray[i] >= result2)
			{
				int j;
				for (j = 0; j + i < length2 && doubleArray[j + i] == result2; j++)
				{
				}
				num = (double)(i - 1) / (double)(i + length2 - i - j - 1);
				if (i > 0 && doubleArray[i - 1] < result2)
				{
					double num2 = (double)i / (double)(length2 - 1);
					num = num2 + (num - num2) * (1.0 - (result2 - doubleArray[i - 1]) / (doubleArray[i] - doubleArray[i - 1]));
				}
				break;
			}
		}
		string text = "0." + new string('#', (int)result);
		return num.ToString(text);
	}

	private double sdP(double[] x, out double xbar)
	{
		int length = x.GetLength(0);
		xbar = 0.0;
		for (int i = 0; i < length; i++)
		{
			xbar += x[i];
		}
		xbar /= length;
		double num = 0.0;
		double num2 = 0.0;
		for (int j = 0; j < length; j++)
		{
			num2 = x[j] - xbar;
			num += num2 * num2;
		}
		return Math.Sqrt(num / (double)length);
	}

	public string ComputeStdevaS(string range)
	{
		double[] doubleArrayA = GetDoubleArrayA(range);
		if (doubleArrayA.GetLength(0) < 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		double xbar = 0.0;
		return sd(doubleArrayA, out xbar).ToString();
	}

	public string ComputeVarPAdv(string range)
	{
		double[] doubleArrayA = GetDoubleArrayA(range);
		int length = doubleArrayA.GetLength(0);
		return ((double)(length - 1) * var(doubleArrayA) / (double)length).ToString();
	}

	public string ComputeVarSAdv(string range)
	{
		double[] doubleArrayA = GetDoubleArrayA(range);
		int length = doubleArrayA.GetLength(0);
		return ((double)(length - 1) * var(doubleArrayA) / (double)length - 1.0).ToString();
	}

	public string ComputePermutationA(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		array[0] = GetValueFromArg(array[0]);
		array[1] = GetValueFromArg(array[1]);
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		if (int.TryParse(array[0], NumberStyles.Any, null, out var result2) && int.TryParse(array[1], NumberStyles.Any, null, out var result3))
		{
			if ((result2 == 0 && result3 < 0) || result2 < 0 || result3 < 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			string text2 = Math.Pow(result2, result3).ToString();
			if (ComputeIsErr(text2) == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			return text2;
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeNormOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result) ? Convert.ToInt16(result).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (length != 3)
			{
				num = ((array[3] == TRUEVALUESTR) ? 1 : 0);
			}
			num2 = ((num != 0.0) ? normaldist(result2, result3, result4) : normaldensity(result2, result3, result4));
		}
		return num2.ToString();
	}

	public string ComputeNormOinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 >= 1.0 || result2 <= 0.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments] + ErrorStrings[4].ToString());
				}
				return ErrorStrings[4].ToString();
			}
			num = NormalCumulativeDistributionFunctionInverse(result2, result3, result4);
		}
		return num.ToString();
	}

	public string ComputeNormOsODist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 1 && length != 2) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		double num2 = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result))
		{
			if (length == 2)
			{
				num = ((array[1] == TRUEVALUESTR) ? 1 : 0);
				double result2 = 0.0;
				if (double.TryParse(array[1], NumberStyles.Any, null, out result2))
				{
					num = 1.0;
				}
			}
			return ((num != 0.0) ? StandardNormalCumulativeDistributionFunction(result) : StandardNormalProbabilityDensity(result)).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return ErrorStrings[1].ToString();
	}

	public double StandardNormalProbabilityDensity(double x)
	{
		return 0.398942280401433 * Math.Exp(-0.5 * x * x);
	}

	public double StandardNormalCumulativeDistributionFunction(double x)
	{
		if (x < 0.0)
		{
			return 1.0 - StandardNormalCumulativeDistributionFunction(0.0 - x);
		}
		double num = StandardNormalProbabilityDensityFunction(x);
		double num2 = 1.0 / (1.0 + 0.2316419 * x);
		return 1.0 - num * (0.31938153 * num2 + -0.356563782 * Math.Pow(num2, 2.0) + 1.781477937 * Math.Pow(num2, 3.0) + -1.821255978 * Math.Pow(num2, 4.0) + 1.330274429 * Math.Pow(num2, 5.0));
	}

	private double StandardNormalProbabilityDensityFunction(double x)
	{
		return 0.398942280401433 * Math.Exp(-0.5 * x * x);
	}

	public double StandardNormalCumulativeDistribution(double x)
	{
		if (x < 0.0)
		{
			return 1.0 - StandardNormalCumulativeDistribution(0.0 - x);
		}
		double num = StandardNormalProbabilityDensityFunction(x);
		double num2 = 1.0 / (1.0 + 0.2316419 * x);
		return 1.0 - num * (0.31938153 * num2 + -0.356563782 * Math.Pow(num2, 2.0) + 1.781477937 * Math.Pow(num2, 3.0) + -1.821255978 * Math.Pow(num2, 4.0) + 1.330274429 * Math.Pow(num2, 5.0));
	}

	public double StandardNormalCumulativeDistributionFunctionInverse(double p)
	{
		if (p < 0.0 || p > 1.0)
		{
			throw new ArgumentException(FormulaErrorStrings[value_between] + " 0 & 1");
		}
		if (p == 0.0)
		{
			return double.NegativeInfinity;
		}
		if (p == 1.0)
		{
			return double.PositiveInfinity;
		}
		if (p == 0.5)
		{
			return 0.0;
		}
		double num;
		if (0.0 < p && p < 0.02425)
		{
			num = Math.Sqrt(-2.0 * Math.Log(p));
			return (((((-0.007784894002430293 * num + -0.3223964580411365) * num + -2.400758277161838) * num + -2.549732539343734) * num + 4.374664141464968) * num + 2.938163982698783) / ((((0.007784695709041462 * num + 0.3224671290700398) * num + 2.445134137142996) * num + 3.754408661907416) * num + 1.0);
		}
		if (0.02425 <= p && p <= 0.97575)
		{
			num = p - 0.5;
			double num2 = num * num;
			return (((((-39.69683028665376 * num2 + 220.9460984245205) * num2 + -275.9285104469687) * num2 + 138.357751867269) * num2 + -30.66479806614716) * num2 + 2.506628277459239) * num / (((((-54.47609879822406 * num2 + 161.5858368580409) * num2 + -155.6989798598866) * num2 + 66.80131188771972) * num2 + -13.28068155288572) * num2 + 1.0);
		}
		num = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
		return (0.0 - (((((-0.007784894002430293 * num + -0.3223964580411365) * num + -2.400758277161838) * num + -2.549732539343734) * num + 4.374664141464968) * num + 2.938163982698783)) / ((((0.007784695709041462 * num + 0.3224671290700398) * num + 2.445134137142996) * num + 3.754408661907416) * num + 1.0);
	}

	public string ComputeNormOsOInv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2))
		{
			if (result2 <= 0.0 || result2 >= 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[4].ToString();
			}
			num = StandardNormalCumulativeDistributionFunctionInverse(result2);
		}
		return num.ToString();
	}

	public string ComputeWeiBullODist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length - 1; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2) && double.TryParse(array[2], NumberStyles.Any, null, out var result3))
		{
			if (result < 0.0 || result2 <= 0.0 || result3 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return errorStrings[4].ToString();
			}
			if (result2.ToString().Length >= 5 && result3.ToString().Length >= 3)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[incorrect_array_length]);
				}
				return errorStrings[4].ToString();
			}
			if (length != 3)
			{
				num = ((array[3] == TRUEVALUESTR) ? 1 : 0);
				double result4 = 0.0;
				if (double.TryParse(array[3], NumberStyles.Any, null, out result4))
				{
					num = 1.0;
				}
			}
			return ((num == 1.0) ? (1.0 - Math.Exp(0.0 - Math.Pow(result / result3, result2))) : (Math.Pow(result, result2 - 1.0) * Math.Exp(0.0 - Math.Pow(result / result3, result2)) * result2 / Math.Pow(result3, result2))).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	public string ComputeExponODist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return errorStrings[4].ToString();
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(array[i], out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (result3 < 0.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
				}
				return errorStrings[4].ToString();
			}
			return ((result != 0.0) ? (1.0 - Math.Exp((0.0 - result4) * result3)) : (result4 * Math.Exp((0.0 - result4) * result3))).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	private double GammaInv(double p, double a, double b)
	{
		p = 1.0 - p;
		double beginX = 0.0;
		double endX = 4503599627370496.0;
		double beginY = 0.0;
		double endY = 1.0;
		double di = 1.0 / (9.0 * a);
		double num = 1.0 - di - StandardNormalCumulativeDistributionFunctionInverse(p) * Math.Sqrt(di);
		double result = a * num * num * num;
		int num2 = 1;
		while (true)
		{
			switch (num2)
			{
			case 1:
				num2 = GammaInvInitialState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
				break;
			case 2:
				num2 = GammaInvMiddleState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
				break;
			case 3:
				num2 = GammaInvFinalState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
				break;
			case 0:
				return result * b;
			}
		}
	}

	private int GammaInvInitialState(double a, double p, ref double beginX, ref double beginY, ref double endX, ref double endY, ref double di, ref double result)
	{
		for (int i = 0; i < 10; i++)
		{
			if (result > endX || result < beginX)
			{
				di = 0.0625;
				break;
			}
			double num = GammaInvUpperIncomplete(a, result);
			if (num < beginY || num > endY)
			{
				di = 0.0625;
				break;
			}
			if (num < p)
			{
				endX = result;
				beginY = num;
			}
			else
			{
				beginX = result;
				endY = num;
			}
			di = (a - 1.0) * Math.Log(result) - result - GammaLn(a);
			if (di < -709.782712893384)
			{
				di = 0.0625;
				break;
			}
			di = (num - p) / (0.0 - Math.Exp(di));
			if (Math.Abs(di / result) < 1E-15)
			{
				return 0;
			}
			result -= di;
		}
		return 2;
	}

	private int GammaInvMiddleState(double a, double p, ref double beginX, ref double beginY, ref double endX, ref double endY, ref double di, ref double result)
	{
		if (endX == 4503599627370496.0)
		{
			if (result <= 0.0)
			{
				result = 1.0;
			}
			while (endX == 4503599627370496.0)
			{
				result = (1.0 + di) * result;
				double num = GammaInvUpperIncomplete(a, result);
				if (num < p)
				{
					endX = result;
					beginY = num;
					break;
				}
				di *= 2.0;
			}
		}
		return 3;
	}

	private int GammaInvFinalState(double a, double p, ref double beginX, ref double beginY, ref double endX, ref double endY, ref double di, ref double result)
	{
		di = 0.5;
		double num = 0.0;
		for (int i = 0; i < 400; i++)
		{
			result = beginX + di * (endX - beginX);
			double num2 = GammaInvUpperIncomplete(a, result);
			if (Math.Abs((endX - beginX) / (beginX + endX)) < 5.000000000000001E-15 || Math.Abs((num2 - p) / p) < 5.000000000000001E-15 || result <= 0.0)
			{
				break;
			}
			if (num2 >= p)
			{
				beginX = result;
				endY = num2;
				if (num < 0.0)
				{
					di = 0.5;
					num = 0.0;
				}
				else
				{
					di = ((num > 1.0) ? (0.5 * di + 0.5) : ((p - beginY) / (endY - beginY)));
				}
				num += 1.0;
			}
			else
			{
				endX = result;
				beginY = num2;
				if (di > 0.0)
				{
					di = 0.5;
					num = 0.0;
				}
				else
				{
					di = ((num < -1.0) ? (0.5 * di) : ((p - beginY) / (endY - beginY)));
				}
				num -= 1.0;
			}
		}
		return 0;
	}

	private double GammaInvUpperIncomplete(double a, double x)
	{
		double num = Math.Exp(a * Math.Log(x) - x - GammaLn(a));
		if (x < 1.0 || x < a)
		{
			return 1.0 - num * GammaLowerIncomplete(a, x);
		}
		return num * GammaUpperIncomplete(a, x);
	}

	private double GammaLowerIncomplete(double a, double x)
	{
		double num = a;
		double num2 = 1.0;
		double num3 = 1.0;
		do
		{
			num += 1.0;
			num2 *= x / num;
			num3 += num2;
		}
		while (num2 / num3 > 1E-15);
		return num3 / a;
	}

	private double GammaUpperIncomplete(double a, double x)
	{
		double num = 1.0 - a;
		double num2 = x + num + 1.0;
		double num3 = 0.0;
		double num4 = x + 1.0;
		double num5 = 1.0;
		double num6 = num2 * x;
		double num7 = x;
		double num8 = num4 / num6;
		double num9 = 1.0;
		do
		{
			num3 += 1.0;
			num += 1.0;
			num2 += 2.0;
			double num10 = num * num3;
			double num11 = num4 * num2 - num5 * num10;
			double num12 = num6 * num2 - num7 * num10;
			if (num12 != 0.0)
			{
				num9 = Math.Abs((num12 * num8 - num11) / num11);
				num8 = num11 / num12;
			}
			num5 = num4;
			num4 = num11;
			num7 = num6;
			num6 = num12;
			if (Math.Abs(num11) > 4503599627370496.0)
			{
				num5 *= 2.220446049250313E-16;
				num4 *= 2.220446049250313E-16;
				num7 *= 2.220446049250313E-16;
				num6 *= 2.220446049250313E-16;
			}
		}
		while (num9 > 1E-15);
		return num8;
	}

	private double GammaDistCummulative(double a, double b, double x)
	{
		x /= b;
		if (x == 0.0)
		{
			return 0.0;
		}
		double num = Math.Exp(a * Math.Log(x) - x - GammaLn(a));
		if (x > 1.0 && x > a)
		{
			return 1.0 - num * GammaUpperIncomplete(a, x);
		}
		return num * GammaLowerIncomplete(a, x);
	}

	private double GammaDistProbability(double a, double b, double x)
	{
		if (x == 0.0)
		{
			return 0.0;
		}
		return Math.Exp(0.0 - GammaLn(a) - a * Math.Log(b) + (a - 1.0) * Math.Log(x) - x / b);
	}

	public string ComputeGammadist(string argList)
	{
		return ComputeGammaOdist(argList);
	}

	public string ComputeGammainv(string argList)
	{
		return ComputeGammaOinv(argList);
	}

	public string ComputeGeomean(string range)
	{
		double num = 1.0;
		int num2 = 0;
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		foreach (string text in array)
		{
			double result;
			string valueFromArg;
			if (text.IndexOf(':') > -1)
			{
				if (text.StartsWith(TIC))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[1].ToString();
				}
				string[] cellsFromArgs = GetCellsFromArgs(text);
				foreach (string arg in cellsFromArgs)
				{
					try
					{
						valueFromArg = GetValueFromArg(arg);
					}
					catch (Exception ex)
					{
						ExceptionThrown = true;
						if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
						{
							throw LibraryComputationException;
						}
						return ex.Message;
					}
					if (valueFromArg.Length <= 0)
					{
						continue;
					}
					if (ErrorStrings.Contains(valueFromArg))
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[bad_formula]);
						}
						return valueFromArg;
					}
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result))
					{
						num2++;
						num *= result;
					}
					else if (ErrorStrings.Contains(valueFromArg))
					{
						return valueFromArg;
					}
				}
				continue;
			}
			try
			{
				valueFromArg = GetValueFromArg(text);
			}
			catch (Exception ex2)
			{
				ExceptionThrown = true;
				if (rethrowLibraryComputationExceptions && LibraryComputationException != null)
				{
					throw LibraryComputationException;
				}
				return ex2.Message;
			}
			if (valueFromArg.Length > 0)
			{
				string text2 = FormulaErrorStringCheck(valueFromArg, FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
				if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result))
				{
					num2++;
					num *= result;
				}
				else if (ErrorStrings.Contains(valueFromArg))
				{
					return valueFromArg;
				}
			}
		}
		if (num2 > 0)
		{
			num = Math.Pow(num, 1.0 / (double)num2);
		}
		return num.ToString();
	}

	public string ComputeGammaOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if ((length != 4 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		if (array[3].StartsWith(TIC) && array[3].EndsWith(TIC))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
			}
			return errorStrings[1].ToString();
		}
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out var result5))
		{
			if (result3 < 0.0 || result4 <= 0.0 || result5 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return errorStrings[4].ToString();
			}
			double.TryParse(array[3], NumberStyles.Any, null, out result);
			return ((result != 0.0) ? GammaDistCummulative(result4, result5, result3) : GammaDistProbability(result4, result5, result3)).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	public string ComputeGammaOinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double result3 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result4) ? Convert.ToInt16(result4).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result4) ? Convert.ToInt16(result4).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result4) ? Convert.ToInt16(result4).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out result) && double.TryParse(array[1], NumberStyles.Any, null, out result2) && double.TryParse(array[2], NumberStyles.Any, null, out result3))
		{
			if (result < 0.0 || result >= 1.0 || result2 <= 0.0 || result3 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result == 0.0)
			{
				return "0";
			}
			num = GammaInv(result, result2, result3);
		}
		if (num <= 0.0)
		{
			return "#N/A";
		}
		return num.ToString();
	}

	public string ComputeGammaln0Precise(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		argList = GetValueFromArg(argList);
		argList = (bool.TryParse(argList, out var result) ? Convert.ToInt16(result).ToString() : argList);
		double result2 = 0.0;
		if (double.TryParse(argList, NumberStyles.Any, null, out result2) && result2 == 1.0)
		{
			return "0";
		}
		if (!(result2 > 0.0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return GammaLn(result2).ToString();
	}

	public string ComputeTOInv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		int result = 0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result2) ? Convert.ToInt16(result2).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result2) ? Convert.ToInt16(result2).ToString() : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && int.TryParse(array[1], NumberStyles.Any, null, out result))
		{
			if (result < 1 || result3 < 0.0 || result3.ToString().StartsWith("-"))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(errorStrings[4].ToString() + " " + FormulaErrorStrings[invalid_arg_value]);
				}
				return errorStrings[4].ToString();
			}
			num = TCumulativeDistributionInverse(result3, result);
			if (ComputeIsErr(num.ToString()) == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[3].ToString();
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new Exception(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_arg_value]);
		}
		return errorStrings[1].ToString();
	}

	private double TCumulativeDistributionInverse(double p, int k)
	{
		if (p < 0.0 || p > 1.0)
		{
			throw new ArgumentException(FormulaErrorStrings[value_between] + " 0 & 1");
		}
		if (p == 0.0)
		{
			return double.NegativeInfinity;
		}
		if (p == 1.0)
		{
			return double.PositiveInfinity;
		}
		if (p == 0.5)
		{
			return 0.0;
		}
		switch (k)
		{
		case 1:
			return Math.Tan(Math.PI * (p - 0.5));
		case 2:
		{
			double d = 4.0 * p * (1.0 - p);
			return 2.0 * (p - 0.5) * Math.Sqrt(2.0 / d);
		}
		case 4:
		{
			double d = 4.0 * p * (1.0 - p);
			double num4 = Math.Sqrt(d);
			double num5 = Math.Cos(1.0 / 3.0 * Math.Acos(num4)) / num4;
			return (double)(Math.Sign(p - 0.5) * 2) * Math.Sqrt(num5 - 1.0);
		}
		default:
		{
			double num = ((k <= 6) ? TCumulativeDistributionInverse(p, 4) : StandardNormalCumulativeDistributionFunctionInverse(p));
			for (int i = 0; i < 10; i++)
			{
				double num2 = TCumulativeDensity(num, k);
				if (Math.Abs(p - num2) < 0.0001)
				{
					return num;
				}
				double num3 = TProbabilityDensity(num, k);
				num += (p - num2) / num3;
			}
			throw new Exception(FormulaErrorStrings[solution_converge]);
		}
		}
	}

	private double TProbabilityDensity(double x, int k)
	{
		double num = GammaFunction(0.5 * (double)k + 0.5);
		double num2 = Math.Pow(1.0 + x * x / (double)k, -0.5 * (double)k - 0.5);
		double num3 = Math.Sqrt((double)k * Math.PI) * GammaFunction(0.5 * (double)k);
		return num * num2 / num3;
	}

	private double TCumulativeDensity(double x, int k)
	{
		if (double.IsNaN(x))
		{
			return double.NaN;
		}
		if (x == 0.0)
		{
			return 0.5;
		}
		if (x > 0.0)
		{
			double x2 = (double)k / (x * x + (double)k);
			return 1.0 - 0.5 * RIBetaFunction(x2, 0.5 * (double)k, 0.5);
		}
		return 1.0 - TCumulativeDensity(0.0 - x, k);
	}

	public string ComputeFOinvORt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && result2 > 0.0 && result2 < 1.0 && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[min_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = finv(result2, (int)result3, (int)result4);
		}
		if (num <= 0.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[iterations_dont_converge]);
			}
			return FormulaErrorStrings[iterations_dont_converge];
		}
		return num.ToString();
	}

	public string ComputeBinomOInv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		int num = 0;
		string text2 = GetValueFromArg(array[0]);
		string valueFromArg = GetValueFromArg(array[1]);
		string valueFromArg2 = GetValueFromArg(array[2]);
		if (string.IsNullOrEmpty(text2))
		{
			text2 = (array[0] = "0");
		}
		if (string.IsNullOrEmpty(valueFromArg) || string.IsNullOrEmpty(valueFromArg2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_expression]);
			}
			return ErrorStrings[4].ToString();
		}
		double.TryParse(text2.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result2);
		double.TryParse(valueFromArg.Replace(TIC, string.Empty), NumberStyles.Any, null, out var result3);
		double.TryParse(valueFromArg2.Replace(TIC, string.Empty), NumberStyles.Any, null, out result);
		if (result2 == 0.0)
		{
			return "0";
		}
		if (result2 < 0.0 || result3 <= 0.0 || result3 >= 1.0 || result <= 0.0 || result >= 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_expression]);
			}
			return ErrorStrings[4].ToString();
		}
		if (result3 > 0.0 && result3 < 1.0 && result >= 0.0 && result < 1.0)
		{
			num = critbinom((int)result2, result3, result);
			if (num == int.MaxValue)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[calculation_overflow]);
				}
				return FormulaErrorStrings[calculation_overflow];
			}
			return num.ToString();
		}
		if (result2 <= 0.0 || result3 <= 0.0 || result3 >= 1.0 || result < 0.0 || result > 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[min_value]);
			}
			return ErrorStrings[4].ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeLognormOinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result2 > 1.0 || result4 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_arg_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = Math.Exp(normalinv(result2, result3, result4));
		}
		return num.ToString();
	}

	public string ComputeLognormOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TRUEVALUESTR, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2) && double.TryParse(array[2], NumberStyles.Any, null, out var result3))
		{
			if (result <= 0.0 || result3 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[4].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
				}
				return ErrorStrings[4].ToString();
			}
			if (array[3] == FALSEVALUESTR)
			{
				num = Math.Exp(0.0 - Math.Pow(Math.Log(result) - result2, 2.0) / (2.0 * Math.Pow(result3, 2.0)));
				num = num / result * result2 * Math.Sqrt(Math.PI * 2.0);
			}
			else
			{
				num = StandardNormalCumulativeDistribution((Math.Log(result) - result2) / result3);
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(ErrorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeConfidenceOnorm(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new Exception(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[min_value]);
				}
				return ErrorStrings[4].ToString();
			}
			num = (ExcelLikeComputations ? newnormalinv(1.0 - result2 + result2 / 2.0) : normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0));
			num = num * result3 / Math.Sqrt(result4);
		}
		return num.ToString();
	}

	public string ComputeChisqOdistORt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2))
		{
			if (result < 0.0 || result2 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result == 0.0)
			{
				return result2.ToString();
			}
			if (result2 == 1.0)
			{
				_ = excelLikeComputations;
			}
			num = 1.0 - chidist(result, result2);
			for (int j = 0; j < num.ToString().Length; j++)
			{
			}
			Math.Round((decimal)num);
		}
		return num.ToString();
	}

	public string ComputeFOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int result = 0;
		int result2 = 0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && int.TryParse(array[1], NumberStyles.Any, null, out result) && int.TryParse(array[2], NumberStyles.Any, null, out result2))
		{
			if (result < 1 || result2 < 1 || result3.ToString().StartsWith("-"))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(errorStrings[4].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
				}
				return errorStrings[4].ToString();
			}
			if (array[3] == TRUEVALUESTR)
			{
				num = FCumulativeDensity(result3, result, result2);
			}
			else if (array[3] == FALSEVALUESTR)
			{
				num = FProbabilityDensity(result3, result, result2);
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new Exception(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	private double FProbabilityDensity(double x, int k1, int k2)
	{
		if (k1 <= 0 || k2 <= 0)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (x == 0.0)
		{
			return 0.0;
		}
		double num = Math.Pow((double)k1 * x, 0.5 * (double)k1);
		double num2 = Math.Pow(k2, 0.5 * (double)k2);
		double num3 = Math.Pow((double)k1 * x + (double)k2, 0.5 * (double)(k1 + k2));
		double num4 = num * num2 / num3;
		double num5 = BetaFunction(0.5 * (double)k1, 0.5 * (double)k2);
		double num6 = x * num5;
		return num4 / num6;
	}

	private double FCumulativeDensity(double x, int k1, int k2)
	{
		if (k1 <= 0 || k2 <= 0)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (x < 0.0)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_parameter]);
		}
		if (x == 0.0)
		{
			return 0.0;
		}
		double x2 = (double)k1 * x / ((double)k1 * x + (double)k2);
		double val = RIBetaFunction(x2, 0.5 * (double)k1, 0.5 * (double)k2);
		return Math.Min(1.0, val);
	}

	private static double BetaFunction(double a, double b)
	{
		if (a + b > 143.0)
		{
			if (b > 20.0)
			{
				return 2.5066282746310002 * Math.Pow(a, a - 0.5) * Math.Pow(b, b - 0.5) / Math.Pow(a + b, a + b - 0.5);
			}
			return GammaFunction(b) * Math.Pow(a, 0.0 - b);
		}
		return GammaFunction(a) * GammaFunction(b) / GammaFunction(a + b);
	}

	private static double GammaFunction(double z)
	{
		if (z > 143.0)
		{
			throw new ArgumentException("Cannot currently compute gamma function for z > 143");
		}
		if (z > 0.0 && z < 21.0 && z % 1.0 == 0.0)
		{
			return Factorial((int)Math.Round(z - 1.0, 0));
		}
		if (z > 0.0 && z < 11.0 && z % 0.5 == 0.0)
		{
			int num = (int)z;
			return 1.77245385090552 * (double)Factorial(2 * num) / (Math.Pow(4.0, num) * (double)Factorial(num));
		}
		double num2 = 1.0 + 1.0 / (12.0 * z) + 1.0 / (288.0 * z * z) - 139.0 / (51840.0 * Math.Pow(z, 3.0)) - 571.0 / (2488320.0 * Math.Pow(z, 4.0)) + 163879.0 / (209018880.0 * Math.Pow(z, 5.0)) + 5246819.0 / (75246796800.0 * Math.Pow(z, 6.0));
		return Math.Pow(z, z - 0.5) * Math.Exp(0.0 - z) * 2.5066282746310002 * num2;
	}

	private double RIBetaFunction(double x, double a, double b)
	{
		if (x <= 0.0)
		{
			return 0.0;
		}
		if (x >= 1.0)
		{
			return 1.0;
		}
		if (a % 1.0 == 0.0 && b % 1.0 == 0.0 && a + b > 0.0)
		{
			return RIBetaFunction(x, (int)a, (int)b);
		}
		if (b % 1.0 == 0.0 && a + b < 172.0)
		{
			return RIBetaFunction(x, a, (int)b);
		}
		if (a % 1.0 == 0.0 && a + b < 172.0)
		{
			return 1.0 - RIBetaFunction(1.0 - x, b, (int)a);
		}
		if (a == 0.5 && b == 0.5)
		{
			return 2.0 / Math.PI * Math.Atan(Math.Sqrt(x / (1.0 - x)));
		}
		if (a == 0.5 && b % 0.5 == 0.0)
		{
			return 1.0 - RIBetaFunction(1.0 - x, b, 0.5);
		}
		if (a % 0.5 == 0.0 && b == 0.5)
		{
			if (a < 45.0)
			{
				double num = 0.0;
				int num2 = (int)Math.Round(a - 0.5, 0);
				double num3 = Convert.ToDouble(ComputeGammaln("0.5".ToString()));
				for (int i = 0; i < num2; i++)
				{
					num += Math.Exp(GammaLn(i + 1) - GammaLn((double)i + 1.5) - num3) * Math.Pow(x, i);
				}
				return RIBetaFunction(x, 0.5, 0.5) - Math.Sqrt(x * (1.0 - x)) * num;
			}
			double num4 = BetaFunction(a, 0.5);
			double num5 = Math.Sqrt(1.0 - Math.Pow(num4 * Math.Sqrt((a - 1.0) / Math.PI) * double.Epsilon, 1.0 / (a - 1.0)));
			double[] array = new double[10] { 0.066671344308688, 0.14945134915058, 0.21908636251598, 0.26926671931, 0.29552422471475, 0.29552422471475, 0.26926671931, 0.21908636251598, 0.14945134915058, 0.066671344308688 };
			double[] array2 = new double[10] { 0.013046735791414, 0.067468316655507, 0.16029521585049, 0.28330230293538, 0.42556283050918, 0.57443716949081, 0.71669769706462, 0.83970478414951, 0.93253168334449, 0.98695326420859 };
			double num6 = Math.Sqrt(1.0 - x);
			double num7 = 0.0;
			for (int j = 0; j < 10; j++)
			{
				num7 += array[j] * Math.Pow(1.0 - Math.Pow((num5 - num6) * array2[j] + num6, 2.0), a - 1.0);
			}
			double num8 = Math.Exp(GammaLn(a + 0.5) - GammaLn(a) - GammaLn(0.5));
			return (num5 - num6) * num8 * num7;
		}
		if (a % 0.5 == 0.0 && b % 0.5 == 0.0)
		{
			double num9 = 0.0;
			int num10 = (int)Math.Round(b - 0.5, 0);
			double num11 = GammaLn(a);
			double num12 = Math.Pow(x, a);
			for (int k = 0; k < num10; k++)
			{
				num9 += Math.Exp(GammaLn(a + (double)k + 0.5) - num11 - GammaLn((double)k + 1.5)) * Math.Pow(1.0 - x, k) * num12;
			}
			double val = RIBetaFunction(x, a, 0.5) + Math.Sqrt(1.0 - x) * num9;
			return Math.Max(0.0, Math.Min(1.0, val));
		}
		if (x > 0.5)
		{
			return 1.0 - RIBetaFunction(1.0 - x, b, a);
		}
		double val2 = IBetaFunction(x, a, b) / BetaFunction(a, b);
		return Math.Max(0.0, Math.Min(1.0, val2));
	}

	private double RIBetaFunction(double x, int a, int b)
	{
		double num = 0.0;
		int num2 = a + b - 1;
		if (num2 < 21)
		{
			for (int i = a; i < a + b; i++)
			{
				num += Math.Pow(x, i) * Math.Pow(1.0 - x, num2 - i) / (double)(Factorial(i) * Factorial(num2 - i));
			}
			num *= (double)Factorial(num2);
		}
		else
		{
			for (int j = a; j < a + b; j++)
			{
				num += Math.Pow(x, j) * Math.Pow(1.0 - x, num2 - j) * Combinations(num2, j);
			}
		}
		return Math.Max(0.0, Math.Min(1.0, num));
	}

	private double RIBetaFunction(double x, double a, int b)
	{
		if (a + (double)b > 172.0)
		{
			throw new ArgumentException("Cannot currently compute RegularizedIncompleteBetaFunction for a + b > 172");
		}
		double num = 0.0;
		for (int i = 1; i < b + 1; i++)
		{
			num += Math.Pow(1.0 - x, i - 1) * Math.Exp(GammaLn(a + (double)i - 1.0) - GammaLn(i));
		}
		return num * (Math.Pow(x, a) * Math.Exp(0.0 - GammaLn(a)));
	}

	private double IBetaFunction(double x, double a, double b)
	{
		if (x == 0.0)
		{
			return 0.0;
		}
		if (x == 1.0)
		{
			return BetaFunction(a, b);
		}
		if (x <= 0.9)
		{
			return PIBetaFunction(0.0, x, a, b);
		}
		if (x <= 0.99)
		{
			double num = PIBetaFunction(0.0, 0.9, a, b);
			double num2 = PIBetaFunction(0.9, x, a, b);
			return num + num2;
		}
		double num3 = PIBetaFunction(0.0, 0.9, a, b);
		double num4 = PIBetaFunction(0.9, 0.99, a, b);
		double num5 = PIBetaFunction(0.99, x, a, b);
		return num3 + num4 + num5;
	}

	private double PIBetaFunction(double xL, double xU, double a, double b)
	{
		if (xU == xL)
		{
			return 0.0;
		}
		if (xU < xL)
		{
			return double.NaN;
		}
		int num = 1000;
		if (a < 1.0)
		{
			num = 80000;
		}
		double num2 = (xU - xL) / (double)num;
		double num3 = xL + 0.5 * num2;
		double num4 = 0.0;
		for (int i = 0; i < num; i++)
		{
			num4 += Math.Pow(num3, a - 1.0) * Math.Pow(1.0 - num3, b - 1.0) * num2;
			num3 += num2;
		}
		return num4;
	}

	public string ComputeFOdistORt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double result2 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result3) ? Convert.ToInt16(result3).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result3) ? Convert.ToInt16(result3).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result3) ? Convert.ToInt16(result3).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result4) && double.TryParse(array[1], NumberStyles.Any, null, out result) && double.TryParse(array[2], NumberStyles.Any, null, out result2))
		{
			if (result4 < 0.0 || result < 1.0 || result2 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			double num2 = Math.Exp(GammaLn((result + result2) / 2.0) - GammaLn(result / 2.0) - GammaLn(result2 / 2.0) + result / 2.0 * Math.Log(result / result2));
			return (1.0 - num2 * fdist(result4, (int)result, (int)result2)).ToString();
		}
		if (rethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
		}
		return FormulaErrorStrings[invalid_Math_argument];
	}

	public string ComputeChisqOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 && length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2))
		{
			if ((result2 != 1.0 || !excelLikeComputations) && result2 < 1.0)
			{
				if (excelLikeComputations)
				{
					return "#NUM!";
				}
				return FormulaErrorStrings[invalid_arguments];
			}
			if (array[2] == TRUEVALUESTR)
			{
				num = chidist(result, result2);
				if (result <= 0.0 || Math.Abs(result) - Math.Abs(result) != 0.0)
				{
					throw new Exception("Invalid n: $n\n");
				}
			}
			else
			{
				num = ChiSquaredProbabilityDensityFunction(result, (int)result2);
			}
		}
		return num.ToString();
	}

	public string ComputeChisqOinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2))
		{
			if (result < 0.0 || result >= 1.0 || result2 <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result == 0.0)
			{
				return "0";
			}
			num = chiinv(1.0 - result, result2);
		}
		return num.ToString();
	}

	public string ComputeChisqOTest(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = array[0];
		double num = 0.0;
		double num2 = 0.0;
		if (text.IndexOf(':') > -1)
		{
			string s = text.Substring(0, text.IndexOf(':'));
			int num3 = ColIndex(s);
			int num4 = RowIndex(s);
			s = text.Substring(text.IndexOf(':') + 1);
			int num5 = RowIndex(s);
			int num6 = ColIndex(s);
			if (grid is ISheetData)
			{
				if (!(!num4.Equals(-1) || num5.Equals(-1)).Equals(num4.Equals(-1) || !num5.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				if (num4 == -1)
				{
					num4 = ((ISheetData)grid).GetFirstRow();
				}
				if (num3 == -1)
				{
					num3 = ((ISheetData)grid).GetFirstColumn();
				}
				if (num6 == -1)
				{
					num6 = ((ISheetData)grid).GetLastColumn();
				}
				if (num5 == -1)
				{
					num5 = ((ISheetData)grid).GetLastRow();
				}
			}
			num2 = Math.Abs(num3 - num6) * Math.Abs(num4 - num5);
			num2 = 1.0001;
			if (num2 < 1.0)
			{
				return FormulaErrorStrings[invalid_Math_argument];
			}
		}
		else if (excelLikeComputations)
		{
			return "#N/A";
		}
		num2 = 0.99555;
		double[] doubleArray = GetDoubleArray(array[0]);
		double[] doubleArray2 = GetDoubleArray(array[1]);
		int length = doubleArray2.GetLength(0);
		if (length <= 0 || length != doubleArray.GetLength(0))
		{
			return ErrorStrings[0].ToString();
		}
		double num7 = 0.0;
		for (int i = 0; i < length; i++)
		{
			num = doubleArray[i] - doubleArray2[i];
			num7 += num * num / doubleArray2[i];
		}
		return (1.0 - chidist(num7, num2)).ToString();
	}

	public string ComputeChisqOinvORt(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2))
		{
			if (result <= 0.0 || result > 1.0 || result2 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result == 1.0)
			{
				return "0";
			}
			num = chiinv(result, result2);
		}
		return num.ToString();
	}

	public string ComputeBinomOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out var result5))
		{
			if (result3 < 0.0 || result3 > result4 || result5 < 0.0 || result5 > 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(ErrorStrings[4].ToString() + " " + FormulaErrorStrings[min_value]);
				}
				return ErrorStrings[4].ToString();
			}
			double.TryParse(array[3], NumberStyles.Any, null, out result);
			return ((result != 0.0) ? binomdist((int)result4, (int)result3, result5) : (comb((int)result3, (int)result4) * Math.Pow(result5, result3) * Math.Pow(1.0 - result5, result4 - result3))).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new Exception(ErrorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_arg_value]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeZOtest(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		for (int i = 1; i < length; i++)
		{
			if (i <= length - 1)
			{
				string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text2))
				{
					return text2;
				}
			}
		}
		string valueFromArg = GetValueFromArg(array[1]);
		if (!double.TryParse(valueFromArg, NumberStyles.Any, null, out var result))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		double[] doubleArray = GetDoubleArray(array[0]);
		double xbar;
		double result2 = sd(doubleArray, out xbar);
		if (length == 3)
		{
			double.TryParse(valueFromArg, NumberStyles.Any, null, out result2);
		}
		string text3 = (1.0 - normaldist((xbar - result) / (result2 / Math.Sqrt(doubleArray.GetLength(0))), 0.0, 1.0)).ToString();
		if (ComputeIsErr(text3) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return text3;
	}

	public string ComputeRankOAvg(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		double num = 0.0;
		string valueFromArg = GetValueFromArg(array[0]);
		if (double.TryParse(valueFromArg, NumberStyles.Any, null, out var result))
		{
			double result2 = 0.0;
			if (length == 3)
			{
				string text3 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text3))
				{
					return text3;
				}
				valueFromArg = GetValueFromArg(array[2]);
				double.TryParse(valueFromArg, NumberStyles.Integer, null, out result2);
			}
			double result3 = 0.0;
			bool flag = false;
			_ = array[1];
			double[] doubleArray = GetDoubleArray(array[1]);
			double.TryParse(valueFromArg, NumberStyles.Any, null, out result3);
			if (result2 == 0.0)
			{
				Array.Sort(doubleArray, (double a, double b) => -a.CompareTo(b));
			}
			else
			{
				Array.Sort(doubleArray);
			}
			int num2 = -1;
			double[] array2 = doubleArray;
			foreach (double num3 in array2)
			{
				num2++;
				num += 1.0;
				if (num3 == result)
				{
					double num4 = double.Parse(ComputeRank(array[0] + ParseArgumentSeparator + array[1] + ParseArgumentSeparator + "0"));
					double num5 = double.Parse(ComputeRank(array[0] + ParseArgumentSeparator + array[1] + ParseArgumentSeparator + "1"));
					double num6 = ((double)(doubleArray.Length + 1) - num4 - num5) / 2.0;
					num += num6;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
		}
		return num.ToString();
	}

	public string ComputeRankOEq(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		int num = 0;
		string text3 = GetValueFromArg(array[0]);
		if (array[1].StartsWith(TIC) || array[1].Contains(","))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		if (array[0].Equals(string.Empty) || array[1].Equals(string.Empty))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[4].ToString());
			}
			return ErrorStrings[4].ToString();
		}
		if (double.TryParse(text3, NumberStyles.Any, null, out var result))
		{
			double result2 = 0.0;
			if (length == 3)
			{
				string text4 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text4))
				{
					return text4;
				}
				text3 = GetValueFromArg(array[2]);
				if (text3.Equals(string.Empty))
				{
					text3 = "0";
				}
				else if (Convert.ToDouble(text3) > 1.0)
				{
					text3 = "1";
				}
				double.TryParse(text3, NumberStyles.Integer, null, out result2);
			}
			double result3 = 0.0;
			bool flag = false;
			_ = array[1];
			double[] doubleArray = GetDoubleArray(array[1]);
			double.TryParse(text3, NumberStyles.Any, null, out result3);
			if (result2 == 0.0)
			{
				Array.Sort(doubleArray, (double a, double b) => -a.CompareTo(b));
			}
			else
			{
				Array.Sort(doubleArray);
			}
			double[] array2 = doubleArray;
			foreach (double num2 in array2)
			{
				num++;
				if (num2 == result)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[0].ToString();
			}
		}
		if (num.Equals(0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		return num.ToString();
	}

	public string ComputeIHDIST(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int result = 0;
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		if (double.TryParse(valueFromArg, NumberStyles.Any, null, out var result2))
		{
			int.TryParse(valueFromArg2, NumberStyles.Any, null, out result);
		}
		return IHProbDens(result2, result).ToString();
	}

	public static double IHProbDens(double x, int n)
	{
		if (x < 0.0 || x > (double)n)
		{
			return 0.0;
		}
		double num = 0.0;
		for (int i = 0; i <= n; i++)
		{
			num += Math.Pow(-1.0, i) * Combinations(n, i) * Math.Pow(x - (double)i, n - 1) * (double)Math.Sign(x - (double)i);
		}
		num *= 0.5;
		return num / (double)Factorial(n - 1);
	}

	public static double Combinations(int n, int k)
	{
		return Math.Round(Math.Exp(LogCombin(n, k)), 0);
	}

	internal static double LogCombin(int n, int k)
	{
		return LogFactorial(n) - LogFactorial(k) - LogFactorial(n - k);
	}

	private static double LogFactorial(int x)
	{
		double num = 0.0;
		for (int i = 2; i <= x; i++)
		{
			num += Math.Log(i);
		}
		return num;
	}

	public static long Factorial(int n)
	{
		if (n < 0)
		{
			throw new ArgumentException("Factorial not defined for negative n");
		}
		if (n > 20)
		{
			throw new ArgumentException("Answer will exceed max long");
		}
		long num = 1L;
		for (int num2 = n; num2 > 0; num2--)
		{
			num *= num2;
		}
		return num;
	}

	public string ComputeUnidist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (!double.TryParse(array[0], NumberStyles.Any, null, out var result) || !double.TryParse(array[1], NumberStyles.Any, null, out var result2) || !double.TryParse(array[2], NumberStyles.Any, null, out var result3))
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		return UniProbDens(result, result2, result3).ToString();
	}

	public static double UniProbDens(double x, double min, double max)
	{
		if (max <= min)
		{
			throw new ArgumentException("max must be greater than min");
		}
		if (x < min || x > max)
		{
			return 0.0;
		}
		return 1.0 / (max - min);
	}

	public string ComputeQuartileOExc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out var result2) && result2 >= 0.0 && result2 <= 4.0)
		{
			return ComputePercentile(array[0] + ParseArgumentSeparator + result2 * 0.25);
		}
		if (result2 <= 0.0 || result2 >= 4.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeQuartileOInc(string range)
	{
		if (!range.Contains(parseArgumentSeparator.ToString()))
		{
			AdjustRangeArg(ref range);
		}
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if ((!IsRange(array[0]) && string.IsNullOrEmpty(GetValueFromArg(array[0]))) || (!IsRange(array[1]) && string.IsNullOrEmpty(GetValueFromArg(array[1]))) || bool.TryParse(GetValueFromArg(array[0]), out var result) || bool.TryParse(GetValueFromArg(array[1]), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		if (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out var result2) && result2 >= 0.0 && result2 <= 4.0)
		{
			return ComputePercentile(array[0] + ParseArgumentSeparator + result2 * 0.25);
		}
		if (result2 < 0.0 || result2 > 4.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[4].ToString();
		}
		return FormulaErrorStrings[invalid_arguments];
	}

	public string ComputeNegbinomODist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 4)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result) && double.TryParse(array[1], NumberStyles.Any, null, out var result2) && double.TryParse(array[2], NumberStyles.Any, null, out var result3))
		{
			num = negbinomdensity((int)result, (int)result2, result3);
		}
		return num.ToString();
	}

	public string ComputePoissonODist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double result = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result2) ? Convert.ToInt16(result2).ToString() : array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out var result4) && double.TryParse(array[2], NumberStyles.Any, null, out result))
		{
			if (result3 < 0.0 || result4 < 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[4].ToString();
			}
			int num2 = (int)result3;
			if (result == 0.0)
			{
				double num3 = 1.0;
				for (int j = 2; j <= num2; j++)
				{
					num3 *= (double)j;
				}
				num = Math.Exp(0.0 - result4) * Math.Pow(result4, num2) / num3;
			}
			else
			{
				double num4 = 1.0;
				num = 0.0;
				double num5 = 1.0;
				for (int k = 0; k <= num2; k++)
				{
					num += num5 / num4;
					num4 *= (double)(k + 1);
					num5 *= result4;
				}
				num = Math.Exp(0.0 - result4) * num;
			}
		}
		return num.ToString();
	}

	public string ComputeDelta(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = null;
		string text3 = null;
		try
		{
			if (array.Length > 2 || array.Length < 1)
			{
				return FormulaErrorStrings[10].ToString();
			}
			double num;
			double num2;
			if (array.Length == 1)
			{
				text2 = GetValueFromArg(array[0]);
				text2 = text2.Replace(TIC, "");
				num = double.Parse(text2);
				num2 = 0.0;
			}
			else
			{
				text2 = GetValueFromArg(array[0]);
				text3 = GetValueFromArg(array[1]);
				if (string.IsNullOrEmpty(text2))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[bad_formula]);
					}
					return ErrorStrings[0].ToString();
				}
				text2 = (string.IsNullOrEmpty(text2) ? "0" : text2);
				text2 = text2.Replace(TIC, "");
				text3 = (string.IsNullOrEmpty(text3) ? "0" : text3);
				text3 = text3.Replace(TIC, "");
				num = double.Parse(text2);
				num2 = double.Parse(text3);
			}
			return (num == num2) ? "1" : "0";
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text2) == TRUEVALUESTR || ComputeIsText(text3) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeGestep(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.Length > 2 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = null;
		string text3 = null;
		try
		{
			if (array.Length > 2 || array.Length < 1)
			{
				return FormulaErrorStrings[10].ToString();
			}
			double num;
			double num2;
			if (array.Length == 1)
			{
				text2 = GetValueFromArg(array[0]);
				text2 = text2.Replace(TIC, "");
				num = double.Parse(text2);
				num2 = 0.0;
			}
			else
			{
				text2 = GetValueFromArg(array[0]);
				text2 = text2.Replace(TIC, "");
				text3 = GetValueFromArg(array[1]);
				text3 = (string.IsNullOrEmpty(text3) ? "0" : text3);
				text3 = text3.Replace(TIC, "");
				num = double.Parse(text2);
				num2 = double.Parse(text3);
			}
			return (num >= num2) ? "1" : "0";
		}
		catch
		{
			ExceptionThrown = true;
			if (rethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[parameters_notvalid]);
			}
			if (ComputeIsText(text2) == TRUEVALUESTR || ComputeIsText(text3) == TRUEVALUESTR)
			{
				return ErrorStrings[5].ToString();
			}
			if (text2 == "")
			{
				return ErrorStrings[0].ToString();
			}
			if (double.Parse(text2) < 0.0 || double.Parse(text3) < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			return ErrorStrings[1].ToString();
		}
	}

	public string ComputeDevsq(string range)
	{
		string text = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double[] doubleArray = GetDoubleArray(range);
		int length = doubleArray.GetLength(0);
		if (length <= 0 || string.IsNullOrEmpty(range))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			num += doubleArray[i];
		}
		num /= (double)length;
		double num2 = 0.0;
		for (int j = 0; j < length; j++)
		{
			double num3 = doubleArray[j] - num;
			num2 += num3 * num3;
		}
		return num2.ToString();
	}

	public string ComputeAverageIF(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		double num = 0.0;
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = array[0];
		string text3 = array[1];
		text3 = (string.IsNullOrEmpty(text3) ? "0" : text3);
		if (text3.Length < 1)
		{
			return "0";
		}
		char op = 'e';
		if (text3[0] != TIC[0] && "=><".IndexOf(text3[0]) == -1)
		{
			text3 = GetValueFromArg(text3);
		}
		double result = double.MinValue;
		text3 = findCriteria(text3, ref op);
		double.TryParse(text3, out result);
		string text4 = ((length == 2) ? text2 : array[2]);
		string[] cellsFromArgs = GetCellsFromArgs(text2);
		string[] cellsFromArgs2 = GetCellsFromArgs(text4);
		if (cellsFromArgs[0].Equals(ErrorStrings[5]) || cellsFromArgs2[0].Equals(ErrorStrings[5]))
		{
			return ErrorStrings[5].ToString();
		}
		int length2 = cellsFromArgs.GetLength(0);
		if (length2 > cellsFromArgs2.GetLength(0))
		{
			int num2 = text4.IndexOf(':');
			if (num2 > -1)
			{
				int num3 = RowIndex(text4.Substring(0, num2));
				int num4 = RowIndex(text4.Substring(num2 + 1));
				if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
				{
					return ErrorStrings[5].ToString();
				}
				if (num3 == -1 && grid is ISheetData)
				{
					num3 = ((ISheetData)grid).GetLastRow();
				}
				int num5 = ColIndex(text4.Substring(0, num2));
				if (num5 == -1 && grid is ISheetData)
				{
					num5 = ((ISheetData)grid).GetFirstColumn();
				}
				if (num4 == -1 && grid is ISheetData)
				{
					num4 = ((ISheetData)grid).GetLastRow();
				}
				int num6 = ColIndex(text4.Substring(num2 + 1));
				if (num6 == -1 && grid is ISheetData)
				{
					num6 = ((ISheetData)grid).GetLastColumn();
				}
				if (num3 != num4)
				{
					num4 += length2 - cellsFromArgs2.GetLength(0);
				}
				else if (num5 != num6)
				{
					num6 += length2 - cellsFromArgs2.GetLength(0);
				}
				text4 = text4.Substring(0, num2 + 1) + RangeInfo.GetAlphaLabel(num6) + num4;
				cellsFromArgs2 = GetCellsFromArgs(text4);
			}
		}
		double num7 = 0.0;
		double result2;
		switch (op)
		{
		case 'e':
		{
			if (text3.Contains("*"))
			{
				int length3 = text3.IndexOf("*");
				text3 = text3.Substring(0, length3);
				for (int l = 0; l < length2; l++)
				{
					string valueFromArg = GetValueFromArg(cellsFromArgs[l]);
					if (valueFromArg.Replace(TIC, string.Empty).Substring(0, length3) == text3 || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2) && result2 == result))
					{
						valueFromArg = cellsFromArgs2[l];
						valueFromArg = GetValueFromArg(valueFromArg);
						if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
						{
							num7 += result2;
							num += 1.0;
						}
					}
				}
				break;
			}
			for (int m = 0; m < length2; m++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[m]);
				if (valueFromArg.Replace(TIC, string.Empty) == text3 || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2) && result2 == result))
				{
					valueFromArg = cellsFromArgs2[m];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		case 'o':
		{
			for (int num8 = 0; num8 < length2; num8++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[num8]);
				if (valueFromArg.Replace(TIC, string.Empty) != text3 || (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2) && result2 != result))
				{
					valueFromArg = cellsFromArgs2[num8];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		case 'j':
		{
			for (int j = 0; j < length2; j++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[j]);
				if (double.TryParse(valueFromArg, out result2) && result2 >= result)
				{
					valueFromArg = cellsFromArgs2[j];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		case 'g':
		{
			for (int n = 0; n < length2; n++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[n]);
				if (double.TryParse(valueFromArg, out result2) && result2 > result)
				{
					valueFromArg = cellsFromArgs2[n];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		case 'l':
		{
			for (int k = 0; k < length2; k++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[k]);
				if (double.TryParse(valueFromArg, out result2) && result2 < result)
				{
					valueFromArg = cellsFromArgs2[k];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		case 'k':
		{
			for (int i = 0; i < length2; i++)
			{
				string valueFromArg = GetValueFromArg(cellsFromArgs[i]);
				if (double.TryParse(valueFromArg, out result2) && result2 <= result)
				{
					valueFromArg = cellsFromArgs2[i];
					valueFromArg = GetValueFromArg(valueFromArg);
					if (double.TryParse(valueFromArg, NumberStyles.Any, null, out result2))
					{
						num7 += result2;
						num += 1.0;
					}
				}
			}
			break;
		}
		}
		double num9 = num7 / num;
		if (ComputeIsErr(num9.ToString()) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[3].ToString();
		}
		return num9.ToString();
	}

	public string ComputeConfidenceT(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[min_value]);
				}
				return ErrorStrings[4].ToString();
			}
			if (result4 == 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[3].ToString();
			}
			num = (ExcelLikeComputations ? newnormalinv(1.0 - result2 + result2 / 2.0) : normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0));
			num = num * result3 / Math.Sqrt(result4);
		}
		return num.ToString();
	}

	public string ComputeFOinv(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		array[0] = (string.IsNullOrEmpty(array[0]) ? "0" : array[0]);
		array[0] = (bool.TryParse(array[0], out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		array[1] = (string.IsNullOrEmpty(array[1]) ? "0" : array[1]);
		array[1] = (bool.TryParse(array[1], out result) ? Convert.ToInt16(result).ToString() : array[1]);
		array[2] = (string.IsNullOrEmpty(array[2]) ? "0" : array[2]);
		array[2] = (bool.TryParse(array[2], out result) ? Convert.ToInt16(result).ToString() : array[2]);
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && double.TryParse(array[1], NumberStyles.Any, null, out var result3) && double.TryParse(array[2], NumberStyles.Any, null, out var result4))
		{
			if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[min_value]);
				}
				return errorStrings[4].ToString();
			}
			num = FCumulativeDistributionInverse(result2, (int)result3, (int)result4);
			if (num <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[iterations_dont_converge]);
				}
				return FormulaErrorStrings[iterations_dont_converge];
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	public string ComputeModeOMult(string range)
	{
		double[] doubleArray = GetDoubleArray(range);
		double[] array = doubleArray.Clone() as double[];
		int length = doubleArray.GetLength(0);
		if (length <= 1)
		{
			return "#N/A";
		}
		Array.Sort(doubleArray);
		List<object> list = new List<object>();
		double num = double.NaN;
		int num2 = 0;
		int num3 = 0;
		for (int i = 1; i < length; i++)
		{
			if (doubleArray[i] == doubleArray[i - 1])
			{
				num2++;
				continue;
			}
			if (num2 > num3)
			{
				num3 = num2;
				num = doubleArray[i - 1];
				list.Clear();
				list.Add(num);
			}
			else if (num2 == num3)
			{
				list.Add(doubleArray[i - 1]);
			}
			num2 = 0;
		}
		if (num2 > num3)
		{
			num3 = num2;
			num = doubleArray[length - 1];
			list.Clear();
			list.Add(num);
		}
		if (num3 > 0)
		{
			if (num2 == num3)
			{
				list.Add(doubleArray[length - 1]);
			}
			if (list.Count > 1)
			{
				double[] array2 = array;
				foreach (double num4 in array2)
				{
					if (list.IndexOf(num4) > -1)
					{
						num = num4;
						break;
					}
				}
			}
			return num.ToString();
		}
		return "#N/A";
	}

	public string ComputeModeOsngl(string range)
	{
		double[] doubleArray = GetDoubleArray(range);
		double[] array = doubleArray.Clone() as double[];
		int length = doubleArray.GetLength(0);
		if (length <= 1)
		{
			return "#N/A";
		}
		Array.Sort(doubleArray);
		List<object> list = new List<object>();
		double num = double.NaN;
		int num2 = 0;
		int num3 = 0;
		for (int i = 1; i < length; i++)
		{
			if (doubleArray[i] == doubleArray[i - 1])
			{
				num2++;
				continue;
			}
			if (num2 > num3)
			{
				num3 = num2;
				num = doubleArray[i - 1];
				list.Clear();
				list.Add(num);
			}
			else if (num2 == num3)
			{
				list.Add(doubleArray[i - 1]);
			}
			num2 = 0;
		}
		if (num2 > num3)
		{
			num3 = num2;
			num = doubleArray[length - 1];
			list.Clear();
			list.Add(num);
		}
		if (num3 > 0)
		{
			if (num2 == num3)
			{
				list.Add(doubleArray[length - 1]);
			}
			if (list.Count > 1)
			{
				double[] array2 = array;
				foreach (double num4 in array2)
				{
					if (list.IndexOf(num4) > -1)
					{
						num = num4;
						break;
					}
				}
			}
			return num.ToString();
		}
		return "#N/A";
	}

	public string ComputeTOdist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		int result = 0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]).Replace(TIC, string.Empty);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result2) && int.TryParse(array[1], NumberStyles.Any, null, out result))
		{
			if (result < 1 || result2.ToString().StartsWith("-"))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new Exception(errorStrings[4].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
				}
				return errorStrings[4].ToString();
			}
			if (array[2] == TRUEVALUESTR)
			{
				num = TCumulativeDensity(result2, result);
			}
			else if (array[2] == FALSEVALUESTR)
			{
				num = TProbabilityDensity(result2, result);
			}
			return num.ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new Exception(errorStrings[1].ToString() + " " + FormulaErrorStrings[invalid_parameter]);
		}
		return errorStrings[1].ToString();
	}

	public string ComputeBetaDist(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		if (length < 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		double result = 0.0;
		double result2 = 0.0;
		double num = 0.0;
		for (int i = 0; i < length; i++)
		{
			array[i] = GetValueFromArg(array[i]);
		}
		if (double.TryParse(array[0], NumberStyles.Any, null, out var result3) && double.TryParse(array[1], NumberStyles.Any, null, out result) && double.TryParse(array[2], NumberStyles.Any, null, out result2))
		{
			if (result < 0.0 || result2 < 0.0)
			{
				return ErrorStrings[4].ToString();
			}
			if (array[3] == TRUEVALUESTR)
			{
				num = BetaCumulativeDist(result3, result, result2);
			}
			else if (array[3] == FALSEVALUESTR)
			{
				num = BetaProbabilityDens(result3, result, result2);
			}
		}
		return num.ToString();
	}

	public double BetaCumulativeDist(double x, double a, double b)
	{
		return RIBetaFunction(x, a, b);
	}

	private double BetaProbabilityDens(double x, double a, double b)
	{
		double num = BetaFunction(a, b);
		return Math.Pow(x, a - 1.0) * Math.Pow(1.0 - x, b - 1.0) / num;
	}

	public string ComputeGauss(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(args);
		if (text == "0")
		{
			return text;
		}
		if (text == double.PositiveInfinity.ToString() || text == double.NegativeInfinity.ToString() || text == double.NaN.ToString())
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		return (double.Parse(ComputeNormOsODist(text + parseArgumentSeparator + TRUEVALUESTR)) - 0.5).ToString();
	}

	public string ComputeGamma(string args)
	{
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(args, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(args);
		int result = 0;
		if ((text.StartsWith("-") && int.TryParse(text, out result)) || text == "0")
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[4].ToString();
		}
		return CalculateGammaValue(text).ToString();
	}

	private double CalculateGammaValue(string number)
	{
		double[] array = new double[9] { 0.9999999999998099, 676.5203681218851, -1259.139216722403, 771.3234287776531, -176.6150291621406, 12.507343278686905, -0.13857109526572, 9.984369578E-06, 1.50563273515E-07 };
		double num = double.Parse(number);
		double num2 = 7.0;
		if (num < 0.5)
		{
			return Math.PI / (Math.Sin(Math.PI * num) * CalculateGammaValue((1.0 - num).ToString()));
		}
		num -= 1.0;
		double num3 = array[0];
		for (int i = 1; (double)i < num2 + 2.0; i++)
		{
			num3 += array[i] / (num + (double)i);
		}
		double num4 = num + num2 + 0.5;
		return Math.Sqrt(Math.PI * 2.0) * Math.Pow(num4, num + 0.5) * Math.Exp(0.0 - num4) * num3;
	}

	public string ComputeVarS(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		List<double> list = new List<double>();
		for (int i = 0; i < length; i++)
		{
			string empty = string.Empty;
			if (array[i].Contains(":"))
			{
				empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
				double[] doubleArray = GetDoubleArray(array[i]);
				list.AddRange(doubleArray);
				continue;
			}
			empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			double result;
			if (array[i].StartsWith(TIC) && array[i].EndsWith(TIC))
			{
				string[] array2 = array[i].Substring(1, array[i].Length - 2).Split(parseArgumentSeparator);
				if (ErrorStrings.Contains(empty))
				{
					for (int j = 0; j < array2.Length; j++)
					{
						if (double.TryParse(GetValueFromArg(array2[j]), out result))
						{
							list.Add(result);
						}
					}
					continue;
				}
				for (int k = 0; k < array2.Length; k++)
				{
					if (double.TryParse(GetValueFromArg(array2[k]), out result))
					{
						list.Add(result);
					}
				}
			}
			else if (double.TryParse(GetValueFromArg(array[i]), out result))
			{
				list.Add(result);
			}
		}
		double mean = list.Average();
		return (list.Sum((double num) => Math.Pow(num - mean, 2.0)) / (double)(list.Count - 1)).ToString();
	}

	private static string Spell(int number)
	{
		Dictionary<object, object> dictionary = new Dictionary<object, object>();
		dictionary.Add(0, "");
		dictionary.Add(1, "one");
		dictionary.Add(2, "two");
		dictionary.Add(3, "three");
		dictionary.Add(4, "four");
		dictionary.Add(5, "five");
		dictionary.Add(6, "six");
		dictionary.Add(7, "seven");
		dictionary.Add(8, "eight");
		dictionary.Add(9, "nine");
		dictionary.Add(10, "ten");
		dictionary.Add(11, "eleven");
		dictionary.Add(12, "twelve");
		dictionary.Add(13, "thirteen");
		dictionary.Add(14, "fourteen");
		dictionary.Add(15, "fifteen");
		dictionary.Add(16, "sixteen");
		dictionary.Add(17, "seventeen");
		dictionary.Add(18, "eighteen");
		dictionary.Add(19, "nineteen");
		dictionary.Add(20, "twenty");
		dictionary.Add(30, "thirty");
		dictionary.Add(40, "forty");
		dictionary.Add(50, "fifty");
		dictionary.Add(60, "sixty");
		dictionary.Add(70, "seventy");
		dictionary.Add(80, "eighty");
		dictionary.Add(90, "ninety");
		if (number >= 1000)
		{
			return Spell(number / 1000) + " thousand " + Spell(number % 1000);
		}
		if (number >= 100)
		{
			return Spell(number / 100) + " hundred " + Spell(number % 100);
		}
		if (number >= 21)
		{
			return dictionary[number / 10 * 10]?.ToString() + " " + dictionary[number % 10];
		}
		return dictionary[number].ToString();
	}

	public string TranslateText(string input, string languagePair)
	{
		try
		{
			return string.Empty;
		}
		catch
		{
			return "Can't able to get text";
		}
	}

	public string ComputeCode(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = GetValueFromArg(array[0]).Replace(TIC, string.Empty);
		string text2 = FormulaErrorStringCheck(argList, FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		if (string.IsNullOrEmpty(text))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = Encoding.UTF8.GetBytes(text)[0];
		return num.ToString();
	}

	public string ComputeFindB(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 2 && array.Length != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string value = StripTics0(GetValueFromArg(array[0]));
		string text = StripTics0(GetValueFromArg(array[1]));
		int result = 1;
		if (array.Length == 3 && !int.TryParse(GetValueFromArg(array[2]), out result))
		{
			result = 1;
		}
		if (result <= 0 || result > text.Length)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = text.IndexOf(value, result - 1);
		if (num < 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		return (num + 1).ToString();
	}

	public string ComputeLeftB(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length != 1 && length != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		bool flag = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		string formula = ((length == 2) ? array[1] : "1");
		formula = ComputedValue(formula);
		int num = int.Parse(formula) + (flag ? 1 : 0);
		arg = arg[..((arg.Length >= num) ? num : arg.Length)];
		if (flag && !arg.EndsWith(TIC))
		{
			arg += TIC;
		}
		return arg;
	}

	public string ComputeJis(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		char[] array2 = StripTics0(GetValueFromArg(array[0])).ToCharArray();
		for (int i = 0; i < array2.Length; i++)
		{
			if (array2[i] == ' ')
			{
				array2[i] = '\u3000';
			}
			else if (array2[i] < '\u007f')
			{
				array2[i] = (char)(array2[i] + 65248);
			}
		}
		return new string(array2);
	}

	public string ComputeLenB(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		return ((arg.StartsWith(TIC) && arg.EndsWith(TIC)) ? (arg.Length - 2) : arg.Length).ToString();
	}

	public string ComputeMidB(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		bool flag = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		int num = int.Parse(GetValueFromArg(array[2]));
		if (array[1].IndexOf("#VALUE!") > -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int num2 = int.Parse(GetValueFromArg(array[1])) + ((!flag) ? (-1) : 0);
		if (num2 + num > arg.Length)
		{
			return FormulaErrorStrings[invalid_arguments];
		}
		arg = arg.Substring(num2, num);
		if (flag && !arg.StartsWith(TIC))
		{
			arg = TIC + arg;
		}
		if (flag && !arg.EndsWith(TIC))
		{
			arg += TIC;
		}
		return arg;
	}

	public string ComputeRightB(string range)
	{
		string[] array = SplitArgsPreservingQuotedCommas(range);
		int length = array.GetLength(0);
		if (length != 1 && length != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return FormulaErrorStrings[invalid_arguments];
		}
		string arg = array[0];
		arg = GetValueFromArg(arg);
		bool flag = arg.StartsWith(TIC) && arg.EndsWith(TIC);
		string text = ((length == 2) ? array[1] : "1");
		if (text.IndexOf("#VALUE!") > -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentNullException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		text = ComputedValue(text);
		int num = int.Parse(text) + (flag ? 1 : 0);
		int startIndex = ((arg.Length >= num) ? (arg.Length - num) : 0);
		arg = arg.Substring(startIndex);
		if (flag && !arg.StartsWith(TIC))
		{
			arg = TIC + arg;
		}
		return arg;
	}

	public string ComputeNumberValue(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		char c = ParseDecimalSeparator;
		char value = ParseArgumentSeparator;
		if (length > 3)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = StripTics0(GetValueFromArg(array[0]));
		if (length > 1)
		{
			try
			{
				string text2 = StripTics0(GetValueFromArg(array[1]));
				string text3 = StripTics0(GetValueFromArg(array[2]));
				if (text2.Equals("invalid expression") || text3.Equals("invalid expression") || (string.IsNullOrEmpty(text2) && string.IsNullOrEmpty(text3)))
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				c = StripTics0(text2)[0];
				value = StripTics0(text3)[0];
			}
			catch (Exception ex)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ex.Message);
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (string.IsNullOrEmpty(text))
		{
			return "0";
		}
		int num = text.IndexOf(c);
		int num2 = text.IndexOf(value);
		if (num2 >= num && (num != -1 || num2 != -1))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		text = text.Replace(TIC, string.Empty);
		text = text.Replace(" ", string.Empty);
		text = text.Replace(value.ToString(), string.Empty);
		text = text.Replace(c, ParseDecimalSeparator);
		text = text.Replace(",", string.Empty);
		string text4 = ComputeValue(text);
		if (ComputeIsNumber(text4) != TRUEVALUESTR || text.EndsWith("$"))
		{
			if (TimeSpan.TryParse(text, out var result))
			{
				return result.TotalDays.ToString();
			}
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		return text4;
	}

	public string ComputeProper(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string valueFromArg = GetValueFromArg(array[0]);
		if (string.IsNullOrEmpty(valueFromArg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[bad_formula];
		}
		string text = StripTics0(valueFromArg);
		int num = text.IndexOf("'");
		if (num >= 0 && num < text.Length - 1)
		{
			text = Regex.Replace(text, "[']", " '").ToUpperInvariant();
			if (string.IsNullOrEmpty(text))
			{
				return string.Empty;
			}
			if (text.Equals("invalid expression"))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[5].ToString());
				}
				return ErrorStrings[5].ToString();
			}
			text = CultureInfo.CurrentCulture.TextInfo.ToLower(text).Replace(" '", "'");
			return text.ToString();
		}
		if (Regex.IsMatch(text, "^([A-Za-z0-9\\-]+)"))
		{
			string[] array2 = Regex.Split(text, "(?<=[a-zA-Z])(?=\\d)");
			text = string.Empty;
			string[] array3 = array2;
			for (int i = 0; i < array3.Length; i++)
			{
				_ = array3[i];
				text = CultureInfo.CurrentCulture.TextInfo.ToLower(text);
			}
			return text;
		}
		if (Regex.IsMatch(text, "^[a-zA-Z0-9]+$"))
		{
			return text = Regex.Replace(text, "[^a-zA-Z0-9_\\\\]", "").ToUpperInvariant();
		}
		return CultureInfo.CurrentCulture.TextInfo.ToLower(text);
	}

	public string ComputeReplace(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int result = 0;
		int result2 = 0;
		if (length != 4 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string text2 = FormulaErrorStringCheck(array[3], FormulaArgumentType.Text);
		if (ErrorStrings.Contains(text2))
		{
			return text2;
		}
		for (int i = 1; i <= 2; i++)
		{
			array[i] = (string.IsNullOrEmpty(array[i]) ? "0" : array[i]);
			array[i] = (bool.TryParse(GetValueFromArg(array[i]), out var result3) ? Convert.ToInt16(result3).ToString() : array[i]);
			string text3 = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
		}
		string text4 = StripTics0(GetValueFromArg(array[0]));
		string text5 = StripTics0(GetValueFromArg(array[3]));
		string empty = string.Empty;
		if (int.TryParse(GetValueFromArg(array[1]), out result) && int.TryParse(GetValueFromArg(array[2]), out result2))
		{
			try
			{
				string empty2 = string.Empty;
				if (string.IsNullOrEmpty(text4))
				{
					return text5;
				}
				if (text4.Length <= result && result > result2)
				{
					return text4 + text5;
				}
				if (text4.Length <= result)
				{
					empty2 = text4;
					return text4.Replace(empty2, text5);
				}
				empty2 = text4.Substring(result - 1, result2);
				return text4.Replace(empty2, text5);
			}
			catch (Exception)
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw;
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeRept(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string value = StripTics0(GetValueFromArg(array[0]));
		double result = 1.0;
		string valueFromArg = GetValueFromArg(array[1]);
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(valueFromArg) || valueFromArg.Equals("invalid expression"))
		{
			return string.Empty;
		}
		if (!double.TryParse(valueFromArg.Replace(TIC, string.Empty), out result))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return ErrorStrings[5].ToString();
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; (double)i < result; i++)
		{
			stringBuilder.Append(value);
		}
		return stringBuilder.ToString();
	}

	public string ComputeSearchB(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int result = 1;
		if (length != 2 && length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		_ = CultureInfo.CurrentCulture;
		string value = StripTics0(GetValueFromArg(array[0]));
		string text = StripTics0(GetValueFromArg(array[1]));
		int num = text.IndexOf(value) + 1;
		if (length == 3 && int.TryParse(GetValueFromArg(array[2]), out result))
		{
			try
			{
				num = text.IndexOf(value, result) + 1;
			}
			catch
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num.Equals(0))
		{
			return ErrorStrings[1].ToString();
		}
		return num.ToString();
	}

	public string ComputeUniChar(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		array[0] = (bool.TryParse(GetValueFromArg(array[0]), out var result) ? Convert.ToInt16(result).ToString() : array[0]);
		string text2 = StripTics0(GetValueFromArg(array[0]));
		int result2 = 0;
		if (text2.Equals("invalid expression"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		if (!int.TryParse(text2, out result2) || result2 == 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		return ((char)result2).ToString().ToString();
	}

	public string ComputeUniCode(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = StripTics0(GetValueFromArg(array[0]));
		int result = 0;
		if (text.Equals("invalid expression"))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[5].ToString());
			}
			return ErrorStrings[5].ToString();
		}
		if (text.Equals("invalid expression") || string.IsNullOrEmpty(text) || (int.TryParse(text, out result) && result == 0))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[1].ToString());
			}
			return ErrorStrings[1].ToString();
		}
		return char.GetNumericValue(text, 0).ToString().ToString();
	}

	public string ComputeChar(string arg)
	{
		if (SplitArgsPreservingQuotedCommas(arg).GetLength(0) > 1 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(arg, FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string valueFromArg = GetValueFromArg(arg);
		valueFromArg = (bool.TryParse(valueFromArg, out var result) ? Convert.ToInt16(result).ToString() : valueFromArg);
		string empty = string.Empty;
		if (int.TryParse(valueFromArg, out var result2) && result2 > 0 && result2 < 256)
		{
			return ((char)result2).ToString();
		}
		if (RethrowLibraryComputationExceptions)
		{
			throw new ArgumentException(FormulaErrorStrings[bad_formula]);
		}
		return ErrorStrings[1].ToString();
	}

	public string ComputeClean(string arg)
	{
		if (SplitArgsPreservingQuotedCommas(arg).Length != 1)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		bool result = true;
		string scopedRange = string.Empty;
		if (!arg.Contains(TIC) && !IsCellReference(arg) && !double.TryParse(arg, out var _) && !TryGetNamedRange(arg, out scopedRange) && !bool.TryParse(ComputeIsLogical(arg), out result))
		{
			return ErrorStrings[5].ToString();
		}
		int num = ErrorStrings.IndexOf(arg);
		if (num > -1)
		{
			return ErrorStrings[num].ToString();
		}
		string text = GetValueFromArg(arg);
		for (int i = 0; i <= 31; i++)
		{
			string text2 = ComputeChar(i.ToString());
			if (text.Contains(text2))
			{
				text = text.Replace(text2, string.Empty);
			}
		}
		if (text.StartsWith(TIC) && text.EndsWith(TIC))
		{
			text = text.Substring(1, text.Length - 2);
		}
		return text;
	}

	public string ComputeExact(string range)
	{
		AdjustRangeArg(ref range);
		string[] array = SplitArgsPreservingQuotedCommas(range);
		if (array.GetLength(0) != 2)
		{
			return FormulaErrorStrings[requires_2_args];
		}
		string text = GetValueFromArg(array[0]);
		string text2 = GetValueFromArg(array[1]);
		if (double.TryParse(text, out var result))
		{
			text = result.ToString();
		}
		if (double.TryParse(text2, out result))
		{
			text2 = result.ToString();
		}
		if (!(text == text2))
		{
			return FALSEVALUESTR;
		}
		return TRUEVALUESTR;
	}

	public string ComputeFind(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		if (array.Length != 2 && array.Length != 3)
		{
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(arg, FormulaArgumentType.TwoTextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string value = StripTics0(GetValueFromArg(array[0]));
		string text2 = StripTics0(GetValueFromArg(array[1]));
		int result = 1;
		if (array.Length == 3 && !int.TryParse(GetValueFromArg(array[2]), out result))
		{
			result = 1;
		}
		if (result <= 0 || result > text2.Length)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = text2.IndexOf(value, result - 1);
		if (num < 0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		return (num + 1).ToString();
	}

	public string ComputeIndex(string arg)
	{
		string[] array = SplitArgsPreservingQuotedCommas(arg);
		int length = array.GetLength(0);
		if (length < 2 || length == 0 || string.IsNullOrEmpty(arg))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 1; i < length; i++)
		{
			if (i <= length - 1)
			{
				string text = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(text))
				{
					return text;
				}
			}
		}
		int num = array[0].IndexOf(":");
		if (string.IsNullOrEmpty(array[1]))
		{
			if (RowIndex(array[0].Substring(0, num)) != RowIndex(array[0].Substring(num + 1)))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[bad_formula]);
				}
				return ErrorStrings[1].ToString();
			}
			array[1] = "0";
		}
		else if (string.IsNullOrEmpty(array[0]) || (length == 3 && string.IsNullOrEmpty(array[2]) && ColIndex(array[0].Substring(0, num)) != ColIndex(array[0].Substring(num + 1))))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		string text2 = array[0];
		text2 = text2.Replace(TIC, string.Empty);
		int num2 = text2.IndexOf(":");
		if (num2 == -1)
		{
			if (IsCellReference(text2))
			{
				text2 = text2 + ":" + text2;
			}
			else
			{
				if (text2.IndexOf(';') <= -1)
				{
					return FindArrayIndex(text2, array);
				}
				string[] array2 = SplitArguments(text2, ';');
				if (array2[0].IndexOf(',') <= -1)
				{
					return FindArrayIndex(text2, array);
				}
				int num3 = SplitArgsPreservingQuotedCommas(array2[0]).Length;
				double[,] array3 = new double[array2.Length, num3];
				int num4 = num3;
				int num5 = 0;
				for (num2 = 0; num2 < array2.Length; num2++)
				{
					string[] array4 = SplitArgsPreservingQuotedCommas(array2[num2]);
					num5 = array4.Length;
					if (num4 != num5)
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
						}
						return FormulaErrorStrings[wrong_number_arguments];
					}
					for (int j = 0; j < num4; j++)
					{
						array3[num2, j] = double.Parse(GetValueFromArg(array4[j]));
					}
				}
				double result = -1.0;
				double result2 = -1.0;
				if (length == 3 && double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out result) && result >= 0.0 && double.TryParse(GetValueFromArg(array[2]), NumberStyles.Integer, null, out result2) && result2 >= 0.0)
				{
					if (result == 0.0 && result2 != 0.0)
					{
						return array3[(int)result, (int)result2 - 1].ToString();
					}
					if (result2 == 0.0 && result != 0.0)
					{
						return array3[(int)result - 1, (int)result2].ToString();
					}
					if (result2 != 0.0 || result != 0.0)
					{
						return array3[(int)result - 1, (int)result2 - 1].ToString();
					}
					return array3[0, 0].ToString();
				}
				if (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out result) && result >= 0.0)
				{
					if (result != 0.0)
					{
						return array3[(int)result - 1, 0].ToString();
					}
					return array3[0, 0].ToString();
				}
			}
		}
		num2 = text2.IndexOf(":");
		if (arg.IndexOf("#N/A") > -1 || arg.IndexOf("#N~A") > -1)
		{
			return "#N/A";
		}
		if (arg.IndexOf("#DIV/0!") > -1 || arg.IndexOf("#DIV~0!") > -1)
		{
			return "#DIV/0!";
		}
		string sheetTokenFromReference = GetSheetTokenFromReference(text2);
		int num6 = ((length == 1) ? 1 : (double.TryParse(GetValueFromArg(array[1]), NumberStyles.Integer, null, out var result3) ? ((int)result3) : (-1)));
		int num7 = ((length <= 2) ? 1 : (double.TryParse(GetValueFromArg(array[2]), NumberStyles.Integer, null, out result3) ? ((int)result3) : (-1)));
		if (num6 == -1 || num7 == -1)
		{
			return ErrorStrings[2].ToString();
		}
		int num8 = RowIndex(text2.Substring(0, num2));
		int num9 = RowIndex(text2.Substring(num2 + 1));
		if (!(!num8.Equals(-1) || num9.Equals(-1)).Equals(num8.Equals(-1) || !num9.Equals(-1)))
		{
			return ErrorStrings[5].ToString();
		}
		GridSheetFamilyItem sheetFamilyItem = GetSheetFamilyItem(grid);
		ISheetData sheetData = null;
		if (sheetTokenFromReference != string.Empty)
		{
			sheetData = sheetFamilyItem.TokenToParentObject[sheetTokenFromReference] as ISheetData;
		}
		if (num8 == -1 && sheetFamilyItem.TokenToParentObject != null && sheetData != null)
		{
			num8 = sheetData.GetFirstRow();
		}
		else if (num8 == -1 && grid is ISheetData)
		{
			num8 = ((ISheetData)grid).GetFirstRow();
		}
		if (num9 == -1 && sheetFamilyItem.TokenToParentObject != null && sheetData != null)
		{
			num9 = sheetData.GetLastRow();
		}
		else if (num9 == -1 && grid is ISheetData)
		{
			num9 = ((ISheetData)grid).GetLastRow();
		}
		int num10 = ColIndex(text2.Substring(0, num2));
		int num11 = ColIndex(text2.Substring(num2 + 1));
		if (num10 == -1 && sheetFamilyItem.TokenToParentObject != null && sheetData != null)
		{
			num10 = sheetData.GetFirstColumn();
		}
		else if (num10 == -1 && grid is ISheetData)
		{
			num10 = ((ISheetData)grid).GetFirstColumn();
		}
		if (num11 == -1 && sheetFamilyItem.TokenToParentObject != null && sheetData != null)
		{
			num11 = sheetData.GetLastColumn();
		}
		if (num11 == -1 && grid is ISheetData)
		{
			num11 = ((ISheetData)grid).GetLastColumn();
		}
		if (length == 2 && num6 > num9 - num8 + 1)
		{
			num7 = num6;
			num6 = 1;
		}
		if (num6 > num9 - num8 + 1 || num7 > num11 - num10 + 1)
		{
			return ErrorStrings[2].ToString();
		}
		num6 = RowIndex(text2.Substring(0, num2)) + ((num6 <= 0) ? num6 : (num6 - 1));
		if (RowIndex(text2.Substring(0, num2)) == -1 && grid is ISheetData)
		{
			num6 += 2;
		}
		num7 = ColIndex(text2.Substring(0, num2)) + ((num7 <= 0) ? num7 : (num7 - 1));
		if (ColIndex(text2.Substring(0, num2)) == -1 && grid is ISheetData)
		{
			num7 += 2;
		}
		if (computeFunctionLevel > 0 && isIndexInteriorFormula && hitCount == computedValueLevel)
		{
			string empty = string.Empty;
			string[] cellsFromArgs = GetCellsFromArgs(text2);
			if (cellsFromArgs.Length != 0)
			{
				empty = (cellsFromArgs[0] + ":" + cellsFromArgs[^1]).Replace(sheetTokenFromReference, string.Empty);
				return sheetTokenFromReference + empty;
			}
			return string.Format("{2}{0}{1}", RangeInfo.GetAlphaLabel(num7), num6, sheetTokenFromReference);
		}
		string valueFromArg = GetValueFromArg(string.Format("{2}{0}{1}", RangeInfo.GetAlphaLabel(num7), num6, sheetTokenFromReference));
		if (!isIndexInteriorFormula && string.IsNullOrEmpty(valueFromArg) && treatStringsAsZero)
		{
			return "0";
		}
		return valueFromArg;
	}

	private string FindArrayIndex(string r, string[] args)
	{
		string[] array = null;
		string result = string.Empty;
		double result2 = -1.0;
		double result3 = -1.0;
		int length = args.GetLength(0);
		array = ((r.IndexOf(';') <= -1) ? SplitArgsPreservingQuotedCommas(r) : SplitArguments(r, ';'));
		if (length == 3 && double.TryParse(GetValueFromArg(args[1]), NumberStyles.Integer, null, out result2) && result2 >= 0.0 && result2 == 1.0 && double.TryParse(GetValueFromArg(args[2]), NumberStyles.Integer, null, out result3) && result3 >= 0.0)
		{
			if ((double)array.Length >= result3)
			{
				result = (((int)result3 == 0) ? array[0] : array[(int)result3 - 1]);
			}
		}
		else
		{
			if (!double.TryParse(GetValueFromArg(args[1]), NumberStyles.Integer, null, out result2) || !(result2 >= 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[invalid_Math_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			if (!((double)array.Length >= result2))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentNullException(FormulaErrorStrings[invalid_arguments]);
				}
				return ErrorStrings[2].ToString();
			}
			result = (((int)result2 == 0) ? array[0] : array[(int)result2 - 1]);
		}
		return result;
	}

	public string ComputeSearch(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		int length = array.GetLength(0);
		int result = 1;
		if ((length != 2 && length != 3) || string.IsNullOrEmpty(argList))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(argList, FormulaArgumentType.TwoTextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string value = StripTics0(GetValueFromArg(array[0])).ToLower();
		string text2 = StripTics0(GetValueFromArg(array[1])).ToLower();
		if (string.IsNullOrEmpty(text2))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[bad_formula]);
			}
			return ErrorStrings[1].ToString();
		}
		int num = text2.IndexOf(value) + 1;
		if (length == 3 && int.TryParse(GetValueFromArg(array[2]), out result))
		{
			try
			{
				num = text2.IndexOf(value, result - 1) + 1;
			}
			catch
			{
				ExceptionThrown = true;
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		if (num.Equals(0))
		{
			return ErrorStrings[1].ToString();
		}
		return num.ToString();
	}

	private List<string[,]> FindUniqueElement(string[,] arrayList, string byCol, string exactOnce)
	{
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		List<string> list = new List<string>();
		List<string[,]> list2 = new List<string[,]>();
		int length = arrayList.GetLength(0);
		int length2 = arrayList.GetLength(1);
		if (byCol == TRUEVALUESTR)
		{
			for (int i = 0; i < length2; i++)
			{
				string text = "";
				for (int j = 0; j < length; j++)
				{
					text = text + arrayList[j, i] + ",";
				}
				if (dictionary.ContainsKey(text))
				{
					dictionary[text]++;
				}
				else
				{
					dictionary[text] = 1;
				}
			}
			foreach (string key in dictionary.Keys)
			{
				if (exactOnce == FALSEVALUESTR || dictionary[key] == 1)
				{
					list.Add(key);
				}
			}
			foreach (string item in list)
			{
				string[,] array = new string[length, 1];
				string[] array2 = item.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
				for (int k = 0; k < length; k++)
				{
					array[k, 0] = array2[k];
				}
				list2.Add(array);
			}
		}
		else
		{
			for (int l = 0; l < length; l++)
			{
				string text2 = "";
				for (int m = 0; m < length2; m++)
				{
					text2 = text2 + arrayList[l, m] + ",";
				}
				if (dictionary.ContainsKey(text2))
				{
					dictionary[text2]++;
				}
				else
				{
					dictionary[text2] = 1;
				}
			}
			foreach (string key2 in dictionary.Keys)
			{
				if (exactOnce == FALSEVALUESTR || dictionary[key2] == 1)
				{
					list.Add(key2);
				}
			}
			foreach (string item2 in list)
			{
				string[,] array3 = new string[1, length2];
				string[] array4 = item2.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
				for (int n = 0; n < length2; n++)
				{
					array3[0, n] = array4[n];
				}
				list2.Add(array3);
			}
		}
		return list2;
	}

	public string ComputeUnique(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = ((array[0].StartsWith(TIC) || array[0].EndsWith(TIC)) ? ValidateArgumentType(array[0], FormulaArgumentType.Text) : ValidateArgumentType(array[0], FormulaArgumentType.Range));
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = array[0].ToString();
		string text2;
		if (length > 1 && array[1].ToString() != string.Empty)
		{
			text2 = ValidateArgumentType(array[1], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			text2 = GetValueFromArg(array[1].ToString());
		}
		else
		{
			text2 = FALSEVALUESTR.ToString();
		}
		string text3;
		if (length > 2 && array[2].ToString() != string.Empty)
		{
			text3 = ValidateArgumentType(array[2], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text3 = GetValueFromArg(array[2].ToString());
		}
		else
		{
			text3 = FALSEVALUESTR.ToString();
		}
		int num = text.IndexOf(':');
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		if (num != -1)
		{
			num2 = ColIndex(text.Substring(0, num));
			num3 = ColIndex(text.Substring(num + 1));
			num4 = RowIndex(text.Substring(0, num));
			num5 = RowIndex(text.Substring(num + 1));
		}
		string[] array2 = null;
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		string empty = string.Empty;
		if ((num2 != 0 && num3 != 0 && num2 == num3) || (num4 != 0 && num5 != 0 && num4 == num5) || (text.Contains(parseArgumentSeparator.ToString()) && !text.Contains(";")))
		{
			array2 = ((text.IndexOf(':') <= -1) ? text.Replace(TIC, string.Empty).Split(parseArgumentSeparator) : GetCellsFromArgs(text));
			string[] array3 = array2;
			foreach (string arg in array3)
			{
				string valueFromArg = GetValueFromArg(arg);
				if (dictionary.ContainsKey(valueFromArg))
				{
					dictionary[valueFromArg]++;
				}
				else
				{
					dictionary[valueFromArg] = 1;
				}
				list2.Add(valueFromArg);
			}
			foreach (string item in list2)
			{
				if (num4 == num5 && text2 == FALSEVALUESTR)
				{
					list.Add(item);
				}
				else if (num4 == num5 && text2 == TRUEVALUESTR && text3 == FALSEVALUESTR)
				{
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
				else if (num4 == num5 && text2 == TRUEVALUESTR && text3 == TRUEVALUESTR)
				{
					if (dictionary[item] == 1 && !list.Contains(item))
					{
						list.Add(item);
					}
				}
				else if (num2 == num3 && text2 == FALSEVALUESTR && text3 == FALSEVALUESTR)
				{
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
				else if (num2 == num3 && text2 == TRUEVALUESTR)
				{
					list.Add(item);
				}
				else if (num2 == num3 && text2 == FALSEVALUESTR && text3 == TRUEVALUESTR && dictionary[item] == 1 && !list.Contains(item))
				{
					list.Add(item);
				}
			}
			if (computeFunctionLevel > 0)
			{
				string empty2 = string.Empty;
				string text4 = string.Empty;
				int num6 = 0;
				foreach (string item2 in list)
				{
					num6++;
					empty2 = item2.ToString();
					if (num6 % num3 == 0 && num6 != list.Count)
					{
						empty2 += ";";
					}
					else if (num6 != list.Count)
					{
						empty2 += parseArgumentSeparator;
					}
					text4 += empty2;
				}
				if (!text4.StartsWith(TIC) && !text4.EndsWith(TIC))
				{
					text4 = TIC + text4 + TIC;
				}
				return text4;
			}
			if (list.Count != 0)
			{
				return list[0].ToString();
			}
			if (list.Count == 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[7].ToString());
				}
				return ErrorStrings[7].ToString();
			}
		}
		else
		{
			List<string[,]> list3 = null;
			if (text.IndexOf(':') > -1 || text.Contains(";"))
			{
				int num7 = 0;
				int num8 = 0;
				int num9 = 0;
				string[,] array4 = null;
				if (text.IndexOf(':') > -1)
				{
					array2 = GetCellsFromArgs(text);
					num7 = int.Parse(ComputeRows(text));
					num8 = int.Parse(ComputeColumns(text));
					array4 = new string[num7, num8];
					for (int j = 0; j < num7; j++)
					{
						for (int k = 0; k < num8; k++)
						{
							array4[j, k] = GetValueFromArg(array2[num9]);
							num9++;
						}
					}
				}
				else
				{
					array2 = SplitArguments(text.Replace(TIC, ""), ';');
					num7 = SplitArgsPreservingQuotedCommas(array2[0]).Length;
					num8 = SplitArgsPreservingQuotedCommas(array2[0]).Length;
					array4 = new string[num7, num8];
					for (int l = 0; l < array2.Length; l++)
					{
						string[] array5 = SplitArgsPreservingQuotedCommas(array2[l]);
						if (num7 != num8)
						{
							if (RethrowLibraryComputationExceptions)
							{
								throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
							}
							return FormulaErrorStrings[wrong_number_arguments];
						}
						for (int m = 0; m < num7; m++)
						{
							array4[l, m] = GetValueFromArg(array5[m]);
						}
					}
				}
				list3 = FindUniqueElement(array4, text2, text3);
				if (computeFunctionLevel > 0)
				{
					string empty3 = string.Empty;
					string text5 = string.Empty;
					int length2 = list3[0].GetLength(0);
					int length3 = list3[0].GetLength(1);
					for (int n = 0; n < length2; n++)
					{
						for (int num10 = 0; num10 < length3; num10++)
						{
							for (int num11 = 0; num11 < list3.Count; num11++)
							{
								empty3 = list3[num11][n, num10].ToString();
								text5 = string.Concat(text5, empty3 + parseArgumentSeparator);
							}
							text5 = text5.Remove(text5.Length - 1) + ";";
						}
					}
					text5 = text5.Remove(text5.Length - 1);
					if (!text5.StartsWith(TIC) && !text5.EndsWith(TIC))
					{
						text5 = TIC + text5 + TIC;
					}
					return text5;
				}
				if (list3.Count != 0)
				{
					return list3[0][0, 0].ToString();
				}
				if (list3.Count == 0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[7].ToString());
					}
					return ErrorStrings[7].ToString();
				}
			}
		}
		return empty;
	}

	private string CheckForErrorValue(string text, string delimiter, string instance_num, string match_mode, string match_end, string if_not_found, ref bool check)
	{
		if (ErrorStrings.Contains(text))
		{
			check = true;
			return text;
		}
		if (ErrorStrings.Contains(delimiter))
		{
			check = true;
			return delimiter;
		}
		if (ErrorStrings.Contains(instance_num))
		{
			check = true;
			return instance_num;
		}
		if (ErrorStrings.Contains(match_mode))
		{
			check = true;
			return match_mode;
		}
		if (ErrorStrings.Contains(match_end))
		{
			check = true;
			return match_end;
		}
		if (ErrorStrings.Contains(if_not_found))
		{
			check = true;
			return if_not_found;
		}
		return FALSEVALUESTR;
	}

	public string ComputeTextAfter(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		string text = string.Empty;
		string delimiter = string.Empty;
		string instance_num = string.Empty;
		string match_mode = string.Empty;
		string match_end = string.Empty;
		string if_not_found = string.Empty;
		GetValueForArg(array, ref text, ref delimiter, ref instance_num, ref match_mode, ref match_end, ref if_not_found);
		bool check = false;
		string result = CheckForErrorValue(text, delimiter, instance_num, match_mode, match_end, if_not_found, ref check);
		if (check.ToString().ToUpper() == TRUEVALUESTR)
		{
			return result;
		}
		int num = 0;
		if ((delimiter.Length == 1 || delimiter == " ") && (instance_num.StartsWith("-") || instance_num.StartsWith("u")))
		{
			num = FindIndexOfCharacterFromEnd(text, delimiter, instance_num);
		}
		else if ((delimiter.Length == 1 || delimiter == " ") && !instance_num.StartsWith("-") && !instance_num.StartsWith("u"))
		{
			num = FindIndexOfCharacter(text, delimiter, instance_num);
		}
		else if (delimiter.Length > 1 && !instance_num.StartsWith("-") && !instance_num.StartsWith("u"))
		{
			num = ((!(match_mode == "1")) ? FindIndexOfWord(text, delimiter, instance_num) : FindIndexOfWord(text.ToUpper(), delimiter.ToUpper(), instance_num));
			if (num != -1)
			{
				num += delimiter.Length;
			}
		}
		else
		{
			num = ((!(match_mode == "1")) ? FindIndexOfWordFromEnd(text, delimiter, instance_num) : FindIndexOfWordFromEnd(text.ToUpper(), delimiter.ToUpper(), instance_num));
			if (num != -1)
			{
				num += delimiter.Length;
			}
		}
		if (num == -1 && instance_num == "-1" && match_end == "1")
		{
			return text;
		}
		if (num == -1 && instance_num == "1" && match_end == "1")
		{
			return string.Empty;
		}
		if (num == -1 && delimiter == string.Empty)
		{
			return text;
		}
		if (num == -1 && length > 5 && if_not_found != string.Empty)
		{
			return if_not_found;
		}
		if (num == -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		if (text.Substring(num + 1).StartsWith(" "))
		{
			return text.Substring(num + 2);
		}
		return text.Substring(num + 1);
	}

	private void GetValueForArg(string[] args, ref string text, ref string delimiter, ref string instance_num, ref string match_mode, ref string match_end, ref string if_not_found)
	{
		int length = args.GetLength(0);
		text = ValidateArgumentType(args[0], FormulaArgumentType.Text);
		if (!ErrorStrings.Contains(text))
		{
			text = GetValueFromArg(text);
		}
		delimiter = ValidateArgumentType(args[1], FormulaArgumentType.Text);
		if (!ErrorStrings.Contains(delimiter))
		{
			delimiter = GetValueFromArg(delimiter).Replace(TIC, string.Empty);
		}
		if (length > 2 && args[2].ToString() != string.Empty)
		{
			instance_num = ValidateArgumentType(args[2], FormulaArgumentType.Numbers);
			if (!ErrorStrings.Contains(instance_num))
			{
				instance_num = GetValueFromArg(instance_num);
			}
			int num = int.Parse(instance_num);
			if (num > text.Length || num == 0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				instance_num = ErrorStrings[1].ToString();
			}
		}
		else
		{
			instance_num = "1";
		}
		if (length > 3 && args[3].ToString() != string.Empty)
		{
			match_mode = ValidateArgumentType(args[3], FormulaArgumentType.Numbers);
			if (!ErrorStrings.Contains(match_mode))
			{
				match_mode = GetValueFromArg(match_mode);
			}
			if (match_mode.ToUpper() == TRUEVALUESTR)
			{
				match_mode = "1";
			}
			else if (match_mode.ToUpper() == FALSEVALUESTR)
			{
				match_mode = "0";
			}
			if (double.TryParse(match_mode.Replace(TIC, string.Empty), out var result) && result != 0.0 && result != 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				match_mode = ErrorStrings[1].ToString();
			}
		}
		else
		{
			match_mode = "0";
		}
		if (length > 4 && args[4].ToString() != string.Empty)
		{
			match_end = ValidateArgumentType(args[4], FormulaArgumentType.Numbers);
			if (!ErrorStrings.Contains(match_end))
			{
				match_end = GetValueFromArg(match_end);
			}
			if (double.TryParse(match_end.Replace(TIC, string.Empty), out var result2) && result2 != 0.0 && result2 != 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				match_end = ErrorStrings[1].ToString();
			}
		}
		else
		{
			match_end = "0";
		}
		if (length > 5 && args[5].ToString() != string.Empty)
		{
			if_not_found = ValidateArgumentType(args[5], FormulaArgumentType.Text);
			if (!ErrorStrings.Contains(if_not_found))
			{
				if_not_found = GetValueFromArg(if_not_found);
			}
		}
	}

	public string ComputeTextBefore(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		string text = string.Empty;
		string delimiter = string.Empty;
		string instance_num = string.Empty;
		string match_mode = string.Empty;
		string match_end = string.Empty;
		string if_not_found = string.Empty;
		GetValueForArg(array, ref text, ref delimiter, ref instance_num, ref match_mode, ref match_end, ref if_not_found);
		bool check = false;
		string result = CheckForErrorValue(text, delimiter, instance_num, match_mode, match_end, if_not_found, ref check);
		if (check.ToString().ToUpper() == TRUEVALUESTR)
		{
			return result;
		}
		int num = 0;
		num = (((delimiter.Length == 1 || delimiter == " ") && (instance_num.StartsWith("-") || instance_num.StartsWith("u"))) ? FindIndexOfCharacterFromEnd(text, delimiter, instance_num) : (((delimiter.Length == 1 || delimiter == " ") && !instance_num.StartsWith("-") && !instance_num.StartsWith("u")) ? FindIndexOfCharacter(text, delimiter, instance_num) : ((delimiter.Length > 1 && !instance_num.StartsWith("-") && !instance_num.StartsWith("u")) ? ((!(match_mode == "1")) ? FindIndexOfWord(text, delimiter, instance_num) : FindIndexOfWord(text.ToUpper(), delimiter.ToUpper(), instance_num)) : ((!(match_mode == "1")) ? FindIndexOfWordFromEnd(text, delimiter, instance_num) : FindIndexOfWordFromEnd(text.ToUpper(), delimiter.ToUpper(), instance_num)))));
		if (num == -1 && length > 5 && if_not_found != string.Empty)
		{
			return if_not_found;
		}
		if (num == -1 && instance_num == "-1" && match_end == "1")
		{
			return string.Empty;
		}
		if (num == -1 && instance_num == "1" && match_end == "1")
		{
			return text;
		}
		if (num == -1 && delimiter == string.Empty)
		{
			return string.Empty;
		}
		if (num == -1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(ErrorStrings[0].ToString());
			}
			return ErrorStrings[0].ToString();
		}
		if (text.Substring(0, num).EndsWith(" "))
		{
			return text.Substring(0, num - 1);
		}
		return text.Substring(0, num);
	}

	private int FindIndexOfCharacterFromEnd(string text, string delimiter, string instance_num)
	{
		int num = 0;
		for (int num2 = text.Length - 1; num2 >= 0; num2--)
		{
			if (text[num2].ToString() == delimiter)
			{
				num++;
				if (num == int.Parse(instance_num.Replace("-", string.Empty).Replace("u", string.Empty)))
				{
					return num2;
				}
			}
		}
		return -1;
	}

	private int FindIndexOfWordFromEnd(string text, string delimiter, string instance_num)
	{
		string[] array = text.Split(new char[5] { ' ', '.', ',', '!', '?' }, StringSplitOptions.RemoveEmptyEntries);
		int num = 0;
		for (int num2 = array.Length - 1; num2 >= 0; num2--)
		{
			if (array[num2].Equals(delimiter))
			{
				num++;
				if (num == int.Parse(instance_num))
				{
					return text.IndexOf(array[num2], StringComparison.Ordinal);
				}
			}
		}
		return -1;
	}

	private int FindIndexOfWord(string text, string delimiter, string instance_num)
	{
		string[] array = text.Split(new char[5] { ' ', '.', ',', '!', '?' }, StringSplitOptions.RemoveEmptyEntries);
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].Equals(delimiter))
			{
				num++;
				if (num == int.Parse(instance_num))
				{
					return text.IndexOf(array[i], StringComparison.Ordinal);
				}
			}
		}
		return -1;
	}

	private int FindIndexOfCharacter(string text, string delimiter, string instance_num)
	{
		int result = -1;
		int num = 0;
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i].ToString() == delimiter)
			{
				num++;
				if (num == int.Parse(instance_num))
				{
					result = i;
					break;
				}
			}
		}
		return result;
	}

	public string ComputeValueToText(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < length; i++)
		{
			string text = FormulaErrorStringCheck(array[i].ToString(), FormulaArgumentType.TextWithNumber);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		if (IsArrayFormula || (array[0].StartsWith(TIC) && array[0].Contains(parseArgumentSeparator.ToString())))
		{
			return ValueToTextArrayCalculation(array);
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string empty = string.Empty;
		bool result = false;
		if (length > 1)
		{
			empty = GetValueFromArg(array[1]);
			empty = (bool.TryParse(empty.Replace(TIC, string.Empty), out result) ? Convert.ToInt32(result).ToString() : empty);
		}
		else
		{
			empty = "0";
		}
		return ValueToTextCalculation(valueFromArg, empty);
	}

	private string ValueToTextCalculation(string value, string format)
	{
		if (ComputeIsText(format) == TRUEVALUESTR)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[5].ToString();
		}
		if (double.TryParse(format.Replace(TIC, string.Empty), out var result) && result != 0.0 && result != 1.0)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[1].ToString();
		}
		if (value == TRUEVALUESTR.ToString() || value == FALSEVALUESTR.ToString() || ErrorStrings.Contains(value))
		{
			return value;
		}
		if (ComputeIsText(value) == TRUEVALUESTR && format == "1")
		{
			return TIC + value + TIC;
		}
		if (format == "0" && value.Contains(TIC))
		{
			return value.Replace(TIC, string.Empty);
		}
		return value;
	}

	internal string ValueToTextArrayCalculation(string[] range)
	{
		string[] array = null;
		string text = string.Empty;
		if (range[0].StartsWith(TIC) && range[0].EndsWith(TIC))
		{
			array = range[0].Replace(TIC, string.Empty).Split(',');
		}
		string empty = string.Empty;
		bool result = false;
		if (range.GetLength(0) > 1)
		{
			empty = GetValueFromArg(range[1].ToString());
			empty = (bool.TryParse(empty.Replace(TIC, string.Empty), out result) ? Convert.ToInt32(result).ToString() : empty);
		}
		else
		{
			empty = "0";
		}
		if (computedValueLevel > 1)
		{
			for (int i = 0; i < array.Length; i++)
			{
				text = text + TIC + ValueToTextCalculation(array[i], empty) + TIC + ";";
			}
			return text.Remove(text.Length - 1);
		}
		return ValueToTextCalculation(array[0], empty);
	}

	public string ComputeArrayToText(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.TextWithNumber);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		string empty = string.Empty;
		if (length > 1)
		{
			string text2 = array[1];
			if (text2 == TRUEVALUESTR)
			{
				text2 = "1";
			}
			else if (text2 == FALSEVALUESTR)
			{
				text2 = "0";
			}
			if (double.TryParse(text2.Replace(TIC, string.Empty), out var result) && result != 0.0 && result != 1.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			text = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
			return ConvertArrayToTextValue(array[0], text2);
		}
		return ConvertArrayToTextValue(array[0], "0");
	}

	private string ConvertArrayToTextValue(string range, string format)
	{
		List<string> list = new List<string>();
		SplitArgsPreservingQuotedCommas(range);
		string[] array = null;
		int num = 0;
		if (IsRange(range))
		{
			string[] cellsFromArgs = GetCellsFromArgs(range);
			foreach (string arg in cellsFromArgs)
			{
				string valueFromArg = GetValueFromArg(arg);
				list.Add(ArrayToTextCalculation(valueFromArg, format));
			}
			array = range.Split(':');
			num = ColIndex(array[1]) - ColIndex(array[0]) + 1;
		}
		else
		{
			if (!range.Contains(parseArgumentSeparator.ToString()) && !range.Contains(";"))
			{
				string valueFromArg2 = GetValueFromArg(range);
				string text = ArrayToTextCalculation(valueFromArg2, format);
				if (format == "1")
				{
					return TIC + text + TIC;
				}
				return text;
			}
			if (range.StartsWith(TIC) && range.EndsWith(TIC))
			{
				range = range.Replace(TIC, string.Empty);
			}
			array = range.Split(';');
			for (int j = 0; j < array.Length; j++)
			{
				string[] array2 = array[j].Split(parseArgumentSeparator);
				for (int k = 0; k < array2.Length; k++)
				{
					list.Add(ArrayToTextCalculation(array2[k], format));
				}
			}
			num = array[0].Split(parseArgumentSeparator).Length;
		}
		List<List<string>> list2 = ConvertToStructuredData(list, num);
		StringBuilder stringBuilder = new StringBuilder();
		if (format == "1")
		{
			foreach (List<string> item in list2)
			{
				stringBuilder.Append(string.Join(parseArgumentSeparator.ToString(), item)).Append(";");
			}
		}
		else
		{
			foreach (List<string> item2 in list2)
			{
				stringBuilder.Append(string.Join(parseArgumentSeparator.ToString(), item2)).Append(parseArgumentSeparator.ToString());
			}
		}
		if ((stringBuilder.Length > 0 && stringBuilder[stringBuilder.Length - 1] == ';') || stringBuilder[stringBuilder.Length - 1] == parseArgumentSeparator)
		{
			stringBuilder.Length--;
		}
		if (computeFunctionLevel > 0)
		{
			return TIC + stringBuilder.ToString() + TIC;
		}
		if (format == "1")
		{
			return TIC + stringBuilder.ToString() + TIC;
		}
		return stringBuilder.ToString();
	}

	private List<List<string>> ConvertToStructuredData(List<string> result, int numberOfColumns)
	{
		List<List<string>> list = new List<List<string>>();
		for (int i = 0; i < result.Count; i += numberOfColumns)
		{
			List<string> list2 = new List<string>();
			for (int j = 0; j < numberOfColumns && i + j < result.Count; j++)
			{
				list2.Add(result[i + j]);
			}
			list.Add(list2);
		}
		return list;
	}

	private string ArrayToTextCalculation(string value, string format)
	{
		if (value.Replace(TIC, string.Empty) == TRUEVALUESTR.ToString() || value.Replace(TIC, string.Empty) == FALSEVALUESTR.ToString() || ErrorStrings.Contains(value))
		{
			return value;
		}
		if (value.StartsWith(TIC) && value.EndsWith(TIC) && format == "1")
		{
			return value;
		}
		if (value != null && format == "1" && ComputeIsNumber(value) == FALSEVALUESTR)
		{
			return TIC + value + TIC;
		}
		if (format == "0" && value.StartsWith(TIC) && value.EndsWith(TIC))
		{
			return value.Replace(TIC, string.Empty);
		}
		return value;
	}

	public string ComputeToCol(string args)
	{
		string ignore;
		string scanByColumn;
		string range;
		string text = CheckingErrorStringsOfArgument(out ignore, out scanByColumn, out range, args);
		if (!string.IsNullOrEmpty(text))
		{
			return text;
		}
		string empty = string.Empty;
		bool isFormulaToRow = false;
		empty = ConvertValuesOfArray(range, ignore, scanByColumn, isFormulaToRow);
		if (computeFunctionLevel > 0)
		{
			return TIC + empty + TIC;
		}
		if (empty.Contains(";"))
		{
			return empty.Split(';')[0];
		}
		return empty;
	}

	private string CheckingErrorStringsOfArgument(out string ignore, out string scanByColumn, out string range, string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		ignore = string.Empty;
		scanByColumn = string.Empty;
		range = array[0];
		int num = array.Length;
		if (num > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!range.StartsWith(TIC) && !range.EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(range, FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(range, FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		if (num > 1)
		{
			empty = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
			ignore = GetValueFromArg(array[1]);
			if (ignore.ToUpper() == "TRUE")
			{
				ignore = "1";
			}
			if (ignore.ToUpper() == "FALSE")
			{
				ignore = "0";
			}
			if (double.TryParse(ignore.Replace(TIC, string.Empty), out var result) && (result > 3.0 || result < 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			if (ComputeIsText(ignore) == TRUEVALUESTR)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[5].ToString();
			}
			if (num > 2)
			{
				empty = FormulaErrorStringCheck(array[2], FormulaArgumentType.Text);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
				scanByColumn = GetValueFromArg(array[2]);
				if (scanByColumn == "0")
				{
					scanByColumn = "FALSE";
				}
				if (scanByColumn == "1")
				{
					scanByColumn = "TRUE";
				}
				if (scanByColumn.ToUpper() != TRUEVALUESTR && scanByColumn.ToUpper() != FALSEVALUESTR)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
					}
					return ErrorStrings[1].ToString();
				}
			}
		}
		return string.Empty;
	}

	private string ConvertValuesOfArray(string range, string ignore, string scanByColumn, bool isFormulaToRow)
	{
		SplitArgsPreservingQuotedCommas(range);
		string empty = string.Empty;
		List<string> values = new List<string>();
		if (IsRange(range))
		{
			string[] array = GetCellsFromArgs(range);
			if (scanByColumn == TRUEVALUESTR)
			{
				array = ReorderCellsColumnWise(array);
			}
			string[] array2 = array;
			foreach (string arg in array2)
			{
				empty = GetValueFromArg(arg).ToString();
				CheckConditionsForValue(empty, ignore, values);
			}
			if (isFormulaToRow)
			{
				return string.Join(parseArgumentSeparator.ToString(), values);
			}
			return string.Join(";", values);
		}
		if (range.Contains(parseArgumentSeparator.ToString()) && !range.Contains(";"))
		{
			string[] array2 = range.Replace(TIC, string.Empty).Split(parseArgumentSeparator);
			foreach (string cellValue in array2)
			{
				CheckConditionsForValue(cellValue, ignore, values);
			}
			if (isFormulaToRow)
			{
				return string.Join(parseArgumentSeparator.ToString(), values);
			}
			return string.Join(";", values);
		}
		if (range.Contains(";") && !range.Contains(parseArgumentSeparator.ToString()))
		{
			string[] array2 = range.Replace(TIC, string.Empty).Split(';');
			foreach (string cellValue2 in array2)
			{
				CheckConditionsForValue(cellValue2, ignore, values);
			}
			if (isFormulaToRow)
			{
				return string.Join(parseArgumentSeparator.ToString(), values);
			}
			return string.Join(";", values);
		}
		List<string> arrayValues = new List<string>();
		GetValuesOfArray(out var totalNumberOfColumns, out var totalNumberOfRows, out arrayValues, range);
		if (scanByColumn.ToUpper() == TRUEVALUESTR)
		{
			List<List<string>> list = ConvertToStructuredData(arrayValues, totalNumberOfColumns);
			for (int j = 0; j < totalNumberOfColumns; j++)
			{
				for (int k = 0; k < totalNumberOfRows; k++)
				{
					string cellValue3 = list[k][j].Replace(TIC, string.Empty);
					CheckConditionsForValue(cellValue3, ignore, values);
				}
			}
			if (isFormulaToRow)
			{
				return string.Join(parseArgumentSeparator.ToString(), values);
			}
			return string.Join(";", values);
		}
		foreach (string item in arrayValues)
		{
			CheckConditionsForValue(item.Replace(TIC, string.Empty), ignore, values);
		}
		if (isFormulaToRow)
		{
			return string.Join(parseArgumentSeparator.ToString(), values);
		}
		return string.Join(";", values);
	}

	private void CheckConditionsForValue(string cellValue, string ignore, List<string> values)
	{
		if (ignore.Equals(string.Empty) || ignore == "0")
		{
			if (cellValue.Equals(string.Empty))
			{
				values.Add("0");
			}
			if (cellValue != string.Empty)
			{
				values.Add(cellValue);
			}
		}
		if (ignore.Equals("1") && cellValue != string.Empty)
		{
			values.Add(cellValue);
		}
		if (ignore.Equals("2") && !ErrorStrings.Contains(cellValue))
		{
			values.Add(cellValue);
		}
		if (ignore.Equals("3") && cellValue != string.Empty && !ErrorStrings.Contains(cellValue))
		{
			values.Add(cellValue);
		}
	}

	private void GetValuesOfArray(out int totalNumberOfColumns, out int totalNumberOfRows, out List<string> arrayValues, string range)
	{
		arrayValues = new List<string>();
		if (IsRange(range))
		{
			string[] cellsFromArgs = GetCellsFromArgs(range);
			foreach (string arg in cellsFromArgs)
			{
				string valueFromArg = GetValueFromArg(arg);
				arrayValues.Add(valueFromArg.Equals(string.Empty) ? "0" : valueFromArg);
			}
			string[] array = range.Split(':');
			totalNumberOfRows = RowIndex(array[1]) - RowIndex(array[0]) + 1;
			totalNumberOfColumns = ColIndex(array[1]) - ColIndex(array[0]) + 1;
			return;
		}
		int num = 0;
		int num2 = 0;
		if (range.Contains(parseArgumentSeparator.ToString()) && range.Contains(";"))
		{
			string[] array2 = range.Split(';');
			for (int j = 0; j < array2.Length; j++)
			{
				string[] array3 = array2[j].Split(parseArgumentSeparator);
				for (int k = 0; k < array3.Length; k++)
				{
					arrayValues.Add(array3[k].Replace(TIC, string.Empty));
				}
			}
			num = array2[0].Split(parseArgumentSeparator).Length;
			num2 = array2.Length;
		}
		else if (range.Contains(";"))
		{
			string[] array4 = range.Split(';');
			for (int l = 0; l < array4.Length; l++)
			{
				arrayValues.Add(array4[l]);
			}
			num = array4.Length;
		}
		else if (range.Contains(parseArgumentSeparator.ToString()))
		{
			string[] array5 = range.Split(parseArgumentSeparator);
			for (int m = 0; m < array5.Length; m++)
			{
				arrayValues.Add(array5[m]);
			}
			num2 = array5.Length;
		}
		totalNumberOfColumns = num;
		totalNumberOfRows = num2;
	}

	public string ComputeToRow(string args)
	{
		string ignore;
		string scanByColumn;
		string range;
		string text = CheckingErrorStringsOfArgument(out ignore, out scanByColumn, out range, args);
		if (!string.IsNullOrEmpty(text))
		{
			return text;
		}
		string empty = string.Empty;
		bool isFormulaToRow = true;
		empty = ConvertValuesOfArray(range, ignore, scanByColumn, isFormulaToRow);
		if (computeFunctionLevel > 0)
		{
			return TIC + empty + TIC;
		}
		if (empty.Contains(parseArgumentSeparator.ToString()))
		{
			return empty.Split(parseArgumentSeparator)[0];
		}
		return empty;
	}

	public string ComputeChooseCols(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int num = array.Length;
		if (string.IsNullOrEmpty(args) || num < 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		for (int i = 1; i < num; i++)
		{
			if (!array[i].StartsWith(TIC) && !array[i].EndsWith(TIC))
			{
				empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
			}
			else
			{
				empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Text);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
			}
		}
		bool isFormulaChooseColumn = true;
		List<string> arrayValues = new List<string>();
		GetValuesOfArray(out var totalNumberOfColumns, out var totalNumberOfRows, out arrayValues, array[0]);
		int[] columnIndexes;
		string indexes = GetIndexes(array, totalNumberOfColumns, totalNumberOfRows, isFormulaChooseColumn, out columnIndexes);
		if (indexes != string.Empty)
		{
			return indexes;
		}
		for (int j = 0; j < columnIndexes.Length; j++)
		{
			if (columnIndexes[j] > totalNumberOfColumns)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		string text = ChooseValuesFromArray(array[0], columnIndexes, totalNumberOfColumns, totalNumberOfRows, arrayValues, isFormulaChooseColumn);
		if (computeFunctionLevel > 0)
		{
			return TIC + text + TIC;
		}
		string[] array2 = null;
		if (text.Contains(';') && !text.Contains(parseArgumentSeparator))
		{
			array2 = text.Split(';');
		}
		else if (text.Contains(parseArgumentSeparator) && !text.Contains(';'))
		{
			array2 = text.Split(parseArgumentSeparator);
		}
		else if (text.Contains(';') && text.Contains(parseArgumentSeparator))
		{
			array2 = text.Split(';');
			return array2[0].Split(parseArgumentSeparator)[0];
		}
		return array2[0];
	}

	private string GetIndexes(string[] args, int totalNumberOfColumns, int totalNumberOfRows, bool isFormulaChooseColumn, out int[] columnIndexes)
	{
		List<int> list = new List<int>();
		string empty = string.Empty;
		string[] array = null;
		columnIndexes = null;
		for (int i = 1; i < args.Length; i++)
		{
			if (args[i].IndexOf(':') > -1 && IsRange(args[i]))
			{
				string[] cellsFromArgs = GetCellsFromArgs(args[i]);
				foreach (string arg in cellsFromArgs)
				{
					empty = GetValueFromArg(arg);
					if (empty == "0")
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(ErrorStrings[1].ToString());
						}
						return ErrorStrings[1].ToString();
					}
					if (int.Parse(empty) > 0)
					{
						list.Add(int.Parse(empty) - 1);
					}
					else if (isFormulaChooseColumn)
					{
						list.Add(int.Parse(empty) + totalNumberOfColumns);
					}
					else
					{
						list.Add(int.Parse(empty) + totalNumberOfRows);
					}
				}
			}
			if (args[i].Contains(parseArgumentSeparator.ToString()) || (args[i].Contains(";") && !IsRange(args[i])))
			{
				array = ((!args[i].Contains(";")) ? args[i].Split(parseArgumentSeparator) : args[i].Split(';'));
				string[] cellsFromArgs = array;
				foreach (string text in cellsFromArgs)
				{
					empty = GetValueFromArg(text.Replace(TIC, string.Empty)).ToString();
					if (empty == "0")
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(ErrorStrings[1].ToString());
						}
						return ErrorStrings[1].ToString();
					}
					if (int.Parse(empty) > 0)
					{
						list.Add(int.Parse(empty) - 1);
					}
					else if (isFormulaChooseColumn)
					{
						list.Add(int.Parse(empty) + totalNumberOfColumns);
					}
					else
					{
						list.Add(int.Parse(empty) + totalNumberOfRows);
					}
				}
			}
			else
			{
				if (IsRange(args[i]))
				{
					continue;
				}
				empty = GetValueFromArg(args[i]);
				if (empty == "0")
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(ErrorStrings[1].ToString());
					}
					return ErrorStrings[1].ToString();
				}
				if (int.Parse(empty) > 0)
				{
					list.Add(int.Parse(empty) - 1);
				}
				else if (isFormulaChooseColumn)
				{
					list.Add(int.Parse(empty) + totalNumberOfColumns);
				}
				else
				{
					list.Add(int.Parse(empty) + totalNumberOfRows);
				}
			}
		}
		columnIndexes = list.ToArray();
		return string.Empty;
	}

	private string ChooseValuesFromArray(string range, int[] columnIndexes, int totalNumberOfColumns, int totalNumberOfRows, List<string> arrayValues, bool isFormulaChooseColumn)
	{
		List<List<string>> list = new List<List<string>>();
		List<string> list2 = new List<string>();
		if (isFormulaChooseColumn)
		{
			list = ConvertToStructuredDataByColumns(arrayValues, totalNumberOfColumns);
			for (int i = 0; i < columnIndexes.Length; i++)
			{
				for (int j = 0; j < totalNumberOfColumns; j++)
				{
					if (columnIndexes[i] == j)
					{
						list2.AddRange(list[j]);
					}
				}
			}
			list = ConvertToStructuredDataByColumns(list2, totalNumberOfRows);
		}
		else
		{
			list = ConvertToStructuredData(arrayValues, totalNumberOfColumns);
			for (int k = 0; k < columnIndexes.Length; k++)
			{
				for (int l = 0; l < totalNumberOfRows; l++)
				{
					if (columnIndexes[k] == l)
					{
						list2.AddRange(list[l]);
					}
				}
			}
			list = ConvertToStructuredData(list2, totalNumberOfColumns);
		}
		return string.Join(";", list.Select((List<string> row) => string.Join(parseArgumentSeparator.ToString(), row)));
	}

	public string ComputeChooseRows(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int num = array.Length;
		if (string.IsNullOrEmpty(args) || num < 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		for (int i = 1; i < num; i++)
		{
			if (!array[i].StartsWith(TIC) && !array[i].EndsWith(TIC))
			{
				empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Range);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
			}
			else
			{
				empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Text);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
			}
		}
		bool isFormulaChooseColumn = false;
		List<string> arrayValues = new List<string>();
		GetValuesOfArray(out var totalNumberOfColumns, out var totalNumberOfRows, out arrayValues, array[0]);
		int[] columnIndexes;
		string indexes = GetIndexes(array, totalNumberOfColumns, totalNumberOfRows, isFormulaChooseColumn, out columnIndexes);
		if (indexes != string.Empty)
		{
			return indexes;
		}
		for (int j = 0; j < columnIndexes.Length; j++)
		{
			if (columnIndexes[j] > totalNumberOfRows)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(ErrorStrings[1].ToString());
				}
				return ErrorStrings[1].ToString();
			}
		}
		string text = ChooseValuesFromArray(array[0], columnIndexes, totalNumberOfColumns, totalNumberOfRows, arrayValues, isFormulaChooseColumn);
		if (computeFunctionLevel > 0)
		{
			return TIC + text + TIC;
		}
		string[] array2 = null;
		if (text.Contains(';') && !text.Contains(parseArgumentSeparator))
		{
			array2 = text.Split(';');
		}
		else if (text.Contains(parseArgumentSeparator) && !text.Contains(';'))
		{
			array2 = text.Split(parseArgumentSeparator);
		}
		else if (text.Contains(';') && text.Contains(parseArgumentSeparator))
		{
			array2 = text.Split(';');
			return array2[0].Split(parseArgumentSeparator)[0];
		}
		return array2[0];
	}

	private List<List<string>> ConvertToStructuredDataByColumns(List<string> cellData, int numberOfColumns)
	{
		List<List<string>> list = new List<List<string>>();
		for (int i = 0; i < numberOfColumns; i++)
		{
			list.Add(new List<string>());
		}
		int num = cellData.Count / numberOfColumns;
		for (int j = 0; j < num; j++)
		{
			for (int k = 0; k < numberOfColumns; k++)
			{
				int index = j * numberOfColumns + k;
				list[k].Add(cellData[index]);
			}
		}
		return list;
	}

	public string ComputeSequence(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 4 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string text = FormulaErrorStringCheck(array[0], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(array[0].ToString());
		for (int i = 0; i < length; i++)
		{
			if (array[i].IndexOf(':') > -1)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[7].ToString();
			}
		}
		string text2;
		if (length > 1 && array[1].ToString() != string.Empty)
		{
			text2 = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text2))
			{
				return text2;
			}
			text2 = GetValueFromArg(array[1].ToString());
		}
		else
		{
			text2 = "1";
		}
		string text3;
		if (length > 2 && array[2].ToString() != string.Empty)
		{
			text3 = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text3))
			{
				return text3;
			}
			text3 = GetValueFromArg(array[2].ToString());
		}
		else
		{
			text3 = "1";
		}
		string s;
		if (length > 3 && array[3].ToString() != string.Empty)
		{
			string text4 = FormulaErrorStringCheck(array[3], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(text4))
			{
				return text4;
			}
			s = GetValueFromArg(array[3].ToString());
		}
		else
		{
			s = "1";
		}
		int result = (int.TryParse(text, out result) ? result : 0);
		int result2 = (int.TryParse(text2, out result2) ? result2 : 0);
		int result3 = (int.TryParse(text3, out result3) ? result3 : 0);
		int result4 = (int.TryParse(s, out result4) ? result4 : 0);
		int[,] array2 = CreateSequence(result, result2, result3, result4);
		if (computeFunctionLevel > 0)
		{
			string empty = string.Empty;
			string text5 = string.Empty;
			int num = 0;
			int[,] array3 = array2;
			int upperBound = array3.GetUpperBound(0);
			int upperBound2 = array3.GetUpperBound(1);
			for (int j = array3.GetLowerBound(0); j <= upperBound; j++)
			{
				for (int k = array3.GetLowerBound(1); k <= upperBound2; k++)
				{
					int num2 = array3[j, k];
					num++;
					empty = num2.ToString();
					if (num % result2 == 0 && num != array2.Length)
					{
						empty += ";";
					}
					else if (num != array2.Length)
					{
						empty += parseArgumentSeparator;
					}
					text5 += empty;
				}
			}
			if (!text5.StartsWith(TIC) && !text5.EndsWith(TIC))
			{
				text5 = TIC + text5 + TIC;
			}
			return text5;
		}
		if (string.IsNullOrEmpty(cell))
		{
			return array2[0, 0].ToString();
		}
		int num3 = ColIndex(cell);
		int num4 = RowIndex(cell);
		GetFormulaArrayBounds(cell, result, result2, out var firstRowIndex, out var firstColIndex, out var _, out var _);
		int num5 = num4 - firstRowIndex;
		int num6 = num3 - firstColIndex;
		int num7 = array2[num5, num6];
		return num7.ToString();
	}

	private int[,] CreateSequence(int rows, int columns, int start, int step)
	{
		int[,] array = new int[rows, columns];
		int num = start;
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < columns; j++)
			{
				array[i, j] = num;
				num += step;
			}
		}
		return array;
	}

	public string ComputeTextSplit(string args)
	{
		string[] array = null;
		array = ((!args.Contains(TIC + TIC)) ? SplitArgsPreservingQuotedCommas(args) : ComputeDelimiters(args));
		int length = array.GetLength(0);
		if (length < 2 || length > 5 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		for (int i = 0; i < 2; i++)
		{
			string text = FormulaErrorStringCheck(array[i], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(text))
			{
				return text;
			}
		}
		string valueFromArg = GetValueFromArg(array[0]);
		string valueFromArg2 = GetValueFromArg(array[1]);
		string text2 = string.Empty;
		string empty = string.Empty;
		string empty2 = string.Empty;
		string empty3 = string.Empty;
		if (length > 2)
		{
			text2 = ValidateArgumentType(array[2], FormulaArgumentType.Text);
			if (!ErrorStrings.Contains(text2))
			{
				text2 = GetValueFromArg(text2);
			}
			if (length > 3 && array[3] != string.Empty)
			{
				empty = ValidateArgumentType(array[3], FormulaArgumentType.TextWithNumber);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
				empty = GetValueFromArg(empty);
			}
			else
			{
				empty = FALSEVALUESTR;
			}
			if (length > 4 && array[4] != string.Empty)
			{
				empty2 = ValidateArgumentType(array[4], FormulaArgumentType.TextWithNumber);
				if (ErrorStrings.Contains(empty2))
				{
					return empty2;
				}
				empty2 = GetValueFromArg(empty2);
			}
			else
			{
				empty2 = "0";
			}
			if (length > 5 && array[5] != string.Empty)
			{
				empty3 = ValidateArgumentType(array[5], FormulaArgumentType.Text);
				if (ErrorStrings.Contains(empty3) && !empty3.Contains(ErrorStrings[0].ToString()))
				{
					return empty3;
				}
				empty3 = GetValueFromArg(empty3);
			}
			else
			{
				empty3 = ErrorStrings[0].ToString();
			}
		}
		else
		{
			empty = FALSEVALUESTR;
			empty2 = "0";
			empty3 = ErrorStrings[0].ToString();
		}
		string[] columns = null;
		List<List<string>> result = new List<List<string>>();
		int maxCol = 0;
		if (text2 != string.Empty)
		{
			SplitText(valueFromArg, text2, valueFromArg2, empty, empty2, columns, ref maxCol, ref result);
		}
		else
		{
			ComputeColumnsDelimiter(valueFromArg, valueFromArg2, empty, empty2, columns, ref maxCol, ref result);
		}
		if (!string.IsNullOrEmpty(empty3))
		{
			for (int j = 0; j < result.Count; j++)
			{
				for (int k = 0; k < result[j].Count; k++)
				{
					while (result[j].Count < maxCol)
					{
						result[j].Add(empty3);
					}
				}
			}
		}
		if (computeFunctionLevel > 0)
		{
			string text3 = string.Empty;
			for (int l = 0; l < result.Count; l++)
			{
				for (int m = 0; m < result[l].Count; m++)
				{
					text3 = text3 + TIC + result[l][m] + TIC + parseArgumentSeparator;
				}
				text3 = text3.Remove(text3.Length - 1);
				text3 += ";";
			}
			return TIC + text3.Remove(text3.Length - 1) + TIC;
		}
		string text4 = result[0][0].ToString();
		if (text4.EndsWith(" "))
		{
			return text4.Remove(text4.Length - 1);
		}
		return text4;
	}

	private string[] ComputeDelimiters(string args)
	{
		string text = TIC + TIC + parseArgumentSeparator;
		string text2 = parseArgumentSeparator + TIC + TIC;
		string text3 = TIC + parseArgumentSeparator + TIC;
		List<string> list = new List<string>();
		string[] array = args.Split(new string[1] { text }, StringSplitOptions.RemoveEmptyEntries);
		if (array[0].Contains(text2))
		{
			list = array[0].Split(new string[1] { text2 }, StringSplitOptions.RemoveEmptyEntries).ToList();
			list[1] = TIC + TIC + list[1] + TIC + TIC;
		}
		else if (array[0].Contains(parseArgumentSeparator.ToString()))
		{
			list = array[0].Split(new string[1] { parseArgumentSeparator.ToString() }, StringSplitOptions.RemoveEmptyEntries).ToList();
		}
		else
		{
			list.Add(array[0]);
		}
		for (int i = 1; i < array.Length; i++)
		{
			if (i == array.Length - 1 && array[i].Contains(parseArgumentSeparator.ToString()))
			{
				List<string> list2 = null;
				if (array[i].StartsWith(text3))
				{
					string item = array[i].Substring(0, text3.Length);
					string text4 = array[i].Substring(text3.Length + 1);
					list.Add(item);
					list2 = text4.Split(new string[1] { parseArgumentSeparator.ToString() }, StringSplitOptions.None).ToList();
				}
				else
				{
					list2 = array[i].Split(new string[1] { parseArgumentSeparator.ToString() }, StringSplitOptions.None).ToList();
				}
				foreach (string item2 in list2)
				{
					list.Add(item2);
				}
			}
			else if (array.Length > 1)
			{
				list.Add(text + array[i] + TIC + TIC);
			}
			else
			{
				list.Add(array[i]);
			}
		}
		return list.ToArray();
	}

	private void SplitText(string text, string rowDelimiter, string colDelimiter, string ignoreEmpty, string match_mode, string[] columns, ref int maxCol, ref List<List<string>> result)
	{
		string[] array = null;
		if (rowDelimiter.Replace(TIC, string.Empty).Length > 1)
		{
			string[] array2 = SplitArgsPreservingQuotedCommas(rowDelimiter.Substring(1, rowDelimiter.Length - 2));
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = array2[i].Replace(TIC, string.Empty);
			}
			if (match_mode == "1")
			{
				string pattern = string.Join("|", array2.Select(Regex.Escape));
				array = Regex.Split(text, pattern, RegexOptions.IgnoreCase);
			}
			else
			{
				array = text.Split(array2, StringSplitOptions.None);
			}
		}
		else
		{
			rowDelimiter = rowDelimiter.Replace(TIC, string.Empty);
			array = ((!(match_mode == "1")) ? text.Split(new string[1] { rowDelimiter }, StringSplitOptions.None) : Regex.Split(text, Regex.Escape(rowDelimiter), RegexOptions.IgnoreCase));
		}
		string[] array3 = array;
		foreach (string text2 in array3)
		{
			ComputeColumnsDelimiter(text2, colDelimiter, ignoreEmpty, match_mode, columns, ref maxCol, ref result);
		}
	}

	private void ComputeColumnsDelimiter(string text, string colDelimiter, string ignoreEmpty, string match_mode, string[] columns, ref int maxCol, ref List<List<string>> result)
	{
		if (colDelimiter.Replace(TIC, string.Empty).Length > 1)
		{
			string[] array = SplitArgsPreservingQuotedCommas(colDelimiter.Substring(1, colDelimiter.Length - 2));
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = array[i].Replace(TIC, string.Empty);
			}
			if (match_mode == "1")
			{
				string pattern = string.Join("|", array.Select(Regex.Escape));
				columns = Regex.Split(text, pattern, RegexOptions.IgnoreCase);
			}
			else
			{
				columns = text.Split(array, StringSplitOptions.None);
			}
		}
		else
		{
			colDelimiter = colDelimiter.Replace(TIC, string.Empty);
			columns = ((!(match_mode == "1")) ? text.Split(new string[1] { colDelimiter }, StringSplitOptions.None) : Regex.Split(text, Regex.Escape(colDelimiter), RegexOptions.IgnoreCase));
		}
		if (ignoreEmpty == TRUEVALUESTR)
		{
			columns = columns.Where((string c) => !string.IsNullOrEmpty(c)).ToArray();
		}
		if (columns.Length > maxCol)
		{
			maxCol = columns.Length;
		}
		result.Add(columns.ToList());
	}

	public string ComputeTake(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length < 2 || length > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		string text = string.Empty;
		string text2 = string.Empty;
		for (int i = 1; i < array.Length; i++)
		{
			empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		if (length == 2)
		{
			text = GetValueFromArg(array[1]);
			if (text.ToUpper() == TRUEVALUESTR)
			{
				text = "1";
			}
			else if (text.ToUpper() == FALSEVALUESTR)
			{
				text = "0";
			}
			if (double.TryParse(text.Replace(TIC, string.Empty), out var result) && result == 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[7].ToString();
			}
		}
		if (length == 3)
		{
			text = GetValueFromArg(array[1]);
			text2 = GetValueFromArg(array[2]);
			if (text.ToUpper() == TRUEVALUESTR)
			{
				text = "1";
			}
			else if (text.ToUpper() == FALSEVALUESTR)
			{
				text = "0";
			}
			if (text2.ToUpper() == TRUEVALUESTR)
			{
				text2 = "1";
			}
			else if (text2.ToUpper() == FALSEVALUESTR)
			{
				text2 = "0";
			}
			if (double.TryParse(text2.Replace(TIC, string.Empty), out var result2) && result2 == 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[7].ToString();
			}
			if (double.TryParse(text.Replace(TIC, string.Empty), out var result3) && result3 == 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[7].ToString();
			}
		}
		string text3 = RetrieveValuesFromRange(array[0], text, text2, array);
		if (computeFunctionLevel > 0)
		{
			return TIC + text3 + TIC;
		}
		string[] array2 = null;
		text3 = text3.Replace(TIC, string.Empty);
		if (text3.Contains(';') && !text3.Contains(parseArgumentSeparator))
		{
			array2 = text3.Split(';');
		}
		else
		{
			if (!text3.Contains(parseArgumentSeparator) || text3.Contains(';'))
			{
				if (text3.Contains(';') && text3.Contains(parseArgumentSeparator))
				{
					array2 = text3.Split(';');
					return array2[0].Split(parseArgumentSeparator)[0];
				}
				return text3;
			}
			array2 = text3.Split(parseArgumentSeparator);
		}
		return array2[0];
	}

	private string RetrieveValuesFromRange(string range, string rows, string columns, string[] args)
	{
		List<string> arrayValues = new List<string>();
		int totalNumberOfColumns = 0;
		int totalNumberOfRows = 0;
		GetValuesOfArray(out totalNumberOfColumns, out totalNumberOfRows, out arrayValues, range);
		int num = ((!string.IsNullOrEmpty(rows)) ? int.Parse(rows) : 0);
		int num2 = ((!string.IsNullOrEmpty(columns)) ? int.Parse(columns) : 0);
		List<List<string>> list = ConvertToStructuredData(arrayValues, totalNumberOfColumns);
		List<string> list2 = new List<string>();
		new List<string>();
		if (rows != string.Empty && columns == string.Empty)
		{
			if ((num < 0 && Math.Abs(num) >= totalNumberOfRows) || num >= totalNumberOfRows)
			{
				return string.Join(";", list.Select((List<string> row) => string.Join(parseArgumentSeparator.ToString(), row)));
			}
			int num3 = ((num < 0) ? (totalNumberOfRows + num) : 0);
			int num4 = ((num < 0) ? totalNumberOfRows : num);
			for (int i = num3; i < num4; i++)
			{
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list[i]));
			}
		}
		else if (rows == string.Empty && columns != string.Empty)
		{
			if ((num2 < 0 && Math.Abs(num2) >= totalNumberOfColumns) || num2 >= totalNumberOfColumns)
			{
				return string.Join(";", list.Select((List<string> row) => string.Join(parseArgumentSeparator.ToString(), row)));
			}
			for (int j = 0; j < totalNumberOfRows; j++)
			{
				List<string> list3 = new List<string>();
				int num5 = ((num2 < 0) ? (totalNumberOfColumns + num2) : 0);
				int num6 = ((num2 < 0) ? totalNumberOfColumns : num2);
				for (int k = num5; k < num6; k++)
				{
					list3.Add(list[j][k]);
				}
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list3));
			}
		}
		else if (rows != string.Empty && columns != string.Empty)
		{
			if (num > 0 && num2 < 0)
			{
				int num7 = ((Math.Abs(num2) <= totalNumberOfColumns) ? (totalNumberOfColumns + num2) : 0);
				if (num > totalNumberOfRows)
				{
					num = totalNumberOfRows;
				}
				for (int l = 0; l < num; l++)
				{
					List<string> list4 = new List<string>();
					for (int m = num7; m < totalNumberOfColumns; m++)
					{
						list4.Add(list[l][m]);
					}
					list2.Add(string.Join(parseArgumentSeparator.ToString(), list4));
				}
			}
			else if (num2 > 0 && num < 0)
			{
				int num8 = ((Math.Abs(num) <= totalNumberOfRows) ? (totalNumberOfRows + num) : 0);
				if (num2 > totalNumberOfColumns)
				{
					num2 = totalNumberOfColumns;
				}
				int num9 = Math.Min(num2, list[0].Count);
				for (int n = num8; n < totalNumberOfRows; n++)
				{
					List<string> list5 = new List<string>();
					for (int num10 = 0; num10 < num9; num10++)
					{
						list5.Add(list[n][num10]);
					}
					list2.Add(string.Join(parseArgumentSeparator.ToString(), list5));
				}
			}
			else if (num2 > 0 && num > 0)
			{
				if (num > totalNumberOfRows)
				{
					num = totalNumberOfRows;
				}
				if (num2 > totalNumberOfColumns)
				{
					num2 = totalNumberOfColumns;
				}
				for (int num11 = 0; num11 < num; num11++)
				{
					List<string> list6 = new List<string>();
					for (int num12 = 0; num12 < num2; num12++)
					{
						list6.Add(list[num11][num12]);
					}
					list2.Add(string.Join(parseArgumentSeparator.ToString(), list6));
				}
			}
			else if (num2 < 0 && num < 0)
			{
				int num13 = ((Math.Abs(num) <= totalNumberOfRows) ? (totalNumberOfRows + num) : 0);
				int num14 = ((Math.Abs(num2) <= totalNumberOfColumns) ? (totalNumberOfColumns + num2) : 0);
				for (int num15 = num13; num15 < totalNumberOfRows; num15++)
				{
					List<string> list7 = new List<string>();
					for (int num16 = num14; num16 < totalNumberOfColumns; num16++)
					{
						list7.Add(list[num15][num16]);
					}
					list2.Add(string.Join(parseArgumentSeparator.ToString(), list7));
				}
			}
		}
		return string.Join(";", list2);
	}

	public string ComputeDrop(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length < 2 || length > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		string empty2 = string.Empty;
		string text = string.Empty;
		List<string> arrayValues = new List<string>();
		GetValuesOfArray(out var totalNumberOfColumns, out var totalNumberOfRows, out arrayValues, array[0]);
		for (int i = 1; i < array.Length; i++)
		{
			empty = FormulaErrorStringCheck(array[i], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		empty2 = GetValueFromArg(array[1]);
		if (empty2.ToUpper() == TRUEVALUESTR)
		{
			empty2 = "1";
		}
		else if (empty2.ToUpper() == FALSEVALUESTR)
		{
			empty2 = "0";
		}
		if (length == 2 && double.TryParse(empty2.Replace(TIC, string.Empty), out var result) && Math.Abs(result) >= (double)totalNumberOfRows)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
			}
			return ErrorStrings[7].ToString();
		}
		if (length == 3)
		{
			text = GetValueFromArg(array[2]);
			if (text.ToUpper() == TRUEVALUESTR)
			{
				text = "1";
			}
			else if (text.ToUpper() == FALSEVALUESTR)
			{
				text = "0";
			}
			if ((double.TryParse(text.Replace(TIC, string.Empty), out var result2) && Math.Abs(result2) >= (double)totalNumberOfColumns) || (double.TryParse(empty2.Replace(TIC, string.Empty), out var result3) && Math.Abs(result3) >= (double)totalNumberOfRows))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[7].ToString();
			}
		}
		string empty3 = string.Empty;
		empty3 = DropValuesFromArray(array[0], empty2, text, totalNumberOfRows, totalNumberOfColumns, arrayValues);
		if (computeFunctionLevel > 0)
		{
			return TIC + empty3 + TIC;
		}
		string[] array2 = null;
		empty3 = empty3.Replace(TIC, string.Empty);
		if (empty3.Contains(';') && !empty3.Contains(parseArgumentSeparator))
		{
			array2 = empty3.Split(';');
		}
		else
		{
			if (!empty3.Contains(parseArgumentSeparator) || empty3.Contains(';'))
			{
				if (empty3.Contains(';') && empty3.Contains(parseArgumentSeparator))
				{
					array2 = empty3.Split(';');
					return array2[0].Split(parseArgumentSeparator)[0];
				}
				return empty3;
			}
			array2 = empty3.Split(parseArgumentSeparator);
		}
		return array2[0];
	}

	private string DropValuesFromArray(string range, string rows, string columns, int totalNumberOfRows, int totalNumberOfColumns, List<string> arrayValues)
	{
		int num = ((!string.IsNullOrEmpty(rows)) ? int.Parse(rows) : 0);
		int num2 = ((!string.IsNullOrEmpty(columns)) ? int.Parse(columns) : 0);
		List<List<string>> list = ConvertToStructuredData(arrayValues, totalNumberOfColumns);
		List<string> list2 = new List<string>();
		if (rows != string.Empty && columns == string.Empty)
		{
			int num3 = ((num > 0) ? num : 0);
			int num4 = ((num > 0) ? totalNumberOfRows : (totalNumberOfRows + num));
			for (int i = num3; i < num4; i++)
			{
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list[i]));
			}
			return string.Join(";", list2);
		}
		if (rows == string.Empty && columns != string.Empty)
		{
			for (int j = 0; j < totalNumberOfRows; j++)
			{
				List<string> list3 = new List<string>();
				if (num2 <= 0)
				{
					for (int k = 0; k < totalNumberOfColumns + num2; k++)
					{
						list3.Add(list[j][k]);
					}
				}
				else
				{
					for (int l = num2; l < totalNumberOfColumns; l++)
					{
						list3.Add(list[j][l]);
					}
				}
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list3));
			}
			return string.Join(";", list2);
		}
		if (rows != string.Empty && columns != string.Empty)
		{
			int num5 = ((num >= 0) ? num : 0);
			int num6 = ((num >= 0) ? totalNumberOfRows : (totalNumberOfRows + num));
			int num7 = ((num2 >= 0) ? num2 : 0);
			int num8 = ((num2 >= 0) ? totalNumberOfColumns : (totalNumberOfColumns + num2));
			for (int m = num5; m < num6; m++)
			{
				List<string> list4 = new List<string>();
				for (int n = num7; n < num8; n++)
				{
					list4.Add(list[m][n]);
				}
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list4));
			}
		}
		return string.Join(";", list2);
	}

	public string ComputeExpand(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int length = array.GetLength(0);
		if (length > 4 || length < 2 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		empty = ((array[0].StartsWith(TIC) || array[0].EndsWith(TIC)) ? FormulaErrorStringCheck(array[0], FormulaArgumentType.Text) : FormulaErrorStringCheck(array[0], FormulaArgumentType.Range));
		if (ErrorStrings.Contains(empty))
		{
			return empty;
		}
		empty = array[0];
		string text = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
		if (ErrorStrings.Contains(text))
		{
			return text;
		}
		text = GetValueFromArg(array[1]);
		string cols = string.Empty;
		if (length > 2)
		{
			cols = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(cols))
			{
				return cols;
			}
			cols = GetValueFromArg(array[2]);
		}
		string empty2 = string.Empty;
		if (length > 3)
		{
			empty2 = FormulaErrorStringCheck(array[3], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty2))
			{
				return empty2;
			}
			empty2 = GetValueFromArg(array[3]).Replace(TIC, string.Empty);
		}
		else
		{
			empty2 = ErrorStrings[0].ToString();
		}
		return ExpandedArray(empty, text, cols, empty2);
	}

	private string ExpandedArray(string array, string rows, string cols, string padWith)
	{
		string[] array2 = null;
		int num = 0;
		int num2 = 0;
		string[,] array3 = null;
		if (array.IndexOf(":") > -1)
		{
			int num3 = 0;
			int num4 = array.IndexOf(':');
			int num5 = RowIndex(array.Substring(0, num4));
			int num6 = RowIndex(array.Substring(num4 + 1));
			int num7 = ColIndex(array.Substring(0, num4));
			int num8 = ColIndex(array.Substring(num4 + 1));
			num = num6 - num5 + 1;
			num2 = num8 - num7 + 1;
			array3 = new string[num, num2];
			array2 = GetCellsFromArgs(array);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num2; j++)
				{
					array3[i, j] = GetValueFromArg(array2[num3]);
					num3++;
				}
			}
		}
		else if (array.StartsWith(TIC) && array.EndsWith(TIC))
		{
			array2 = (array.Contains(";") ? SplitArguments(array.Replace(TIC, ""), ';') : new string[1] { array });
			num = (num2 = SplitArgsPreservingQuotedCommas(array2[0]).Length);
			array3 = new string[num, num2];
			for (int k = 0; k < array2.Length; k++)
			{
				string[] array4 = SplitArgsPreservingQuotedCommas(array2[k]);
				for (int l = 0; l < num; l++)
				{
					array3[k, l] = GetValueFromArg(array4[l]);
				}
			}
		}
		else if (IsCellReference(array))
		{
			array3 = new string[1, 1] { { GetValueFromArg(array) } };
		}
		int num9 = ((!(rows == string.Empty)) ? int.Parse(rows) : (num9 = num));
		int num10 = ((!(cols == string.Empty)) ? int.Parse(cols) : (num10 = num2));
		num9 = ((num9 == 0) ? 1 : num9);
		num10 = ((num10 == 0) ? 1 : num10);
		if (num9 < num || num10 < num2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_Math_argument]);
			}
			return ErrorStrings[1].ToString();
		}
		string[,] array5 = new string[num9, num10];
		for (int m = 0; m < num9; m++)
		{
			for (int n = 0; n < num10; n++)
			{
				if (m < num && n < num2)
				{
					array5[m, n] = array3[m, n];
				}
				else
				{
					array5[m, n] = padWith;
				}
			}
		}
		if (computeFunctionLevel > 0)
		{
			string text = string.Empty;
			for (int num11 = 0; num11 < num9; num11++)
			{
				for (int num12 = 0; num12 < num10; num12++)
				{
					text = text + array5[num11, num12].ToString() + parseArgumentSeparator;
				}
				text = text.Remove(text.Length - 1) + ";";
			}
			text = text.Remove(text.Length - 1);
			if (!text.StartsWith(TIC) && !text.EndsWith(TIC))
			{
				text = TIC + text + TIC;
			}
			return text;
		}
		return array5[0, 0].ToString();
	}

	public string ComputeWrapRows(string args)
	{
		bool isFormulaWrapRows = true;
		string vector;
		string wrapCount;
		string padWith;
		string text = ArgumentErrorCheck(args, out vector, out wrapCount, out padWith);
		if (text != string.Empty)
		{
			return text;
		}
		string text2 = WrapValuesOfArray(vector, wrapCount, padWith, isFormulaWrapRows);
		if (computeFunctionLevel > 0)
		{
			return TIC + text2 + TIC;
		}
		string[] array = null;
		if (text2.Contains(";") && !text2.Contains(parseArgumentSeparator.ToString()))
		{
			array = text2.Split(';');
		}
		else
		{
			if (!text2.Contains(parseArgumentSeparator.ToString()) || text2.Contains(";"))
			{
				if (text2.Contains(";") && text2.Contains(parseArgumentSeparator.ToString()))
				{
					array = text2.Split(';');
					return array[0].Split(parseArgumentSeparator)[0];
				}
				return text2;
			}
			array = text2.Split(parseArgumentSeparator);
		}
		return array[0];
	}

	private string WrapValuesOfArray(string vector, string wrapCount, string padWith, bool isFormulaWrapRows)
	{
		int num = int.Parse(wrapCount);
		GetValuesOfArray(out var totalNumberOfColumns, out var _, out var arrayValues, vector.Replace(TIC, string.Empty));
		List<List<string>> list = new List<List<string>>();
		list = ConvertToStructuredData(arrayValues, num);
		foreach (List<string> item in list)
		{
			while (item.Count < num)
			{
				item.Add(padWith.Replace(TIC, string.Empty));
			}
		}
		string empty = string.Empty;
		if (!isFormulaWrapRows)
		{
			totalNumberOfColumns = (arrayValues.Count + num - 1) / num;
			List<string> list2 = new List<string>();
			for (int i = 0; i < num; i++)
			{
				List<string> list3 = new List<string>();
				for (int j = 0; j < totalNumberOfColumns; j++)
				{
					list3.Add(list[j][i]);
				}
				list2.Add(string.Join(parseArgumentSeparator.ToString(), list3));
			}
			return string.Join(";", list2);
		}
		return string.Join(";", list.Select((List<string> row) => string.Join(parseArgumentSeparator.ToString(), row)));
	}

	public string ComputeWrapCols(string args)
	{
		bool isFormulaWrapRows = false;
		string vector;
		string wrapCount;
		string padWith;
		string text = ArgumentErrorCheck(args, out vector, out wrapCount, out padWith);
		if (text != string.Empty)
		{
			return text;
		}
		string text2 = WrapValuesOfArray(vector, wrapCount, padWith, isFormulaWrapRows);
		if (computeFunctionLevel > 0)
		{
			return TIC + text2 + TIC;
		}
		string[] array = null;
		if (text2.Contains(";") && !text2.Contains(parseArgumentSeparator.ToString()))
		{
			array = text2.Split(';');
		}
		else
		{
			if (!text2.Contains(parseArgumentSeparator.ToString()) || text2.Contains(";"))
			{
				if (text2.Contains(";") && text2.Contains(parseArgumentSeparator.ToString()))
				{
					array = text2.Split(';');
					return array[0].Split(parseArgumentSeparator)[0];
				}
				return text2;
			}
			array = text2.Split(parseArgumentSeparator);
		}
		return array[0];
	}

	private string ArgumentErrorCheck(string args, out string vector, out string wrapCount, out string padWith)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int num = array.Length;
		vector = array[0];
		wrapCount = string.Empty;
		padWith = string.Empty;
		if (num > 3 || string.IsNullOrEmpty(args))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0], FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		if (IsRange(array[0]))
		{
			string[] array2 = array[0].Split(':');
			if (ColIndex(array2[0]) != ColIndex(array2[1]))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
				}
				return ErrorStrings[1].ToString();
			}
		}
		else if (array[0].Contains(";") && array[0].Contains(parseArgumentSeparator.ToString()))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return ErrorStrings[1].ToString();
		}
		if (num > 1)
		{
			empty = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
			wrapCount = GetValueFromArg(array[1]);
			if (wrapCount.ToUpper() == TRUEVALUESTR)
			{
				wrapCount = "1";
			}
			else if (wrapCount.ToUpper() == FALSEVALUESTR)
			{
				wrapCount = "0";
			}
			if (double.TryParse(wrapCount.Replace(TIC, string.Empty), out var result) && result <= 0.0)
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[4].ToString();
			}
			if (num > 2)
			{
				padWith = array[2];
				if (ErrorStrings.Contains(padWith))
				{
					padWith = padWith;
				}
				else
				{
					empty = FormulaErrorStringCheck(padWith, FormulaArgumentType.Text);
					if (ErrorStrings.Contains(empty))
					{
						return empty;
					}
				}
				if (padWith.Equals(string.Empty))
				{
					padWith = ErrorStrings[0].ToString();
				}
			}
		}
		return string.Empty;
	}

	public string ComputeSort(string args)
	{
		string[] array = SplitArgsPreservingQuotedCommas(args);
		int num = array.Length;
		if (string.IsNullOrEmpty(args) || num > 4)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string empty = string.Empty;
		if (!array[0].StartsWith(TIC) && !array[0].EndsWith(TIC))
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Range);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		else
		{
			empty = FormulaErrorStringCheck(array[0].ToString(), FormulaArgumentType.Text);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
		}
		string empty2 = string.Empty;
		string empty3 = string.Empty;
		string empty4 = string.Empty;
		int num2 = 0;
		string[] array2 = null;
		List<string> list = new List<string>();
		if (IsRange(array[0]))
		{
			string[] cellsFromArgs = GetCellsFromArgs(array[0]);
			foreach (string arg in cellsFromArgs)
			{
				string valueFromArg = GetValueFromArg(arg);
				list.Add(valueFromArg);
			}
			array2 = array[0].Split(':');
			num2 = ColIndex(array2[1]);
		}
		else
		{
			array2 = array[0].Split(';');
			for (int j = 0; j < array2.Length; j++)
			{
				string[] array3 = array2[j].Split(parseArgumentSeparator);
				for (int k = 0; k < array3.Length; k++)
				{
					list.Add(array3[k].Replace(TIC, string.Empty));
				}
			}
			num2 = array2[0].Split(parseArgumentSeparator).Length;
		}
		if (num > 1)
		{
			empty = FormulaErrorStringCheck(array[1], FormulaArgumentType.Numbers);
			if (ErrorStrings.Contains(empty))
			{
				return empty;
			}
			empty2 = GetValueFromArg(array[1]);
			if (empty2.ToUpper() == TRUEVALUESTR)
			{
				empty2 = "1";
			}
			if (double.TryParse(empty2.Replace(TIC, string.Empty), out var result) && (result > (double)num2 || result < 0.0))
			{
				if (RethrowLibraryComputationExceptions)
				{
					throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
				}
				return ErrorStrings[1].ToString();
			}
			if (num > 2)
			{
				empty = FormulaErrorStringCheck(array[2], FormulaArgumentType.Numbers);
				if (ErrorStrings.Contains(empty))
				{
					return empty;
				}
				empty3 = GetValueFromArg(array[2]);
				if (empty3.ToUpper() == TRUEVALUESTR)
				{
					empty3 = "1";
				}
				if (double.TryParse(empty3.Replace(TIC, string.Empty), out var result2) && result2 != 1.0 && result2 != -1.0)
				{
					if (RethrowLibraryComputationExceptions)
					{
						throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
					}
					return ErrorStrings[1].ToString();
				}
				if (num > 3)
				{
					empty = FormulaErrorStringCheck(array[3], FormulaArgumentType.Text);
					if (ErrorStrings.Contains(empty))
					{
						return empty;
					}
					empty4 = GetValueFromArg(array[3]);
					if (empty4 == "1")
					{
						empty4 = TRUEVALUESTR;
					}
					if (empty4 == "0")
					{
						empty4 = FALSEVALUESTR;
					}
					if (empty4.ToUpper() != TRUEVALUESTR && empty4.ToUpper() != FALSEVALUESTR)
					{
						if (RethrowLibraryComputationExceptions)
						{
							throw new ArgumentException(FormulaErrorStrings[invalid_argument]);
						}
						return ErrorStrings[1].ToString();
					}
				}
				else
				{
					empty4 = FALSEVALUESTR;
				}
			}
			else
			{
				empty4 = FALSEVALUESTR;
				empty3 = "1";
			}
		}
		else
		{
			empty4 = FALSEVALUESTR;
			empty2 = "1";
			empty3 = "1";
		}
		string text = PerformSortingOfRange(list, empty2, empty3, empty4, num2);
		if (computeFunctionLevel > 0)
		{
			return TIC + text + TIC;
		}
		return text.Split(parseArgumentSeparator)[0];
	}

	private string PerformSortingOfRange(List<string> result, string sortIndex, string sortOrder, string byColumn, int numberOfColumns)
	{
		List<List<string>> data = ConvertToStructuredData(result, numberOfColumns);
		data = ((!byColumn.Equals(TRUEVALUESTR.ToUpper())) ? SortByColumn(data, int.Parse(sortIndex) - 1, int.Parse(sortOrder)) : SortByRow(data, int.Parse(sortIndex) - 1, int.Parse(sortOrder)));
		StringBuilder stringBuilder = new StringBuilder();
		foreach (List<string> item in data)
		{
			stringBuilder.Append(string.Join(parseArgumentSeparator.ToString(), item)).Append(";");
		}
		if (stringBuilder.Length > 0 && stringBuilder[stringBuilder.Length - 1] == ';')
		{
			stringBuilder.Length--;
		}
		return stringBuilder.ToString();
	}

	private List<List<string>> SortByRow(List<List<string>> data, int sortIndex, int sortOrder)
	{
		List<string> rowToSort = data[sortIndex];
		int[] array = new int[rowToSort.Count];
		for (int j = 0; j < rowToSort.Count; j++)
		{
			array[j] = j;
		}
		Array.Sort(array, (int i1, int i2) => CompareValues(rowToSort[i1], rowToSort[i2], sortOrder));
		List<List<string>> list = new List<List<string>>();
		for (int k = 0; k < data.Count; k++)
		{
			List<string> list2 = new List<string>();
			for (int l = 0; l < array.Length; l++)
			{
				list2.Add(data[k][array[l]]);
			}
			list.Add(list2);
		}
		return list;
	}

	private List<List<string>> SortByColumn(List<List<string>> data, int sortIndex, int sortOrder)
	{
		data.Sort((List<string> row1, List<string> row2) => CompareValues(row1[sortIndex], row2[sortIndex], sortOrder));
		return data;
	}

	private int CompareValues(string x, string y, int sortOrder)
	{
		object x2 = x;
		object y2 = y;
		DateTime result;
		DateTime result2;
		if (ComputeIsNumber(x) == TRUEVALUESTR && ComputeIsNumber(y) == TRUEVALUESTR)
		{
			x2 = int.Parse(x);
			y2 = int.Parse(y);
		}
		else if (DateTime.TryParse(x, out result) && DateTime.TryParse(y, out result2))
		{
			x2 = result;
			y2 = result2;
		}
		int num = Comparer<object>.Default.Compare(x2, y2);
		if (sortOrder != 1)
		{
			return -num;
		}
		return num;
	}

	public string ComputeEncodeURL(string argList)
	{
		string[] array = SplitArgsPreservingQuotedCommas(argList);
		if (array.GetLength(0) != 1)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		string scopedRange = string.Empty;
		if (!IsCellReference(array[0]) && !TryGetNamedRange(array[0], out scopedRange) && !array[0].Contains(TIC))
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[invalid_arguments]);
			}
			return ErrorStrings[5].ToString();
		}
		return Uri.EscapeDataString(StripTics0(GetValueFromArg(array[0]))).Replace("+", "%20");
	}

	public string ComputeFilterXml(string argList)
	{
		if (SplitArgsPreservingQuotedCommas(argList).GetLength(0) != 2)
		{
			if (RethrowLibraryComputationExceptions)
			{
				throw new ArgumentException(FormulaErrorStrings[wrong_number_arguments]);
			}
			return FormulaErrorStrings[wrong_number_arguments];
		}
		_ = string.Empty;
		return "Not supported in WINRT";
	}
}
